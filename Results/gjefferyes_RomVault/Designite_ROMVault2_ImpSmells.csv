Implementation smell,Namespace,Class,File,Method,Description
Long Method,ROMVault2,Report,C:\repos\gjefferyes_RomVault\ROMVault2\Report.cs,MakeFixFilesRecurse,The method has 110 lines of code.
Long Method,ROMVault2,FindFixes,C:\repos\gjefferyes_RomVault\ROMVault2\FindFixes.cs,ListCheck,The method has 177 lines of code.
Long Method,ROMVault2,FindFixes,C:\repos\gjefferyes_RomVault\ROMVault2\FindFixes.cs,ListCheckSHA1CHD,The method has 123 lines of code.
Long Method,ROMVault2,FixFileCopy,C:\repos\gjefferyes_RomVault\ROMVault2\FixFileCopy.cs,CopyFile,The method has 515 lines of code.
Long Method,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,FixFilePreCheckFixFile,The method has 100 lines of code.
Long Method,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,FixFileCanBeFixed,The method has 137 lines of code.
Long Method,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,FixZip,The method has 584 lines of code.
Long Method,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,DoubleCheckDelete,The method has 102 lines of code.
Long Method,ROMVault2,FrmProgressWindowFix,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindowFix.cs,InitializeComponent,The method has 233 lines of code.
Long Method,ROMVault2,DatUpdate,C:\repos\gjefferyes_RomVault\ROMVault2\DatUpdate.cs,MergeInDat,The method has 117 lines of code.
Long Method,ROMVault2,FileScanning,C:\repos\gjefferyes_RomVault\ROMVault2\FileScanning.cs,CheckADir,The method has 212 lines of code.
Long Method,ROMVault2,FileScanning,C:\repos\gjefferyes_RomVault\ROMVault2\FileScanning.cs,Compare,The method has 129 lines of code.
Long Method,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,BgwProgressChanged,The method has 101 lines of code.
Long Method,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,InitializeComponent,The method has 172 lines of code.
Long Method,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The method has 193 lines of code.
Long Method,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The method has 220 lines of code.
Long Method,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,PaintTree,The method has 119 lines of code.
Long Method,ROMVault2,Settings,C:\repos\gjefferyes_RomVault\ROMVault2\Settings.cs,ReadConfig,The method has 117 lines of code.
Long Method,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,UpdateGameGrid,The method has 119 lines of code.
Long Method,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,GameGrid_CellFormatting,The method has 113 lines of code.
Long Method,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,UpdateRomGrid,The method has 157 lines of code.
Long Method,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The method has 976 lines of code.
Long Method,ROMVault2.SupportedFiles.CHD,CHD,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\CHD\CHD.cs,CheckFile,The method has 125 lines of code.
Long Method,ROMVault2.DatReaders,DatCmpReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatCmpReader.cs,LoadGameFromDat,The method has 125 lines of code.
Long Method,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,DeflateFast,The method has 101 lines of code.
Long Method,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,DeflateSlow,The method has 127 lines of code.
Long Method,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Deflate,The method has 149 lines of code.
Long Method,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The method has 448 lines of code.
Long Method,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The method has 307 lines of code.
Long Method,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,InflateFast,The method has 206 lines of code.
Long Method,ROMVault2.SupportedFiles.Zip.ZLib,InflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Inflate,The method has 159 lines of code.
Long Method,ROMVault2.SupportedFiles.Zip.ZLib,InfTree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\InfTree.cs,huft_build,The method has 212 lines of code.
Long Method,ROMVault2.SupportedFiles.Zip,ZipFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,ZipFileOpen,The method has 157 lines of code.
Long Method,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,LocalFileHeaderRead,The method has 107 lines of code.
Complex Method,ROMVault2,DatMaker,C:\repos\gjefferyes_RomVault\ROMVault2\DatMaker.cs,PlainProcessDir,Cyclomatic complexity of the method is 8
Complex Method,ROMVault2,DatMaker,C:\repos\gjefferyes_RomVault\ROMVault2\DatMaker.cs,ProcessDir,Cyclomatic complexity of the method is 15
Complex Method,ROMVault2,Report,C:\repos\gjefferyes_RomVault\ROMVault2\Report.cs,MakeFixFilesRecurse,Cyclomatic complexity of the method is 27
Complex Method,ROMVault2,Report,C:\repos\gjefferyes_RomVault\ROMVault2\Report.cs,FindAllDats,Cyclomatic complexity of the method is 8
Complex Method,ROMVault2,Report,C:\repos\gjefferyes_RomVault\ROMVault2\Report.cs,ReportMissingFindSizes,Cyclomatic complexity of the method is 9
Complex Method,ROMVault2,FindFixes,C:\repos\gjefferyes_RomVault\ROMVault2\FindFixes.cs,ScanFiles,Cyclomatic complexity of the method is 9
Complex Method,ROMVault2,FindFixes,C:\repos\gjefferyes_RomVault\ROMVault2\FindFixes.cs,ListCheck,Cyclomatic complexity of the method is 35
Complex Method,ROMVault2,FindFixes,C:\repos\gjefferyes_RomVault\ROMVault2\FindFixes.cs,ListCheckSHA1CHD,Cyclomatic complexity of the method is 20
Complex Method,ROMVault2,FixFileCopy,C:\repos\gjefferyes_RomVault\ROMVault2\FixFileCopy.cs,CopyFile,Cyclomatic complexity of the method is 58
Complex Method,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,PerformFixes,Cyclomatic complexity of the method is 8
Complex Method,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,FixDir,Cyclomatic complexity of the method is 9
Complex Method,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,FixFilePreCheckFixFile,Cyclomatic complexity of the method is 9
Complex Method,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,FixFileCanBeFixed,Cyclomatic complexity of the method is 10
Complex Method,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,FixZip,Cyclomatic complexity of the method is 23
Complex Method,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,CheckDeleteObject,Cyclomatic complexity of the method is 9
Complex Method,ROMVault2,DatUpdate,C:\repos\gjefferyes_RomVault\ROMVault2\DatUpdate.cs,RecursiveDatTree,Cyclomatic complexity of the method is 8
Complex Method,ROMVault2,DatUpdate,C:\repos\gjefferyes_RomVault\ROMVault2\DatUpdate.cs,RemoveOldDats,Cyclomatic complexity of the method is 8
Complex Method,ROMVault2,DatUpdate,C:\repos\gjefferyes_RomVault\ROMVault2\DatUpdate.cs,RemoveOldDatsCleanUpFiles,Cyclomatic complexity of the method is 9
Complex Method,ROMVault2,DatUpdate,C:\repos\gjefferyes_RomVault\ROMVault2\DatUpdate.cs,MergeInDat,Cyclomatic complexity of the method is 23
Complex Method,ROMVault2,DatUpdate,C:\repos\gjefferyes_RomVault\ROMVault2\DatUpdate.cs,FullCompare,Cyclomatic complexity of the method is 16
Complex Method,ROMVault2,FileScanning,C:\repos\gjefferyes_RomVault\ROMVault2\FileScanning.cs,Compare,Cyclomatic complexity of the method is 9
Complex Method,ROMVault2,FileScanning,C:\repos\gjefferyes_RomVault\ROMVault2\FileScanning.cs,FullCompare,Cyclomatic complexity of the method is 28
Complex Method,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,BgwProgressChanged,Cyclomatic complexity of the method is 17
Complex Method,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,SetupTree,Cyclomatic complexity of the method is 11
Complex Method,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,PaintTree,Cyclomatic complexity of the method is 19
Complex Method,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,CheckMouseDown,Cyclomatic complexity of the method is 11
Complex Method,ROMVault2,Settings,C:\repos\gjefferyes_RomVault\ROMVault2\Settings.cs,ReadConfig,Cyclomatic complexity of the method is 21
Complex Method,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,UpdateGameGrid,Cyclomatic complexity of the method is 16
Complex Method,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,GameGrid_CellFormatting,Cyclomatic complexity of the method is 8
Complex Method,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,AddRom,Cyclomatic complexity of the method is 24
Complex Method,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,RomGridMouseUp,Cyclomatic complexity of the method is 8
Complex Method,ROMVault2,DBHelper,C:\repos\gjefferyes_RomVault\ROMVault2\DBHelper.cs,TrrntZipStringCompare,Cyclomatic complexity of the method is 8
Complex Method,ROMVault2,DBHelper,C:\repos\gjefferyes_RomVault\ROMVault2\DBHelper.cs,RomSortCRCSize,Cyclomatic complexity of the method is 10
Complex Method,ROMVault2,DBHelper,C:\repos\gjefferyes_RomVault\ROMVault2\DBHelper.cs,RomSortSHA1CHD,Cyclomatic complexity of the method is 10
Complex Method,ROMVault2.DatReaders,DatDOSReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatDOSReader.cs,LoadGameFromDat,Cyclomatic complexity of the method is 10
Complex Method,ROMVault2.DatReaders,DatCmpReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatCmpReader.cs,ReadDat,Cyclomatic complexity of the method is 10
Complex Method,ROMVault2.DatReaders,DatCmpReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatCmpReader.cs,LoadDirFromDat,Cyclomatic complexity of the method is 8
Complex Method,ROMVault2.DatReaders,DatCmpReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatCmpReader.cs,LoadGameFromDat,Cyclomatic complexity of the method is 13
Complex Method,ROMVault2.DatReaders,DatCmpReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatCmpReader.cs,LoadRomFromDat,Cyclomatic complexity of the method is 9
Complex Method,ROMVault2.DatReaders,DatMessXmlReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatMessXMLReader.cs,LoadGameFromDat,Cyclomatic complexity of the method is 16
Complex Method,ROMVault2.DatReaders,DatReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatReader.cs,ReadInDatFile,Cyclomatic complexity of the method is 8
Complex Method,ROMVault2.DatReaders,DatReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatReader.cs,DatSetCheckParentSets,Cyclomatic complexity of the method is 15
Complex Method,ROMVault2.DatReaders,DatReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatReader.cs,DatSetMergeSets,Cyclomatic complexity of the method is 13
Complex Method,ROMVault2.DatReaders,DatReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatReader.cs,DatSetCreateSubDirs,Cyclomatic complexity of the method is 12
Complex Method,ROMVault2.DatReaders,DatXmlReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatXMLReader.cs,ReadDat,Cyclomatic complexity of the method is 9
Complex Method,ROMVault2.DatReaders,DatXmlReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatXMLReader.cs,ReadMameDat,Cyclomatic complexity of the method is 9
Complex Method,ROMVault2.DatReaders,DatXmlReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatXMLReader.cs,LoadHeaderFromDat,Cyclomatic complexity of the method is 11
Complex Method,ROMVault2.DatReaders,DatXmlReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatXMLReader.cs,LoadDirFromDat,Cyclomatic complexity of the method is 9
Complex Method,ROMVault2.DatReaders,DatXmlReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatXMLReader.cs,LoadGameFromDat,Cyclomatic complexity of the method is 11
Complex Method,ROMVault2.RvDB,RvDir,C:\repos\gjefferyes_RomVault\ROMVault2\RvDB\RvDir.cs,Read,Cyclomatic complexity of the method is 8
Complex Method,ROMVault2.RvDB,RvFile,C:\repos\gjefferyes_RomVault\ROMVault2\RvDB\RvFile.cs,Write,Cyclomatic complexity of the method is 23
Complex Method,ROMVault2.RvDB,RvFile,C:\repos\gjefferyes_RomVault\ROMVault2\RvDB\RvFile.cs,DatAdd,Cyclomatic complexity of the method is 8
Complex Method,ROMVault2.RvDB,RvFile,C:\repos\gjefferyes_RomVault\ROMVault2\RvDB\RvFile.cs,FileRemove,Cyclomatic complexity of the method is 8
Complex Method,ROMVault2.RvDB,RvFile,C:\repos\gjefferyes_RomVault\ROMVault2\RvDB\RvFile.cs,FileAdd,Cyclomatic complexity of the method is 8
Complex Method,ROMVault2.SupportedFiles.Files,UnCompFiles,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Files\UnCompFiles.cs,CheckSumRead,Cyclomatic complexity of the method is 8
Complex Method,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,DeflateNone,Cyclomatic complexity of the method is 11
Complex Method,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,DeflateFast,Cyclomatic complexity of the method is 14
Complex Method,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,DeflateSlow,Cyclomatic complexity of the method is 15
Complex Method,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Deflate,Cyclomatic complexity of the method is 19
Complex Method,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Flush,Cyclomatic complexity of the method is 10
Complex Method,ROMVault2.SupportedFiles.Zip.ZLib,InfTree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\InfTree.cs,huft_build,Cyclomatic complexity of the method is 25
Complex Method,ROMVault2.SupportedFiles.Zip.ZLib,Tree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Tree.cs,gen_bitlen,Cyclomatic complexity of the method is 12
Complex Method,ROMVault2.SupportedFiles.Zip.ZLib,ZlibBaseStream,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,Cyclomatic complexity of the method is 9
Complex Method,ROMVault2.SupportedFiles.Zip.ZLib,ZlibBaseStream,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\ZlibBaseStream.cs,Read,Cyclomatic complexity of the method is 18
Complex Method,ROMVault2.Utils,RelativePath,C:\repos\gjefferyes_RomVault\ROMVault2\Utils\RelativePath.cs,MakeRelative,Cyclomatic complexity of the method is 11
Complex Method,ROMVault2.Utils,VarFix,C:\repos\gjefferyes_RomVault\ROMVault2\Utils\VarFix.cs,CleanMD5SHA1,Cyclomatic complexity of the method is 8
Complex Method,ROMVault2.IO,Directory,C:\repos\gjefferyes_RomVault\ROMVault2\IO\RVIO.cs,Move,Cyclomatic complexity of the method is 9
Complex Method,ROMVault2.SupportedFiles.Zip,ZipFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,ZipFileOpen,Cyclomatic complexity of the method is 27
Complex Method,ROMVault2.SupportedFiles.Zip,ZipFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,TrrntZipStringCompare,Cyclomatic complexity of the method is 8
Complex Method,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,LocalFileHeaderRead,Cyclomatic complexity of the method is 21
Complex Method,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,LocalFileCheck,Cyclomatic complexity of the method is 11
Long Parameter List,ROMVault2,FixFileCopy,C:\repos\gjefferyes_RomVault\ROMVault2\FixFileCopy.cs,CopyFile,The method has 7 parameters. Parameters: fileIn' zipFileOut' zipFilenameOut' fileOut' forceRaw' error' foundFile
Long Parameter List,ROMVault2,bgwShowFix,C:\repos\gjefferyes_RomVault\ROMVault2\BackGroundWorkerInterface.cs,bgwShowFix,The method has 8 parameters. Parameters: fixDir' fixZip' fixFile' size' dir' sourceDir' sourceZip' sourceFile
Long Parameter List,ROMVault2,FileScanning,C:\repos\gjefferyes_RomVault\ROMVault2\FileScanning.cs,FullCompare,The method has 5 parameters. Parameters: dbFile' testFile' secondPass' fullDir' sLevel
Long Parameter List,ROMVault2.SupportedFiles.Files,UnCompFiles,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Files\UnCompFiles.cs,CheckSumRead,The method has 5 parameters. Parameters: filename' testDeep' crc' bMD5' bSHA1
Long Parameter List,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Initialize,The method has 5 parameters. Parameters: codec' level' windowBits' memLevel' strategy
Long Parameter List,ROMVault2.SupportedFiles.Zip.ZLib,Config,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Config,The method has 5 parameters. Parameters: goodLength' maxLazy' niceLength' maxChainLength' flavor
Long Parameter List,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Init,The method has 6 parameters. Parameters: bl' bd' tl' tl_index' td' td_index
Long Parameter List,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,InflateFast,The method has 8 parameters. Parameters: bl' bd' tl' tl_index' td' td_index' s' z
Long Parameter List,ROMVault2.SupportedFiles.Zip.ZLib,InfTree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\InfTree.cs,huft_build,The method has 11 parameters. Parameters: b' bindex' n' s' d' e' t' m' hp' hn' v
Long Parameter List,ROMVault2.SupportedFiles.Zip.ZLib,InfTree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\InfTree.cs,inflate_trees_bits,The method has 5 parameters. Parameters: c' bb' tb' hp' z
Long Parameter List,ROMVault2.SupportedFiles.Zip.ZLib,InfTree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\InfTree.cs,inflate_trees_dynamic,The method has 9 parameters. Parameters: nl' nd' c' bl' bd' tl' td' hp' z
Long Parameter List,ROMVault2.SupportedFiles.Zip.ZLib,InfTree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\InfTree.cs,inflate_trees_fixed,The method has 5 parameters. Parameters: bl' bd' tl' td' z
Long Parameter List,ROMVault2.SupportedFiles.Zip.ZLib,StaticTree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Zlib.cs,StaticTree,The method has 5 parameters. Parameters: treeCodes' extraBits' extraBase' elems' maxLength
Long Parameter List,ROMVault2.SupportedFiles.Zip.ZLib,ZlibBaseStream,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\ZlibBaseStream.cs,ZlibBaseStream,The method has 5 parameters. Parameters: stream' compressionMode' level' flavor' leaveOpen
Long Parameter List,ROMVault2.IO,Win32Native,C:\repos\gjefferyes_RomVault\ROMVault2\IO\Win32Native.cs,CreateFile,The method has 7 parameters. Parameters: lpFileName' dwDesiredAccess' dwShareMode' securityAttrs' dwCreationDisposition' dwFlagsAndAttributes' hTemplateFile
Long Parameter List,ROMVault2.SupportedFiles.Zip,ZipFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,ZipFileOpenReadStream,The method has 5 parameters. Parameters: index' raw' stream' streamSize' compressionMethod
Long Parameter List,ROMVault2.SupportedFiles.Zip,ZipFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,ZipFileOpenReadStreamQuick,The method has 5 parameters. Parameters: pos' raw' stream' streamSize' compressionMethod
Long Parameter List,ROMVault2.SupportedFiles.Zip,ZipFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,ZipFileOpenWriteStream,The method has 6 parameters. Parameters: raw' trrntzip' filename' uncompressedSize' compressionMethod' stream
Long Parameter List,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,LocalFileOpenWriteStream,The method has 5 parameters. Parameters: raw' trrntZip' uncompressedSize' compressionMethod' stream
Long Identifier,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,,The length of the parameter aboutRomVaultToolStripMenuItem is 30.
Long Identifier,ROMVault2.SupportedFiles.Zip,ZipFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,,The length of the parameter CentralDirectoryHeaderSigniature is 32.
Long Identifier,ROMVault2.SupportedFiles.Zip,ZipFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,,The length of the parameter Zip64EndOfCentralDirectoryLocator is 33.
Long Statement,ROMVault2,DatMaker,C:\repos\gjefferyes_RomVault\ROMVault2\DatMaker.cs,PlainProcessDir,The length of the statement  "                    WriteLine(indent + "\t<description>" + clean(item.Game == null ? item.Name : item.Game.GetData(RvGame.GameData.Description)) + "</description>"); " is 145.
Long Statement,ROMVault2,DatMaker,C:\repos\gjefferyes_RomVault\ROMVault2\DatMaker.cs,PlainProcessDir,The length of the statement  "                            WriteLine(indent + "\t<rom name=\"" + clean(file.Name) + "\" size=\"" + file.Size + "\" crc=\"" + Utils.ArrByte.ToString(file.CRC) + "\" md5=\"" + Utils.ArrByte.ToString(file.MD5) + "\" sha1=\"" + Utils.ArrByte.ToString(file.SHA1) + "\"/>"); " is 241.
Long Statement,ROMVault2,DatMaker,C:\repos\gjefferyes_RomVault\ROMVault2\DatMaker.cs,PlainProcessDir,The length of the statement  "                                WriteLine(indent + "\t<rom name=\"" + dName + "\\" + clean(subFile.Name) + "\" size=\"" + subFile.Size + "\" crc=\"" + Utils.ArrByte.ToString(subFile.CRC) + "\" md5=\"" + Utils.ArrByte.ToString(subFile.MD5) + "\" sha1=\"" + Utils.ArrByte.ToString(subFile.SHA1) + "\"/>"); " is 271.
Long Statement,ROMVault2,DatMaker,C:\repos\gjefferyes_RomVault\ROMVault2\DatMaker.cs,ProcessDir,The length of the statement  "                                disks.Add((indent + "\t<disk name=\"" + clean(chd.Name).Replace(".chd"' "") + "\" sha1=\"" + Utils.ArrByte.ToString(chd.SHA1CHD) + "\"/>")); " is 140.
Long Statement,ROMVault2,DatMaker,C:\repos\gjefferyes_RomVault\ROMVault2\DatMaker.cs,ProcessDir,The length of the statement  "                            WriteLine(indent + "\t<rom name=\"" + clean(file.Name) + "\" size=\"" + file.Size + "\" crc=\"" + Utils.ArrByte.ToString(file.CRC) + "\" md5=\"" + Utils.ArrByte.ToString(file.MD5) + "\" sha1=\"" + Utils.ArrByte.ToString(file.SHA1) + "\"/>"); " is 241.
Long Statement,ROMVault2,Report,C:\repos\gjefferyes_RomVault\ROMVault2\Report.cs,scrub,The length of the statement  "                            res.Insert(res.Count - 1' "\t\t<comment>Excludes " + rc.ToString() + " item" + (rc == 0 ? "" : "s") + " that could be fixed</comment>"); " is 136.
Long Statement,ROMVault2,Report,C:\repos\gjefferyes_RomVault\ROMVault2\Report.cs,MakeFixFiles,The length of the statement  "                Description = @"Please select fixdat files destination. NOTE: " + (scrubIt ? @"reports will include Red items only (omitting any Yellow that may be present)" : @"reports will include both Red and Yellow items")' " is 211.
Long Statement,ROMVault2,Report,C:\repos\gjefferyes_RomVault\ROMVault2\Report.cs,MakeFixFilesRecurse,The length of the statement  "                            string datFilename = Path.Combine(_outdir' "fixDat_" + Path.GetFileNameWithoutExtension(_tDat.GetData(RvDat.DatData.DatFullName)) + ".dat"); " is 140.
Long Statement,ROMVault2,Report,C:\repos\gjefferyes_RomVault\ROMVault2\Report.cs,MakeFixFilesRecurse,The length of the statement  "                                datFilename = Path.Combine(_outdir' "fixDat_" + Path.GetFileNameWithoutExtension(_tDat.GetData(RvDat.DatData.DatFullName)) + "(" + test + ").dat"); " is 147.
Long Statement,ROMVault2,Report,C:\repos\gjefferyes_RomVault\ROMVault2\Report.cs,MakeFixFilesRecurse,The length of the statement  "                                "<!DOCTYPE datafile PUBLIC \"-//Logiqx//DTD ROM Management Datafile//EN\" \"http://www.logiqx.com/Dats/datafile.dtd\">"); " is 121.
Long Statement,ROMVault2,Report,C:\repos\gjefferyes_RomVault\ROMVault2\Report.cs,MakeFixFilesRecurse,The length of the statement  "                        if (tRom.DatStatus == DatStatus.InDatCollect && tRom.GotStatus != GotStatus.Got && !(tRom.RepStatus == RepStatus.CanBeFixed || tRom.RepStatus == RepStatus.CorruptCanBeFixed)) " is 174.
Long Statement,ROMVault2,Report,C:\repos\gjefferyes_RomVault\ROMVault2\Report.cs,ReportDrawBars,The length of the statement  "            _ts.WriteLine("+" + new string('-'' _fileNameLength + 2) + "+" + new string('-'' _fileSizeLength + 2) + "+----------+" + new string('-'' _repStatusLength + 2) + "+"); " is 166.
Long Statement,ROMVault2,FindFixes,C:\repos\gjefferyes_RomVault\ROMVault2\FindFixes.cs,ScanFiles,The length of the statement  "                    if (!ArrByte.bCompare(lstRomTableSortedCRCSize[romIndex0].CRC'lstRomTableSortedCRCSize[romIndex1].CRC) || lstRomTableSortedCRCSize[romIndex0].Size != lstRomTableSortedCRCSize[romIndex1].Size) " is 191.
Long Statement,ROMVault2,FindFixes,C:\repos\gjefferyes_RomVault\ROMVault2\FindFixes.cs,ListCheck,The length of the statement  "            List<RvFile> corruptFiles = new List<RvFile>(); // corrupt files that we do not need' a corrupt file is missing if it is needed " is 127.
Long Statement,ROMVault2,FindFixes,C:\repos\gjefferyes_RomVault\ROMVault2\FindFixes.cs,ListCheck,The length of the statement  "                            missingFiles.Add(tFile); // corrupt files that are also InDatcollect are treated as missing files' and a fix should be found. " is 125.
Long Statement,ROMVault2,FindFixes,C:\repos\gjefferyes_RomVault\ROMVault2\FindFixes.cs,ListCheck,The length of the statement  "                        ReportError.SendAndShow(Resources.FindFixes_ListCheck_Unknown_test_status + tFile.DatFullName + Resources.Comma + tFile.DatStatus + Resources.Comma + tFile.RepStatus); " is 167.
Long Statement,ROMVault2,FindFixes,C:\repos\gjefferyes_RomVault\ROMVault2\FindFixes.cs,ListCheck,The length of the statement  "                    missingFile.RepStatus = missingFile.RepStatus == RepStatus.Corrupt ? RepStatus.CorruptCanBeFixed : RepStatus.CanBeFixed; " is 120.
Long Statement,ROMVault2,FindFixes,C:\repos\gjefferyes_RomVault\ROMVault2\FindFixes.cs,ListCheck,The length of the statement  "                    missingFile.RepStatus = missingFile.RepStatus == RepStatus.Corrupt ? RepStatus.CorruptCanBeFixed : RepStatus.CanBeFixed; " is 120.
Long Statement,ROMVault2,FindFixes,C:\repos\gjefferyes_RomVault\ROMVault2\FindFixes.cs,ListCheck,The length of the statement  "            // we can only check corrupt files using the CRC from the ZIP header' as it is corrupt so we cannot get a correct SHA1 / MD5 to check with " is 138.
Long Statement,ROMVault2,FindFixes,C:\repos\gjefferyes_RomVault\ROMVault2\FindFixes.cs,ListCheck,The length of the statement  "                // now that we know this file is not needed for a fix do a CRC only find against correct files to see if this file can be deleted. " is 130.
Long Statement,ROMVault2,FindFixes,C:\repos\gjefferyes_RomVault\ROMVault2\FindFixes.cs,ListCheck,The length of the statement  "                // now that we know this file is not needed for a fix do a CRC only find against correct files to see if this file can be deleted. " is 130.
Long Statement,ROMVault2,FindFixes,C:\repos\gjefferyes_RomVault\ROMVault2\FindFixes.cs,ListCheck,The length of the statement  "                    if (!CheckIfMissingFileCanBeFixedByGotFile(lstRomTableSortedCRC[start + iLoop1]' lstRomTableSortedCRC[start + iLoop0])) continue; " is 129.
Long Statement,ROMVault2,FindFixes,C:\repos\gjefferyes_RomVault\ROMVault2\FindFixes.cs,CheckIfMissingFileCanBeFixedByGotFile,The length of the statement  "            if (missingFile.FileStatusIs(FileStatus.SHA1FromDAT) &&  gotFile.FileStatusIs(FileStatus.SHA1Verified) && !ArrByte.bCompare(missingFile.SHA1' gotFile.SHA1)) " is 156.
Long Statement,ROMVault2,FindFixes,C:\repos\gjefferyes_RomVault\ROMVault2\FindFixes.cs,CheckIfMissingFileCanBeFixedByGotFile,The length of the statement  "            if (missingFile.FileStatusIs(FileStatus.MD5FromDAT) &&  gotFile.FileStatusIs(FileStatus.MD5Verified) && !ArrByte.bCompare(missingFile.MD5' gotFile.MD5)) " is 152.
Long Statement,ROMVault2,FindFixes,C:\repos\gjefferyes_RomVault\ROMVault2\FindFixes.cs,CheckIfGotfileAndMatchingFileAreFullMatches,The length of the statement  "            if (gotFile.FileStatusIs(FileStatus.SHA1Verified) && matchingFile.FileStatusIs(FileStatus.SHA1Verified) && !ArrByte.bCompare(gotFile.SHA1' matchingFile.SHA1)) " is 158.
Long Statement,ROMVault2,FindFixes,C:\repos\gjefferyes_RomVault\ROMVault2\FindFixes.cs,CheckIfGotfileAndMatchingFileAreFullMatches,The length of the statement  "            if (gotFile.FileStatusIs(FileStatus.MD5Verified) && matchingFile.FileStatusIs(FileStatus.MD5Verified) && !ArrByte.bCompare(gotFile.MD5' matchingFile.MD5)) " is 154.
Long Statement,ROMVault2,FindFixes,C:\repos\gjefferyes_RomVault\ROMVault2\FindFixes.cs,ListCheckSHA1CHD,The length of the statement  "            List<RvFile> corruptFiles = new List<RvFile>(); // corrupt files that we do not need' a corrupt file is missing if it is needed " is 127.
Long Statement,ROMVault2,FindFixes,C:\repos\gjefferyes_RomVault\ROMVault2\FindFixes.cs,ListCheckSHA1CHD,The length of the statement  "                            missingFiles.Add(tFile); // corrupt files that are also InDatcollect are treated as missing files' and a fix should be found. " is 125.
Long Statement,ROMVault2,FindFixes,C:\repos\gjefferyes_RomVault\ROMVault2\FindFixes.cs,ListCheckSHA1CHD,The length of the statement  "                        ReportError.SendAndShow(Resources.FindFixes_ListCheck_Unknown_test_status + tFile.DatFullName + Resources.Comma + tFile.DatStatus + Resources.Comma + tFile.RepStatus); " is 167.
Long Statement,ROMVault2,FindFixes,C:\repos\gjefferyes_RomVault\ROMVault2\FindFixes.cs,ListCheckSHA1CHD,The length of the statement  "                    missingFile.RepStatus = (missingFile.RepStatus == RepStatus.Corrupt) || (missingFile.RepStatus == RepStatus.MoveToCorrupt) ? RepStatus.CorruptCanBeFixed : RepStatus.CanBeFixed; " is 176.
Long Statement,ROMVault2,FindFixes,C:\repos\gjefferyes_RomVault\ROMVault2\FindFixes.cs,ListCheckSHA1CHD,The length of the statement  "            // we can only check corrupt files using the CRC from the ZIP header' as it is corrupt so we cannot get a correct SHA1 / MD5 to check with " is 138.
Long Statement,ROMVault2,FindFixes,C:\repos\gjefferyes_RomVault\ROMVault2\FindFixes.cs,ListCheckSHA1CHD,The length of the statement  "                // now that we know this file is not needed for a fix do a CRC only find against correct files to see if this file can be deleted. " is 130.
Long Statement,ROMVault2,FixFileCopy,C:\repos\gjefferyes_RomVault\ROMVault2\FixFileCopy.cs,CopyFile,The length of the statement  "                        zipFileIn.ZipFileOpenReadStreamQuick((ulong)fileIn.ZipFileHeaderPosition' rawCopy' out readStream' out streamSize' out compressionMethod); " is 138.
Long Statement,ROMVault2,FixFileCopy,C:\repos\gjefferyes_RomVault\ROMVault2\FixFileCopy.cs,CopyFile,The length of the statement  "            if (!rawCopy && (Program.rvSettings.FixLevel == eFixLevel.TrrntZipLevel1 || Program.rvSettings.FixLevel == eFixLevel.TrrntZipLevel2 || Program.rvSettings.FixLevel == eFixLevel.TrrntZipLevel3)) " is 192.
Long Statement,ROMVault2,FixFileCopy,C:\repos\gjefferyes_RomVault\ROMVault2\FixFileCopy.cs,CopyFile,The length of the statement  "                ZipReturn zr = zipFileOut.ZipFileOpenWriteStream(rawCopy' sourceTrrntzip' fileOut.Name' (ulong)fileIn.Size' compressionMethod' out writeStream); " is 144.
Long Statement,ROMVault2,FixFileCopy,C:\repos\gjefferyes_RomVault\ROMVault2\FixFileCopy.cs,CopyFile,The length of the statement  "                            error = "The SHA1 found does not match a previously scanned SHA1' this should not happen' unless something got corrupt."; " is 121.
Long Statement,ROMVault2,FixFileCopy,C:\repos\gjefferyes_RomVault\ROMVault2\FixFileCopy.cs,CopyFile,The length of the statement  "                        foundFile.FileStatusSet(FileStatus.SizeVerified | FileStatus.CRCVerified | FileStatus.MD5Verified | FileStatus.SHA1Verified); " is 125.
Long Statement,ROMVault2,FixFileCopy,C:\repos\gjefferyes_RomVault\ROMVault2\FixFileCopy.cs,CopyFile,The length of the statement  "            fileOut.FileStatusSet(FileStatus.SHA1CHDFromHeader | FileStatus.MD5CHDFromHeader | FileStatus.SHA1CHDVerified | FileStatus.MD5CHDVerified' fileIn); " is 147.
Long Statement,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,FixFile,The length of the statement  "                    ReportError.UnhandledExceptionHandler(Resources.FixFiles_FixFile_Unknown_fix_file_type + fixFile.RepStatus + " Dat Status = " + fixFile.DatStatus + " GotStatus " + fixFile.GotStatus); " is 183.
Long Statement,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,FixFileCheckName,The length of the statement  "                    ReportProgress(new bgwShowError(sourceFullName' "Error Setting File Attributes to Normal. Before Case correction Rename. Code " + error)); " is 138.
Long Statement,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,FixFileMoveToSort,The length of the statement  "            ReportProgress(new bgwShowFix(Path.GetDirectoryName(fixFileFullName)' ""' Path.GetFileName(fixFileFullName)' fixFile.Size' "-->"' "ToSort"' ""' fixFile.Name)); " is 159.
Long Statement,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,FixFileMoveToSort,The length of the statement  "            ReturnCode returnCode = FixFileCopy.CopyFile(fixFile' ref tempZipOut' toSortFullName' toSortRom' false' out _error' out foundFile); " is 131.
Long Statement,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,FixFileMoveToSort,The length of the statement  "                ReportProgress(new bgwShowError(fixFilePath' "Error Setting File Attributes to Normal. Before Delete Moving ToSort. Code " + error)); " is 133.
Long Statement,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,FixFileMoveToCorrupt,The length of the statement  "            _bgw.ReportProgress(0' new bgwShowFix(Path.GetDirectoryName(fixFileFullName)' ""' Path.GetFileName(fixFileFullName)' fixFile.Size' "-->"' "Corrupt"' ""' fixFile.Name)); " is 168.
Long Statement,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,FixFileMoveToCorrupt,The length of the statement  "            ReturnCode returnCode = FixFileCopy.CopyFile(fixFile' ref tempZipOut' toSortCorruptFullName' toSortCorruptRom' false' out _error' out foundFile); " is 145.
Long Statement,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,FixFileMoveToCorrupt,The length of the statement  "                _bgw.ReportProgress(0' new bgwShowError(fixFilePath' "Error Setting File Attributes to Normal. Before Delete Moving ToSort. Code " + error)); " is 141.
Long Statement,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,FixFilePreCheckFixFile,The length of the statement  "            // start by finding the first file in the DB. (This should always work' as it will at least find the current file that CanBeFixed " is 129.
Long Statement,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,FixFilePreCheckFixFile,The length of the statement  "                                // so now we have found the file with the same case insensative name and can rename it to something else to get it out of the way for now. " is 138.
Long Statement,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,FixFileCanBeFixed,The length of the statement  "                    if (family[iFind].GotStatus == GotStatus.Got && FindFixes.CheckIfMissingFileCanBeFixedByGotFile(fixFile' family[iFind])) " is 120.
Long Statement,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,FixFileCanBeFixed,The length of the statement  "            ReportProgress(new bgwShowFix(Path.GetDirectoryName(fixFileFullName)' ""' Path.GetFileName(fixFileFullName)' fixFile.Size' "<--"' Path.GetDirectoryName(fts)' Path.GetFileName(fts)' fixingFile.Name)); " is 199.
Long Statement,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,FixFileCanBeFixed,The length of the statement  "            returnCode = FixFileCopy.CopyFile(fixingFile' ref tempZipOut' fixFile.FullName' fixFile' false' out _error' out foundFile); " is 123.
Long Statement,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,FixFileCanBeFixed,The length of the statement  "            // Check the files that we found that where used to fix this file' and if they not listed as correct files' they can be set to be deleted. " is 138.
Long Statement,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,FixZip,The length of the statement  "            bool needsTrrntzipped = fixZip.ZipStatus != ZipStatus.TrrntZip && fixZip.GotStatus == GotStatus.Got && fixZip.DatStatus == DatStatus.InDatCollect && (Program.rvSettings.FixLevel == eFixLevel.TrrntZipLevel1 || Program.rvSettings.FixLevel == eFixLevel.TrrntZipLevel2 || Program.rvSettings.FixLevel == eFixLevel.TrrntZipLevel3); " is 325.
Long Statement,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,FixZip,The length of the statement  "                ReportProgress(new bgwShowFix(Path.GetDirectoryName(fixZipFullName)' Path.GetFileName(fixZipFullName)' ""' 0' "TrrntZipping"' ""' ""' "")); " is 139.
Long Statement,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,FixZip,The length of the statement  "                            ReportError.SendAndShow(Resources.FixFiles_FixZip_Error_in_Fix_Rom_Status + zipFileFixing.RepStatus + Resources.FixFiles_FixZip_Colon + zipFileFixing.DatStatus + Resources.FixFiles_FixZip_Colon + zipFileFixing.GotStatus); " is 221.
Long Statement,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,FixZip,The length of the statement  "                                ReportError.SendAndShow(Resources.FixFiles_FixZip_Error_in_Fix_Rom_Status + zipFileFixing.RepStatus + Resources.FixFiles_FixZip_Colon + zipFileFixing.DatStatus + Resources.FixFiles_FixZip_Colon + zipFileFixing.GotStatus); " is 221.
Long Statement,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,FixZip,The length of the statement  "                            if (!(zipFileFixing.DatStatus == DatStatus.InDatCollect && (zipFileFixing.GotStatus == GotStatus.NotGot || zipFileFixing.GotStatus == GotStatus.Corrupt))) " is 154.
Long Statement,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,FixZip,The length of the statement  "                                ReportError.SendAndShow(Resources.FixFiles_FixZip_Error_in_Fix_Rom_Status + zipFileFixing.RepStatus + Resources.FixFiles_FixZip_Colon + zipFileFixing.DatStatus + Resources.FixFiles_FixZip_Colon + zipFileFixing.GotStatus); " is 221.
Long Statement,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,FixZip,The length of the statement  "                                returnCode = FixFileCopy.CopyFile(fileIn' ref tempZipOut' tempZipFilename' zipFileFixing' false' out _error' out foundFile); " is 124.
Long Statement,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,FixZip,The length of the statement  "                                if (family[iFind].GotStatus == GotStatus.Got && FindFixes.CheckIfMissingFileCanBeFixedByGotFile(zipFileFixing' family[iFind])) " is 126.
Long Statement,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,FixZip,The length of the statement  "                                ReportProgress(new bgwShowFix(Path.GetDirectoryName(fixZipFullName)' Path.GetFileName(fixZipFullName)' zipFileFixing.Name' zipFileFixing.Size' "<--"' sourceDir' sourceFile' lstFixRomTable[0].Name)); " is 198.
Long Statement,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,FixZip,The length of the statement  "                                returnCode = FixFileCopy.CopyFile(lstFixRomTable[0]' ref tempZipOut' tempZipFilename' zipFileFixing' false' out _error' out foundFile); " is 135.
Long Statement,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,FixZip,The length of the statement  "                                ReportError.SendAndShow(Resources.FixFiles_FixZip_Error_in_Fix_Rom_Status + zipFileFixing.RepStatus + Resources.FixFiles_FixZip_Colon + zipFileFixing.DatStatus + Resources.FixFiles_FixZip_Colon + zipFileFixing.GotStatus); " is 221.
Long Statement,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,FixZip,The length of the statement  "                            ReportProgress(new bgwShowFix(Path.GetDirectoryName(fixZipFullName)' Path.GetFileName(fixZipFullName)' zipFileFixing.Name' zipFileFixing.Size' "-->"' "ToSort"' Path.GetFileName(destination)' toSortRom.Name)); " is 208.
Long Statement,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,FixZip,The length of the statement  "                            returnCode = FixFileCopy.CopyFile((RvFile)fixZip.Child(iRom)' ref toSortZipOut' destination' toSortRom' true' out _error' out foundFile); " is 137.
Long Statement,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,FixZip,The length of the statement  "                            if (!((zipFileFixing.DatStatus == DatStatus.InDatCollect || zipFileFixing.DatStatus == DatStatus.NotInDat) && zipFileFixing.GotStatus == GotStatus.Corrupt)) " is 156.
Long Statement,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,FixZip,The length of the statement  "                                ReportError.SendAndShow(Resources.FixFiles_FixZip_Error_in_Fix_Rom_Status + zipFileFixing.RepStatus + Resources.FixFiles_FixZip_Colon + zipFileFixing.DatStatus + Resources.FixFiles_FixZip_Colon + zipFileFixing.GotStatus); " is 221.
Long Statement,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,FixZip,The length of the statement  "                            ReportProgress(new bgwShowFix(Path.GetDirectoryName(fixZipFullName)' Path.GetFileName(fixZipFullName)' zipFileFixing.Name' zipFileFixing.Size' "-->"' "Corrupt"' Path.GetFileName(toSortFullName)' zipFileFixing.Name)); " is 216.
Long Statement,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,FixZip,The length of the statement  "                            returnCode = FixFileCopy.CopyFile((RvFile)fixZip.Child(iRom)' ref toSortCorruptOut' toSortFullName' toSortCorruptRom' true' out _error' out foundFile); " is 151.
Long Statement,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,FixZip,The length of the statement  "                        ReportError.UnhandledExceptionHandler("Unknown file status found " + zipFileFixing.RepStatus + " while fixing file " + fixZip.Name + " Dat Status = " + zipFileFixing.DatStatus + " GotStatus " + zipFileFixing.GotStatus); " is 219.
Long Statement,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,FixZip,The length of the statement  "                    ReportProgress(new bgwShowError(filename' "Error Setting File Attributes to Normal. Deleting Original Fix File. Code " + error)); " is 129.
Long Statement,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,DoubleCheckDelete,The length of the statement  "                if (family[iFind].GotStatus == GotStatus.Got && FindFixes.CheckIfMissingFileCanBeFixedByGotFile(fileDeleting' family[iFind])) " is 125.
Long Statement,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,DoubleCheckDelete,The length of the statement  "                        ReportError.LogOut("Double Check Delete Error Unknown " + lstFixRomTable[i].FullName + " " + lstFixRomTable[i].RepStatus); " is 122.
Long Statement,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,DoubleCheckDelete,The length of the statement  "                ReportError.UnhandledExceptionHandler("Double Check Delete could not find the correct file. (" + fileDeleting.FullName + ")"); " is 126.
Long Statement,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,MoveZiptoCorrupt,The length of the statement  "                ReportProgress(new bgwShowError(fixZipFullName' "Error Setting File Attributes to Normal. Before Moving To Corrupt. Code " + error)); " is 133.
Long Statement,ROMVault2,FrmProgressWindowFix,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindowFix.cs,BgwProgressChanged,The length of the statement  "                dgrq.CreateCells(dataGridView1' bgwSf.FixDir' bgwSf.FixZip' bgwSf.FixFile' bgwSf.Size' bgwSf.Dir' bgwSf.SourceDir' bgwSf.SourceZip' bgwSf.SourceFile); " is 150.
Long Statement,ROMVault2,FrmProgressWindowFix,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindowFix.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(FrmProgressWindowFix)); " is 140.
Long Statement,ROMVault2,FrmProgressWindowFix,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindowFix.cs,InitializeComponent,The length of the statement  "            this.dataGridView1.GridColor = System.Drawing.Color.FromArgb(((int)(((byte)(224))))' ((int)(((byte)(224))))' ((int)(((byte)(224))))); " is 133.
Long Statement,ROMVault2,DatUpdate,C:\repos\gjefferyes_RomVault\ROMVault2\DatUpdate.cs,AddNewDats,The length of the statement  "                    Debug.WriteLine("Checking " + dbDat.GetData(RvDat.DatData.DatFullName) + " : and " + fileDat.GetData(RvDat.DatData.DatFullName) + " : " + res); " is 143.
Long Statement,ROMVault2,DatUpdate,C:\repos\gjefferyes_RomVault\ROMVault2\DatUpdate.cs,AddNewDats,The length of the statement  "                        _bgw.ReportProgress(0' new bgwText("Dat : " + Path.GetFileNameWithoutExtension(fileDat.GetData(RvDat.DatData.DatFullName)))); " is 125.
Long Statement,ROMVault2,DatUpdate,C:\repos\gjefferyes_RomVault\ROMVault2\DatUpdate.cs,AddNewDats,The length of the statement  "                        _bgw.ReportProgress(0' new bgwText("Scanning New Dat : " + Path.GetFileNameWithoutExtension(fileDat.GetData(RvDat.DatData.DatFullName)))); " is 138.
Long Statement,ROMVault2,DatUpdate,C:\repos\gjefferyes_RomVault\ROMVault2\DatUpdate.cs,UpdateDatFile,The length of the statement  "            if ((autoAddDirectory || !String.IsNullOrEmpty(newDatFile.Dat.GetData(RvDat.DatData.RootDir))) && newDatFile.Dat.GetData(RvDat.DatData.DirSetup)!= "noautodir") " is 159.
Long Statement,ROMVault2,DatUpdate,C:\repos\gjefferyes_RomVault\ROMVault2\DatUpdate.cs,UpdateDatFile,The length of the statement  "                ReportError.Show("Dat Merge conflict occured Cache contains " + conflictDat.GetData(RvDat.DatData.DatFullName) + " new dat " + newDatFile.Dat.GetData(RvDat.DatData.DatFullName) + " is trying to use the same dirctory and so will be ignored."); " is 242.
Long Statement,ROMVault2,DatUpdate,C:\repos\gjefferyes_RomVault\ROMVault2\DatUpdate.cs,MergeInDat,The length of the statement  "                    while (dbIndex + dbDatsCount < dbDat.ChildCount && DBHelper.CompareName(dbChild' dbDat.Child(dbIndex + dbDatsCount)) == 0) " is 122.
Long Statement,ROMVault2,DatUpdate,C:\repos\gjefferyes_RomVault\ROMVault2\DatUpdate.cs,MergeInDat,The length of the statement  "                    while (newIndex + newDatsCount < newDat.ChildCount && DBHelper.CompareName(newDatChild' newDat.Child(newIndex + newDatsCount)) == 0) " is 132.
Long Statement,ROMVault2,DatUpdate,C:\repos\gjefferyes_RomVault\ROMVault2\DatUpdate.cs,UpdateDirs,The length of the statement  "                            if (dbChild.Name != fileChild.Name) // check if the case of the Item in the DB is different from the Dat Root Actual filename " is 125.
Long Statement,ROMVault2,FileScanning,C:\repos\gjefferyes_RomVault\ROMVault2\FileScanning.cs,CheckADir,The length of the statement  "                                        tFile.FileStatusSet(FileStatus.SizeVerified | FileStatus.CRCVerified | FileStatus.SHA1Verified | FileStatus.MD5Verified); " is 121.
Long Statement,ROMVault2,FileScanning,C:\repos\gjefferyes_RomVault\ROMVault2\FileScanning.cs,Compare,The length of the statement  "                        while (fileIndex + filesCount < fileDir.ChildCount && DBHelper.CompareName(fileChild' fileDir.Child(fileIndex + filesCount)) == 0) " is 130.
Long Statement,ROMVault2,FileScanning,C:\repos\gjefferyes_RomVault\ROMVault2\FileScanning.cs,MatchFound,The length of the statement  "                    if (tDir.Tree == null) // do not recurse into directories that are in the tree' as they are processed by the top level code. " is 124.
Long Statement,ROMVault2,FileScanning,C:\repos\gjefferyes_RomVault\ROMVault2\FileScanning.cs,IsDeepScanned,The length of the statement  "                    (!zFile.FileStatusIs(FileStatus.SizeVerified) || !zFile.FileStatusIs(FileStatus.CRCVerified) || !zFile.FileStatusIs(FileStatus.SHA1Verified) || !zFile.FileStatusIs(FileStatus.MD5Verified))) " is 189.
Long Statement,ROMVault2,FileScanning,C:\repos\gjefferyes_RomVault\ROMVault2\FileScanning.cs,FullCompare,The length of the statement  "            // and the file we are scanning has not already been deep scanned' then we need to do a deep scan' and check the deep scan values " is 129.
Long Statement,ROMVault2,FileScanning,C:\repos\gjefferyes_RomVault\ROMVault2\FileScanning.cs,DeepScanFile,The length of the statement  "            tFile.FileStatusSet(FileStatus.SizeVerified | FileStatus.CRCVerified | FileStatus.SHA1Verified | FileStatus.MD5Verified); " is 121.
Long Statement,ROMVault2,FrmHelpAbout,C:\repos\gjefferyes_RomVault\ROMVault2\FrmHelpAbout.cs,InitializeComponent,The length of the statement  "            this.lblVersion.Font = new System.Drawing.Font("Microsoft Sans Serif"' 9F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 154.
Long Statement,ROMVault2,FrmHelpAbout,C:\repos\gjefferyes_RomVault\ROMVault2\FrmHelpAbout.cs,InitializeComponent,The length of the statement  "            this.label1.Font = new System.Drawing.Font("Microsoft Sans Serif"' 9.75F' ((System.Drawing.FontStyle)((System.Drawing.FontStyle.Bold | System.Drawing.FontStyle.Underline)))' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 222.
Long Statement,ROMVault2,FrmHelpAbout,C:\repos\gjefferyes_RomVault\ROMVault2\FrmHelpAbout.cs,InitializeComponent,The length of the statement  "            this.label2.Font = new System.Drawing.Font("Microsoft Sans Serif"' 9.75F' ((System.Drawing.FontStyle)((System.Drawing.FontStyle.Bold | System.Drawing.FontStyle.Underline)))' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 222.
Long Statement,ROMVault2,FrmKey,C:\repos\gjefferyes_RomVault\ROMVault2\FrmKey.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(FrmKey)); " is 126.
Long Statement,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(FrmProgressWindow)); " is 137.
Long Statement,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,InitializeComponent,The length of the statement  "            this.ErrorGrid.GridColor = System.Drawing.Color.FromArgb(((int)(((byte)(224))))' ((int)(((byte)(224))))' ((int)(((byte)(224))))); " is 129.
Long Statement,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,BtnDeleteSelectedClick,The length of the statement  "                    ReportError.Show(Resources.FrmSetDir_BtnDeleteSelectedClick_You_cannot_delete_the + datLocation + Resources.FrmSetDir_BtnDeleteSelectedClick_Directory_Settings' " is 160.
Long Statement,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(FrmSetDir)); " is 129.
Long Statement,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The length of the statement  "            this.DataGridGames.GridColor = System.Drawing.Color.FromArgb(((int)(((byte)(224))))' ((int)(((byte)(224))))' ((int)(((byte)(224))))); " is 133.
Long Statement,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The length of the statement  "            this.grpBoxAddNew.Font = new System.Drawing.Font("Microsoft Sans Serif"' 8.25F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 159.
Long Statement,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The length of the statement  "            this.btnSetRomLocation.Font = new System.Drawing.Font("Microsoft Sans Serif"' 8.25F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 167.
Long Statement,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The length of the statement  "            this.txtROMLocation.Font = new System.Drawing.Font("Microsoft Sans Serif"' 8.25F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 164.
Long Statement,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The length of the statement  "            this.lblROMLocation.Font = new System.Drawing.Font("Microsoft Sans Serif"' 8.25F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 164.
Long Statement,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The length of the statement  "            this.txtDATLocation.Font = new System.Drawing.Font("Microsoft Sans Serif"' 8.25F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 164.
Long Statement,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The length of the statement  "            this.lblDATLocation.Font = new System.Drawing.Font("Microsoft Sans Serif"' 8.25F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 164.
Long Statement,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The length of the statement  "            this.lblDelete.Font = new System.Drawing.Font("Microsoft Sans Serif"' 8.25F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 156.
Long Statement,ROMVault2,FrmShowError,C:\repos\gjefferyes_RomVault\ROMVault2\FrmShowError.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(FrmShowError)); " is 132.
Long Statement,ROMVault2,FrmSplashScreen,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSplashScreen.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(FrmSplashScreen)); " is 135.
Long Statement,ROMVault2,FrmSplashScreen,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSplashScreen.cs,InitializeComponent,The length of the statement  "            this.lblVersion.Font = new System.Drawing.Font("Microsoft Sans Serif"' 9F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 154.
Long Statement,ROMVault2,ReportError,C:\repos\gjefferyes_RomVault\ROMVault2\ReportError.cs,UnhandledExceptionHandler,The length of the statement  "                string message = string.Format("An Application Error has occurred.\r\n\r\nEXCEPTION:\r\nSource: {0}\r\nMessage: {1}\r\n"' e.Exception.Source' e.Exception.Message); " is 163.
Long Statement,ROMVault2,ReportError,C:\repos\gjefferyes_RomVault\ROMVault2\ReportError.cs,UnhandledExceptionHandler,The length of the statement  "                    message += string.Format("\r\nINNER EXCEPTION:\r\nSource: {0}\r\nMessage: {1}\r\n"' e.Exception.InnerException.Source' e.Exception.InnerException.Message); " is 155.
Long Statement,ROMVault2,ReportError,C:\repos\gjefferyes_RomVault\ROMVault2\ReportError.cs,UnhandledExceptionHandler,The length of the statement  "                string message = string.Format("An Application Error has occurred.\r\n\r\nEXCEPTION:\r\nSource: {0}\r\nMessage: {1}\r\n"' e.Source' e.Message); " is 143.
Long Statement,ROMVault2,ReportError,C:\repos\gjefferyes_RomVault\ROMVault2\ReportError.cs,UnhandledExceptionHandler,The length of the statement  "                    message += string.Format("\r\nINNER EXCEPTION:\r\nSource: {0}\r\nMessage: {1}\r\n"' e.InnerException.Source' e.InnerException.Message); " is 135.
Long Statement,ROMVault2,ReportError,C:\repos\gjefferyes_RomVault\ROMVault2\ReportError.cs,ReportFile,The length of the statement  "            sw.WriteLine(f.ReportIndex.ToString("D8") + " " + ArrByte.ToString(f.CRC) + " " + f.GotStatus.ToString().PadRight(10) + " " + f.RepStatus.ToString().PadRight(15) + " " + f.TreeFullName); " is 186.
Long Statement,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,OnPaint,The length of the statement  "            Rectangle t = new Rectangle(e.ClipRectangle.Left + _hScroll' e.ClipRectangle.Top + _vScroll' e.ClipRectangle.Width' e.ClipRectangle.Height); " is 140.
Long Statement,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,PaintTree,The length of the statement  "                    g.DrawImage(pTree.Tree.TreeExpanded ? rvImages.ExpandBoxMinus : rvImages.ExpandBoxPlus' RSub(pTree.Tree.RExpand' _hScroll' _vScroll)); " is 134.
Long Statement,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,PaintTree,The length of the statement  "            Rectangle recBackGround = new Rectangle(pTree.Tree.RText.X' pTree.Tree.RText.Y' Width - pTree.Tree.RText.X + _hScroll' pTree.Tree.RText.Height); " is 144.
Long Statement,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,PaintTree,The length of the statement  "                    thistxt = pTree.Name + ": " + pTree.DirDat(0).GetData(RvDat.DatData.Description) + " ( Have:" + pTree.DirStatus.CountCorrect() + " \\ Missing: " + pTree.DirStatus.CountMissing() + " )"; " is 185.
Long Statement,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,PaintTree,The length of the statement  "                    thistxt = pTree.Name + ": " + pTree.Dat.GetData(RvDat.DatData.Description) + " ( Have:" + pTree.DirStatus.CountCorrect() + " \\ Missing: " + pTree.DirStatus.CountMissing() + " )"; " is 179.
Long Statement,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,PaintTree,The length of the statement  "                    thistxt = pTree.Name + " ( Have:" + pTree.DirStatus.CountCorrect() + " \\ Missing: " + pTree.DirStatus.CountMissing() + " )"; " is 125.
Long Statement,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,PaintTree,The length of the statement  "                    g.DrawString(thistxt' new Font("Microsoft Sans Serif"' 8)' Brushes.White' pTree.Tree.RText.Left - _hScroll' pTree.Tree.RText.Top + 1 - _vScroll); " is 145.
Long Statement,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,PaintTree,The length of the statement  "                    g.DrawString(thistxt' new Font("Microsoft Sans Serif"' 8)' Brushes.Black' pTree.Tree.RText.Left - _hScroll' pTree.Tree.RText.Top + 1 - _vScroll); " is 145.
Long Statement,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,CheckMouseDown,The length of the statement  "                SetChecked(pTree' pTree.Tree.Checked == RvTreeRow.TreeSelect.Selected ? RvTreeRow.TreeSelect.UnSelected : RvTreeRow.TreeSelect.Selected); " is 137.
Long Statement,ROMVault2,Settings,C:\repos\gjefferyes_RomVault\ROMVault2\Settings.cs,ReadConfig,The length of the statement  "                FileStream fs = new FileStream(Path.Combine(AppDomain.CurrentDomain.BaseDirectory' "RomVault2.cfg")' FileMode.Open' FileAccess.Read); " is 133.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The length of the statement  "            lblSIName = new Label { Location = SPoint(6' 15)' Size = SSize(76' 13)' Text = "Name :"' TextAlign = ContentAlignment.TopRight }; " is 129.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The length of the statement  "            lblSIDescription = new Label { Location = SPoint(6' 31)' Size = SSize(76' 13)' Text = "Description :"' TextAlign = ContentAlignment.TopRight' Visible = false }; " is 160.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The length of the statement  "            lblSITDescription = new Label { Location = SPoint(84' 30)' Size = SSize(320' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false }; " is 139.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The length of the statement  "            lblSIManufacturer = new Label { Location = SPoint(6' 47)' Size = SSize(76' 13)' Text = "Manufacturer :"' TextAlign = ContentAlignment.TopRight' Visible = false }; " is 162.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The length of the statement  "            lblSITManufacturer = new Label { Location = SPoint(84' 46)' Size = SSize(320' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false }; " is 140.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The length of the statement  "            lblSICloneOf = new Label { Location = SPoint(6' 63)' Size = SSize(76' 13)' Text = "Clone of :"' TextAlign = ContentAlignment.TopRight' Visible = false }; " is 153.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The length of the statement  "            lblSITCloneOf = new Label { Location = SPoint(84' 62)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false }; " is 135.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The length of the statement  "            lblSIYear = new Label { Location = SPoint(206' 63)' Size = SSize(76' 13)' Text = "Year :"' TextAlign = ContentAlignment.TopRight' Visible = false }; " is 148.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The length of the statement  "            lblSITYear = new Label { Location = SPoint(284' 62)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false }; " is 133.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The length of the statement  "            lblSIRomOf = new Label { Location = SPoint(6' 79)' Size = SSize(76' 13)' Text = "ROM of :"' TextAlign = ContentAlignment.TopRight' Visible = false }; " is 149.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The length of the statement  "            lblSITRomOf = new Label { Location = SPoint(84' 78)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false }; " is 133.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The length of the statement  "            lblSITotalRoms = new Label { Location = SPoint(206' 79)' Size = SSize(76' 13)' Text = "Total ROMs :"' TextAlign = ContentAlignment.TopRight' Visible = false }; " is 159.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The length of the statement  "            lblSITTotalRoms = new Label { Location = SPoint(284' 78)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false }; " is 138.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The length of the statement  "            lblSIPublisher = new Label { Location = SPoint(6' 47)' Size = SSize(76' 13)' Text = "Publisher :"' TextAlign = ContentAlignment.TopRight' Visible = false }; " is 156.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The length of the statement  "            lblSITPublisher = new Label { Location = SPoint(84' 46)' Size = SSize(320' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false }; " is 137.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The length of the statement  "            lblSIDeveloper = new Label { Location = SPoint(6' 63)' Size = SSize(76' 13)' Text = "Developer :"' TextAlign = ContentAlignment.TopRight' Visible = false }; " is 156.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The length of the statement  "            lblSITDeveloper = new Label { Location = SPoint(84' 62)' Size = SSize(320' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false }; " is 137.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The length of the statement  "            lblSIEdition = new Label { Location = SPoint(6' 79)' Size = SSize(76' 13)' Text = "Edition :"' TextAlign = ContentAlignment.TopRight' Visible = false }; " is 152.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The length of the statement  "            lblSITEdition = new Label { Location = SPoint(84' 78)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false }; " is 135.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The length of the statement  "            lblSIVersion = new Label { Location = SPoint(206' 79)' Size = SSize(76' 13)' Text = "Version :"' TextAlign = ContentAlignment.TopRight' Visible = false }; " is 154.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The length of the statement  "            lblSITVersion = new Label { Location = SPoint(284' 78)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false }; " is 136.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The length of the statement  "            lblSIType = new Label { Location = SPoint(406' 79)' Size = SSize(76' 13)' Text = "Type :"' TextAlign = ContentAlignment.TopRight' Visible = false }; " is 148.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The length of the statement  "            lblSITType = new Label { Location = SPoint(484' 78)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false }; " is 133.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The length of the statement  "            lblSIMedia = new Label { Location = SPoint(6' 95)' Size = SSize(76' 13)' Text = "Media :"' TextAlign = ContentAlignment.TopRight' Visible = false }; " is 148.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The length of the statement  "            lblSITMedia = new Label { Location = SPoint(84' 94)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false }; " is 133.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The length of the statement  "            lblSILanguage = new Label { Location = SPoint(206' 95)' Size = SSize(76' 13)' Text = "Language :"' TextAlign = ContentAlignment.TopRight' Visible = false }; " is 156.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The length of the statement  "            lblSITLanguage = new Label { Location = SPoint(284' 94)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false }; " is 137.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The length of the statement  "            lblSIPlayers = new Label { Location = SPoint(406' 95)' Size = SSize(76' 13)' Text = "Players :"' TextAlign = ContentAlignment.TopRight' Visible = false }; " is 154.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The length of the statement  "            lblSITPlayers = new Label { Location = SPoint(484' 94)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false }; " is 136.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The length of the statement  "            lblSIRatings = new Label { Location = SPoint(6' 111)' Size = SSize(76' 13)' Text = "Ratings :"' TextAlign = ContentAlignment.TopRight' Visible = false }; " is 153.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The length of the statement  "            lblSITRatings = new Label { Location = SPoint(84' 110)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false }; " is 136.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The length of the statement  "            lblSIGenre = new Label { Location = SPoint(206' 111)' Size = SSize(76' 13)' Text = "Genre :"' TextAlign = ContentAlignment.TopRight' Visible = false }; " is 151.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The length of the statement  "            lblSITGenre = new Label { Location = SPoint(284' 110)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false }; " is 135.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The length of the statement  "            lblSIPeripheral  = new Label { Location = SPoint(406' 111)' Size = SSize(76' 13)' Text = "Peripheral :"' TextAlign = ContentAlignment.TopRight' Visible = false }; " is 162.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The length of the statement  "            lblSITPeripheral = new Label { Location = SPoint(484' 110)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false }; " is 140.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The length of the statement  "            lblSIBarCode = new Label { Location = SPoint(6' 127)' Size = SSize(76' 13)' Text = "Barcode :"' TextAlign = ContentAlignment.TopRight' Visible = false }; " is 153.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The length of the statement  "            lblSITBarCode = new Label { Location = SPoint(84' 126)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false }; " is 136.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The length of the statement  "            lblSIMediaCatalogNumber = new Label { Location = SPoint(406' 127)' Size = SSize(76' 13)' Text = "Cat. No. :"' TextAlign = ContentAlignment.TopRight' Visible = false }; " is 167.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The length of the statement  "            lblSITMediaCatalogNumber = new Label { Location = SPoint(484' 126)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false }; " is 148.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,UpdateGameGrid,The length of the statement  "            lblDITRomsUnknown.Text = (tDir.DirStatus.CountUnknown() + tDir.DirStatus.CountInToSort()).ToString(CultureInfo.InvariantCulture); " is 129.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,GameGrid_CellFormatting,The length of the statement  "                        g.DrawString(tRvDir.DirStatus.Get(RepairStatus.DisplayOrder[l]).ToString(CultureInfo.InvariantCulture)' drawFont' drawBrushBlack' new PointF(gOff + 20' 3)); " is 156.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,AddRom,The length of the statement  "            if (tRomTable.DatStatus != DatStatus.InDatMerged || tRomTable.RepStatus != RepStatus.NotCollected || chkBoxShowMerged.Checked) " is 126.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,AddRom,The length of the statement  "                    RomGrid.Rows[row].Cells["ZipIndex"].Value = tRomTable.ZipFileIndex == -1 ? "" : tRomTable.ZipFileIndex.ToString(CultureInfo.InvariantCulture); " is 142.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,AddRom,The length of the statement  "                    RomGrid.Rows[row].Cells["ZipHeader"].Value = tRomTable.ZipFileHeaderPosition == null ? "" : tRomTable.ZipFileHeaderPosition.ToString(); " is 135.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,RomGrid_SortCompare,The length of the statement  "                e.SortResult = int.Parse(e.CellValue1.ToString().Split(' ')[0]).CompareTo(int.Parse(e.CellValue2.ToString().Split(' ')[0])); " is 124.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(FrmMain)); " is 127.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The length of the statement  "            dataGridViewCellStyle1.Font = new System.Drawing.Font("Microsoft Sans Serif"' 8.25F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 167.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The length of the statement  "            dataGridViewCellStyle2.Font = new System.Drawing.Font("Microsoft Sans Serif"' 8.25F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 167.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The length of the statement  "            this.GameGrid.GridColor = System.Drawing.Color.FromArgb(((int)(((byte)(224))))' ((int)(((byte)(224))))' ((int)(((byte)(224))))); " is 128.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The length of the statement  "            dataGridViewCellStyle3.Font = new System.Drawing.Font("Microsoft Sans Serif"' 8.25F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 167.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The length of the statement  "            this.GameGrid.CellFormatting += new System.Windows.Forms.DataGridViewCellFormattingEventHandler(this.GameGrid_CellFormatting); " is 126.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The length of the statement  "            this.GameGrid.ColumnHeaderMouseClick += new System.Windows.Forms.DataGridViewCellMouseEventHandler(this.GameGridColumnHeaderMouseClick); " is 136.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The length of the statement  "            dataGridViewCellStyle4.Font = new System.Drawing.Font("Microsoft Sans Serif"' 8.25F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 167.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The length of the statement  "            dataGridViewCellStyle5.Font = new System.Drawing.Font("Microsoft Sans Serif"' 8.25F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 167.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The length of the statement  "            this.RomGrid.GridColor = System.Drawing.Color.FromArgb(((int)(((byte)(224))))' ((int)(((byte)(224))))' ((int)(((byte)(224))))); " is 127.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The length of the statement  "            dataGridViewCellStyle6.Font = new System.Drawing.Font("Microsoft Sans Serif"' 8.25F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 167.
Long Statement,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The length of the statement  "            this.RomGrid.CellFormatting += new System.Windows.Forms.DataGridViewCellFormattingEventHandler(this.RomGrid_CellFormatting); " is 124.
Long Statement,ROMVault2,RepairStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,InitStatusCheck,The length of the statement  "            StatusCheck[(int)FileType.Dir' (int)DatStatus.InDatCollect' (int)GotStatus.Got] = new List<RepStatus> { RepStatus.DirCorrect }; " is 127.
Long Statement,ROMVault2,RepairStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,InitStatusCheck,The length of the statement  "            StatusCheck[(int)FileType.Dir' (int)DatStatus.InDatCollect' (int)GotStatus.NotGot] = new List<RepStatus> { RepStatus.DirMissing }; " is 130.
Long Statement,ROMVault2,RepairStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,InitStatusCheck,The length of the statement  "            StatusCheck[(int)FileType.Dir' (int)DatStatus.InToSort' (int)GotStatus.Got] = new List<RepStatus> { RepStatus.DirInToSort }; " is 124.
Long Statement,ROMVault2,RepairStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,InitStatusCheck,The length of the statement  "            StatusCheck[(int)FileType.Dir' (int)DatStatus.InToSort' (int)GotStatus.NotGot] = new List<RepStatus> { RepStatus.Deleted }; " is 123.
Long Statement,ROMVault2,RepairStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,InitStatusCheck,The length of the statement  "            StatusCheck[(int)FileType.Dir' (int)DatStatus.NotInDat' (int)GotStatus.Got] = new List<RepStatus> { RepStatus.DirUnknown }; " is 123.
Long Statement,ROMVault2,RepairStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,InitStatusCheck,The length of the statement  "            StatusCheck[(int)FileType.Dir' (int)DatStatus.NotInDat' (int)GotStatus.NotGot] = new List<RepStatus> { RepStatus.Deleted }; " is 123.
Long Statement,ROMVault2,RepairStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,InitStatusCheck,The length of the statement  "            StatusCheck[(int)FileType.Zip' (int)DatStatus.InDatCollect' (int)GotStatus.Got] = new List<RepStatus> { RepStatus.DirCorrect }; " is 127.
Long Statement,ROMVault2,RepairStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,InitStatusCheck,The length of the statement  "            StatusCheck[(int)FileType.Zip' (int)DatStatus.InDatCollect' (int)GotStatus.Corrupt] = new List<RepStatus> { RepStatus.DirCorrupt }; " is 131.
Long Statement,ROMVault2,RepairStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,InitStatusCheck,The length of the statement  "            StatusCheck[(int)FileType.Zip' (int)DatStatus.InDatCollect' (int)GotStatus.FileLocked] = new List<RepStatus> { RepStatus.UnScanned }; " is 133.
Long Statement,ROMVault2,RepairStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,InitStatusCheck,The length of the statement  "            StatusCheck[(int)FileType.Zip' (int)DatStatus.InDatCollect' (int)GotStatus.NotGot] = new List<RepStatus> { RepStatus.DirMissing }; " is 130.
Long Statement,ROMVault2,RepairStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,InitStatusCheck,The length of the statement  "            StatusCheck[(int)FileType.Zip' (int)DatStatus.InToSort' (int)GotStatus.Got] = new List<RepStatus> { RepStatus.DirInToSort }; " is 124.
Long Statement,ROMVault2,RepairStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,InitStatusCheck,The length of the statement  "            StatusCheck[(int)FileType.Zip' (int)DatStatus.InToSort' (int)GotStatus.Corrupt] = new List<RepStatus> { RepStatus.DirCorrupt }; " is 127.
Long Statement,ROMVault2,RepairStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,InitStatusCheck,The length of the statement  "            StatusCheck[(int)FileType.Zip' (int)DatStatus.InToSort' (int)GotStatus.FileLocked] = new List<RepStatus> { RepStatus.UnScanned }; " is 129.
Long Statement,ROMVault2,RepairStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,InitStatusCheck,The length of the statement  "            StatusCheck[(int)FileType.Zip' (int)DatStatus.InToSort' (int)GotStatus.NotGot] = new List<RepStatus> { RepStatus.Deleted }; " is 123.
Long Statement,ROMVault2,RepairStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,InitStatusCheck,The length of the statement  "            StatusCheck[(int)FileType.Zip' (int)DatStatus.NotInDat' (int)GotStatus.Got] = new List<RepStatus> { RepStatus.DirUnknown }; " is 123.
Long Statement,ROMVault2,RepairStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,InitStatusCheck,The length of the statement  "            StatusCheck[(int)FileType.Zip' (int)DatStatus.NotInDat' (int)GotStatus.Corrupt] = new List<RepStatus> { RepStatus.DirCorrupt }; " is 127.
Long Statement,ROMVault2,RepairStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,InitStatusCheck,The length of the statement  "            StatusCheck[(int)FileType.Zip' (int)DatStatus.NotInDat' (int)GotStatus.FileLocked] = new List<RepStatus> { RepStatus.UnScanned }; " is 129.
Long Statement,ROMVault2,RepairStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,InitStatusCheck,The length of the statement  "            StatusCheck[(int)FileType.Zip' (int)DatStatus.NotInDat' (int)GotStatus.NotGot] = new List<RepStatus> { RepStatus.Deleted }; " is 123.
Long Statement,ROMVault2,RepairStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,InitStatusCheck,The length of the statement  "            StatusCheck[(int)FileType.File' (int)DatStatus.InDatBad' (int)GotStatus.FileLocked] = new List<RepStatus> { RepStatus.UnScanned }; " is 130.
Long Statement,ROMVault2,RepairStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,InitStatusCheck,The length of the statement  "            StatusCheck[(int)FileType.File' (int)DatStatus.InDatBad' (int)GotStatus.NotGot] = new List<RepStatus> { RepStatus.NotCollected }; " is 129.
Long Statement,ROMVault2,RepairStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,InitStatusCheck,The length of the statement  "            StatusCheck[(int)FileType.File' (int)DatStatus.InDatCollect' (int)GotStatus.Corrupt] = new List<RepStatus> { RepStatus.Corrupt' RepStatus.MoveToCorrupt' RepStatus.CorruptCanBeFixed }; " is 183.
Long Statement,ROMVault2,RepairStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,InitStatusCheck,The length of the statement  "            StatusCheck[(int)FileType.File' (int)DatStatus.InDatCollect' (int)GotStatus.FileLocked] = new List<RepStatus> { RepStatus.UnScanned }; " is 134.
Long Statement,ROMVault2,RepairStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,InitStatusCheck,The length of the statement  "            StatusCheck[(int)FileType.File' (int)DatStatus.InDatCollect' (int)GotStatus.Got] = new List<RepStatus> { RepStatus.Correct }; " is 125.
Long Statement,ROMVault2,RepairStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,InitStatusCheck,The length of the statement  "            StatusCheck[(int)FileType.File' (int)DatStatus.InDatCollect' (int)GotStatus.NotGot] = new List<RepStatus> { RepStatus.Missing' RepStatus.CanBeFixed }; " is 150.
Long Statement,ROMVault2,RepairStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,InitStatusCheck,The length of the statement  "            StatusCheck[(int)FileType.File' (int)DatStatus.InDatMerged' (int)GotStatus.Corrupt] = new List<RepStatus> { RepStatus.Corrupt' RepStatus.MoveToCorrupt' RepStatus.Delete }; " is 171.
Long Statement,ROMVault2,RepairStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,InitStatusCheck,The length of the statement  "            StatusCheck[(int)FileType.File' (int)DatStatus.InDatMerged' (int)GotStatus.FileLocked] = new List<RepStatus> { RepStatus.UnScanned }; " is 133.
Long Statement,ROMVault2,RepairStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,InitStatusCheck,The length of the statement  "            StatusCheck[(int)FileType.File' (int)DatStatus.InDatMerged' (int)GotStatus.Got] = new List<RepStatus> { RepStatus.UnNeeded' RepStatus.Delete' RepStatus.NeededForFix }; " is 167.
Long Statement,ROMVault2,RepairStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,InitStatusCheck,The length of the statement  "            StatusCheck[(int)FileType.File' (int)DatStatus.InDatMerged' (int)GotStatus.NotGot] = new List<RepStatus> { RepStatus.NotCollected }; " is 132.
Long Statement,ROMVault2,RepairStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,InitStatusCheck,The length of the statement  "            StatusCheck[(int)FileType.File' (int)DatStatus.InToSort' (int)GotStatus.Corrupt] = new List<RepStatus> { RepStatus.Corrupt' RepStatus.Delete }; " is 143.
Long Statement,ROMVault2,RepairStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,InitStatusCheck,The length of the statement  "            StatusCheck[(int)FileType.File' (int)DatStatus.InToSort' (int)GotStatus.FileLocked] = new List<RepStatus> { RepStatus.UnScanned }; " is 130.
Long Statement,ROMVault2,RepairStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,InitStatusCheck,The length of the statement  "            StatusCheck[(int)FileType.File' (int)DatStatus.InToSort' (int)GotStatus.Got] = new List<RepStatus> { RepStatus.InToSort' RepStatus.Ignore' RepStatus.NeededForFix' RepStatus.Delete }; " is 182.
Long Statement,ROMVault2,RepairStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,InitStatusCheck,The length of the statement  "            StatusCheck[(int)FileType.File' (int)DatStatus.InToSort' (int)GotStatus.NotGot] = new List<RepStatus> { RepStatus.Deleted }; " is 124.
Long Statement,ROMVault2,RepairStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,InitStatusCheck,The length of the statement  "            StatusCheck[(int)FileType.File' (int)DatStatus.NotInDat' (int)GotStatus.Corrupt] = new List<RepStatus> { RepStatus.Corrupt' RepStatus.MoveToCorrupt' RepStatus.Delete }; " is 168.
Long Statement,ROMVault2,RepairStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,InitStatusCheck,The length of the statement  "            StatusCheck[(int)FileType.File' (int)DatStatus.NotInDat' (int)GotStatus.Got] = new List<RepStatus> { RepStatus.Unknown' RepStatus.Ignore' RepStatus.Delete' RepStatus.MoveToSort' RepStatus.NeededForFix' RepStatus.Rename }; " is 221.
Long Statement,ROMVault2,RepairStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,InitStatusCheck,The length of the statement  "            StatusCheck[(int)FileType.File' (int)DatStatus.NotInDat' (int)GotStatus.FileLocked] = new List<RepStatus> { RepStatus.UnScanned }; " is 130.
Long Statement,ROMVault2,RepairStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,InitStatusCheck,The length of the statement  "            StatusCheck[(int)FileType.File' (int)DatStatus.NotInDat' (int)GotStatus.NotGot] = new List<RepStatus> { RepStatus.Deleted }; " is 124.
Long Statement,ROMVault2,RepairStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,InitStatusCheck,The length of the statement  "            StatusCheck[(int)FileType.ZipFile' (int)DatStatus.InDatBad' (int)GotStatus.NotGot] = new List<RepStatus> { RepStatus.NotCollected }; " is 132.
Long Statement,ROMVault2,RepairStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,InitStatusCheck,The length of the statement  "            StatusCheck[(int)FileType.ZipFile' (int)DatStatus.InDatBad' (int)GotStatus.Got] = new List<RepStatus> { RepStatus.Correct }; " is 124.
Long Statement,ROMVault2,RepairStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,InitStatusCheck,The length of the statement  "            StatusCheck[(int)FileType.ZipFile' (int)DatStatus.InDatCollect' (int)GotStatus.Corrupt] = new List<RepStatus> { RepStatus.Corrupt' RepStatus.MoveToCorrupt' RepStatus.CorruptCanBeFixed }; " is 186.
Long Statement,ROMVault2,RepairStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,InitStatusCheck,The length of the statement  "            StatusCheck[(int)FileType.ZipFile' (int)DatStatus.InDatCollect' (int)GotStatus.Got] = new List<RepStatus> { RepStatus.Correct }; " is 128.
Long Statement,ROMVault2,RepairStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,InitStatusCheck,The length of the statement  "            StatusCheck[(int)FileType.ZipFile' (int)DatStatus.InDatCollect' (int)GotStatus.FileLocked] = new List<RepStatus> { RepStatus.UnScanned }; " is 137.
Long Statement,ROMVault2,RepairStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,InitStatusCheck,The length of the statement  "            StatusCheck[(int)FileType.ZipFile' (int)DatStatus.InDatCollect' (int)GotStatus.NotGot] = new List<RepStatus> { RepStatus.Missing' RepStatus.CanBeFixed }; " is 153.
Long Statement,ROMVault2,RepairStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,InitStatusCheck,The length of the statement  "            StatusCheck[(int)FileType.ZipFile' (int)DatStatus.InDatMerged' (int)GotStatus.Got] = new List<RepStatus> { RepStatus.UnNeeded' RepStatus.Delete' RepStatus.NeededForFix' RepStatus.Rename }; " is 188.
Long Statement,ROMVault2,RepairStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,InitStatusCheck,The length of the statement  "            StatusCheck[(int)FileType.ZipFile' (int)DatStatus.InDatMerged' (int)GotStatus.NotGot] = new List<RepStatus> { RepStatus.NotCollected }; " is 135.
Long Statement,ROMVault2,RepairStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,InitStatusCheck,The length of the statement  "            StatusCheck[(int)FileType.ZipFile' (int)DatStatus.InToSort' (int)GotStatus.Corrupt] = new List<RepStatus> { RepStatus.Corrupt' RepStatus.Delete }; " is 146.
Long Statement,ROMVault2,RepairStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,InitStatusCheck,The length of the statement  "            StatusCheck[(int)FileType.ZipFile' (int)DatStatus.InToSort' (int)GotStatus.Got] = new List<RepStatus> { RepStatus.InToSort' RepStatus.NeededForFix' RepStatus.Delete }; " is 167.
Long Statement,ROMVault2,RepairStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,InitStatusCheck,The length of the statement  "            StatusCheck[(int)FileType.ZipFile' (int)DatStatus.InToSort' (int)GotStatus.NotGot] = new List<RepStatus> { RepStatus.Deleted }; " is 127.
Long Statement,ROMVault2,RepairStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,InitStatusCheck,The length of the statement  "            StatusCheck[(int)FileType.ZipFile' (int)DatStatus.NotInDat' (int)GotStatus.Corrupt] = new List<RepStatus> { RepStatus.Corrupt' RepStatus.MoveToCorrupt' RepStatus.Delete }; " is 171.
Long Statement,ROMVault2,RepairStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,InitStatusCheck,The length of the statement  "            StatusCheck[(int)FileType.ZipFile' (int)DatStatus.NotInDat' (int)GotStatus.Got] = new List<RepStatus> { RepStatus.Unknown' RepStatus.Delete' RepStatus.MoveToSort' RepStatus.NeededForFix' RepStatus.Rename }; " is 206.
Long Statement,ROMVault2,RepairStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,InitStatusCheck,The length of the statement  "            StatusCheck[(int)FileType.ZipFile' (int)DatStatus.NotInDat' (int)GotStatus.NotGot] = new List<RepStatus> { RepStatus.Deleted }; " is 127.
Long Statement,ROMVault2,ReportStatus,C:\repos\gjefferyes_RomVault\ROMVault2\RepairStatus.cs,CountAnyFiles,The length of the statement  "            // this list include probably more status's than are needed' but all are here to double check I don't delete something I should not. " is 132.
Long Statement,ROMVault2,DBHelper,C:\repos\gjefferyes_RomVault\ROMVault2\DBHelper.cs,DatCompare,The length of the statement  "            int retv = Math.Sign(string.Compare(var1.GetData(RvDat.DatData.DatFullName)' var2.GetData(RvDat.DatData.DatFullName)' StringComparison.CurrentCultureIgnoreCase)); " is 162.
Long Statement,ROMVault2,DBHelper,C:\repos\gjefferyes_RomVault\ROMVault2\DBHelper.cs,RomSearchFindFixes,The length of the statement  "                if (lstFiles[intIndex].GotStatus == GotStatus.Got && FindFixes.CheckIfMissingFileCanBeFixedByGotFile(tRom' lstFiles[intIndex])) " is 127.
Long Statement,ROMVault2.SupportedFiles.CHD,CHD,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\CHD\CHD.cs,CHDOutputHandler,The length of the statement  "                    if (!System.Text.RegularExpressions.Regex.IsMatch(sOut' @"^chdman - MAME Compressed Hunks of Data \(CHD\) manager ([0-9\.]+) \(.*\)"))  " is 134.
Long Statement,ROMVault2.SupportedFiles.CHD,CHD,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\CHD\CHD.cs,CHDErrorHandler,The length of the statement  "                else if (System.Text.RegularExpressions.Regex.IsMatch(sLine' @"^No verification to be done; CHD has (uncompressed|no checksum)")) " is 129.
Long Statement,ROMVault2.DatReaders,DatDOSReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatDOSReader.cs,ReadDat,The length of the statement  "                        DatUpdate.SendAndShowDat(Resources.DatCmpReader_ReadDat_Error_keyword + DatFileLoader.Next + Resources.DatCmpReader_ReadDat_not_known' DatFileLoader.Filename); " is 159.
Long Statement,ROMVault2.DatReaders,DatDOSReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatDOSReader.cs,LoadHeaderFromDat,The length of the statement  "                    tDat.AddData(RvDat.DatData.DatName'  VarFix.CleanFileName(DatFileLoader.Next.Substring(5) + " " + DatFileLoader.GnRest()).Trim()); DatFileLoader.Gn(); " is 150.
Long Statement,ROMVault2.DatReaders,DatDOSReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatDOSReader.cs,LoadHeaderFromDat,The length of the statement  "                        case "name:": tDat.AddData(RvDat.DatData.DatName' VarFix.CleanFileName(DatFileLoader.GnRest())); DatFileLoader.Gn(); break; " is 123.
Long Statement,ROMVault2.DatReaders,DatDOSReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatDOSReader.cs,LoadHeaderFromDat,The length of the statement  "                            DatUpdate.SendAndShowDat(Resources.DatCmpReader_ReadDat_Error_keyword + DatFileLoader.Next + Resources.DatCmpReader_LoadHeaderFromDat_not_known_in_clrmamepro' DatFileLoader.Filename); " is 183.
Long Statement,ROMVault2.DatReaders,DatDOSReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatDOSReader.cs,LoadGameFromDat,The length of the statement  "                DatUpdate.SendAndShowDat(Resources.DatCmpReader_LoadGameFromDat_Name_not_found_as_first_object_in' DatFileLoader.Filename); " is 123.
Long Statement,ROMVault2.DatReaders,DatDOSReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatDOSReader.cs,LoadGameFromDat,The length of the statement  "                        DatUpdate.SendAndShowDat(Resources.DatCmpReader_ReadDat_Error_keyword + DatFileLoader.Next + Resources.DatCmpReader_LoadGameFromDat_not_known_in_game' DatFileLoader.Filename); " is 175.
Long Statement,ROMVault2.DatReaders,DatCmpReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatCmpReader.cs,ReadDat,The length of the statement  "                        DatUpdate.SendAndShowDat(Resources.DatCmpReader_ReadDat_Error_keyword + DatFileLoader.Next + Resources.DatCmpReader_ReadDat_not_known' DatFileLoader.Filename); " is 159.
Long Statement,ROMVault2.DatReaders,DatCmpReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatCmpReader.cs,LoadHeaderFromDat,The length of the statement  "                    case "name": tDat.AddData(RvDat.DatData.DatName' VarFix.CleanFileName(DatFileLoader.GnRest())); DatFileLoader.Gn(); break; " is 122.
Long Statement,ROMVault2.DatReaders,DatCmpReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatCmpReader.cs,LoadHeaderFromDat,The length of the statement  "                        DatUpdate.SendAndShowDat(Resources.DatCmpReader_ReadDat_Error_keyword + DatFileLoader.Next + Resources.DatCmpReader_LoadHeaderFromDat_not_known_in_clrmamepro' DatFileLoader.Filename); " is 183.
Long Statement,ROMVault2.DatReaders,DatCmpReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatCmpReader.cs,LoadDirFromDat,The length of the statement  "                DatUpdate.SendAndShowDat(Resources.DatCmpReader_LoadGameFromDat_Name_not_found_as_first_object_in' DatFileLoader.Filename); " is 123.
Long Statement,ROMVault2.DatReaders,DatCmpReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatCmpReader.cs,LoadDirFromDat,The length of the statement  "                        DatUpdate.SendAndShowDat(Resources.DatCmpReader_LoadDirFromDat_Error_Keyword + DatFileLoader.Next + Resources.DatCmpReader_LoadDirFromDat_not_know_in_dir' DatFileLoader.Filename); " is 179.
Long Statement,ROMVault2.DatReaders,DatCmpReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatCmpReader.cs,LoadGameFromDat,The length of the statement  "                DatUpdate.SendAndShowDat(Resources.DatCmpReader_LoadGameFromDat_Name_not_found_as_first_object_in' DatFileLoader.Filename); " is 123.
Long Statement,ROMVault2.DatReaders,DatCmpReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatCmpReader.cs,LoadGameFromDat,The length of the statement  "                    case "romof": tDir.Game.AddData(RvGame.GameData.RomOf' VarFix.CleanFileName(DatFileLoader.GnRest())); DatFileLoader.Gn(); break; " is 128.
Long Statement,ROMVault2.DatReaders,DatCmpReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatCmpReader.cs,LoadGameFromDat,The length of the statement  "                    case "manufacturer": tDir.Game.AddData(RvGame.GameData.Manufacturer' DatFileLoader.GnRest()); DatFileLoader.Gn(); break; " is 120.
Long Statement,ROMVault2.DatReaders,DatCmpReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatCmpReader.cs,LoadGameFromDat,The length of the statement  "                        DatUpdate.SendAndShowDat(Resources.DatCmpReader_ReadDat_Error_keyword + DatFileLoader.Next + Resources.DatCmpReader_LoadGameFromDat_not_known_in_game' DatFileLoader.Filename); " is 175.
Long Statement,ROMVault2.DatReaders,DatCmpReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatCmpReader.cs,LoadRomFromDat,The length of the statement  "                DatUpdate.SendAndShowDat(Resources.DatCmpReader_LoadGameFromDat_Name_not_found_as_first_object_in' DatFileLoader.Filename); " is 123.
Long Statement,ROMVault2.DatReaders,DatCmpReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatCmpReader.cs,LoadRomFromDat,The length of the statement  "                        DatUpdate.SendAndShowDat(Resources.DatCmpReader_ReadDat_Error_keyword + DatFileLoader.Next + Resources.DatCmpReader_LoadRomFromDat_not_known_in_rom' DatFileLoader.Filename); " is 173.
Long Statement,ROMVault2.DatReaders,DatCmpReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatCmpReader.cs,LoadDiskFromDat,The length of the statement  "                DatUpdate.SendAndShowDat(Resources.DatCmpReader_LoadGameFromDat_Name_not_found_as_first_object_in' DatFileLoader.Filename); " is 123.
Long Statement,ROMVault2.DatReaders,DatCmpReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatCmpReader.cs,LoadDiskFromDat,The length of the statement  "                        DatUpdate.SendAndShowDat(Resources.DatCmpReader_ReadDat_Error_keyword + DatFileLoader.Next + Resources.DatCmpReader_LoadRomFromDat_not_known_in_rom' DatFileLoader.Filename); " is 173.
Long Statement,ROMVault2.DatReaders,DatCmpReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatCmpReader.cs,LoadArchiveFromDat,The length of the statement  "                        DatUpdate.SendAndShowDat(Resources.DatCmpReader_ReadDat_Error_keyword + DatFileLoader.Next + " not know in Archive"' DatFileLoader.Filename); " is 141.
Long Statement,ROMVault2.DatReaders,DatReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatReader.cs,ReadInDatFile,The length of the statement  "            else if (strLine.ToLower().IndexOf("clrmamepro"' StringComparison.Ordinal) >= 0 || strLine.ToLower().IndexOf("romvault"' StringComparison.Ordinal) >= 0 || strLine.ToLower().IndexOf("game"' StringComparison.Ordinal) >= 0) " is 220.
Long Statement,ROMVault2.DatReaders,DatReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatReader.cs,ReadXMLDat,The length of the statement  "                _bgw.ReportProgress(0' new bgwShowError(strFilename' string.Format("Error Occured Reading Dat:\r\n{0}\r\n"' e.Message))); " is 121.
Long Statement,ROMVault2.DatReaders,DatReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatReader.cs,DatSetCheckParentSets,The length of the statement  "                                if (mGame.Child(r).Name != romofGame.Child(r1).Name || ((RvFile)mGame.Child(r)).Size != ((RvFile)romofGame.Child(r1)).Size) " is 123.
Long Statement,ROMVault2.DatReaders,DatReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatReader.cs,DatSetMergeSets,The length of the statement  "                while (lstParentGames.Count > 0 && lstParentGames[lstParentGames.Count - 1].Game.GetData(RvGame.GameData.IsBios).ToLower() == "yes") " is 132.
Long Statement,ROMVault2.RvDB,RvBase,C:\repos\gjefferyes_RomVault\ROMVault2\RvDB\RvBase.cs,RepStatusReset,The length of the statement  "            if ((RepStatus == RepStatus.UnSet || RepStatus == RepStatus.Unknown || RepStatus == RepStatus.Ignore) && FileType == FileType.File && GotStatus == GotStatus.Got && DatStatus==DatStatus.NotInDat) " is 194.
Long Statement,ROMVault2.RvDB,RvFile,C:\repos\gjefferyes_RomVault\ROMVault2\RvDB\RvFile.cs,DatRemove,The length of the statement  "            FileStatusClear(FileStatus.SizeFromDAT | FileStatus.CRCFromDAT | FileStatus.SHA1FromDAT | FileStatus.MD5FromDAT | FileStatus.SHA1CHDFromDAT | FileStatus.MD5CHDFromDAT); " is 168.
Long Statement,ROMVault2.RvDB,RvFile,C:\repos\gjefferyes_RomVault\ROMVault2\RvDB\RvFile.cs,DatAdd,The length of the statement  "                FileStatus.SizeFromDAT | FileStatus.CRCFromDAT | FileStatus.SHA1FromDAT | FileStatus.MD5FromDAT | FileStatus.SHA1CHDFromDAT | FileStatus.MD5CHDFromDAT' " is 151.
Long Statement,ROMVault2.RvDB,RvFile,C:\repos\gjefferyes_RomVault\ROMVault2\RvDB\RvFile.cs,FileRemove,The length of the statement  "                FileStatus.SizeFromHeader | FileStatus.CRCFromHeader | FileStatus.SHA1FromHeader | FileStatus.MD5FromHeader | FileStatus.SHA1CHDFromHeader | FileStatus.MD5CHDFromHeader | " is 170.
Long Statement,ROMVault2.RvDB,RvFile,C:\repos\gjefferyes_RomVault\ROMVault2\RvDB\RvFile.cs,FileRemove,The length of the statement  "                FileStatus.SizeVerified | FileStatus.CRCVerified | FileStatus.SHA1Verified | FileStatus.MD5Verified | FileStatus.SHA1CHDVerified | FileStatus.MD5CHDVerified); " is 158.
Long Statement,ROMVault2.RvDB,RvFile,C:\repos\gjefferyes_RomVault\ROMVault2\RvDB\RvFile.cs,FileAdd,The length of the statement  "                FileStatus.SizeFromHeader | FileStatus.CRCFromHeader | FileStatus.SHA1FromHeader | FileStatus.MD5FromHeader | FileStatus.SHA1CHDFromHeader | FileStatus.MD5CHDFromHeader | " is 170.
Long Statement,ROMVault2.RvDB,RvFile,C:\repos\gjefferyes_RomVault\ROMVault2\RvDB\RvFile.cs,FileAdd,The length of the statement  "                FileStatus.SizeVerified | FileStatus.CRCVerified | FileStatus.SHA1Verified | FileStatus.MD5Verified | FileStatus.SHA1CHDVerified | FileStatus.MD5CHDVerified' " is 157.
Long Statement,ROMVault2.RvDB,DB,C:\repos\gjefferyes_RomVault\ROMVault2\RvDB\DB.cs,Read,The length of the statement  "                ReportError.Show(Resources.DB_Read_Data_Cache_version_is_out_of_date_you_should_now_rescan_your_dat_directory_and_roms_directory_); " is 131.
Long Statement,ROMVault2.SupportedFiles.Zip.ZLib,ZlibBaseStream,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\ZlibBaseStream.cs,finish,The length of the statement  "                            throw new ZlibException(String.Format("Bad CRC32 in GZIP trailer. (actual({0:X8})!=expected({1:X8}))"' crc32_actual' crc32_expected)); " is 134.
Long Statement,ROMVault2.SupportedFiles.Zip.ZLib,ZlibBaseStream,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\ZlibBaseStream.cs,finish,The length of the statement  "                            throw new ZlibException(String.Format("Bad size in GZIP trailer. (actual({0})!=expected({1}))"' isize_actual' isize_expected)); " is 127.
Long Statement,ROMVault2.Utils,RelativePath,C:\repos\gjefferyes_RomVault\ROMVault2\Utils\RelativePath.cs,MakeRelative,The length of the statement  "                bool isDifferentRoot = (String.Compare(Path.GetPathRoot(fromDirectory)' Path.GetPathRoot(toPath)' StringComparison.OrdinalIgnoreCase) != 0); " is 140.
Long Statement,ROMVault2.IO,Directory,C:\repos\gjefferyes_RomVault\ROMVault2\IO\RVIO.cs,Move,The length of the statement  "                if (hr == Win32Native.ERROR_ACCESS_DENIED) // WinNT throws IOException. This check is for Win9x. We can't change it for backcomp. " is 129.
Long Statement,ROMVault2.IO,File,C:\repos\gjefferyes_RomVault\ROMVault2\IO\RVIO.cs,Copy,The length of the statement  "                throw new ArgumentException("Argument_EmptyFileName"' (sourceFileName.Length == 0 ? "sourceFileName" : "destFileName")); " is 120.
Long Statement,ROMVault2.IO,File,C:\repos\gjefferyes_RomVault\ROMVault2\IO\RVIO.cs,Copy,The length of the statement  "                    using (SafeFileHandle handle = Win32Native.UnsafeCreateFile(fullSourceFileName' FileStream.GENERIC_READ' FileShare.Read' null' FileMode.Open' 0' IntPtr.Zero)) " is 158.
Long Statement,ROMVault2.IO,File,C:\repos\gjefferyes_RomVault\ROMVault2\IO\RVIO.cs,Copy,The length of the statement  "                            throw new IOException(String.Format(CultureInfo.CurrentCulture' Environment.GetResourceString("Arg_FileIsDirectory_Name")' destFileName)' Win32Native.ERROR_ACCESS_DENIED' fullDestFileName); " is 189.
Long Statement,ROMVault2.IO,File,C:\repos\gjefferyes_RomVault\ROMVault2\IO\RVIO.cs,Move,The length of the statement  "                throw new ArgumentException("Argument_EmptyFileName"' (sourceFileName.Length == 0 ? "sourceFileName" : "destFileName")); " is 120.
Long Statement,ROMVault2.SupportedFiles.Zip,ZipFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,EndOfCentralDirWrite,The length of the statement  "            bw.Write((ushort)(_localFiles.Count >= 0xffff ? 0xffff : _localFiles.Count));  // TotalNumber of enteries in the central directory  " is 130.
Long Statement,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,LocalFileHeaderRead,The length of the statement  "                    if (Zip64 && tCompressedSize != 0xffffffff && tCompressedSize != _compressedSize)   // if Zip64 File then the compressedSize should be 0xffffffff " is 145.
Long Statement,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,LocalFileHeaderRead,The length of the statement  "                    if (Zip64 && tUnCompressedSize != 0xffffffff && tUnCompressedSize != UncompressedSize)   // if Zip64 File then the unCompressedSize should be 0xffffffff " is 152.
Complex Conditional,ROMVault2,Report,C:\repos\gjefferyes_RomVault\ROMVault2\Report.cs,MakeFixFilesRecurse,The conditional expression  "tRom.DatStatus == DatStatus.InDatCollect && tRom.GotStatus != GotStatus.Got && !(tRom.RepStatus == RepStatus.CanBeFixed || tRom.RepStatus == RepStatus.CorruptCanBeFixed)"  is complex.
Complex Conditional,ROMVault2,Report,C:\repos\gjefferyes_RomVault\ROMVault2\Report.cs,ReportMissingFindSizes,The conditional expression  "(rt == ReportType.PartialMissing && Partial.Contains(f.RepStatus)) ||                          (rt == ReportType.Fixing && Fixing.Contains(f.RepStatus))"  is complex.
Complex Conditional,ROMVault2,Report,C:\repos\gjefferyes_RomVault\ROMVault2\Report.cs,ReportMissing,The conditional expression  "(rt == ReportType.PartialMissing && Partial.Contains(f.RepStatus)) ||                         (rt == ReportType.Fixing && Fixing.Contains(f.RepStatus))"  is complex.
Complex Conditional,ROMVault2,FixFileCopy,C:\repos\gjefferyes_RomVault\ROMVault2\FixFileCopy.cs,CopyFile,The conditional expression  "!rawCopy && (Program.rvSettings.FixLevel == eFixLevel.TrrntZipLevel1 || Program.rvSettings.FixLevel == eFixLevel.TrrntZipLevel2 || Program.rvSettings.FixLevel == eFixLevel.TrrntZipLevel3)"  is complex.
Complex Conditional,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,FixZip,The conditional expression  "!                                (                              // got the file in the original zip but will be deleting it                                  (zipFileFixing.DatStatus == DatStatus.NotInDat && zipFileFixing.GotStatus == GotStatus.Got) ||                                  (zipFileFixing.DatStatus == DatStatus.NotInDat && zipFileFixing.GotStatus == GotStatus.Corrupt) ||                                  (zipFileFixing.DatStatus == DatStatus.InDatMerged && zipFileFixing.GotStatus == GotStatus.Got) ||                                  (zipFileFixing.DatStatus == DatStatus.InToSort && zipFileFixing.GotStatus == GotStatus.Got) ||                                  (zipFileFixing.DatStatus == DatStatus.InToSort && zipFileFixing.GotStatus == GotStatus.Corrupt) ||                                    // do not have this file and cannot fix it here                                  (zipFileFixing.DatStatus == DatStatus.InDatCollect && zipFileFixing.GotStatus == GotStatus.NotGot) ||                                  (zipFileFixing.DatStatus == DatStatus.InDatBad && zipFileFixing.GotStatus == GotStatus.NotGot) ||                                  (zipFileFixing.DatStatus == DatStatus.InDatMerged && zipFileFixing.GotStatus == GotStatus.NotGot)                                  )"  is complex.
Complex Conditional,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,FixZip,The conditional expression  "!                                    (                                      (zipFileFixing.DatStatus == DatStatus.InDatCollect && zipFileFixing.GotStatus == GotStatus.Got) ||                                      (zipFileFixing.DatStatus == DatStatus.InDatMerged && zipFileFixing.GotStatus == GotStatus.Got) ||                                      (zipFileFixing.DatStatus == DatStatus.NotInDat && zipFileFixing.GotStatus == GotStatus.Got) ||                                      (zipFileFixing.DatStatus == DatStatus.InToSort && zipFileFixing.GotStatus == GotStatus.Got) ||                                      (zipFileFixing.DatStatus == DatStatus.InToSort && zipFileFixing.GotStatus == GotStatus.Corrupt)                                    )"  is complex.
Complex Conditional,ROMVault2,FileScanning,C:\repos\gjefferyes_RomVault\ROMVault2\FileScanning.cs,MatchFound,The conditional expression  "dbChild.TimeStamp != fileChild.TimeStamp || EScanLevel == eScanLevel.Level3 ||                          (EScanLevel == eScanLevel.Level2 && !IsDeepScanned((RvDir)dbChild))"  is complex.
Complex Conditional,ROMVault2,FileScanning,C:\repos\gjefferyes_RomVault\ROMVault2\FileScanning.cs,IsDeepScanned,The conditional expression  "zFile != null && zFile.GotStatus == GotStatus.Got &&                      (!zFile.FileStatusIs(FileStatus.SizeVerified) || !zFile.FileStatusIs(FileStatus.CRCVerified) || !zFile.FileStatusIs(FileStatus.SHA1Verified) || !zFile.FileStatusIs(FileStatus.MD5Verified))"  is complex.
Complex Conditional,ROMVault2.SupportedFiles.CHD,CHD,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\CHD\CHD.cs,CheckFile,The conditional expression  "compression0 == 0 && compression1 == 0 && compression2 == 0 && compression3 == 0"  is complex.
Complex Conditional,ROMVault2.DatReaders,DatDOSReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatDOSReader.cs,LoadRomFromDat,The conditional expression  "posName < 0 || posSize < 0 || posDate < 0 || posCrc < 0 || posEnd < 0"  is complex.
Complex Conditional,ROMVault2.DatReaders,DatReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatReader.cs,DatSetMergeSets,The conditional expression  "(name == romofGame.Child(r1).Name.ToLower() || mergename == romofGame.Child(r1).Name.ToLower()) &&                               (ArrByte.iCompare(((RvFile)mGame.Child(r)).CRC' ((RvFile)romofGame.Child(r1)).CRC) != 0 ||                               ((RvFile)mGame.Child(r)).Size != ((RvFile)romofGame.Child(r1)).Size)"  is complex.
Complex Conditional,ROMVault2.DatReaders,DatReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatReader.cs,DatSetMergeSets,The conditional expression  "(name == romofGame.Child(r1).Name.ToLower() || mergename == romofGame.Child(r1).Name.ToLower()) &&                              (ArrByte.iCompare(((RvFile)mGame.Child(r)).CRC' ((RvFile)romofGame.Child(r1)).CRC) == 0 &&                               ((RvFile)mGame.Child(r)).Size == ((RvFile)romofGame.Child(r1)).Size)"  is complex.
Complex Conditional,ROMVault2.RvDB,RvBase,C:\repos\gjefferyes_RomVault\ROMVault2\RvDB\RvBase.cs,RepStatusReset,The conditional expression  "(RepStatus == RepStatus.UnSet || RepStatus == RepStatus.Unknown || RepStatus == RepStatus.Ignore) && FileType == FileType.File && GotStatus == GotStatus.Got && DatStatus==DatStatus.NotInDat"  is complex.
Complex Conditional,ROMVault2.RvDB,RvDir,C:\repos\gjefferyes_RomVault\ROMVault2\RvDB\RvDir.cs,ChildAdd,The conditional expression  "(FileType == FileType.Dir && child.FileType == FileType.ZipFile) ||                  (FileType == FileType.Zip && child.FileType != FileType.ZipFile)"  is complex.
Complex Conditional,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,DeflateSlow,The conditional expression  "match_length <= 5 && (compressionStrategy == CompressionStrategy.Filtered ||                                                (match_length == MIN_MATCH && strstart - match_start > 4096))"  is complex.
Complex Conditional,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,longest_match,The conditional expression  "window[match + best_len] != scan_end ||                      window[match + best_len - 1] != scan_end1 ||                      window[match] != window[scan] ||                      window[++match] != window[scan + 1]"  is complex.
Complex Conditional,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Deflate,The conditional expression  "_codec.OutputBuffer == null ||                  (_codec.InputBuffer == null && _codec.AvailableBytesIn != 0) ||                  (status == FINISH_STATE && flush != FlushType.Finish)"  is complex.
Complex Conditional,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Deflate,The conditional expression  "_codec.AvailableBytesIn != 0 || lookahead != 0 || (flush != FlushType.None && status != FINISH_STATE)"  is complex.
Complex Conditional,ROMVault2.SupportedFiles.Zip.ZLib,ZlibCodec,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\ZlibCodec.cs,flush_pending,The conditional expression  "dstate.pending.Length <= dstate.nextPending ||                  OutputBuffer.Length <= NextOut ||                  dstate.pending.Length < (dstate.nextPending + len) ||                  OutputBuffer.Length < (NextOut + len)"  is complex.
Complex Conditional,ROMVault2.Utils,VarFix,C:\repos\gjefferyes_RomVault\ROMVault2\Utils\VarFix.cs,CleanFullFileName,The conditional expression  "c == ':' || c == '*' || c == '?' || c == '<' || c == '>' || c == '|' || c < 32"  is complex.
Complex Conditional,ROMVault2.Utils,VarFix,C:\repos\gjefferyes_RomVault\ROMVault2\Utils\VarFix.cs,CleanFileName,The conditional expression  "c == ':' || c == '*' || c == '?' || c == '<' || c == '>' || c == '|' || c == '\\' || c == '/' || c < 32"  is complex.
Complex Conditional,ROMVault2.IO,Path,C:\repos\gjefferyes_RomVault\ROMVault2\IO\RVIO.cs,IsPathRooted,The conditional expression  "(length >= 1 && (path[0] == DirectorySeparatorChar ||                      path[0] == AltDirectorySeparatorChar)) ||                      (length >= 2 && path[1] == VolumeSeparatorChar)"  is complex.
Complex Conditional,ROMVault2.IO,Path,C:\repos\gjefferyes_RomVault\ROMVault2\IO\RVIO.cs,GetRootLength,The conditional expression  "i < length && ((path[i] != DirectorySeparatorChar && path[i] != AltDirectorySeparatorChar) || --n > 0)"  is complex.
Complex Conditional,ROMVault2.SupportedFiles.Zip,ZipFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,FindEndOfCentralDirSignature,The conditional expression  "(buffer[i] != 0x50) || (buffer[i + 1] != 0x4b) || (buffer[i + 2] != 0x05) || (buffer[i + 3] != 0x06)"  is complex.
Empty Catch Block,ROMVault2,FrmHelpAbout,C:\repos\gjefferyes_RomVault\ROMVault2\FrmHelpAbout.cs,label2_Click,The method has an empty catch block.
Empty Catch Block,ROMVault2,ReportError,C:\repos\gjefferyes_RomVault\ROMVault2\ReportError.cs,UnhandledExceptionHandler,The method has an empty catch block.
Empty Catch Block,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,RomGridMouseUp,The method has an empty catch block.
Empty Catch Block,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,GameGrid_MouseUp,The method has an empty catch block.
Empty Catch Block,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,RomGrid_SortCompare,The method has an empty catch block.
Magic Number,ROMVault2,DatMaker,C:\repos\gjefferyes_RomVault\ROMVault2\DatMaker.cs,justCHDs,The following statement contains a magic number: for (int j = 2; j < lst.Count; j++) WriteLine(lst[j]);
Magic Number,ROMVault2,DatMaker,C:\repos\gjefferyes_RomVault\ROMVault2\DatMaker.cs,ProcessDir,The following statement contains a magic number: for (int i = 0; i < dir.ChildCount; i++)              {                  RvDir item = dir.Child(i) as RvDir;                  if (item != null && item.FileType == FileType.Dir)                  {                      if (disks.Count > 2 && item.Name != disks[0]) // flush the last one if there were only CHDs in it                      {                          justCHDs(indent' disks);                          disks.Clear();                      }                  // tabulate next disk list' if any                  disks = new System.Collections.Generic.List<string>()                      { item.Name' item.Game == null ? item.Name : item.Game.GetData(RvGame.GameData.Description) };                  for (int j = 0; j < item.ChildCount; j++)                      {                          RvFile chd = item.Child(j) as RvFile;                          if (chd != null && chd.FileType == FileType.File && chd.Name.EndsWith(".chd"))                          {                              if (!string.IsNullOrEmpty(Utils.ArrByte.ToString(chd.SHA1CHD)))                                  disks.Add((indent + "\t<disk name=\"" + clean(chd.Name).Replace(".chd"' "") + "\" sha1=\"" + Utils.ArrByte.ToString(chd.SHA1CHD) + "\"/>"));                              else                                  disks.Add((indent + "\t<disk name=\"" + clean(chd.Name).Replace(".chd"' "") + "\" status=\"nodump\"/>"));                          }                      }                  }                  if (item != null && item.FileType == FileType.Zip)                  {                      WriteLine(indent + "<game name=\"" + clean(item.Name) + "\">");                      string desc = item.Game == null ? item.Name : item.Game.GetData(RvGame.GameData.Description);                      WriteLine(indent + "\t<description>" + clean(desc) + "</description>");                        for (int j = 0; j < item.ChildCount; j++)                      {                          RvFile file = item.Child(j) as RvFile;                          if (file != null)                          {                              WriteLine(indent + "\t<rom name=\"" + clean(file.Name) + "\" size=\"" + file.Size + "\" crc=\"" + Utils.ArrByte.ToString(file.CRC) + "\" md5=\"" + Utils.ArrByte.ToString(file.MD5) + "\" sha1=\"" + Utils.ArrByte.ToString(file.SHA1) + "\"/>");                          }                      }                        if (disks.Count > 2) // take care of previous list of CHDs now                      {                          for (int j = 2; j < disks.Count; j++) WriteLine(disks[j]);                          disks.Clear();                      }                        WriteLine(indent + "</game>");                  }                                    if (item != null && item.FileType == FileType.Dir)                  {                      if (numDisks(item) == 0) // only recurse when children are not CHDs                      {                          WriteLine(indent + "<dir name=\"" + clean(item.Name) + "\">");                          ProcessDir(item' depth + 1);                          WriteLine(indent + "</dir>");                      }                  }              }
Magic Number,ROMVault2,DatMaker,C:\repos\gjefferyes_RomVault\ROMVault2\DatMaker.cs,ProcessDir,The following statement contains a magic number: for (int i = 0; i < dir.ChildCount; i++)              {                  RvDir item = dir.Child(i) as RvDir;                  if (item != null && item.FileType == FileType.Dir)                  {                      if (disks.Count > 2 && item.Name != disks[0]) // flush the last one if there were only CHDs in it                      {                          justCHDs(indent' disks);                          disks.Clear();                      }                  // tabulate next disk list' if any                  disks = new System.Collections.Generic.List<string>()                      { item.Name' item.Game == null ? item.Name : item.Game.GetData(RvGame.GameData.Description) };                  for (int j = 0; j < item.ChildCount; j++)                      {                          RvFile chd = item.Child(j) as RvFile;                          if (chd != null && chd.FileType == FileType.File && chd.Name.EndsWith(".chd"))                          {                              if (!string.IsNullOrEmpty(Utils.ArrByte.ToString(chd.SHA1CHD)))                                  disks.Add((indent + "\t<disk name=\"" + clean(chd.Name).Replace(".chd"' "") + "\" sha1=\"" + Utils.ArrByte.ToString(chd.SHA1CHD) + "\"/>"));                              else                                  disks.Add((indent + "\t<disk name=\"" + clean(chd.Name).Replace(".chd"' "") + "\" status=\"nodump\"/>"));                          }                      }                  }                  if (item != null && item.FileType == FileType.Zip)                  {                      WriteLine(indent + "<game name=\"" + clean(item.Name) + "\">");                      string desc = item.Game == null ? item.Name : item.Game.GetData(RvGame.GameData.Description);                      WriteLine(indent + "\t<description>" + clean(desc) + "</description>");                        for (int j = 0; j < item.ChildCount; j++)                      {                          RvFile file = item.Child(j) as RvFile;                          if (file != null)                          {                              WriteLine(indent + "\t<rom name=\"" + clean(file.Name) + "\" size=\"" + file.Size + "\" crc=\"" + Utils.ArrByte.ToString(file.CRC) + "\" md5=\"" + Utils.ArrByte.ToString(file.MD5) + "\" sha1=\"" + Utils.ArrByte.ToString(file.SHA1) + "\"/>");                          }                      }                        if (disks.Count > 2) // take care of previous list of CHDs now                      {                          for (int j = 2; j < disks.Count; j++) WriteLine(disks[j]);                          disks.Clear();                      }                        WriteLine(indent + "</game>");                  }                                    if (item != null && item.FileType == FileType.Dir)                  {                      if (numDisks(item) == 0) // only recurse when children are not CHDs                      {                          WriteLine(indent + "<dir name=\"" + clean(item.Name) + "\">");                          ProcessDir(item' depth + 1);                          WriteLine(indent + "</dir>");                      }                  }              }
Magic Number,ROMVault2,DatMaker,C:\repos\gjefferyes_RomVault\ROMVault2\DatMaker.cs,ProcessDir,The following statement contains a magic number: for (int i = 0; i < dir.ChildCount; i++)              {                  RvDir item = dir.Child(i) as RvDir;                  if (item != null && item.FileType == FileType.Dir)                  {                      if (disks.Count > 2 && item.Name != disks[0]) // flush the last one if there were only CHDs in it                      {                          justCHDs(indent' disks);                          disks.Clear();                      }                  // tabulate next disk list' if any                  disks = new System.Collections.Generic.List<string>()                      { item.Name' item.Game == null ? item.Name : item.Game.GetData(RvGame.GameData.Description) };                  for (int j = 0; j < item.ChildCount; j++)                      {                          RvFile chd = item.Child(j) as RvFile;                          if (chd != null && chd.FileType == FileType.File && chd.Name.EndsWith(".chd"))                          {                              if (!string.IsNullOrEmpty(Utils.ArrByte.ToString(chd.SHA1CHD)))                                  disks.Add((indent + "\t<disk name=\"" + clean(chd.Name).Replace(".chd"' "") + "\" sha1=\"" + Utils.ArrByte.ToString(chd.SHA1CHD) + "\"/>"));                              else                                  disks.Add((indent + "\t<disk name=\"" + clean(chd.Name).Replace(".chd"' "") + "\" status=\"nodump\"/>"));                          }                      }                  }                  if (item != null && item.FileType == FileType.Zip)                  {                      WriteLine(indent + "<game name=\"" + clean(item.Name) + "\">");                      string desc = item.Game == null ? item.Name : item.Game.GetData(RvGame.GameData.Description);                      WriteLine(indent + "\t<description>" + clean(desc) + "</description>");                        for (int j = 0; j < item.ChildCount; j++)                      {                          RvFile file = item.Child(j) as RvFile;                          if (file != null)                          {                              WriteLine(indent + "\t<rom name=\"" + clean(file.Name) + "\" size=\"" + file.Size + "\" crc=\"" + Utils.ArrByte.ToString(file.CRC) + "\" md5=\"" + Utils.ArrByte.ToString(file.MD5) + "\" sha1=\"" + Utils.ArrByte.ToString(file.SHA1) + "\"/>");                          }                      }                        if (disks.Count > 2) // take care of previous list of CHDs now                      {                          for (int j = 2; j < disks.Count; j++) WriteLine(disks[j]);                          disks.Clear();                      }                        WriteLine(indent + "</game>");                  }                                    if (item != null && item.FileType == FileType.Dir)                  {                      if (numDisks(item) == 0) // only recurse when children are not CHDs                      {                          WriteLine(indent + "<dir name=\"" + clean(item.Name) + "\">");                          ProcessDir(item' depth + 1);                          WriteLine(indent + "</dir>");                      }                  }              }
Magic Number,ROMVault2,DatMaker,C:\repos\gjefferyes_RomVault\ROMVault2\DatMaker.cs,ProcessDir,The following statement contains a magic number: if (disks.Count > 2) justCHDs(indent' disks);
Magic Number,ROMVault2,Report,C:\repos\gjefferyes_RomVault\ROMVault2\Report.cs,ReportDrawBars,The following statement contains a magic number: _ts.WriteLine("+" + new string('-'' _fileNameLength + 2) + "+" + new string('-'' _fileSizeLength + 2) + "+----------+" + new string('-'' _repStatusLength + 2) + "+");
Magic Number,ROMVault2,Report,C:\repos\gjefferyes_RomVault\ROMVault2\Report.cs,ReportDrawBars,The following statement contains a magic number: _ts.WriteLine("+" + new string('-'' _fileNameLength + 2) + "+" + new string('-'' _fileSizeLength + 2) + "+----------+" + new string('-'' _repStatusLength + 2) + "+");
Magic Number,ROMVault2,Report,C:\repos\gjefferyes_RomVault\ROMVault2\Report.cs,ReportDrawBars,The following statement contains a magic number: _ts.WriteLine("+" + new string('-'' _fileNameLength + 2) + "+" + new string('-'' _fileSizeLength + 2) + "+----------+" + new string('-'' _repStatusLength + 2) + "+");
Magic Number,ROMVault2,Report,C:\repos\gjefferyes_RomVault\ROMVault2\Report.cs,ReportMissing,The following statement contains a magic number: for (int i = 0; i < dir.ChildCount; i++)              {                  RvBase b = dir.Child(i);                  if (b.Dat != null && b.Dat != dat)                      continue;                    RvFile f = b as RvFile;                    if (f != null)                  {                      if (                         (rt == ReportType.PartialMissing && Partial.Contains(f.RepStatus)) ||                         (rt == ReportType.Fixing && Fixing.Contains(f.RepStatus))                         )                      {                          string filename = f.FileNameInsideGame();                          string crc = ArrByte.ToString(f.CRC);                          _ts.WriteLine("| " + filename + new string(' '' _fileNameLength + 1 - filename.Length) + "| "                                            + f.Size + new string(' '' _fileSizeLength + 1 - f.Size.ToString().Length) + "| "                                            + crc + new string(' '' 9 - crc.Length) + "| "                                            + f.RepStatus + new string(' '' _repStatusLength + 1 - f.RepStatus.ToString().Length) + "|");                      }                  }                  RvDir d = b as RvDir;                  if (d != null)                      ReportMissing(d' dat' rt);              }
Magic Number,ROMVault2,FindFixes,C:\repos\gjefferyes_RomVault\ROMVault2\FindFixes.cs,ScanFiles,The following statement contains a magic number: try              {                  _bgw = sender as BackgroundWorker;                  if (_bgw == null) return;                    Program.SyncCont = e.Argument as SynchronizationContext;                  if (Program.SyncCont == null)                  {                      _bgw = null;                      return;                  }                    _bgw.ReportProgress(0' new bgwText("Clearing DB Status"));                  RepairStatus.ReportStatusReset(DB.DirTree);                    List<RvFile> lstRomTableSortedCRCSize;                  List<RvFile> lstRomTableSortedSHA1CHD;                    _bgw.ReportProgress(0' new bgwText("Loading Rom List"));                  DBHelper.GetSelectedFilesSortCRCSize(out lstRomTableSortedCRCSize);                  DBHelper.GetSelectedFilesSortSHA1CHD(out lstRomTableSortedSHA1CHD);                    _bgw.ReportProgress(0' new bgwText("Scanning for Fixes"));                  _bgw.ReportProgress(0' new bgwSetRange(lstRomTableSortedCRCSize.Count));                    int romIndex0 = 0;                  int romIndex1 = 1;                  while (romIndex1 < lstRomTableSortedCRCSize.Count)                  {                      if (romIndex1 % 100 == 0) _bgw.ReportProgress(romIndex1);                        if (!ArrByte.bCompare(lstRomTableSortedCRCSize[romIndex0].CRC'lstRomTableSortedCRCSize[romIndex1].CRC) || lstRomTableSortedCRCSize[romIndex0].Size != lstRomTableSortedCRCSize[romIndex1].Size)                      {                          ListCheck(lstRomTableSortedCRCSize' romIndex0' romIndex1 - romIndex0);                          romIndex0 = romIndex1;                      }                      romIndex1++;                  }                    ListCheck(lstRomTableSortedCRCSize' romIndex0' romIndex1 - romIndex0);                        _bgw.ReportProgress(0' new bgwSetRange(lstRomTableSortedSHA1CHD.Count));                    romIndex0 = 0;                  romIndex1 = 1;                  while (romIndex1 < lstRomTableSortedSHA1CHD.Count)                  {                      if (romIndex1 % 100 == 0) _bgw.ReportProgress(romIndex1);                        if (!ArrByte.bCompare(lstRomTableSortedSHA1CHD[romIndex0].SHA1CHD'lstRomTableSortedSHA1CHD[romIndex1].SHA1CHD) )                      {                          ListCheckSHA1CHD(lstRomTableSortedSHA1CHD' romIndex0' romIndex1 - romIndex0);                          romIndex0 = romIndex1;                      }                      romIndex1++;                  }                    ListCheckSHA1CHD(lstRomTableSortedSHA1CHD' romIndex0' romIndex1 - romIndex0);                      _bgw = null;                  Program.SyncCont = null;              }              catch (Exception exc)              {                  ReportError.UnhandledExceptionHandler(exc);                    if (_bgw != null) _bgw.ReportProgress(0' new bgwText("Updating Cache"));                  DB.Write();                  if (_bgw != null) _bgw.ReportProgress(0' new bgwText("Complete"));                    _bgw = null;                  Program.SyncCont = null;              }
Magic Number,ROMVault2,FindFixes,C:\repos\gjefferyes_RomVault\ROMVault2\FindFixes.cs,ScanFiles,The following statement contains a magic number: try              {                  _bgw = sender as BackgroundWorker;                  if (_bgw == null) return;                    Program.SyncCont = e.Argument as SynchronizationContext;                  if (Program.SyncCont == null)                  {                      _bgw = null;                      return;                  }                    _bgw.ReportProgress(0' new bgwText("Clearing DB Status"));                  RepairStatus.ReportStatusReset(DB.DirTree);                    List<RvFile> lstRomTableSortedCRCSize;                  List<RvFile> lstRomTableSortedSHA1CHD;                    _bgw.ReportProgress(0' new bgwText("Loading Rom List"));                  DBHelper.GetSelectedFilesSortCRCSize(out lstRomTableSortedCRCSize);                  DBHelper.GetSelectedFilesSortSHA1CHD(out lstRomTableSortedSHA1CHD);                    _bgw.ReportProgress(0' new bgwText("Scanning for Fixes"));                  _bgw.ReportProgress(0' new bgwSetRange(lstRomTableSortedCRCSize.Count));                    int romIndex0 = 0;                  int romIndex1 = 1;                  while (romIndex1 < lstRomTableSortedCRCSize.Count)                  {                      if (romIndex1 % 100 == 0) _bgw.ReportProgress(romIndex1);                        if (!ArrByte.bCompare(lstRomTableSortedCRCSize[romIndex0].CRC'lstRomTableSortedCRCSize[romIndex1].CRC) || lstRomTableSortedCRCSize[romIndex0].Size != lstRomTableSortedCRCSize[romIndex1].Size)                      {                          ListCheck(lstRomTableSortedCRCSize' romIndex0' romIndex1 - romIndex0);                          romIndex0 = romIndex1;                      }                      romIndex1++;                  }                    ListCheck(lstRomTableSortedCRCSize' romIndex0' romIndex1 - romIndex0);                        _bgw.ReportProgress(0' new bgwSetRange(lstRomTableSortedSHA1CHD.Count));                    romIndex0 = 0;                  romIndex1 = 1;                  while (romIndex1 < lstRomTableSortedSHA1CHD.Count)                  {                      if (romIndex1 % 100 == 0) _bgw.ReportProgress(romIndex1);                        if (!ArrByte.bCompare(lstRomTableSortedSHA1CHD[romIndex0].SHA1CHD'lstRomTableSortedSHA1CHD[romIndex1].SHA1CHD) )                      {                          ListCheckSHA1CHD(lstRomTableSortedSHA1CHD' romIndex0' romIndex1 - romIndex0);                          romIndex0 = romIndex1;                      }                      romIndex1++;                  }                    ListCheckSHA1CHD(lstRomTableSortedSHA1CHD' romIndex0' romIndex1 - romIndex0);                      _bgw = null;                  Program.SyncCont = null;              }              catch (Exception exc)              {                  ReportError.UnhandledExceptionHandler(exc);                    if (_bgw != null) _bgw.ReportProgress(0' new bgwText("Updating Cache"));                  DB.Write();                  if (_bgw != null) _bgw.ReportProgress(0' new bgwText("Complete"));                    _bgw = null;                  Program.SyncCont = null;              }
Magic Number,ROMVault2,FixFileCopy,C:\repos\gjefferyes_RomVault\ROMVault2\FixFileCopy.cs,CopyFile,The following statement contains a magic number: ushort compressionMethod = 8;
Magic Number,ROMVault2,FixFileCopy,C:\repos\gjefferyes_RomVault\ROMVault2\FixFileCopy.cs,CopyFile,The following statement contains a magic number: if (!rawCopy && (Program.rvSettings.FixLevel == eFixLevel.TrrntZipLevel1 || Program.rvSettings.FixLevel == eFixLevel.TrrntZipLevel2 || Program.rvSettings.FixLevel == eFixLevel.TrrntZipLevel3))                  compressionMethod = 8;
Magic Number,ROMVault2,FixFileCopy,C:\repos\gjefferyes_RomVault\ROMVault2\FixFileCopy.cs,CopyFile,The following statement contains a magic number: if (!isZeroLengthFile)              {                  #region Do Data Tranfer                    ThreadCRC tcrc32 =null;                  ThreadMD5 tmd5 = null;                  ThreadSHA1 tsha1 = null;                    if (!rawCopy)                  {                      tcrc32 = new ThreadCRC();                      tmd5 = new ThreadMD5();                      tsha1 = new ThreadSHA1();                  }                    ulong sizetogo = streamSize;                    while (sizetogo > 0)                  {                      int sizenow = sizetogo > BufferSize ? BufferSize : (int)sizetogo;                        try                      {                          readStream.Read(_buffer' 0' sizenow);                      }                      catch (ZlibException)                      {                          if (fileIn.FileType == FileType.ZipFile && zipFileIn != null)                          {                              ZipReturn zr = zipFileIn.ZipFileCloseReadStream();                              if (zr != ZipReturn.ZipGood)                              {                                  error = "Error Closing " + zr + " Stream :" + zipFileIn.Filename(fileIn.ReportIndex);                                  return ReturnCode.FileSystemError;                              }                              zipFileIn.ZipFileClose();                            }                          else                          {                              readStream.Close();                          }                            if (fileOut.FileType == FileType.ZipFile)                          {                              ZipReturn zr = zipFileOut.ZipFileCloseWriteStream(new byte[] { 0' 0' 0' 0 });                              if (zr != ZipReturn.ZipGood)                              {                                  error = "Error Closing Stream " + zr;                                  return ReturnCode.FileSystemError;                              }                              zipFileOut.ZipFileRollBack();                          }                          else                          {                              writeStream.Flush();                              writeStream.Close();                              IO.File.Delete(zipFilenameOut);                          }                            error = "Error in Data Stream";                          return ReturnCode.SourceCRCCheckSumError;                      }                      catch (Exception e)                      {                          error = "Error reading Source File " + e.Message;                          return ReturnCode.FileSystemError;                      }                        if (!rawCopy)                      {                          tcrc32.Trigger(_buffer' sizenow);                          tmd5.Trigger(_buffer' sizenow);                          tsha1.Trigger(_buffer' sizenow);                            tcrc32.Wait();                          tmd5.Wait();                          tsha1.Wait();                      }                      try                      {                          writeStream.Write(_buffer' 0' sizenow);                      }                      catch (Exception e)                      {                          Debug.WriteLine(e.Message);                          error = "Error writing out file. " + Environment.NewLine + e.Message;                          return ReturnCode.FileSystemError;                      }                      sizetogo = sizetogo - (ulong)sizenow;                  }                  writeStream.Flush();                    #endregion                    #region Collect Checksums                      // if we did a full copy then we just calculated all the checksums while doing the copy                  if (!rawCopy)                  {                        tcrc32.Finish();                      tmd5.Finish();                      tsha1.Finish();                        bCRC = tcrc32.Hash;                      bMD5 = tmd5.Hash;                      bSHA1 = tsha1.Hash;                        tcrc32.Dispose();                      tmd5.Dispose();                      tsha1.Dispose();                  }                  // if we raw copied and the source file has been FileChecked then we can trust the checksums in the source file                  else                  {                      bCRC = ArrByte.Copy(fileIn.CRC);                      if (fileIn.FileStatusIs(FileStatus.MD5Verified)) bMD5 = ArrByte.Copy(fileIn.MD5);                      if (fileIn.FileStatusIs(FileStatus.SHA1Verified)) bSHA1 = ArrByte.Copy(fileIn.SHA1);                  }                    #endregion                    #region close the ReadStream                    if (fileIn.FileType == FileType.ZipFile && zipFileIn != null)                  {                      ZipReturn zr = zipFileIn.ZipFileCloseReadStream();                      if (zr != ZipReturn.ZipGood)                      {                          error = "Error Closing " + zr + " Stream :" + zipFileIn.Filename(fileIn.ReportIndex);                          return ReturnCode.FileSystemError;                      }                      zipFileIn.ZipFileClose();                  }                  else                  {                      readStream.Close();                        //if (IO.File.Exists(tmpFilename))                      //    IO.File.Delete(tmpFilename);                  }                    #endregion              }              else              {                  // Zero Length File (Directory in a Zip)                  if (fileOut.FileType == FileType.ZipFile)                  {                      zipFileOut.ZipFileAddDirectory();                  }                  bCRC = VarFix.CleanMD5SHA1("00000000"' 8);                  bMD5 = VarFix.CleanMD5SHA1("d41d8cd98f00b204e9800998ecf8427e"' 32);                  bSHA1 = VarFix.CleanMD5SHA1("da39a3ee5e6b4b0d3255bfef95601890afd80709"' 40);              }
Magic Number,ROMVault2,FixFileCopy,C:\repos\gjefferyes_RomVault\ROMVault2\FixFileCopy.cs,CopyFile,The following statement contains a magic number: if (!isZeroLengthFile)              {                  #region Do Data Tranfer                    ThreadCRC tcrc32 =null;                  ThreadMD5 tmd5 = null;                  ThreadSHA1 tsha1 = null;                    if (!rawCopy)                  {                      tcrc32 = new ThreadCRC();                      tmd5 = new ThreadMD5();                      tsha1 = new ThreadSHA1();                  }                    ulong sizetogo = streamSize;                    while (sizetogo > 0)                  {                      int sizenow = sizetogo > BufferSize ? BufferSize : (int)sizetogo;                        try                      {                          readStream.Read(_buffer' 0' sizenow);                      }                      catch (ZlibException)                      {                          if (fileIn.FileType == FileType.ZipFile && zipFileIn != null)                          {                              ZipReturn zr = zipFileIn.ZipFileCloseReadStream();                              if (zr != ZipReturn.ZipGood)                              {                                  error = "Error Closing " + zr + " Stream :" + zipFileIn.Filename(fileIn.ReportIndex);                                  return ReturnCode.FileSystemError;                              }                              zipFileIn.ZipFileClose();                            }                          else                          {                              readStream.Close();                          }                            if (fileOut.FileType == FileType.ZipFile)                          {                              ZipReturn zr = zipFileOut.ZipFileCloseWriteStream(new byte[] { 0' 0' 0' 0 });                              if (zr != ZipReturn.ZipGood)                              {                                  error = "Error Closing Stream " + zr;                                  return ReturnCode.FileSystemError;                              }                              zipFileOut.ZipFileRollBack();                          }                          else                          {                              writeStream.Flush();                              writeStream.Close();                              IO.File.Delete(zipFilenameOut);                          }                            error = "Error in Data Stream";                          return ReturnCode.SourceCRCCheckSumError;                      }                      catch (Exception e)                      {                          error = "Error reading Source File " + e.Message;                          return ReturnCode.FileSystemError;                      }                        if (!rawCopy)                      {                          tcrc32.Trigger(_buffer' sizenow);                          tmd5.Trigger(_buffer' sizenow);                          tsha1.Trigger(_buffer' sizenow);                            tcrc32.Wait();                          tmd5.Wait();                          tsha1.Wait();                      }                      try                      {                          writeStream.Write(_buffer' 0' sizenow);                      }                      catch (Exception e)                      {                          Debug.WriteLine(e.Message);                          error = "Error writing out file. " + Environment.NewLine + e.Message;                          return ReturnCode.FileSystemError;                      }                      sizetogo = sizetogo - (ulong)sizenow;                  }                  writeStream.Flush();                    #endregion                    #region Collect Checksums                      // if we did a full copy then we just calculated all the checksums while doing the copy                  if (!rawCopy)                  {                        tcrc32.Finish();                      tmd5.Finish();                      tsha1.Finish();                        bCRC = tcrc32.Hash;                      bMD5 = tmd5.Hash;                      bSHA1 = tsha1.Hash;                        tcrc32.Dispose();                      tmd5.Dispose();                      tsha1.Dispose();                  }                  // if we raw copied and the source file has been FileChecked then we can trust the checksums in the source file                  else                  {                      bCRC = ArrByte.Copy(fileIn.CRC);                      if (fileIn.FileStatusIs(FileStatus.MD5Verified)) bMD5 = ArrByte.Copy(fileIn.MD5);                      if (fileIn.FileStatusIs(FileStatus.SHA1Verified)) bSHA1 = ArrByte.Copy(fileIn.SHA1);                  }                    #endregion                    #region close the ReadStream                    if (fileIn.FileType == FileType.ZipFile && zipFileIn != null)                  {                      ZipReturn zr = zipFileIn.ZipFileCloseReadStream();                      if (zr != ZipReturn.ZipGood)                      {                          error = "Error Closing " + zr + " Stream :" + zipFileIn.Filename(fileIn.ReportIndex);                          return ReturnCode.FileSystemError;                      }                      zipFileIn.ZipFileClose();                  }                  else                  {                      readStream.Close();                        //if (IO.File.Exists(tmpFilename))                      //    IO.File.Delete(tmpFilename);                  }                    #endregion              }              else              {                  // Zero Length File (Directory in a Zip)                  if (fileOut.FileType == FileType.ZipFile)                  {                      zipFileOut.ZipFileAddDirectory();                  }                  bCRC = VarFix.CleanMD5SHA1("00000000"' 8);                  bMD5 = VarFix.CleanMD5SHA1("d41d8cd98f00b204e9800998ecf8427e"' 32);                  bSHA1 = VarFix.CleanMD5SHA1("da39a3ee5e6b4b0d3255bfef95601890afd80709"' 40);              }
Magic Number,ROMVault2,FixFileCopy,C:\repos\gjefferyes_RomVault\ROMVault2\FixFileCopy.cs,CopyFile,The following statement contains a magic number: if (!isZeroLengthFile)              {                  #region Do Data Tranfer                    ThreadCRC tcrc32 =null;                  ThreadMD5 tmd5 = null;                  ThreadSHA1 tsha1 = null;                    if (!rawCopy)                  {                      tcrc32 = new ThreadCRC();                      tmd5 = new ThreadMD5();                      tsha1 = new ThreadSHA1();                  }                    ulong sizetogo = streamSize;                    while (sizetogo > 0)                  {                      int sizenow = sizetogo > BufferSize ? BufferSize : (int)sizetogo;                        try                      {                          readStream.Read(_buffer' 0' sizenow);                      }                      catch (ZlibException)                      {                          if (fileIn.FileType == FileType.ZipFile && zipFileIn != null)                          {                              ZipReturn zr = zipFileIn.ZipFileCloseReadStream();                              if (zr != ZipReturn.ZipGood)                              {                                  error = "Error Closing " + zr + " Stream :" + zipFileIn.Filename(fileIn.ReportIndex);                                  return ReturnCode.FileSystemError;                              }                              zipFileIn.ZipFileClose();                            }                          else                          {                              readStream.Close();                          }                            if (fileOut.FileType == FileType.ZipFile)                          {                              ZipReturn zr = zipFileOut.ZipFileCloseWriteStream(new byte[] { 0' 0' 0' 0 });                              if (zr != ZipReturn.ZipGood)                              {                                  error = "Error Closing Stream " + zr;                                  return ReturnCode.FileSystemError;                              }                              zipFileOut.ZipFileRollBack();                          }                          else                          {                              writeStream.Flush();                              writeStream.Close();                              IO.File.Delete(zipFilenameOut);                          }                            error = "Error in Data Stream";                          return ReturnCode.SourceCRCCheckSumError;                      }                      catch (Exception e)                      {                          error = "Error reading Source File " + e.Message;                          return ReturnCode.FileSystemError;                      }                        if (!rawCopy)                      {                          tcrc32.Trigger(_buffer' sizenow);                          tmd5.Trigger(_buffer' sizenow);                          tsha1.Trigger(_buffer' sizenow);                            tcrc32.Wait();                          tmd5.Wait();                          tsha1.Wait();                      }                      try                      {                          writeStream.Write(_buffer' 0' sizenow);                      }                      catch (Exception e)                      {                          Debug.WriteLine(e.Message);                          error = "Error writing out file. " + Environment.NewLine + e.Message;                          return ReturnCode.FileSystemError;                      }                      sizetogo = sizetogo - (ulong)sizenow;                  }                  writeStream.Flush();                    #endregion                    #region Collect Checksums                      // if we did a full copy then we just calculated all the checksums while doing the copy                  if (!rawCopy)                  {                        tcrc32.Finish();                      tmd5.Finish();                      tsha1.Finish();                        bCRC = tcrc32.Hash;                      bMD5 = tmd5.Hash;                      bSHA1 = tsha1.Hash;                        tcrc32.Dispose();                      tmd5.Dispose();                      tsha1.Dispose();                  }                  // if we raw copied and the source file has been FileChecked then we can trust the checksums in the source file                  else                  {                      bCRC = ArrByte.Copy(fileIn.CRC);                      if (fileIn.FileStatusIs(FileStatus.MD5Verified)) bMD5 = ArrByte.Copy(fileIn.MD5);                      if (fileIn.FileStatusIs(FileStatus.SHA1Verified)) bSHA1 = ArrByte.Copy(fileIn.SHA1);                  }                    #endregion                    #region close the ReadStream                    if (fileIn.FileType == FileType.ZipFile && zipFileIn != null)                  {                      ZipReturn zr = zipFileIn.ZipFileCloseReadStream();                      if (zr != ZipReturn.ZipGood)                      {                          error = "Error Closing " + zr + " Stream :" + zipFileIn.Filename(fileIn.ReportIndex);                          return ReturnCode.FileSystemError;                      }                      zipFileIn.ZipFileClose();                  }                  else                  {                      readStream.Close();                        //if (IO.File.Exists(tmpFilename))                      //    IO.File.Delete(tmpFilename);                  }                    #endregion              }              else              {                  // Zero Length File (Directory in a Zip)                  if (fileOut.FileType == FileType.ZipFile)                  {                      zipFileOut.ZipFileAddDirectory();                  }                  bCRC = VarFix.CleanMD5SHA1("00000000"' 8);                  bMD5 = VarFix.CleanMD5SHA1("d41d8cd98f00b204e9800998ecf8427e"' 32);                  bSHA1 = VarFix.CleanMD5SHA1("da39a3ee5e6b4b0d3255bfef95601890afd80709"' 40);              }
Magic Number,ROMVault2,FrmProgressWindowFix,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindowFix.cs,FrmProgressWindowFix,The following statement contains a magic number: timer1.Interval = 100;
Magic Number,ROMVault2,FrmProgressWindowFix,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindowFix.cs,BgwProgressChanged,The following statement contains a magic number: if (bgwSFE != null)              {                  int iRow = dataGridView1.Rows.Count - 1;                  dataGridView1.Rows[iRow].Cells[4].Style.BackColor = Color.Red;                  dataGridView1.Rows[iRow].Cells[4].Style.ForeColor = Color.Black;                  dataGridView1.Rows[iRow].Cells[4].Value = bgwSFE.FixError;                  return;              }
Magic Number,ROMVault2,FrmProgressWindowFix,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindowFix.cs,BgwProgressChanged,The following statement contains a magic number: if (bgwSFE != null)              {                  int iRow = dataGridView1.Rows.Count - 1;                  dataGridView1.Rows[iRow].Cells[4].Style.BackColor = Color.Red;                  dataGridView1.Rows[iRow].Cells[4].Style.ForeColor = Color.Black;                  dataGridView1.Rows[iRow].Cells[4].Value = bgwSFE.FixError;                  return;              }
Magic Number,ROMVault2,FrmProgressWindowFix,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindowFix.cs,BgwProgressChanged,The following statement contains a magic number: if (bgwSFE != null)              {                  int iRow = dataGridView1.Rows.Count - 1;                  dataGridView1.Rows[iRow].Cells[4].Style.BackColor = Color.Red;                  dataGridView1.Rows[iRow].Cells[4].Style.ForeColor = Color.Black;                  dataGridView1.Rows[iRow].Cells[4].Value = bgwSFE.FixError;                  return;              }
Magic Number,ROMVault2,FrmProgressWindowFix,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindowFix.cs,UpdateStatusText,The following statement contains a magic number: int percent = range > 0 ? (progressBar.Value * 100) / range : 0;
Magic Number,ROMVault2,FrmProgressWindowFix,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindowFix.cs,InitializeComponent,The following statement contains a magic number: this.splitContainer1.Size = new System.Drawing.Size(1027' 500);
Magic Number,ROMVault2,FrmProgressWindowFix,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindowFix.cs,InitializeComponent,The following statement contains a magic number: this.splitContainer1.Size = new System.Drawing.Size(1027' 500);
Magic Number,ROMVault2,FrmProgressWindowFix,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindowFix.cs,InitializeComponent,The following statement contains a magic number: this.splitContainer1.SplitterDistance = 64;
Magic Number,ROMVault2,FrmProgressWindowFix,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindowFix.cs,InitializeComponent,The following statement contains a magic number: this.splitContainer1.TabIndex = 7;
Magic Number,ROMVault2,FrmProgressWindowFix,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindowFix.cs,InitializeComponent,The following statement contains a magic number: this.cancelButton.Location = new System.Drawing.Point(759' 32);
Magic Number,ROMVault2,FrmProgressWindowFix,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindowFix.cs,InitializeComponent,The following statement contains a magic number: this.cancelButton.Location = new System.Drawing.Point(759' 32);
Magic Number,ROMVault2,FrmProgressWindowFix,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindowFix.cs,InitializeComponent,The following statement contains a magic number: this.cancelButton.Size = new System.Drawing.Size(75' 23);
Magic Number,ROMVault2,FrmProgressWindowFix,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindowFix.cs,InitializeComponent,The following statement contains a magic number: this.cancelButton.Size = new System.Drawing.Size(75' 23);
Magic Number,ROMVault2,FrmProgressWindowFix,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindowFix.cs,InitializeComponent,The following statement contains a magic number: this.cancelButton.TabIndex = 9;
Magic Number,ROMVault2,FrmProgressWindowFix,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindowFix.cs,InitializeComponent,The following statement contains a magic number: this.progressBar.Location = new System.Drawing.Point(12' 32);
Magic Number,ROMVault2,FrmProgressWindowFix,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindowFix.cs,InitializeComponent,The following statement contains a magic number: this.progressBar.Location = new System.Drawing.Point(12' 32);
Magic Number,ROMVault2,FrmProgressWindowFix,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindowFix.cs,InitializeComponent,The following statement contains a magic number: this.progressBar.Size = new System.Drawing.Size(741' 23);
Magic Number,ROMVault2,FrmProgressWindowFix,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindowFix.cs,InitializeComponent,The following statement contains a magic number: this.progressBar.Size = new System.Drawing.Size(741' 23);
Magic Number,ROMVault2,FrmProgressWindowFix,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindowFix.cs,InitializeComponent,The following statement contains a magic number: this.progressBar.TabIndex = 8;
Magic Number,ROMVault2,FrmProgressWindowFix,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindowFix.cs,InitializeComponent,The following statement contains a magic number: this.label.Location = new System.Drawing.Point(13' 9);
Magic Number,ROMVault2,FrmProgressWindowFix,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindowFix.cs,InitializeComponent,The following statement contains a magic number: this.label.Location = new System.Drawing.Point(13' 9);
Magic Number,ROMVault2,FrmProgressWindowFix,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindowFix.cs,InitializeComponent,The following statement contains a magic number: this.label.Size = new System.Drawing.Size(480' 20);
Magic Number,ROMVault2,FrmProgressWindowFix,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindowFix.cs,InitializeComponent,The following statement contains a magic number: this.label.Size = new System.Drawing.Size(480' 20);
Magic Number,ROMVault2,FrmProgressWindowFix,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindowFix.cs,InitializeComponent,The following statement contains a magic number: this.label.TabIndex = 4;
Magic Number,ROMVault2,FrmProgressWindowFix,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindowFix.cs,InitializeComponent,The following statement contains a magic number: this.dataGridView1.GridColor = System.Drawing.Color.FromArgb(((int)(((byte)(224))))' ((int)(((byte)(224))))' ((int)(((byte)(224)))));
Magic Number,ROMVault2,FrmProgressWindowFix,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindowFix.cs,InitializeComponent,The following statement contains a magic number: this.dataGridView1.GridColor = System.Drawing.Color.FromArgb(((int)(((byte)(224))))' ((int)(((byte)(224))))' ((int)(((byte)(224)))));
Magic Number,ROMVault2,FrmProgressWindowFix,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindowFix.cs,InitializeComponent,The following statement contains a magic number: this.dataGridView1.GridColor = System.Drawing.Color.FromArgb(((int)(((byte)(224))))' ((int)(((byte)(224))))' ((int)(((byte)(224)))));
Magic Number,ROMVault2,FrmProgressWindowFix,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindowFix.cs,InitializeComponent,The following statement contains a magic number: this.dataGridView1.RowTemplate.Height = 17;
Magic Number,ROMVault2,FrmProgressWindowFix,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindowFix.cs,InitializeComponent,The following statement contains a magic number: this.dataGridView1.Size = new System.Drawing.Size(1027' 432);
Magic Number,ROMVault2,FrmProgressWindowFix,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindowFix.cs,InitializeComponent,The following statement contains a magic number: this.dataGridView1.Size = new System.Drawing.Size(1027' 432);
Magic Number,ROMVault2,FrmProgressWindowFix,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindowFix.cs,InitializeComponent,The following statement contains a magic number: this.dataGridView1.TabIndex = 7;
Magic Number,ROMVault2,FrmProgressWindowFix,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindowFix.cs,InitializeComponent,The following statement contains a magic number: this.DatTo.Width = 250;
Magic Number,ROMVault2,FrmProgressWindowFix,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindowFix.cs,InitializeComponent,The following statement contains a magic number: this.GameTo.Width = 200;
Magic Number,ROMVault2,FrmProgressWindowFix,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindowFix.cs,InitializeComponent,The following statement contains a magic number: this.RomTo.Width = 200;
Magic Number,ROMVault2,FrmProgressWindowFix,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindowFix.cs,InitializeComponent,The following statement contains a magic number: this.DatFrom.Width = 150;
Magic Number,ROMVault2,FrmProgressWindowFix,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindowFix.cs,InitializeComponent,The following statement contains a magic number: this.dataGridViewTextBoxColumn1.Width = 150;
Magic Number,ROMVault2,FrmProgressWindowFix,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindowFix.cs,InitializeComponent,The following statement contains a magic number: this.dataGridViewTextBoxColumn5.Width = 150;
Magic Number,ROMVault2,FrmProgressWindowFix,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindowFix.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(1027' 500);
Magic Number,ROMVault2,FrmProgressWindowFix,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindowFix.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(1027' 500);
Magic Number,ROMVault2,FileScanning,C:\repos\gjefferyes_RomVault\ROMVault2\FileScanning.cs,CheckADir,The following statement contains a magic number: switch (ft)              {                  case FileType.Zip:                      {                          fileDir = new RvDir(ft);                            // open the zip file                          ZipFile checkZ = new ZipFile();                            ZipReturn zr = checkZ.ZipFileOpen(fullDir' dbDir.TimeStamp' true);                            if (zr == ZipReturn.ZipGood)                          {                              dbDir.ZipStatus = checkZ.ZipStatus;                                // to be Scanning a ZIP file means it is either new or has changed.                              // as the code below only calls back here if that is true.                              //                              // Level1: Only use header CRC's                              // Just get the CRC for the ZIP headers.                              //                              // Level2: Fully checksum changed only files                              // We know this file has been changed to do a full checksum scan.                              //                              // Level3: Fully checksum everything                              // So do a full checksum scan.                              if (EScanLevel == eScanLevel.Level2 || EScanLevel == eScanLevel.Level3)                                  checkZ.DeepScan();                                // add all of the file information from the zip file into scanDir                              for (int i = 0; i < checkZ.LocalFilesCount(); i++)                              {                                  RvFile tFile = new RvFile(DBTypeGet.FileFromDir(ft))                                                     {                                                         Name = checkZ.Filename(i)'                                                         ZipFileIndex = i'                                                         ZipFileHeaderPosition = checkZ.LocalHeader(i)'                                                         Size = checkZ.UncompressedSize(i)'                                                         CRC = checkZ.CRC32(i)                                                     };                                  // all 3 levels read the CRC from the ZIP header                                  tFile.SetStatus(chechingDatStatus' GotStatus.Got);                                  tFile.FileStatusSet(FileStatus.SizeFromHeader | FileStatus.CRCFromHeader);                                    // if we are in level 2 or level 3 then do a full CheckSum Scan.                                  if (EScanLevel == eScanLevel.Level2 || EScanLevel == eScanLevel.Level3)                                  {                                      // DeepScan will return ZipReturn.ZipCRCDecodeError if the headers CRC and                                       // the actual CRC do not match.                                      // So we just need to set the MD5 and SHA1 from the ZIP file.                                      zr = checkZ.FileStatus(i);                                      if (zr == ZipReturn.ZipUntested)                                      {                                          _bgw.ReportProgress(0' new bgwShowCorrupt(zr' fullDir + " : " + checkZ.Filename(i)));                                      }                                      else if (zr != ZipReturn.ZipGood)                                      {                                          _bgw.ReportProgress(0' new bgwShowCorrupt(zr' fullDir + " : " + checkZ.Filename(i)));                                          tFile.GotStatus = GotStatus.Corrupt;                                      }                                      else                                      {                                          tFile.MD5 = checkZ.MD5(i);                                          tFile.SHA1 = checkZ.SHA1(i);                                          tFile.FileStatusSet(FileStatus.SizeVerified | FileStatus.CRCVerified | FileStatus.SHA1Verified | FileStatus.MD5Verified);                                      }                                  }                                    fileDir.ChildAdd(tFile);                              }                          }                          else if (zr == ZipReturn.ZipFileLocked)                          {                              _bgw.ReportProgress(0' new bgwShowError(fullDir' "Zip File Locked"));                              dbDir.TimeStamp = 0;                              dbDir.GotStatus = GotStatus.FileLocked;                          }                          else                          {                              _bgw.ReportProgress(0' new bgwShowCorrupt(zr' fullDir));                              dbDir.GotStatus = GotStatus.Corrupt;                          }                          checkZ.ZipFileClose();                      }                      break;                    case FileType.Dir:                      {                          fileDir = new RvDir(FileType.Dir);                              DirectoryInfo oDir = new DirectoryInfo(fullDir);                          DirectoryInfo[] oDirs = oDir.GetDirectories();                          FileInfo[] oFiles = oDir.GetFiles();                            // add all the subdirectories into scanDir                           foreach (DirectoryInfo dir in oDirs)                          {                              RvBase tDir = new RvDir(FileType.Dir)                                                {                                                    Name = dir.Name'                                                    TimeStamp = dir.LastWriteTime'                                                };                              tDir.SetStatus(chechingDatStatus' GotStatus.Got);                              fileDir.ChildAdd(tDir);                          }                            // add all the files into scanDir                          foreach (FileInfo oFile in oFiles)                          {                              // if we find any zip files add them as zip files.                              string fExt = Path.GetExtension(oFile.Name);                              switch (fExt.ToLower())                              {                                  case ".zip":                                      {                                          RvDir tGame = new RvDir(FileType.Zip)                                                            {                                                                Name = Path.GetFileNameWithoutExtension(oFile.Name)'                                                                TimeStamp = oFile.LastWriteTime'                                                            };                                          tGame.SetStatus(chechingDatStatus' GotStatus.Got);                                          fileDir.ChildAdd(tGame);                                      }                                      break;                                  default:                                      {                                          string fName = oFile.Name;                                          if (fName == "__RomVault.tmp")                                          {                                              File.Delete(oFile.FullName);                                              continue;                                          }                                            // Scanning a file                                          //                                          // Level1 & 2 : (are the same for files) Fully checksum changed only files                                          // Here we are just getting the TimeStamp of the File' and later                                          // if the TimeStamp was not matched we will have to read the files CRC' MD5 & SHA1                                          //                                          // Level3: Fully checksum everything                                          // Get everything about the file right here so                                          // read CRC' MD5 & SHA1                                              // add all the files in the sub-directory to scanDir                                          RvFile tFile = new RvFile(FileType.File)                                                             {                                                                 Name = fName'                                                                 Size = (ulong)oFile.Length'                                                                 TimeStamp = oFile.LastWriteTime                                                             };                                            tFile.FileStatusSet(FileStatus.SizeVerified);                                            int errorCode = CHD.CheckFile(oFile' out tFile.SHA1CHD' out tFile.MD5CHD' out tFile.CHDVersion);                                            if (errorCode == 0)                                          {                                              if (tFile.SHA1CHD != null) tFile.FileStatusSet(FileStatus.SHA1CHDFromHeader);                                              if (tFile.MD5CHD != null) tFile.FileStatusSet(FileStatus.MD5CHDFromHeader);                                                tFile.SetStatus(chechingDatStatus' GotStatus.Got);                                                // if we are scanning at Level3 then we get all the info here                                              if (EScanLevel == eScanLevel.Level3)                                              {                                                  DeepScanFile(fullDir' tFile);                                                  ChdManCheck(fullDir' tFile);                                              }                                          }                                          else if (errorCode == 32)                                          {                                              tFile.GotStatus = GotStatus.FileLocked;                                              _bgw.ReportProgress(0' new bgwShowError(fullDir' "File Locked"));                                          }                                          else                                          {                                              string filename = Path.Combine(fullDir' tFile.Name);                                              ReportError.Show("File: " + filename + " Error: " + new Win32Exception(errorCode).Message + ". Scan Aborted.");                                              _fileErrorAbort = true;                                              return;                                          }                                          fileDir.ChildAdd(tFile);                                      }                                      break;                              }                          }                      }                      break;                  default:                      ReportError.SendAndShow("Un supported file type in CheckADir " + ft);                      break;              }
Magic Number,ROMVault2,FileScanning,C:\repos\gjefferyes_RomVault\ROMVault2\FileScanning.cs,Compare,The following statement contains a magic number: while (dbIndex < dbDir.ChildCount || fileIndex < fileDir.ChildCount)              {                  RvBase dbChild = null;                  RvBase fileChild = null;                  int res = 0;                    if (dbIndex < dbDir.ChildCount && fileIndex < fileDir.ChildCount)                  {                      dbChild = dbDir.Child(dbIndex);                      fileChild = fileDir.Child(fileIndex);                      res = DBHelper.CompareName(dbChild' fileChild);                  }                  else if (fileIndex < fileDir.ChildCount)                  {                      //Get any remaining filedir's                      fileChild = fileDir.Child(fileIndex);                      res = 1;                  }                  else if (dbIndex < dbDir.ChildCount)                  {                      //Get any remaining dbDir's                      dbChild = dbDir.Child(dbIndex);                      res = -1;                  }                    if (report)                  {                      if (fileChild != null)                      {                          long timenow = DateTime.Now.Ticks;                          if ((timenow - _lastUpdateTime) > (TimeSpan.TicksPerSecond / 10))                          {                              _lastUpdateTime = timenow;                              _bgw.ReportProgress(0' new bgwValue2(fileIndex));                              _bgw.ReportProgress(0' new bgwText2(Path.Combine(fullDir' fileChild.Name)));                          }                      }                  }                    // if this file was found in the DB                  switch (res)                  {                      case 0:                            if (dbChild == null || fileChild == null)                          {                              ReportError.SendAndShow(Resources.FileScanning_CheckADir_Error_in_File_Scanning_Code);                              break;                          }                            //Complete MultiName Compare                          List<RvBase> dbs = new List<RvBase>();                          List<RvBase> files = new List<RvBase>();                          int dbsCount = 1;                          int filesCount = 1;                              dbs.Add(dbChild);                          files.Add(fileChild);                            while (dbIndex + dbsCount < dbDir.ChildCount && DBHelper.CompareName(dbChild' dbDir.Child(dbIndex + dbsCount)) == 0)                          {                              dbs.Add(dbDir.Child(dbIndex + dbsCount));                              dbsCount += 1;                          }                          while (fileIndex + filesCount < fileDir.ChildCount && DBHelper.CompareName(fileChild' fileDir.Child(fileIndex + filesCount)) == 0)                          {                              files.Add(fileDir.Child(fileIndex + filesCount));                              filesCount += 1;                          }                            for (int indexfile = 0; indexfile < filesCount; indexfile++)                          {                              if (files[indexfile].SearchFound) continue;                                for (int indexdb = 0; indexdb < dbsCount; indexdb++)                              {                                  if (dbs[indexdb].SearchFound) continue;                                    bool matched = FullCompare(dbs[indexdb]' files[indexfile]' false' fullDir' EScanLevel);                                  if (!matched) continue;                                    MatchFound(dbs[indexdb]' files[indexfile]);                                  dbs[indexdb].SearchFound = true;                                  files[indexfile].SearchFound = true;                              }                                if (files[indexfile].SearchFound) continue;                                for (int indexdb = 0; indexdb < dbsCount; indexdb++)                              {                                  if (dbs[indexdb].SearchFound) continue;                                    bool matched = FullCompare(dbs[indexdb]' files[indexfile]' true' fullDir' EScanLevel);                                  if (!matched) continue;                                    MatchFound(dbs[indexdb]' files[indexfile]);                                  dbs[indexdb].SearchFound = true;                                  files[indexfile].SearchFound = true;                              }                          }                              for (int indexdb = 0; indexdb < dbsCount; indexdb++)                          {                              if (dbs[indexdb].SearchFound)                              {                                  dbIndex++;                                  continue;                              }                              DBFileNotFound(dbs[indexdb]' dbDir' ref dbIndex);                          }                            for (int indexfile = 0; indexfile < filesCount; indexfile++)                          {                              if (files[indexfile].SearchFound)                                  continue;                              NewFileFound(files[indexfile]' dbDir' dbIndex);                              dbIndex++;                          }                            fileIndex += filesCount;                          break;                      case 1:                          NewFileFound(fileChild' dbDir' dbIndex);                          dbIndex++;                          fileIndex++;                          break;                      case -1:                          DBFileNotFound(dbChild' dbDir' ref dbIndex);                          break;                  }                    if (_fileErrorAbort) return;                  if (enableCancel && !DBTypeGet.isCompressedDir(ft) && _bgw.CancellationPending) return;              }
Magic Number,ROMVault2,FileScanning,C:\repos\gjefferyes_RomVault\ROMVault2\FileScanning.cs,DeepScanFile,The following statement contains a magic number: if (errorCode == 32)              {                  tFile.GotStatus = GotStatus.FileLocked;                  return;              }
Magic Number,ROMVault2,FrmHelpAbout,C:\repos\gjefferyes_RomVault\ROMVault2\FrmHelpAbout.cs,InitializeComponent,The following statement contains a magic number: this.lblVersion.Location = new System.Drawing.Point(12' 115);
Magic Number,ROMVault2,FrmHelpAbout,C:\repos\gjefferyes_RomVault\ROMVault2\FrmHelpAbout.cs,InitializeComponent,The following statement contains a magic number: this.lblVersion.Location = new System.Drawing.Point(12' 115);
Magic Number,ROMVault2,FrmHelpAbout,C:\repos\gjefferyes_RomVault\ROMVault2\FrmHelpAbout.cs,InitializeComponent,The following statement contains a magic number: this.lblVersion.Size = new System.Drawing.Size(445' 15);
Magic Number,ROMVault2,FrmHelpAbout,C:\repos\gjefferyes_RomVault\ROMVault2\FrmHelpAbout.cs,InitializeComponent,The following statement contains a magic number: this.lblVersion.Size = new System.Drawing.Size(445' 15);
Magic Number,ROMVault2,FrmHelpAbout,C:\repos\gjefferyes_RomVault\ROMVault2\FrmHelpAbout.cs,InitializeComponent,The following statement contains a magic number: this.lblVersion.TabIndex = 6;
Magic Number,ROMVault2,FrmHelpAbout,C:\repos\gjefferyes_RomVault\ROMVault2\FrmHelpAbout.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(279' 142);
Magic Number,ROMVault2,FrmHelpAbout,C:\repos\gjefferyes_RomVault\ROMVault2\FrmHelpAbout.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(279' 142);
Magic Number,ROMVault2,FrmHelpAbout,C:\repos\gjefferyes_RomVault\ROMVault2\FrmHelpAbout.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(178' 16);
Magic Number,ROMVault2,FrmHelpAbout,C:\repos\gjefferyes_RomVault\ROMVault2\FrmHelpAbout.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(178' 16);
Magic Number,ROMVault2,FrmHelpAbout,C:\repos\gjefferyes_RomVault\ROMVault2\FrmHelpAbout.cs,InitializeComponent,The following statement contains a magic number: this.label1.TabIndex = 7;
Magic Number,ROMVault2,FrmHelpAbout,C:\repos\gjefferyes_RomVault\ROMVault2\FrmHelpAbout.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(12' 142);
Magic Number,ROMVault2,FrmHelpAbout,C:\repos\gjefferyes_RomVault\ROMVault2\FrmHelpAbout.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(12' 142);
Magic Number,ROMVault2,FrmHelpAbout,C:\repos\gjefferyes_RomVault\ROMVault2\FrmHelpAbout.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(167' 16);
Magic Number,ROMVault2,FrmHelpAbout,C:\repos\gjefferyes_RomVault\ROMVault2\FrmHelpAbout.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(167' 16);
Magic Number,ROMVault2,FrmHelpAbout,C:\repos\gjefferyes_RomVault\ROMVault2\FrmHelpAbout.cs,InitializeComponent,The following statement contains a magic number: this.label2.TabIndex = 8;
Magic Number,ROMVault2,FrmHelpAbout,C:\repos\gjefferyes_RomVault\ROMVault2\FrmHelpAbout.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(471' 172);
Magic Number,ROMVault2,FrmHelpAbout,C:\repos\gjefferyes_RomVault\ROMVault2\FrmHelpAbout.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(471' 172);
Magic Number,ROMVault2,FrmKey,C:\repos\gjefferyes_RomVault\ROMVault2\FrmKey.cs,FrmKey_Load,The following statement contains a magic number: Height = displayList.Count * 44 + 32;
Magic Number,ROMVault2,FrmKey,C:\repos\gjefferyes_RomVault\ROMVault2\FrmKey.cs,FrmKey_Load,The following statement contains a magic number: Height = displayList.Count * 44 + 32;
Magic Number,ROMVault2,FrmKey,C:\repos\gjefferyes_RomVault\ROMVault2\FrmKey.cs,FrmKey_Load,The following statement contains a magic number: for (int i = 0; i < displayList.Count; i++)              {                  PictureBox pictureBox = new PictureBox();                  pictureBox.BorderStyle = BorderStyle.FixedSingle;                  pictureBox.Location = new Point(4' 4 + i * 44);                  pictureBox.Name = "pictureBox" + i;                  pictureBox.Size = new Size(48' 42);                  pictureBox.TabIndex = 0;                  pictureBox.TabStop = false;                    Controls.Add(pictureBox);                    Bitmap bm = rvImages.GetBitmap("G_" + displayList[i]);                  pictureBox.Image = bm;                    Label label = new Label();                  label.BackColor = SystemColors.Control;                  label.BorderStyle = BorderStyle.FixedSingle;                  label.Location = new Point(54' 4 + i * 44);                  label.TextAlign = ContentAlignment.MiddleLeft;                  label.Name = "label" + i;                  label.Size = new Size(542' 42);                  label.TabIndex = 0;                    String text;                  switch (displayList[i])                  {                      case RepStatus.Missing:                          text = "Red - This ROM is missing.";                          break;                      case RepStatus.Correct:                          text = "Green - This ROM is Correct.";                          break;                      case RepStatus.NotCollected:                          text = "Gray - This ROM is not collected. Either it is in the parent set' or it is a 'BadDump ROM'";                          break;                      case RepStatus.UnNeeded:                          text = "Light Cyan - This ROM is unneeded here' as this ROM is collected in the parent set.";                          break;                      case RepStatus.Unknown:                          text = "Cyan - This ROM is not needed here. (Find Fixes to see what should be done with this ROM)";                          break;                      case RepStatus.InToSort:                          text = "Magenta - This ROM is in the ToSort directory' after Finding Fixes this ROM is not needed in any sets.";                          break;                      case RepStatus.Corrupt:                          text = "Red - This ROM is Corrupt in the Zip File.";                          break;                      case RepStatus.UnScanned:                          text = "Blue - This file could not be scanned as it is locked by another process.";                          break;                      case RepStatus.Ignore:                          text = "GreyBlue - This file is found in the Ignore file list.";                          break;                      case RepStatus.CanBeFixed:                          text = "Yellow - This ROM is missing here but has been found somewhere else' and so can be fixed.";                          break;                      case RepStatus.MoveToSort:                          text = "Purple - This ROM is not found in any DAT set' and so will be moved out to ToSort.";                          break;                      case RepStatus.Delete:                          text = "Brown - This ROM should be deleted' as a copy of it is correctly located somewhere else.";                          break;                      case RepStatus.NeededForFix:                          text = "Orange - This Rom in not needed here' but is required in another set somewhere else.";                          break;                        default:                          text = "";                          break;                  }                    label.Text = text;                  Controls.Add(label);              }
Magic Number,ROMVault2,FrmKey,C:\repos\gjefferyes_RomVault\ROMVault2\FrmKey.cs,FrmKey_Load,The following statement contains a magic number: for (int i = 0; i < displayList.Count; i++)              {                  PictureBox pictureBox = new PictureBox();                  pictureBox.BorderStyle = BorderStyle.FixedSingle;                  pictureBox.Location = new Point(4' 4 + i * 44);                  pictureBox.Name = "pictureBox" + i;                  pictureBox.Size = new Size(48' 42);                  pictureBox.TabIndex = 0;                  pictureBox.TabStop = false;                    Controls.Add(pictureBox);                    Bitmap bm = rvImages.GetBitmap("G_" + displayList[i]);                  pictureBox.Image = bm;                    Label label = new Label();                  label.BackColor = SystemColors.Control;                  label.BorderStyle = BorderStyle.FixedSingle;                  label.Location = new Point(54' 4 + i * 44);                  label.TextAlign = ContentAlignment.MiddleLeft;                  label.Name = "label" + i;                  label.Size = new Size(542' 42);                  label.TabIndex = 0;                    String text;                  switch (displayList[i])                  {                      case RepStatus.Missing:                          text = "Red - This ROM is missing.";                          break;                      case RepStatus.Correct:                          text = "Green - This ROM is Correct.";                          break;                      case RepStatus.NotCollected:                          text = "Gray - This ROM is not collected. Either it is in the parent set' or it is a 'BadDump ROM'";                          break;                      case RepStatus.UnNeeded:                          text = "Light Cyan - This ROM is unneeded here' as this ROM is collected in the parent set.";                          break;                      case RepStatus.Unknown:                          text = "Cyan - This ROM is not needed here. (Find Fixes to see what should be done with this ROM)";                          break;                      case RepStatus.InToSort:                          text = "Magenta - This ROM is in the ToSort directory' after Finding Fixes this ROM is not needed in any sets.";                          break;                      case RepStatus.Corrupt:                          text = "Red - This ROM is Corrupt in the Zip File.";                          break;                      case RepStatus.UnScanned:                          text = "Blue - This file could not be scanned as it is locked by another process.";                          break;                      case RepStatus.Ignore:                          text = "GreyBlue - This file is found in the Ignore file list.";                          break;                      case RepStatus.CanBeFixed:                          text = "Yellow - This ROM is missing here but has been found somewhere else' and so can be fixed.";                          break;                      case RepStatus.MoveToSort:                          text = "Purple - This ROM is not found in any DAT set' and so will be moved out to ToSort.";                          break;                      case RepStatus.Delete:                          text = "Brown - This ROM should be deleted' as a copy of it is correctly located somewhere else.";                          break;                      case RepStatus.NeededForFix:                          text = "Orange - This Rom in not needed here' but is required in another set somewhere else.";                          break;                        default:                          text = "";                          break;                  }                    label.Text = text;                  Controls.Add(label);              }
Magic Number,ROMVault2,FrmKey,C:\repos\gjefferyes_RomVault\ROMVault2\FrmKey.cs,FrmKey_Load,The following statement contains a magic number: for (int i = 0; i < displayList.Count; i++)              {                  PictureBox pictureBox = new PictureBox();                  pictureBox.BorderStyle = BorderStyle.FixedSingle;                  pictureBox.Location = new Point(4' 4 + i * 44);                  pictureBox.Name = "pictureBox" + i;                  pictureBox.Size = new Size(48' 42);                  pictureBox.TabIndex = 0;                  pictureBox.TabStop = false;                    Controls.Add(pictureBox);                    Bitmap bm = rvImages.GetBitmap("G_" + displayList[i]);                  pictureBox.Image = bm;                    Label label = new Label();                  label.BackColor = SystemColors.Control;                  label.BorderStyle = BorderStyle.FixedSingle;                  label.Location = new Point(54' 4 + i * 44);                  label.TextAlign = ContentAlignment.MiddleLeft;                  label.Name = "label" + i;                  label.Size = new Size(542' 42);                  label.TabIndex = 0;                    String text;                  switch (displayList[i])                  {                      case RepStatus.Missing:                          text = "Red - This ROM is missing.";                          break;                      case RepStatus.Correct:                          text = "Green - This ROM is Correct.";                          break;                      case RepStatus.NotCollected:                          text = "Gray - This ROM is not collected. Either it is in the parent set' or it is a 'BadDump ROM'";                          break;                      case RepStatus.UnNeeded:                          text = "Light Cyan - This ROM is unneeded here' as this ROM is collected in the parent set.";                          break;                      case RepStatus.Unknown:                          text = "Cyan - This ROM is not needed here. (Find Fixes to see what should be done with this ROM)";                          break;                      case RepStatus.InToSort:                          text = "Magenta - This ROM is in the ToSort directory' after Finding Fixes this ROM is not needed in any sets.";                          break;                      case RepStatus.Corrupt:                          text = "Red - This ROM is Corrupt in the Zip File.";                          break;                      case RepStatus.UnScanned:                          text = "Blue - This file could not be scanned as it is locked by another process.";                          break;                      case RepStatus.Ignore:                          text = "GreyBlue - This file is found in the Ignore file list.";                          break;                      case RepStatus.CanBeFixed:                          text = "Yellow - This ROM is missing here but has been found somewhere else' and so can be fixed.";                          break;                      case RepStatus.MoveToSort:                          text = "Purple - This ROM is not found in any DAT set' and so will be moved out to ToSort.";                          break;                      case RepStatus.Delete:                          text = "Brown - This ROM should be deleted' as a copy of it is correctly located somewhere else.";                          break;                      case RepStatus.NeededForFix:                          text = "Orange - This Rom in not needed here' but is required in another set somewhere else.";                          break;                        default:                          text = "";                          break;                  }                    label.Text = text;                  Controls.Add(label);              }
Magic Number,ROMVault2,FrmKey,C:\repos\gjefferyes_RomVault\ROMVault2\FrmKey.cs,FrmKey_Load,The following statement contains a magic number: for (int i = 0; i < displayList.Count; i++)              {                  PictureBox pictureBox = new PictureBox();                  pictureBox.BorderStyle = BorderStyle.FixedSingle;                  pictureBox.Location = new Point(4' 4 + i * 44);                  pictureBox.Name = "pictureBox" + i;                  pictureBox.Size = new Size(48' 42);                  pictureBox.TabIndex = 0;                  pictureBox.TabStop = false;                    Controls.Add(pictureBox);                    Bitmap bm = rvImages.GetBitmap("G_" + displayList[i]);                  pictureBox.Image = bm;                    Label label = new Label();                  label.BackColor = SystemColors.Control;                  label.BorderStyle = BorderStyle.FixedSingle;                  label.Location = new Point(54' 4 + i * 44);                  label.TextAlign = ContentAlignment.MiddleLeft;                  label.Name = "label" + i;                  label.Size = new Size(542' 42);                  label.TabIndex = 0;                    String text;                  switch (displayList[i])                  {                      case RepStatus.Missing:                          text = "Red - This ROM is missing.";                          break;                      case RepStatus.Correct:                          text = "Green - This ROM is Correct.";                          break;                      case RepStatus.NotCollected:                          text = "Gray - This ROM is not collected. Either it is in the parent set' or it is a 'BadDump ROM'";                          break;                      case RepStatus.UnNeeded:                          text = "Light Cyan - This ROM is unneeded here' as this ROM is collected in the parent set.";                          break;                      case RepStatus.Unknown:                          text = "Cyan - This ROM is not needed here. (Find Fixes to see what should be done with this ROM)";                          break;                      case RepStatus.InToSort:                          text = "Magenta - This ROM is in the ToSort directory' after Finding Fixes this ROM is not needed in any sets.";                          break;                      case RepStatus.Corrupt:                          text = "Red - This ROM is Corrupt in the Zip File.";                          break;                      case RepStatus.UnScanned:                          text = "Blue - This file could not be scanned as it is locked by another process.";                          break;                      case RepStatus.Ignore:                          text = "GreyBlue - This file is found in the Ignore file list.";                          break;                      case RepStatus.CanBeFixed:                          text = "Yellow - This ROM is missing here but has been found somewhere else' and so can be fixed.";                          break;                      case RepStatus.MoveToSort:                          text = "Purple - This ROM is not found in any DAT set' and so will be moved out to ToSort.";                          break;                      case RepStatus.Delete:                          text = "Brown - This ROM should be deleted' as a copy of it is correctly located somewhere else.";                          break;                      case RepStatus.NeededForFix:                          text = "Orange - This Rom in not needed here' but is required in another set somewhere else.";                          break;                        default:                          text = "";                          break;                  }                    label.Text = text;                  Controls.Add(label);              }
Magic Number,ROMVault2,FrmKey,C:\repos\gjefferyes_RomVault\ROMVault2\FrmKey.cs,FrmKey_Load,The following statement contains a magic number: for (int i = 0; i < displayList.Count; i++)              {                  PictureBox pictureBox = new PictureBox();                  pictureBox.BorderStyle = BorderStyle.FixedSingle;                  pictureBox.Location = new Point(4' 4 + i * 44);                  pictureBox.Name = "pictureBox" + i;                  pictureBox.Size = new Size(48' 42);                  pictureBox.TabIndex = 0;                  pictureBox.TabStop = false;                    Controls.Add(pictureBox);                    Bitmap bm = rvImages.GetBitmap("G_" + displayList[i]);                  pictureBox.Image = bm;                    Label label = new Label();                  label.BackColor = SystemColors.Control;                  label.BorderStyle = BorderStyle.FixedSingle;                  label.Location = new Point(54' 4 + i * 44);                  label.TextAlign = ContentAlignment.MiddleLeft;                  label.Name = "label" + i;                  label.Size = new Size(542' 42);                  label.TabIndex = 0;                    String text;                  switch (displayList[i])                  {                      case RepStatus.Missing:                          text = "Red - This ROM is missing.";                          break;                      case RepStatus.Correct:                          text = "Green - This ROM is Correct.";                          break;                      case RepStatus.NotCollected:                          text = "Gray - This ROM is not collected. Either it is in the parent set' or it is a 'BadDump ROM'";                          break;                      case RepStatus.UnNeeded:                          text = "Light Cyan - This ROM is unneeded here' as this ROM is collected in the parent set.";                          break;                      case RepStatus.Unknown:                          text = "Cyan - This ROM is not needed here. (Find Fixes to see what should be done with this ROM)";                          break;                      case RepStatus.InToSort:                          text = "Magenta - This ROM is in the ToSort directory' after Finding Fixes this ROM is not needed in any sets.";                          break;                      case RepStatus.Corrupt:                          text = "Red - This ROM is Corrupt in the Zip File.";                          break;                      case RepStatus.UnScanned:                          text = "Blue - This file could not be scanned as it is locked by another process.";                          break;                      case RepStatus.Ignore:                          text = "GreyBlue - This file is found in the Ignore file list.";                          break;                      case RepStatus.CanBeFixed:                          text = "Yellow - This ROM is missing here but has been found somewhere else' and so can be fixed.";                          break;                      case RepStatus.MoveToSort:                          text = "Purple - This ROM is not found in any DAT set' and so will be moved out to ToSort.";                          break;                      case RepStatus.Delete:                          text = "Brown - This ROM should be deleted' as a copy of it is correctly located somewhere else.";                          break;                      case RepStatus.NeededForFix:                          text = "Orange - This Rom in not needed here' but is required in another set somewhere else.";                          break;                        default:                          text = "";                          break;                  }                    label.Text = text;                  Controls.Add(label);              }
Magic Number,ROMVault2,FrmKey,C:\repos\gjefferyes_RomVault\ROMVault2\FrmKey.cs,FrmKey_Load,The following statement contains a magic number: for (int i = 0; i < displayList.Count; i++)              {                  PictureBox pictureBox = new PictureBox();                  pictureBox.BorderStyle = BorderStyle.FixedSingle;                  pictureBox.Location = new Point(4' 4 + i * 44);                  pictureBox.Name = "pictureBox" + i;                  pictureBox.Size = new Size(48' 42);                  pictureBox.TabIndex = 0;                  pictureBox.TabStop = false;                    Controls.Add(pictureBox);                    Bitmap bm = rvImages.GetBitmap("G_" + displayList[i]);                  pictureBox.Image = bm;                    Label label = new Label();                  label.BackColor = SystemColors.Control;                  label.BorderStyle = BorderStyle.FixedSingle;                  label.Location = new Point(54' 4 + i * 44);                  label.TextAlign = ContentAlignment.MiddleLeft;                  label.Name = "label" + i;                  label.Size = new Size(542' 42);                  label.TabIndex = 0;                    String text;                  switch (displayList[i])                  {                      case RepStatus.Missing:                          text = "Red - This ROM is missing.";                          break;                      case RepStatus.Correct:                          text = "Green - This ROM is Correct.";                          break;                      case RepStatus.NotCollected:                          text = "Gray - This ROM is not collected. Either it is in the parent set' or it is a 'BadDump ROM'";                          break;                      case RepStatus.UnNeeded:                          text = "Light Cyan - This ROM is unneeded here' as this ROM is collected in the parent set.";                          break;                      case RepStatus.Unknown:                          text = "Cyan - This ROM is not needed here. (Find Fixes to see what should be done with this ROM)";                          break;                      case RepStatus.InToSort:                          text = "Magenta - This ROM is in the ToSort directory' after Finding Fixes this ROM is not needed in any sets.";                          break;                      case RepStatus.Corrupt:                          text = "Red - This ROM is Corrupt in the Zip File.";                          break;                      case RepStatus.UnScanned:                          text = "Blue - This file could not be scanned as it is locked by another process.";                          break;                      case RepStatus.Ignore:                          text = "GreyBlue - This file is found in the Ignore file list.";                          break;                      case RepStatus.CanBeFixed:                          text = "Yellow - This ROM is missing here but has been found somewhere else' and so can be fixed.";                          break;                      case RepStatus.MoveToSort:                          text = "Purple - This ROM is not found in any DAT set' and so will be moved out to ToSort.";                          break;                      case RepStatus.Delete:                          text = "Brown - This ROM should be deleted' as a copy of it is correctly located somewhere else.";                          break;                      case RepStatus.NeededForFix:                          text = "Orange - This Rom in not needed here' but is required in another set somewhere else.";                          break;                        default:                          text = "";                          break;                  }                    label.Text = text;                  Controls.Add(label);              }
Magic Number,ROMVault2,FrmKey,C:\repos\gjefferyes_RomVault\ROMVault2\FrmKey.cs,FrmKey_Load,The following statement contains a magic number: for (int i = 0; i < displayList.Count; i++)              {                  PictureBox pictureBox = new PictureBox();                  pictureBox.BorderStyle = BorderStyle.FixedSingle;                  pictureBox.Location = new Point(4' 4 + i * 44);                  pictureBox.Name = "pictureBox" + i;                  pictureBox.Size = new Size(48' 42);                  pictureBox.TabIndex = 0;                  pictureBox.TabStop = false;                    Controls.Add(pictureBox);                    Bitmap bm = rvImages.GetBitmap("G_" + displayList[i]);                  pictureBox.Image = bm;                    Label label = new Label();                  label.BackColor = SystemColors.Control;                  label.BorderStyle = BorderStyle.FixedSingle;                  label.Location = new Point(54' 4 + i * 44);                  label.TextAlign = ContentAlignment.MiddleLeft;                  label.Name = "label" + i;                  label.Size = new Size(542' 42);                  label.TabIndex = 0;                    String text;                  switch (displayList[i])                  {                      case RepStatus.Missing:                          text = "Red - This ROM is missing.";                          break;                      case RepStatus.Correct:                          text = "Green - This ROM is Correct.";                          break;                      case RepStatus.NotCollected:                          text = "Gray - This ROM is not collected. Either it is in the parent set' or it is a 'BadDump ROM'";                          break;                      case RepStatus.UnNeeded:                          text = "Light Cyan - This ROM is unneeded here' as this ROM is collected in the parent set.";                          break;                      case RepStatus.Unknown:                          text = "Cyan - This ROM is not needed here. (Find Fixes to see what should be done with this ROM)";                          break;                      case RepStatus.InToSort:                          text = "Magenta - This ROM is in the ToSort directory' after Finding Fixes this ROM is not needed in any sets.";                          break;                      case RepStatus.Corrupt:                          text = "Red - This ROM is Corrupt in the Zip File.";                          break;                      case RepStatus.UnScanned:                          text = "Blue - This file could not be scanned as it is locked by another process.";                          break;                      case RepStatus.Ignore:                          text = "GreyBlue - This file is found in the Ignore file list.";                          break;                      case RepStatus.CanBeFixed:                          text = "Yellow - This ROM is missing here but has been found somewhere else' and so can be fixed.";                          break;                      case RepStatus.MoveToSort:                          text = "Purple - This ROM is not found in any DAT set' and so will be moved out to ToSort.";                          break;                      case RepStatus.Delete:                          text = "Brown - This ROM should be deleted' as a copy of it is correctly located somewhere else.";                          break;                      case RepStatus.NeededForFix:                          text = "Orange - This Rom in not needed here' but is required in another set somewhere else.";                          break;                        default:                          text = "";                          break;                  }                    label.Text = text;                  Controls.Add(label);              }
Magic Number,ROMVault2,FrmKey,C:\repos\gjefferyes_RomVault\ROMVault2\FrmKey.cs,FrmKey_Load,The following statement contains a magic number: for (int i = 0; i < displayList.Count; i++)              {                  PictureBox pictureBox = new PictureBox();                  pictureBox.BorderStyle = BorderStyle.FixedSingle;                  pictureBox.Location = new Point(4' 4 + i * 44);                  pictureBox.Name = "pictureBox" + i;                  pictureBox.Size = new Size(48' 42);                  pictureBox.TabIndex = 0;                  pictureBox.TabStop = false;                    Controls.Add(pictureBox);                    Bitmap bm = rvImages.GetBitmap("G_" + displayList[i]);                  pictureBox.Image = bm;                    Label label = new Label();                  label.BackColor = SystemColors.Control;                  label.BorderStyle = BorderStyle.FixedSingle;                  label.Location = new Point(54' 4 + i * 44);                  label.TextAlign = ContentAlignment.MiddleLeft;                  label.Name = "label" + i;                  label.Size = new Size(542' 42);                  label.TabIndex = 0;                    String text;                  switch (displayList[i])                  {                      case RepStatus.Missing:                          text = "Red - This ROM is missing.";                          break;                      case RepStatus.Correct:                          text = "Green - This ROM is Correct.";                          break;                      case RepStatus.NotCollected:                          text = "Gray - This ROM is not collected. Either it is in the parent set' or it is a 'BadDump ROM'";                          break;                      case RepStatus.UnNeeded:                          text = "Light Cyan - This ROM is unneeded here' as this ROM is collected in the parent set.";                          break;                      case RepStatus.Unknown:                          text = "Cyan - This ROM is not needed here. (Find Fixes to see what should be done with this ROM)";                          break;                      case RepStatus.InToSort:                          text = "Magenta - This ROM is in the ToSort directory' after Finding Fixes this ROM is not needed in any sets.";                          break;                      case RepStatus.Corrupt:                          text = "Red - This ROM is Corrupt in the Zip File.";                          break;                      case RepStatus.UnScanned:                          text = "Blue - This file could not be scanned as it is locked by another process.";                          break;                      case RepStatus.Ignore:                          text = "GreyBlue - This file is found in the Ignore file list.";                          break;                      case RepStatus.CanBeFixed:                          text = "Yellow - This ROM is missing here but has been found somewhere else' and so can be fixed.";                          break;                      case RepStatus.MoveToSort:                          text = "Purple - This ROM is not found in any DAT set' and so will be moved out to ToSort.";                          break;                      case RepStatus.Delete:                          text = "Brown - This ROM should be deleted' as a copy of it is correctly located somewhere else.";                          break;                      case RepStatus.NeededForFix:                          text = "Orange - This Rom in not needed here' but is required in another set somewhere else.";                          break;                        default:                          text = "";                          break;                  }                    label.Text = text;                  Controls.Add(label);              }
Magic Number,ROMVault2,FrmKey,C:\repos\gjefferyes_RomVault\ROMVault2\FrmKey.cs,FrmKey_Load,The following statement contains a magic number: for (int i = 0; i < displayList.Count; i++)              {                  PictureBox pictureBox = new PictureBox();                  pictureBox.BorderStyle = BorderStyle.FixedSingle;                  pictureBox.Location = new Point(4' 4 + i * 44);                  pictureBox.Name = "pictureBox" + i;                  pictureBox.Size = new Size(48' 42);                  pictureBox.TabIndex = 0;                  pictureBox.TabStop = false;                    Controls.Add(pictureBox);                    Bitmap bm = rvImages.GetBitmap("G_" + displayList[i]);                  pictureBox.Image = bm;                    Label label = new Label();                  label.BackColor = SystemColors.Control;                  label.BorderStyle = BorderStyle.FixedSingle;                  label.Location = new Point(54' 4 + i * 44);                  label.TextAlign = ContentAlignment.MiddleLeft;                  label.Name = "label" + i;                  label.Size = new Size(542' 42);                  label.TabIndex = 0;                    String text;                  switch (displayList[i])                  {                      case RepStatus.Missing:                          text = "Red - This ROM is missing.";                          break;                      case RepStatus.Correct:                          text = "Green - This ROM is Correct.";                          break;                      case RepStatus.NotCollected:                          text = "Gray - This ROM is not collected. Either it is in the parent set' or it is a 'BadDump ROM'";                          break;                      case RepStatus.UnNeeded:                          text = "Light Cyan - This ROM is unneeded here' as this ROM is collected in the parent set.";                          break;                      case RepStatus.Unknown:                          text = "Cyan - This ROM is not needed here. (Find Fixes to see what should be done with this ROM)";                          break;                      case RepStatus.InToSort:                          text = "Magenta - This ROM is in the ToSort directory' after Finding Fixes this ROM is not needed in any sets.";                          break;                      case RepStatus.Corrupt:                          text = "Red - This ROM is Corrupt in the Zip File.";                          break;                      case RepStatus.UnScanned:                          text = "Blue - This file could not be scanned as it is locked by another process.";                          break;                      case RepStatus.Ignore:                          text = "GreyBlue - This file is found in the Ignore file list.";                          break;                      case RepStatus.CanBeFixed:                          text = "Yellow - This ROM is missing here but has been found somewhere else' and so can be fixed.";                          break;                      case RepStatus.MoveToSort:                          text = "Purple - This ROM is not found in any DAT set' and so will be moved out to ToSort.";                          break;                      case RepStatus.Delete:                          text = "Brown - This ROM should be deleted' as a copy of it is correctly located somewhere else.";                          break;                      case RepStatus.NeededForFix:                          text = "Orange - This Rom in not needed here' but is required in another set somewhere else.";                          break;                        default:                          text = "";                          break;                  }                    label.Text = text;                  Controls.Add(label);              }
Magic Number,ROMVault2,FrmKey,C:\repos\gjefferyes_RomVault\ROMVault2\FrmKey.cs,FrmKey_Load,The following statement contains a magic number: for (int i = 0; i < displayList.Count; i++)              {                  PictureBox pictureBox = new PictureBox();                  pictureBox.BorderStyle = BorderStyle.FixedSingle;                  pictureBox.Location = new Point(4' 4 + i * 44);                  pictureBox.Name = "pictureBox" + i;                  pictureBox.Size = new Size(48' 42);                  pictureBox.TabIndex = 0;                  pictureBox.TabStop = false;                    Controls.Add(pictureBox);                    Bitmap bm = rvImages.GetBitmap("G_" + displayList[i]);                  pictureBox.Image = bm;                    Label label = new Label();                  label.BackColor = SystemColors.Control;                  label.BorderStyle = BorderStyle.FixedSingle;                  label.Location = new Point(54' 4 + i * 44);                  label.TextAlign = ContentAlignment.MiddleLeft;                  label.Name = "label" + i;                  label.Size = new Size(542' 42);                  label.TabIndex = 0;                    String text;                  switch (displayList[i])                  {                      case RepStatus.Missing:                          text = "Red - This ROM is missing.";                          break;                      case RepStatus.Correct:                          text = "Green - This ROM is Correct.";                          break;                      case RepStatus.NotCollected:                          text = "Gray - This ROM is not collected. Either it is in the parent set' or it is a 'BadDump ROM'";                          break;                      case RepStatus.UnNeeded:                          text = "Light Cyan - This ROM is unneeded here' as this ROM is collected in the parent set.";                          break;                      case RepStatus.Unknown:                          text = "Cyan - This ROM is not needed here. (Find Fixes to see what should be done with this ROM)";                          break;                      case RepStatus.InToSort:                          text = "Magenta - This ROM is in the ToSort directory' after Finding Fixes this ROM is not needed in any sets.";                          break;                      case RepStatus.Corrupt:                          text = "Red - This ROM is Corrupt in the Zip File.";                          break;                      case RepStatus.UnScanned:                          text = "Blue - This file could not be scanned as it is locked by another process.";                          break;                      case RepStatus.Ignore:                          text = "GreyBlue - This file is found in the Ignore file list.";                          break;                      case RepStatus.CanBeFixed:                          text = "Yellow - This ROM is missing here but has been found somewhere else' and so can be fixed.";                          break;                      case RepStatus.MoveToSort:                          text = "Purple - This ROM is not found in any DAT set' and so will be moved out to ToSort.";                          break;                      case RepStatus.Delete:                          text = "Brown - This ROM should be deleted' as a copy of it is correctly located somewhere else.";                          break;                      case RepStatus.NeededForFix:                          text = "Orange - This Rom in not needed here' but is required in another set somewhere else.";                          break;                        default:                          text = "";                          break;                  }                    label.Text = text;                  Controls.Add(label);              }
Magic Number,ROMVault2,FrmKey,C:\repos\gjefferyes_RomVault\ROMVault2\FrmKey.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(600' 532);
Magic Number,ROMVault2,FrmKey,C:\repos\gjefferyes_RomVault\ROMVault2\FrmKey.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(600' 532);
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,FrmProgressWindow,The following statement contains a magic number: ClientSize = new Size(511' 131);
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,FrmProgressWindow,The following statement contains a magic number: ClientSize = new Size(511' 131);
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,BgwProgressChanged,The following statement contains a magic number: if (bgwSC != null)              {                  if (!_errorOpen)                  {                      _errorOpen = true;                      ClientSize = new Size(511' 292);                      MinimumSize = new Size(511' 292);                      FormBorderStyle = FormBorderStyle.SizableToolWindow;                  }                    ErrorGrid.Rows.Add();                  int row = ErrorGrid.Rows.Count - 1;                    ErrorGrid.Rows[row].Cells["CError"].Value = bgwSC.zr;                  ErrorGrid.Rows[row].Cells["CError"].Style.ForeColor = Color.FromArgb(255' 0' 0);                    ErrorGrid.Rows[row].Cells["CErrorFile"].Value = bgwSC.filename;                  ErrorGrid.Rows[row].Cells["CErrorFile"].Style.ForeColor = Color.FromArgb(255' 0' 0);                    if (row >= 0) ErrorGrid.FirstDisplayedScrollingRowIndex = row;              }
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,BgwProgressChanged,The following statement contains a magic number: if (bgwSC != null)              {                  if (!_errorOpen)                  {                      _errorOpen = true;                      ClientSize = new Size(511' 292);                      MinimumSize = new Size(511' 292);                      FormBorderStyle = FormBorderStyle.SizableToolWindow;                  }                    ErrorGrid.Rows.Add();                  int row = ErrorGrid.Rows.Count - 1;                    ErrorGrid.Rows[row].Cells["CError"].Value = bgwSC.zr;                  ErrorGrid.Rows[row].Cells["CError"].Style.ForeColor = Color.FromArgb(255' 0' 0);                    ErrorGrid.Rows[row].Cells["CErrorFile"].Value = bgwSC.filename;                  ErrorGrid.Rows[row].Cells["CErrorFile"].Style.ForeColor = Color.FromArgb(255' 0' 0);                    if (row >= 0) ErrorGrid.FirstDisplayedScrollingRowIndex = row;              }
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,BgwProgressChanged,The following statement contains a magic number: if (bgwSC != null)              {                  if (!_errorOpen)                  {                      _errorOpen = true;                      ClientSize = new Size(511' 292);                      MinimumSize = new Size(511' 292);                      FormBorderStyle = FormBorderStyle.SizableToolWindow;                  }                    ErrorGrid.Rows.Add();                  int row = ErrorGrid.Rows.Count - 1;                    ErrorGrid.Rows[row].Cells["CError"].Value = bgwSC.zr;                  ErrorGrid.Rows[row].Cells["CError"].Style.ForeColor = Color.FromArgb(255' 0' 0);                    ErrorGrid.Rows[row].Cells["CErrorFile"].Value = bgwSC.filename;                  ErrorGrid.Rows[row].Cells["CErrorFile"].Style.ForeColor = Color.FromArgb(255' 0' 0);                    if (row >= 0) ErrorGrid.FirstDisplayedScrollingRowIndex = row;              }
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,BgwProgressChanged,The following statement contains a magic number: if (bgwSC != null)              {                  if (!_errorOpen)                  {                      _errorOpen = true;                      ClientSize = new Size(511' 292);                      MinimumSize = new Size(511' 292);                      FormBorderStyle = FormBorderStyle.SizableToolWindow;                  }                    ErrorGrid.Rows.Add();                  int row = ErrorGrid.Rows.Count - 1;                    ErrorGrid.Rows[row].Cells["CError"].Value = bgwSC.zr;                  ErrorGrid.Rows[row].Cells["CError"].Style.ForeColor = Color.FromArgb(255' 0' 0);                    ErrorGrid.Rows[row].Cells["CErrorFile"].Value = bgwSC.filename;                  ErrorGrid.Rows[row].Cells["CErrorFile"].Style.ForeColor = Color.FromArgb(255' 0' 0);                    if (row >= 0) ErrorGrid.FirstDisplayedScrollingRowIndex = row;              }
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,BgwProgressChanged,The following statement contains a magic number: if (bgwSC != null)              {                  if (!_errorOpen)                  {                      _errorOpen = true;                      ClientSize = new Size(511' 292);                      MinimumSize = new Size(511' 292);                      FormBorderStyle = FormBorderStyle.SizableToolWindow;                  }                    ErrorGrid.Rows.Add();                  int row = ErrorGrid.Rows.Count - 1;                    ErrorGrid.Rows[row].Cells["CError"].Value = bgwSC.zr;                  ErrorGrid.Rows[row].Cells["CError"].Style.ForeColor = Color.FromArgb(255' 0' 0);                    ErrorGrid.Rows[row].Cells["CErrorFile"].Value = bgwSC.filename;                  ErrorGrid.Rows[row].Cells["CErrorFile"].Style.ForeColor = Color.FromArgb(255' 0' 0);                    if (row >= 0) ErrorGrid.FirstDisplayedScrollingRowIndex = row;              }
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,BgwProgressChanged,The following statement contains a magic number: if (bgwSC != null)              {                  if (!_errorOpen)                  {                      _errorOpen = true;                      ClientSize = new Size(511' 292);                      MinimumSize = new Size(511' 292);                      FormBorderStyle = FormBorderStyle.SizableToolWindow;                  }                    ErrorGrid.Rows.Add();                  int row = ErrorGrid.Rows.Count - 1;                    ErrorGrid.Rows[row].Cells["CError"].Value = bgwSC.zr;                  ErrorGrid.Rows[row].Cells["CError"].Style.ForeColor = Color.FromArgb(255' 0' 0);                    ErrorGrid.Rows[row].Cells["CErrorFile"].Value = bgwSC.filename;                  ErrorGrid.Rows[row].Cells["CErrorFile"].Style.ForeColor = Color.FromArgb(255' 0' 0);                    if (row >= 0) ErrorGrid.FirstDisplayedScrollingRowIndex = row;              }
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,BgwProgressChanged,The following statement contains a magic number: if (bgwSDE != null)              {                  if (!_errorOpen)                  {                      _errorOpen = true;                      ClientSize = new Size(511' 292);                      MinimumSize = new Size(511' 292);                      FormBorderStyle = FormBorderStyle.SizableToolWindow;                  }                    ErrorGrid.Rows.Add();                  int row = ErrorGrid.Rows.Count - 1;                    ErrorGrid.Rows[row].Cells["CError"].Value = bgwSDE.error;                  ErrorGrid.Rows[row].Cells["CError"].Style.ForeColor = Color.FromArgb(255' 0' 0);                    ErrorGrid.Rows[row].Cells["CErrorFile"].Value = bgwSDE.filename;                  ErrorGrid.Rows[row].Cells["CErrorFile"].Style.ForeColor = Color.FromArgb(255' 0' 0);                    if (row >= 0) ErrorGrid.FirstDisplayedScrollingRowIndex = row;                }
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,BgwProgressChanged,The following statement contains a magic number: if (bgwSDE != null)              {                  if (!_errorOpen)                  {                      _errorOpen = true;                      ClientSize = new Size(511' 292);                      MinimumSize = new Size(511' 292);                      FormBorderStyle = FormBorderStyle.SizableToolWindow;                  }                    ErrorGrid.Rows.Add();                  int row = ErrorGrid.Rows.Count - 1;                    ErrorGrid.Rows[row].Cells["CError"].Value = bgwSDE.error;                  ErrorGrid.Rows[row].Cells["CError"].Style.ForeColor = Color.FromArgb(255' 0' 0);                    ErrorGrid.Rows[row].Cells["CErrorFile"].Value = bgwSDE.filename;                  ErrorGrid.Rows[row].Cells["CErrorFile"].Style.ForeColor = Color.FromArgb(255' 0' 0);                    if (row >= 0) ErrorGrid.FirstDisplayedScrollingRowIndex = row;                }
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,BgwProgressChanged,The following statement contains a magic number: if (bgwSDE != null)              {                  if (!_errorOpen)                  {                      _errorOpen = true;                      ClientSize = new Size(511' 292);                      MinimumSize = new Size(511' 292);                      FormBorderStyle = FormBorderStyle.SizableToolWindow;                  }                    ErrorGrid.Rows.Add();                  int row = ErrorGrid.Rows.Count - 1;                    ErrorGrid.Rows[row].Cells["CError"].Value = bgwSDE.error;                  ErrorGrid.Rows[row].Cells["CError"].Style.ForeColor = Color.FromArgb(255' 0' 0);                    ErrorGrid.Rows[row].Cells["CErrorFile"].Value = bgwSDE.filename;                  ErrorGrid.Rows[row].Cells["CErrorFile"].Style.ForeColor = Color.FromArgb(255' 0' 0);                    if (row >= 0) ErrorGrid.FirstDisplayedScrollingRowIndex = row;                }
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,BgwProgressChanged,The following statement contains a magic number: if (bgwSDE != null)              {                  if (!_errorOpen)                  {                      _errorOpen = true;                      ClientSize = new Size(511' 292);                      MinimumSize = new Size(511' 292);                      FormBorderStyle = FormBorderStyle.SizableToolWindow;                  }                    ErrorGrid.Rows.Add();                  int row = ErrorGrid.Rows.Count - 1;                    ErrorGrid.Rows[row].Cells["CError"].Value = bgwSDE.error;                  ErrorGrid.Rows[row].Cells["CError"].Style.ForeColor = Color.FromArgb(255' 0' 0);                    ErrorGrid.Rows[row].Cells["CErrorFile"].Value = bgwSDE.filename;                  ErrorGrid.Rows[row].Cells["CErrorFile"].Style.ForeColor = Color.FromArgb(255' 0' 0);                    if (row >= 0) ErrorGrid.FirstDisplayedScrollingRowIndex = row;                }
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,BgwProgressChanged,The following statement contains a magic number: if (bgwSDE != null)              {                  if (!_errorOpen)                  {                      _errorOpen = true;                      ClientSize = new Size(511' 292);                      MinimumSize = new Size(511' 292);                      FormBorderStyle = FormBorderStyle.SizableToolWindow;                  }                    ErrorGrid.Rows.Add();                  int row = ErrorGrid.Rows.Count - 1;                    ErrorGrid.Rows[row].Cells["CError"].Value = bgwSDE.error;                  ErrorGrid.Rows[row].Cells["CError"].Style.ForeColor = Color.FromArgb(255' 0' 0);                    ErrorGrid.Rows[row].Cells["CErrorFile"].Value = bgwSDE.filename;                  ErrorGrid.Rows[row].Cells["CErrorFile"].Style.ForeColor = Color.FromArgb(255' 0' 0);                    if (row >= 0) ErrorGrid.FirstDisplayedScrollingRowIndex = row;                }
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,BgwProgressChanged,The following statement contains a magic number: if (bgwSDE != null)              {                  if (!_errorOpen)                  {                      _errorOpen = true;                      ClientSize = new Size(511' 292);                      MinimumSize = new Size(511' 292);                      FormBorderStyle = FormBorderStyle.SizableToolWindow;                  }                    ErrorGrid.Rows.Add();                  int row = ErrorGrid.Rows.Count - 1;                    ErrorGrid.Rows[row].Cells["CError"].Value = bgwSDE.error;                  ErrorGrid.Rows[row].Cells["CError"].Style.ForeColor = Color.FromArgb(255' 0' 0);                    ErrorGrid.Rows[row].Cells["CErrorFile"].Value = bgwSDE.filename;                  ErrorGrid.Rows[row].Cells["CErrorFile"].Style.ForeColor = Color.FromArgb(255' 0' 0);                    if (row >= 0) ErrorGrid.FirstDisplayedScrollingRowIndex = row;                }
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,UpdateStatusText,The following statement contains a magic number: int percent = range > 0 ? (progressBar.Value * 100) / range : 0;
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,InitializeComponent,The following statement contains a magic number: this.progressBar2.Location = new System.Drawing.Point(12' 71);
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,InitializeComponent,The following statement contains a magic number: this.progressBar2.Location = new System.Drawing.Point(12' 71);
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,InitializeComponent,The following statement contains a magic number: this.progressBar2.Size = new System.Drawing.Size(400' 22);
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,InitializeComponent,The following statement contains a magic number: this.progressBar2.Size = new System.Drawing.Size(400' 22);
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,InitializeComponent,The following statement contains a magic number: this.progressBar2.TabIndex = 3;
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,InitializeComponent,The following statement contains a magic number: this.progressBar.Location = new System.Drawing.Point(12' 99);
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,InitializeComponent,The following statement contains a magic number: this.progressBar.Location = new System.Drawing.Point(12' 99);
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,InitializeComponent,The following statement contains a magic number: this.progressBar.Size = new System.Drawing.Size(400' 23);
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,InitializeComponent,The following statement contains a magic number: this.progressBar.Size = new System.Drawing.Size(400' 23);
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,InitializeComponent,The following statement contains a magic number: this.label.Location = new System.Drawing.Point(12' 9);
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,InitializeComponent,The following statement contains a magic number: this.label.Location = new System.Drawing.Point(12' 9);
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,InitializeComponent,The following statement contains a magic number: this.label.Size = new System.Drawing.Size(368' 15);
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,InitializeComponent,The following statement contains a magic number: this.label.Size = new System.Drawing.Size(368' 15);
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,InitializeComponent,The following statement contains a magic number: this.cancelButton.Location = new System.Drawing.Point(424' 99);
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,InitializeComponent,The following statement contains a magic number: this.cancelButton.Location = new System.Drawing.Point(424' 99);
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,InitializeComponent,The following statement contains a magic number: this.cancelButton.Size = new System.Drawing.Size(75' 23);
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,InitializeComponent,The following statement contains a magic number: this.cancelButton.Size = new System.Drawing.Size(75' 23);
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,InitializeComponent,The following statement contains a magic number: this.cancelButton.TabIndex = 2;
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(12' 34);
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(12' 34);
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(480' 16);
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(480' 16);
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,InitializeComponent,The following statement contains a magic number: this.label2.TabIndex = 4;
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,InitializeComponent,The following statement contains a magic number: this.lbl2Prog.Location = new System.Drawing.Point(386' 9);
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,InitializeComponent,The following statement contains a magic number: this.lbl2Prog.Location = new System.Drawing.Point(386' 9);
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,InitializeComponent,The following statement contains a magic number: this.lbl2Prog.Size = new System.Drawing.Size(109' 25);
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,InitializeComponent,The following statement contains a magic number: this.lbl2Prog.Size = new System.Drawing.Size(109' 25);
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,InitializeComponent,The following statement contains a magic number: this.lbl2Prog.TabIndex = 5;
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,InitializeComponent,The following statement contains a magic number: this.ErrorGrid.GridColor = System.Drawing.Color.FromArgb(((int)(((byte)(224))))' ((int)(((byte)(224))))' ((int)(((byte)(224)))));
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,InitializeComponent,The following statement contains a magic number: this.ErrorGrid.GridColor = System.Drawing.Color.FromArgb(((int)(((byte)(224))))' ((int)(((byte)(224))))' ((int)(((byte)(224)))));
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,InitializeComponent,The following statement contains a magic number: this.ErrorGrid.GridColor = System.Drawing.Color.FromArgb(((int)(((byte)(224))))' ((int)(((byte)(224))))' ((int)(((byte)(224)))));
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,InitializeComponent,The following statement contains a magic number: this.ErrorGrid.RowTemplate.Height = 17;
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,InitializeComponent,The following statement contains a magic number: this.ErrorGrid.Size = new System.Drawing.Size(511' 186);
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,InitializeComponent,The following statement contains a magic number: this.ErrorGrid.Size = new System.Drawing.Size(511' 186);
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,InitializeComponent,The following statement contains a magic number: this.ErrorGrid.TabIndex = 6;
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,InitializeComponent,The following statement contains a magic number: this.CError.Width = 200;
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,InitializeComponent,The following statement contains a magic number: this.splitContainer1.Size = new System.Drawing.Size(511' 320);
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,InitializeComponent,The following statement contains a magic number: this.splitContainer1.Size = new System.Drawing.Size(511' 320);
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,InitializeComponent,The following statement contains a magic number: this.splitContainer1.SplitterDistance = 130;
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,InitializeComponent,The following statement contains a magic number: this.splitContainer1.TabIndex = 8;
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(12' 50);
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(12' 50);
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(480' 16);
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(480' 16);
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,InitializeComponent,The following statement contains a magic number: this.label3.TabIndex = 6;
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(511' 320);
Magic Number,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(511' 320);
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.DataGridGames.GridColor = System.Drawing.Color.FromArgb(((int)(((byte)(224))))' ((int)(((byte)(224))))' ((int)(((byte)(224)))));
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.DataGridGames.GridColor = System.Drawing.Color.FromArgb(((int)(((byte)(224))))' ((int)(((byte)(224))))' ((int)(((byte)(224)))));
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.DataGridGames.GridColor = System.Drawing.Color.FromArgb(((int)(((byte)(224))))' ((int)(((byte)(224))))' ((int)(((byte)(224)))));
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.DataGridGames.Location = new System.Drawing.Point(12' 135);
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.DataGridGames.Location = new System.Drawing.Point(12' 135);
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.DataGridGames.RowTemplate.Height = 17;
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.DataGridGames.Size = new System.Drawing.Size(670' 214);
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.DataGridGames.Size = new System.Drawing.Size(670' 214);
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.DataGridGames.TabIndex = 10;
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.btnDeleteSelected.Location = new System.Drawing.Point(12' 355);
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.btnDeleteSelected.Location = new System.Drawing.Point(12' 355);
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.btnDeleteSelected.Size = new System.Drawing.Size(96' 25);
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.btnDeleteSelected.Size = new System.Drawing.Size(96' 25);
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.btnDeleteSelected.TabIndex = 11;
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.grpBoxAddNew.Location = new System.Drawing.Point(12' 12);
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.grpBoxAddNew.Location = new System.Drawing.Point(12' 12);
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.grpBoxAddNew.Size = new System.Drawing.Size(670' 91);
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.grpBoxAddNew.Size = new System.Drawing.Size(670' 91);
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.grpBoxAddNew.TabIndex = 14;
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.btnSetRomLocation.Location = new System.Drawing.Point(617' 53);
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.btnSetRomLocation.Location = new System.Drawing.Point(617' 53);
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.btnSetRomLocation.Size = new System.Drawing.Size(47' 24);
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.btnSetRomLocation.Size = new System.Drawing.Size(47' 24);
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.btnSetRomLocation.TabIndex = 14;
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.txtROMLocation.Location = new System.Drawing.Point(89' 55);
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.txtROMLocation.Location = new System.Drawing.Point(89' 55);
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.txtROMLocation.Size = new System.Drawing.Size(515' 22);
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.txtROMLocation.Size = new System.Drawing.Size(515' 22);
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.txtROMLocation.TabIndex = 13;
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.lblROMLocation.Location = new System.Drawing.Point(12' 60);
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.lblROMLocation.Location = new System.Drawing.Point(12' 60);
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.lblROMLocation.Size = new System.Drawing.Size(79' 13);
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.lblROMLocation.Size = new System.Drawing.Size(79' 13);
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.lblROMLocation.TabIndex = 12;
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.txtDATLocation.Location = new System.Drawing.Point(89' 25);
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.txtDATLocation.Location = new System.Drawing.Point(89' 25);
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.txtDATLocation.Size = new System.Drawing.Size(515' 22);
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.txtDATLocation.Size = new System.Drawing.Size(515' 22);
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.txtDATLocation.TabIndex = 11;
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.lblDATLocation.Location = new System.Drawing.Point(12' 30);
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.lblDATLocation.Location = new System.Drawing.Point(12' 30);
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.lblDATLocation.Size = new System.Drawing.Size(76' 13);
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.lblDATLocation.Size = new System.Drawing.Size(76' 13);
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.lblDATLocation.TabIndex = 10;
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.lblDelete.Location = new System.Drawing.Point(20' 111);
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.lblDelete.Location = new System.Drawing.Point(20' 111);
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.lblDelete.Size = new System.Drawing.Size(144' 13);
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.lblDelete.Size = new System.Drawing.Size(144' 13);
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.lblDelete.TabIndex = 15;
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.btnClose.Location = new System.Drawing.Point(586' 355);
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.btnClose.Location = new System.Drawing.Point(586' 355);
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.btnClose.Size = new System.Drawing.Size(96' 25);
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.btnClose.Size = new System.Drawing.Size(96' 25);
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.btnClose.TabIndex = 16;
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.btnResetAll.Location = new System.Drawing.Point(138' 355);
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.btnResetAll.Location = new System.Drawing.Point(138' 355);
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.btnResetAll.Size = new System.Drawing.Size(96' 25);
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.btnResetAll.Size = new System.Drawing.Size(96' 25);
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.btnResetAll.TabIndex = 17;
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(694' 391);
Magic Number,ROMVault2,FrmSetDir,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSetDir.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(694' 391);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(8' 19);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(8' 19);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(103' 13);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(103' 13);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.lblDATRoot.Location = new System.Drawing.Point(123' 14);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.lblDATRoot.Location = new System.Drawing.Point(123' 14);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.lblDATRoot.Size = new System.Drawing.Size(357' 22);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.lblDATRoot.Size = new System.Drawing.Size(357' 22);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.lblDATRoot.TabIndex = 3;
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.btnDAT.Location = new System.Drawing.Point(486' 12);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.btnDAT.Location = new System.Drawing.Point(486' 12);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.btnDAT.Size = new System.Drawing.Size(47' 24);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.btnDAT.Size = new System.Drawing.Size(47' 24);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.btnDAT.TabIndex = 6;
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.btnOK.Location = new System.Drawing.Point(167' 314);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.btnOK.Location = new System.Drawing.Point(167' 314);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.btnOK.Size = new System.Drawing.Size(89' 23);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.btnOK.Size = new System.Drawing.Size(89' 23);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.btnOK.TabIndex = 9;
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Location = new System.Drawing.Point(280' 314);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Location = new System.Drawing.Point(280' 314);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Size = new System.Drawing.Size(89' 23);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Size = new System.Drawing.Size(89' 23);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.TabIndex = 10;
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.textBox1.Location = new System.Drawing.Point(123' 111);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.textBox1.Location = new System.Drawing.Point(123' 111);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.textBox1.Size = new System.Drawing.Size(357' 136);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.textBox1.Size = new System.Drawing.Size(357' 136);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.textBox1.TabIndex = 12;
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.label4.Location = new System.Drawing.Point(8' 113);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.label4.Location = new System.Drawing.Point(8' 113);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.label4.Size = new System.Drawing.Size(106' 72);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.label4.Size = new System.Drawing.Size(106' 72);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.label4.TabIndex = 13;
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.cboFixLevel.Location = new System.Drawing.Point(123' 75);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.cboFixLevel.Location = new System.Drawing.Point(123' 75);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.cboFixLevel.Size = new System.Drawing.Size(357' 21);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.cboFixLevel.Size = new System.Drawing.Size(357' 21);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.cboFixLevel.TabIndex = 14;
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.cboScanLevel.Location = new System.Drawing.Point(123' 48);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.cboScanLevel.Location = new System.Drawing.Point(123' 48);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.cboScanLevel.Size = new System.Drawing.Size(357' 21);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.cboScanLevel.Size = new System.Drawing.Size(357' 21);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.cboScanLevel.TabIndex = 15;
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(8' 51);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(8' 51);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(84' 13);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(84' 13);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.label2.TabIndex = 16;
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(8' 79);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(8' 79);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(66' 13);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(66' 13);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.label3.TabIndex = 17;
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.chkDebugLogs.Location = new System.Drawing.Point(279' 261);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.chkDebugLogs.Location = new System.Drawing.Point(279' 261);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.chkDebugLogs.Size = new System.Drawing.Size(126' 17);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.chkDebugLogs.Size = new System.Drawing.Size(126' 17);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.chkDebugLogs.TabIndex = 18;
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.chkCacheSaveTimer.Location = new System.Drawing.Point(125' 285);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.chkCacheSaveTimer.Location = new System.Drawing.Point(125' 285);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.chkCacheSaveTimer.Size = new System.Drawing.Size(156' 17);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.chkCacheSaveTimer.Size = new System.Drawing.Size(156' 17);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.chkCacheSaveTimer.TabIndex = 19;
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.upTime.Increment = new decimal(new int[] {              5'              0'              0'              0});
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.upTime.Location = new System.Drawing.Point(279' 283);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.upTime.Location = new System.Drawing.Point(279' 283);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.upTime.Maximum = new decimal(new int[] {              60'              0'              0'              0});
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.upTime.Minimum = new decimal(new int[] {              5'              0'              0'              0});
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.upTime.Size = new System.Drawing.Size(47' 20);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.upTime.Size = new System.Drawing.Size(47' 20);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.upTime.TabIndex = 20;
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.upTime.Value = new decimal(new int[] {              10'              0'              0'              0});
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.label5.Location = new System.Drawing.Point(329' 286);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.label5.Location = new System.Drawing.Point(329' 286);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.label5.Size = new System.Drawing.Size(44' 13);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.label5.Size = new System.Drawing.Size(44' 13);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.label5.TabIndex = 21;
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.chkDoubleCheckDelete.Location = new System.Drawing.Point(125' 261);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.chkDoubleCheckDelete.Location = new System.Drawing.Point(125' 261);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.chkDoubleCheckDelete.Size = new System.Drawing.Size(128' 17);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.chkDoubleCheckDelete.Size = new System.Drawing.Size(128' 17);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.chkDoubleCheckDelete.TabIndex = 22;
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(545' 346);
Magic Number,ROMVault2,FrmSettings,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSettings.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(545' 346);
Magic Number,ROMVault2,FrmShowError,C:\repos\gjefferyes_RomVault\ROMVault2\FrmShowError.cs,InitializeComponent,The following statement contains a magic number: this.textBox1.Location = new System.Drawing.Point(12' 12);
Magic Number,ROMVault2,FrmShowError,C:\repos\gjefferyes_RomVault\ROMVault2\FrmShowError.cs,InitializeComponent,The following statement contains a magic number: this.textBox1.Location = new System.Drawing.Point(12' 12);
Magic Number,ROMVault2,FrmShowError,C:\repos\gjefferyes_RomVault\ROMVault2\FrmShowError.cs,InitializeComponent,The following statement contains a magic number: this.textBox1.Size = new System.Drawing.Size(565' 525);
Magic Number,ROMVault2,FrmShowError,C:\repos\gjefferyes_RomVault\ROMVault2\FrmShowError.cs,InitializeComponent,The following statement contains a magic number: this.textBox1.Size = new System.Drawing.Size(565' 525);
Magic Number,ROMVault2,FrmShowError,C:\repos\gjefferyes_RomVault\ROMVault2\FrmShowError.cs,InitializeComponent,The following statement contains a magic number: this.button1.Location = new System.Drawing.Point(460' 543);
Magic Number,ROMVault2,FrmShowError,C:\repos\gjefferyes_RomVault\ROMVault2\FrmShowError.cs,InitializeComponent,The following statement contains a magic number: this.button1.Location = new System.Drawing.Point(460' 543);
Magic Number,ROMVault2,FrmShowError,C:\repos\gjefferyes_RomVault\ROMVault2\FrmShowError.cs,InitializeComponent,The following statement contains a magic number: this.button1.Size = new System.Drawing.Size(117' 28);
Magic Number,ROMVault2,FrmShowError,C:\repos\gjefferyes_RomVault\ROMVault2\FrmShowError.cs,InitializeComponent,The following statement contains a magic number: this.button1.Size = new System.Drawing.Size(117' 28);
Magic Number,ROMVault2,FrmShowError,C:\repos\gjefferyes_RomVault\ROMVault2\FrmShowError.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(20' 551);
Magic Number,ROMVault2,FrmShowError,C:\repos\gjefferyes_RomVault\ROMVault2\FrmShowError.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(20' 551);
Magic Number,ROMVault2,FrmShowError,C:\repos\gjefferyes_RomVault\ROMVault2\FrmShowError.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(202' 13);
Magic Number,ROMVault2,FrmShowError,C:\repos\gjefferyes_RomVault\ROMVault2\FrmShowError.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(202' 13);
Magic Number,ROMVault2,FrmShowError,C:\repos\gjefferyes_RomVault\ROMVault2\FrmShowError.cs,InitializeComponent,The following statement contains a magic number: this.label1.TabIndex = 2;
Magic Number,ROMVault2,FrmShowError,C:\repos\gjefferyes_RomVault\ROMVault2\FrmShowError.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(589' 583);
Magic Number,ROMVault2,FrmShowError,C:\repos\gjefferyes_RomVault\ROMVault2\FrmShowError.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(589' 583);
Magic Number,ROMVault2,FrmSplashScreen,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSplashScreen.cs,FrmSplashScreen,The following statement contains a magic number: timer1.Interval = 50;
Magic Number,ROMVault2,FrmSplashScreen,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSplashScreen.cs,BgwRunWorkerCompleted,The following statement contains a magic number: _opacityIncrement = -0.1;
Magic Number,ROMVault2,FrmSplashScreen,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSplashScreen.cs,InitializeComponent,The following statement contains a magic number: this.lblStatus.Location = new System.Drawing.Point(7' 135);
Magic Number,ROMVault2,FrmSplashScreen,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSplashScreen.cs,InitializeComponent,The following statement contains a magic number: this.lblStatus.Location = new System.Drawing.Point(7' 135);
Magic Number,ROMVault2,FrmSplashScreen,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSplashScreen.cs,InitializeComponent,The following statement contains a magic number: this.lblStatus.Padding = new System.Windows.Forms.Padding(2' 2' 0' 0);
Magic Number,ROMVault2,FrmSplashScreen,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSplashScreen.cs,InitializeComponent,The following statement contains a magic number: this.lblStatus.Padding = new System.Windows.Forms.Padding(2' 2' 0' 0);
Magic Number,ROMVault2,FrmSplashScreen,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSplashScreen.cs,InitializeComponent,The following statement contains a magic number: this.lblStatus.Size = new System.Drawing.Size(450' 20);
Magic Number,ROMVault2,FrmSplashScreen,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSplashScreen.cs,InitializeComponent,The following statement contains a magic number: this.lblStatus.Size = new System.Drawing.Size(450' 20);
Magic Number,ROMVault2,FrmSplashScreen,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSplashScreen.cs,InitializeComponent,The following statement contains a magic number: this.progressBar.Location = new System.Drawing.Point(7' 159);
Magic Number,ROMVault2,FrmSplashScreen,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSplashScreen.cs,InitializeComponent,The following statement contains a magic number: this.progressBar.Location = new System.Drawing.Point(7' 159);
Magic Number,ROMVault2,FrmSplashScreen,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSplashScreen.cs,InitializeComponent,The following statement contains a magic number: this.progressBar.Size = new System.Drawing.Size(450' 19);
Magic Number,ROMVault2,FrmSplashScreen,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSplashScreen.cs,InitializeComponent,The following statement contains a magic number: this.progressBar.Size = new System.Drawing.Size(450' 19);
Magic Number,ROMVault2,FrmSplashScreen,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSplashScreen.cs,InitializeComponent,The following statement contains a magic number: this.progressBar.TabIndex = 4;
Magic Number,ROMVault2,FrmSplashScreen,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSplashScreen.cs,InitializeComponent,The following statement contains a magic number: this.lblVersion.Location = new System.Drawing.Point(10' 113);
Magic Number,ROMVault2,FrmSplashScreen,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSplashScreen.cs,InitializeComponent,The following statement contains a magic number: this.lblVersion.Location = new System.Drawing.Point(10' 113);
Magic Number,ROMVault2,FrmSplashScreen,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSplashScreen.cs,InitializeComponent,The following statement contains a magic number: this.lblVersion.Size = new System.Drawing.Size(445' 15);
Magic Number,ROMVault2,FrmSplashScreen,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSplashScreen.cs,InitializeComponent,The following statement contains a magic number: this.lblVersion.Size = new System.Drawing.Size(445' 15);
Magic Number,ROMVault2,FrmSplashScreen,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSplashScreen.cs,InitializeComponent,The following statement contains a magic number: this.lblVersion.TabIndex = 5;
Magic Number,ROMVault2,FrmSplashScreen,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSplashScreen.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(465' 207);
Magic Number,ROMVault2,FrmSplashScreen,C:\repos\gjefferyes_RomVault\ROMVault2\FrmSplashScreen.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(465' 207);
Magic Number,ROMVault2,ReportError,C:\repos\gjefferyes_RomVault\ROMVault2\ReportError.cs,ReportFile,The following statement contains a magic number: sw.WriteLine(f.ReportIndex.ToString("D8") + " " + ArrByte.ToString(f.CRC) + " " + f.GotStatus.ToString().PadRight(10) + " " + f.RepStatus.ToString().PadRight(15) + " " + f.TreeFullName);
Magic Number,ROMVault2,ReportError,C:\repos\gjefferyes_RomVault\ROMVault2\ReportError.cs,ReportFile,The following statement contains a magic number: sw.WriteLine(f.ReportIndex.ToString("D8") + " " + ArrByte.ToString(f.CRC) + " " + f.GotStatus.ToString().PadRight(10) + " " + f.RepStatus.ToString().PadRight(15) + " " + f.TreeFullName);
Magic Number,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,SetupInt,The following statement contains a magic number: AutoScrollMinSize = new Size(500' _yPos);
Magic Number,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,SetupTree,The following statement contains a magic number: pTree.Tree.RTree = new Rectangle(0' _yPos - 8' 1 + nodeDepth * 18' 16);
Magic Number,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,SetupTree,The following statement contains a magic number: pTree.Tree.RTree = new Rectangle(0' _yPos - 8' 1 + nodeDepth * 18' 16);
Magic Number,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,SetupTree,The following statement contains a magic number: pTree.Tree.RTree = new Rectangle(0' _yPos - 8' 1 + nodeDepth * 18' 16);
Magic Number,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,SetupTree,The following statement contains a magic number: pTree.Tree.RExpand = new Rectangle(5 + nodeDepth * 18' _yPos + 4' 9' 9);
Magic Number,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,SetupTree,The following statement contains a magic number: pTree.Tree.RExpand = new Rectangle(5 + nodeDepth * 18' _yPos + 4' 9' 9);
Magic Number,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,SetupTree,The following statement contains a magic number: pTree.Tree.RExpand = new Rectangle(5 + nodeDepth * 18' _yPos + 4' 9' 9);
Magic Number,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,SetupTree,The following statement contains a magic number: pTree.Tree.RExpand = new Rectangle(5 + nodeDepth * 18' _yPos + 4' 9' 9);
Magic Number,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,SetupTree,The following statement contains a magic number: pTree.Tree.RExpand = new Rectangle(5 + nodeDepth * 18' _yPos + 4' 9' 9);
Magic Number,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,SetupTree,The following statement contains a magic number: pTree.Tree.RChecked = new Rectangle(20 + nodeDepth * 18' _yPos + 2' 13' 13);
Magic Number,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,SetupTree,The following statement contains a magic number: pTree.Tree.RChecked = new Rectangle(20 + nodeDepth * 18' _yPos + 2' 13' 13);
Magic Number,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,SetupTree,The following statement contains a magic number: pTree.Tree.RChecked = new Rectangle(20 + nodeDepth * 18' _yPos + 2' 13' 13);
Magic Number,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,SetupTree,The following statement contains a magic number: pTree.Tree.RChecked = new Rectangle(20 + nodeDepth * 18' _yPos + 2' 13' 13);
Magic Number,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,SetupTree,The following statement contains a magic number: pTree.Tree.RChecked = new Rectangle(20 + nodeDepth * 18' _yPos + 2' 13' 13);
Magic Number,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,SetupTree,The following statement contains a magic number: pTree.Tree.RIcon = new Rectangle(35 + nodeDepth * 18' _yPos' 16' 16);
Magic Number,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,SetupTree,The following statement contains a magic number: pTree.Tree.RIcon = new Rectangle(35 + nodeDepth * 18' _yPos' 16' 16);
Magic Number,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,SetupTree,The following statement contains a magic number: pTree.Tree.RIcon = new Rectangle(35 + nodeDepth * 18' _yPos' 16' 16);
Magic Number,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,SetupTree,The following statement contains a magic number: pTree.Tree.RIcon = new Rectangle(35 + nodeDepth * 18' _yPos' 16' 16);
Magic Number,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,SetupTree,The following statement contains a magic number: pTree.Tree.RText = new Rectangle(51 + nodeDepth * 18' _yPos' 500' 16);
Magic Number,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,SetupTree,The following statement contains a magic number: pTree.Tree.RText = new Rectangle(51 + nodeDepth * 18' _yPos' 500' 16);
Magic Number,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,SetupTree,The following statement contains a magic number: pTree.Tree.RText = new Rectangle(51 + nodeDepth * 18' _yPos' 500' 16);
Magic Number,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,SetupTree,The following statement contains a magic number: pTree.Tree.RText = new Rectangle(51 + nodeDepth * 18' _yPos' 500' 16);
Magic Number,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,SetupTree,The following statement contains a magic number: _yPos = _yPos + 16;
Magic Number,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,PaintTree,The following statement contains a magic number: if (pTree.Tree.RTree.IntersectsWith(t))              {                  Pen p = new Pen(Brushes.Gray' 1) { DashStyle = DashStyle.Dot };                    string lTree = pTree.Tree.TreeBranches;                  for (int j = 0; j < lTree.Length; j++)                  {                      int x = j * 18 - _hScroll;                      string cTree = lTree.Substring(j' 1);                      switch (cTree)                      {                          case "│":                              g.DrawLine(p' x + 9' y' x + 9' y + 16);                              break;                            case "├":                          case "└":                              g.DrawLine(p' x + 9' y' x + 9' y + 16);                              g.DrawLine(p' x + 9' y + 16' x + 27' y + 16);                              break;                      }                  }              }
Magic Number,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,PaintTree,The following statement contains a magic number: if (pTree.Tree.RTree.IntersectsWith(t))              {                  Pen p = new Pen(Brushes.Gray' 1) { DashStyle = DashStyle.Dot };                    string lTree = pTree.Tree.TreeBranches;                  for (int j = 0; j < lTree.Length; j++)                  {                      int x = j * 18 - _hScroll;                      string cTree = lTree.Substring(j' 1);                      switch (cTree)                      {                          case "│":                              g.DrawLine(p' x + 9' y' x + 9' y + 16);                              break;                            case "├":                          case "└":                              g.DrawLine(p' x + 9' y' x + 9' y + 16);                              g.DrawLine(p' x + 9' y + 16' x + 27' y + 16);                              break;                      }                  }              }
Magic Number,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,PaintTree,The following statement contains a magic number: if (pTree.Tree.RTree.IntersectsWith(t))              {                  Pen p = new Pen(Brushes.Gray' 1) { DashStyle = DashStyle.Dot };                    string lTree = pTree.Tree.TreeBranches;                  for (int j = 0; j < lTree.Length; j++)                  {                      int x = j * 18 - _hScroll;                      string cTree = lTree.Substring(j' 1);                      switch (cTree)                      {                          case "│":                              g.DrawLine(p' x + 9' y' x + 9' y + 16);                              break;                            case "├":                          case "└":                              g.DrawLine(p' x + 9' y' x + 9' y + 16);                              g.DrawLine(p' x + 9' y + 16' x + 27' y + 16);                              break;                      }                  }              }
Magic Number,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,PaintTree,The following statement contains a magic number: if (pTree.Tree.RTree.IntersectsWith(t))              {                  Pen p = new Pen(Brushes.Gray' 1) { DashStyle = DashStyle.Dot };                    string lTree = pTree.Tree.TreeBranches;                  for (int j = 0; j < lTree.Length; j++)                  {                      int x = j * 18 - _hScroll;                      string cTree = lTree.Substring(j' 1);                      switch (cTree)                      {                          case "│":                              g.DrawLine(p' x + 9' y' x + 9' y + 16);                              break;                            case "├":                          case "└":                              g.DrawLine(p' x + 9' y' x + 9' y + 16);                              g.DrawLine(p' x + 9' y + 16' x + 27' y + 16);                              break;                      }                  }              }
Magic Number,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,PaintTree,The following statement contains a magic number: if (pTree.Tree.RTree.IntersectsWith(t))              {                  Pen p = new Pen(Brushes.Gray' 1) { DashStyle = DashStyle.Dot };                    string lTree = pTree.Tree.TreeBranches;                  for (int j = 0; j < lTree.Length; j++)                  {                      int x = j * 18 - _hScroll;                      string cTree = lTree.Substring(j' 1);                      switch (cTree)                      {                          case "│":                              g.DrawLine(p' x + 9' y' x + 9' y + 16);                              break;                            case "├":                          case "└":                              g.DrawLine(p' x + 9' y' x + 9' y + 16);                              g.DrawLine(p' x + 9' y + 16' x + 27' y + 16);                              break;                      }                  }              }
Magic Number,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,PaintTree,The following statement contains a magic number: if (pTree.Tree.RTree.IntersectsWith(t))              {                  Pen p = new Pen(Brushes.Gray' 1) { DashStyle = DashStyle.Dot };                    string lTree = pTree.Tree.TreeBranches;                  for (int j = 0; j < lTree.Length; j++)                  {                      int x = j * 18 - _hScroll;                      string cTree = lTree.Substring(j' 1);                      switch (cTree)                      {                          case "│":                              g.DrawLine(p' x + 9' y' x + 9' y + 16);                              break;                            case "├":                          case "└":                              g.DrawLine(p' x + 9' y' x + 9' y + 16);                              g.DrawLine(p' x + 9' y + 16' x + 27' y + 16);                              break;                      }                  }              }
Magic Number,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,PaintTree,The following statement contains a magic number: if (pTree.Tree.RTree.IntersectsWith(t))              {                  Pen p = new Pen(Brushes.Gray' 1) { DashStyle = DashStyle.Dot };                    string lTree = pTree.Tree.TreeBranches;                  for (int j = 0; j < lTree.Length; j++)                  {                      int x = j * 18 - _hScroll;                      string cTree = lTree.Substring(j' 1);                      switch (cTree)                      {                          case "│":                              g.DrawLine(p' x + 9' y' x + 9' y + 16);                              break;                            case "├":                          case "└":                              g.DrawLine(p' x + 9' y' x + 9' y + 16);                              g.DrawLine(p' x + 9' y + 16' x + 27' y + 16);                              break;                      }                  }              }
Magic Number,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,PaintTree,The following statement contains a magic number: if (pTree.Tree.RTree.IntersectsWith(t))              {                  Pen p = new Pen(Brushes.Gray' 1) { DashStyle = DashStyle.Dot };                    string lTree = pTree.Tree.TreeBranches;                  for (int j = 0; j < lTree.Length; j++)                  {                      int x = j * 18 - _hScroll;                      string cTree = lTree.Substring(j' 1);                      switch (cTree)                      {                          case "│":                              g.DrawLine(p' x + 9' y' x + 9' y + 16);                              break;                            case "├":                          case "└":                              g.DrawLine(p' x + 9' y' x + 9' y + 16);                              g.DrawLine(p' x + 9' y + 16' x + 27' y + 16);                              break;                      }                  }              }
Magic Number,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,PaintTree,The following statement contains a magic number: if (pTree.Tree.RTree.IntersectsWith(t))              {                  Pen p = new Pen(Brushes.Gray' 1) { DashStyle = DashStyle.Dot };                    string lTree = pTree.Tree.TreeBranches;                  for (int j = 0; j < lTree.Length; j++)                  {                      int x = j * 18 - _hScroll;                      string cTree = lTree.Substring(j' 1);                      switch (cTree)                      {                          case "│":                              g.DrawLine(p' x + 9' y' x + 9' y + 16);                              break;                            case "├":                          case "└":                              g.DrawLine(p' x + 9' y' x + 9' y + 16);                              g.DrawLine(p' x + 9' y + 16' x + 27' y + 16);                              break;                      }                  }              }
Magic Number,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,PaintTree,The following statement contains a magic number: if (pTree.Tree.RTree.IntersectsWith(t))              {                  Pen p = new Pen(Brushes.Gray' 1) { DashStyle = DashStyle.Dot };                    string lTree = pTree.Tree.TreeBranches;                  for (int j = 0; j < lTree.Length; j++)                  {                      int x = j * 18 - _hScroll;                      string cTree = lTree.Substring(j' 1);                      switch (cTree)                      {                          case "│":                              g.DrawLine(p' x + 9' y' x + 9' y + 16);                              break;                            case "├":                          case "└":                              g.DrawLine(p' x + 9' y' x + 9' y + 16);                              g.DrawLine(p' x + 9' y + 16' x + 27' y + 16);                              break;                      }                  }              }
Magic Number,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,PaintTree,The following statement contains a magic number: if (pTree.Tree.RTree.IntersectsWith(t))              {                  Pen p = new Pen(Brushes.Gray' 1) { DashStyle = DashStyle.Dot };                    string lTree = pTree.Tree.TreeBranches;                  for (int j = 0; j < lTree.Length; j++)                  {                      int x = j * 18 - _hScroll;                      string cTree = lTree.Substring(j' 1);                      switch (cTree)                      {                          case "│":                              g.DrawLine(p' x + 9' y' x + 9' y + 16);                              break;                            case "├":                          case "└":                              g.DrawLine(p' x + 9' y' x + 9' y + 16);                              g.DrawLine(p' x + 9' y + 16' x + 27' y + 16);                              break;                      }                  }              }
Magic Number,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,PaintTree,The following statement contains a magic number: if (pTree.Tree.RIcon.IntersectsWith(t))              {                  int icon = 2;                  if (pTree.DirStatus.HasInToSort())                  {                      icon = 4;                  }                  else if (!pTree.DirStatus.HasCorrect())                  {                      icon = 1;                  }                  else if (!pTree.DirStatus.HasMissing())                  {                      icon = 3;                  }                        Bitmap bm;                  if (pTree.Dat == null && pTree.DirDatCount != 1) // Directory above DAT's in Tree                      bm = rvImages.GetBitmap("DirectoryTree" + icon);                  else if (pTree.Dat == null && pTree.DirDatCount == 1) // Directory that contains DAT's                      bm = rvImages.GetBitmap("Tree" + icon);                  else if (pTree.Dat != null && pTree.DirDatCount == 0) // Directories made by a DAT                      bm = rvImages.GetBitmap("Tree" + icon);                  else                  {                      ReportError.SendAndShow("Unknown Tree settings in DisplayTree.");                      bm = null;                  }                    if (bm != null)                  {                      g.DrawImage(bm' RSub(pTree.Tree.RIcon' _hScroll' _vScroll));                  }              }
Magic Number,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,PaintTree,The following statement contains a magic number: if (pTree.Tree.RIcon.IntersectsWith(t))              {                  int icon = 2;                  if (pTree.DirStatus.HasInToSort())                  {                      icon = 4;                  }                  else if (!pTree.DirStatus.HasCorrect())                  {                      icon = 1;                  }                  else if (!pTree.DirStatus.HasMissing())                  {                      icon = 3;                  }                        Bitmap bm;                  if (pTree.Dat == null && pTree.DirDatCount != 1) // Directory above DAT's in Tree                      bm = rvImages.GetBitmap("DirectoryTree" + icon);                  else if (pTree.Dat == null && pTree.DirDatCount == 1) // Directory that contains DAT's                      bm = rvImages.GetBitmap("Tree" + icon);                  else if (pTree.Dat != null && pTree.DirDatCount == 0) // Directories made by a DAT                      bm = rvImages.GetBitmap("Tree" + icon);                  else                  {                      ReportError.SendAndShow("Unknown Tree settings in DisplayTree.");                      bm = null;                  }                    if (bm != null)                  {                      g.DrawImage(bm' RSub(pTree.Tree.RIcon' _hScroll' _vScroll));                  }              }
Magic Number,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,PaintTree,The following statement contains a magic number: if (pTree.Tree.RIcon.IntersectsWith(t))              {                  int icon = 2;                  if (pTree.DirStatus.HasInToSort())                  {                      icon = 4;                  }                  else if (!pTree.DirStatus.HasCorrect())                  {                      icon = 1;                  }                  else if (!pTree.DirStatus.HasMissing())                  {                      icon = 3;                  }                        Bitmap bm;                  if (pTree.Dat == null && pTree.DirDatCount != 1) // Directory above DAT's in Tree                      bm = rvImages.GetBitmap("DirectoryTree" + icon);                  else if (pTree.Dat == null && pTree.DirDatCount == 1) // Directory that contains DAT's                      bm = rvImages.GetBitmap("Tree" + icon);                  else if (pTree.Dat != null && pTree.DirDatCount == 0) // Directories made by a DAT                      bm = rvImages.GetBitmap("Tree" + icon);                  else                  {                      ReportError.SendAndShow("Unknown Tree settings in DisplayTree.");                      bm = null;                  }                    if (bm != null)                  {                      g.DrawImage(bm' RSub(pTree.Tree.RIcon' _hScroll' _vScroll));                  }              }
Magic Number,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,PaintTree,The following statement contains a magic number: if (recBackGround.IntersectsWith(t))              {                  string thistxt;                    if (pTree.Dat == null && pTree.DirDatCount != 1) // Directory above DAT's in Tree                      thistxt = pTree.Name;                  else if (pTree.Dat == null && pTree.DirDatCount == 1) // Directory that contains DAT's                      thistxt = pTree.Name + ": " + pTree.DirDat(0).GetData(RvDat.DatData.Description) + " ( Have:" + pTree.DirStatus.CountCorrect() + " \\ Missing: " + pTree.DirStatus.CountMissing() + " )";                    // pTree.Parent.DirDatCount>1: This should probably be a test like parent contains Dat                   else if (pTree.Dat != null && pTree.Dat.AutoAddDirectory && pTree.Parent.DirDatCount > 1)                      thistxt = pTree.Name + ": " + pTree.Dat.GetData(RvDat.DatData.Description) + " ( Have:" + pTree.DirStatus.CountCorrect() + " \\ Missing: " + pTree.DirStatus.CountMissing() + " )";                  else if (pTree.Dat != null && pTree.DirDatCount == 0) // Directories made by a DAT                      thistxt = pTree.Name + " ( Have:" + pTree.DirStatus.CountCorrect() + " \\ Missing: " + pTree.DirStatus.CountMissing() + " )";                  else                  {                      ReportError.SendAndShow("Unknown Tree settings in DisplayTree.");                      thistxt = "";                  }                      if (_lSelected != null && pTree.TreeFullName == _lSelected.TreeFullName)                  {                      g.FillRectangle(new SolidBrush(Color.FromArgb(51' 153' 255))' RSub(recBackGround' _hScroll' _vScroll));                      g.DrawString(thistxt' new Font("Microsoft Sans Serif"' 8)' Brushes.White' pTree.Tree.RText.Left - _hScroll' pTree.Tree.RText.Top + 1 - _vScroll);                  }                  else                  {                      g.DrawString(thistxt' new Font("Microsoft Sans Serif"' 8)' Brushes.Black' pTree.Tree.RText.Left - _hScroll' pTree.Tree.RText.Top + 1 - _vScroll);                  }              }
Magic Number,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,PaintTree,The following statement contains a magic number: if (recBackGround.IntersectsWith(t))              {                  string thistxt;                    if (pTree.Dat == null && pTree.DirDatCount != 1) // Directory above DAT's in Tree                      thistxt = pTree.Name;                  else if (pTree.Dat == null && pTree.DirDatCount == 1) // Directory that contains DAT's                      thistxt = pTree.Name + ": " + pTree.DirDat(0).GetData(RvDat.DatData.Description) + " ( Have:" + pTree.DirStatus.CountCorrect() + " \\ Missing: " + pTree.DirStatus.CountMissing() + " )";                    // pTree.Parent.DirDatCount>1: This should probably be a test like parent contains Dat                   else if (pTree.Dat != null && pTree.Dat.AutoAddDirectory && pTree.Parent.DirDatCount > 1)                      thistxt = pTree.Name + ": " + pTree.Dat.GetData(RvDat.DatData.Description) + " ( Have:" + pTree.DirStatus.CountCorrect() + " \\ Missing: " + pTree.DirStatus.CountMissing() + " )";                  else if (pTree.Dat != null && pTree.DirDatCount == 0) // Directories made by a DAT                      thistxt = pTree.Name + " ( Have:" + pTree.DirStatus.CountCorrect() + " \\ Missing: " + pTree.DirStatus.CountMissing() + " )";                  else                  {                      ReportError.SendAndShow("Unknown Tree settings in DisplayTree.");                      thistxt = "";                  }                      if (_lSelected != null && pTree.TreeFullName == _lSelected.TreeFullName)                  {                      g.FillRectangle(new SolidBrush(Color.FromArgb(51' 153' 255))' RSub(recBackGround' _hScroll' _vScroll));                      g.DrawString(thistxt' new Font("Microsoft Sans Serif"' 8)' Brushes.White' pTree.Tree.RText.Left - _hScroll' pTree.Tree.RText.Top + 1 - _vScroll);                  }                  else                  {                      g.DrawString(thistxt' new Font("Microsoft Sans Serif"' 8)' Brushes.Black' pTree.Tree.RText.Left - _hScroll' pTree.Tree.RText.Top + 1 - _vScroll);                  }              }
Magic Number,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,PaintTree,The following statement contains a magic number: if (recBackGround.IntersectsWith(t))              {                  string thistxt;                    if (pTree.Dat == null && pTree.DirDatCount != 1) // Directory above DAT's in Tree                      thistxt = pTree.Name;                  else if (pTree.Dat == null && pTree.DirDatCount == 1) // Directory that contains DAT's                      thistxt = pTree.Name + ": " + pTree.DirDat(0).GetData(RvDat.DatData.Description) + " ( Have:" + pTree.DirStatus.CountCorrect() + " \\ Missing: " + pTree.DirStatus.CountMissing() + " )";                    // pTree.Parent.DirDatCount>1: This should probably be a test like parent contains Dat                   else if (pTree.Dat != null && pTree.Dat.AutoAddDirectory && pTree.Parent.DirDatCount > 1)                      thistxt = pTree.Name + ": " + pTree.Dat.GetData(RvDat.DatData.Description) + " ( Have:" + pTree.DirStatus.CountCorrect() + " \\ Missing: " + pTree.DirStatus.CountMissing() + " )";                  else if (pTree.Dat != null && pTree.DirDatCount == 0) // Directories made by a DAT                      thistxt = pTree.Name + " ( Have:" + pTree.DirStatus.CountCorrect() + " \\ Missing: " + pTree.DirStatus.CountMissing() + " )";                  else                  {                      ReportError.SendAndShow("Unknown Tree settings in DisplayTree.");                      thistxt = "";                  }                      if (_lSelected != null && pTree.TreeFullName == _lSelected.TreeFullName)                  {                      g.FillRectangle(new SolidBrush(Color.FromArgb(51' 153' 255))' RSub(recBackGround' _hScroll' _vScroll));                      g.DrawString(thistxt' new Font("Microsoft Sans Serif"' 8)' Brushes.White' pTree.Tree.RText.Left - _hScroll' pTree.Tree.RText.Top + 1 - _vScroll);                  }                  else                  {                      g.DrawString(thistxt' new Font("Microsoft Sans Serif"' 8)' Brushes.Black' pTree.Tree.RText.Left - _hScroll' pTree.Tree.RText.Top + 1 - _vScroll);                  }              }
Magic Number,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,PaintTree,The following statement contains a magic number: if (recBackGround.IntersectsWith(t))              {                  string thistxt;                    if (pTree.Dat == null && pTree.DirDatCount != 1) // Directory above DAT's in Tree                      thistxt = pTree.Name;                  else if (pTree.Dat == null && pTree.DirDatCount == 1) // Directory that contains DAT's                      thistxt = pTree.Name + ": " + pTree.DirDat(0).GetData(RvDat.DatData.Description) + " ( Have:" + pTree.DirStatus.CountCorrect() + " \\ Missing: " + pTree.DirStatus.CountMissing() + " )";                    // pTree.Parent.DirDatCount>1: This should probably be a test like parent contains Dat                   else if (pTree.Dat != null && pTree.Dat.AutoAddDirectory && pTree.Parent.DirDatCount > 1)                      thistxt = pTree.Name + ": " + pTree.Dat.GetData(RvDat.DatData.Description) + " ( Have:" + pTree.DirStatus.CountCorrect() + " \\ Missing: " + pTree.DirStatus.CountMissing() + " )";                  else if (pTree.Dat != null && pTree.DirDatCount == 0) // Directories made by a DAT                      thistxt = pTree.Name + " ( Have:" + pTree.DirStatus.CountCorrect() + " \\ Missing: " + pTree.DirStatus.CountMissing() + " )";                  else                  {                      ReportError.SendAndShow("Unknown Tree settings in DisplayTree.");                      thistxt = "";                  }                      if (_lSelected != null && pTree.TreeFullName == _lSelected.TreeFullName)                  {                      g.FillRectangle(new SolidBrush(Color.FromArgb(51' 153' 255))' RSub(recBackGround' _hScroll' _vScroll));                      g.DrawString(thistxt' new Font("Microsoft Sans Serif"' 8)' Brushes.White' pTree.Tree.RText.Left - _hScroll' pTree.Tree.RText.Top + 1 - _vScroll);                  }                  else                  {                      g.DrawString(thistxt' new Font("Microsoft Sans Serif"' 8)' Brushes.Black' pTree.Tree.RText.Left - _hScroll' pTree.Tree.RText.Top + 1 - _vScroll);                  }              }
Magic Number,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,PaintTree,The following statement contains a magic number: if (recBackGround.IntersectsWith(t))              {                  string thistxt;                    if (pTree.Dat == null && pTree.DirDatCount != 1) // Directory above DAT's in Tree                      thistxt = pTree.Name;                  else if (pTree.Dat == null && pTree.DirDatCount == 1) // Directory that contains DAT's                      thistxt = pTree.Name + ": " + pTree.DirDat(0).GetData(RvDat.DatData.Description) + " ( Have:" + pTree.DirStatus.CountCorrect() + " \\ Missing: " + pTree.DirStatus.CountMissing() + " )";                    // pTree.Parent.DirDatCount>1: This should probably be a test like parent contains Dat                   else if (pTree.Dat != null && pTree.Dat.AutoAddDirectory && pTree.Parent.DirDatCount > 1)                      thistxt = pTree.Name + ": " + pTree.Dat.GetData(RvDat.DatData.Description) + " ( Have:" + pTree.DirStatus.CountCorrect() + " \\ Missing: " + pTree.DirStatus.CountMissing() + " )";                  else if (pTree.Dat != null && pTree.DirDatCount == 0) // Directories made by a DAT                      thistxt = pTree.Name + " ( Have:" + pTree.DirStatus.CountCorrect() + " \\ Missing: " + pTree.DirStatus.CountMissing() + " )";                  else                  {                      ReportError.SendAndShow("Unknown Tree settings in DisplayTree.");                      thistxt = "";                  }                      if (_lSelected != null && pTree.TreeFullName == _lSelected.TreeFullName)                  {                      g.FillRectangle(new SolidBrush(Color.FromArgb(51' 153' 255))' RSub(recBackGround' _hScroll' _vScroll));                      g.DrawString(thistxt' new Font("Microsoft Sans Serif"' 8)' Brushes.White' pTree.Tree.RText.Left - _hScroll' pTree.Tree.RText.Top + 1 - _vScroll);                  }                  else                  {                      g.DrawString(thistxt' new Font("Microsoft Sans Serif"' 8)' Brushes.Black' pTree.Tree.RText.Left - _hScroll' pTree.Tree.RText.Top + 1 - _vScroll);                  }              }
Magic Number,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size(455' 416);
Magic Number,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size(455' 416);
Magic Number,ROMVault2,Settings,C:\repos\gjefferyes_RomVault\ROMVault2\Settings.cs,ReadConfig,The following statement contains a magic number: if (File.Exists(Path.Combine(AppDomain.CurrentDomain.BaseDirectory' "RomVault2.cfg")))              {                    FileStream fs = new FileStream(Path.Combine(AppDomain.CurrentDomain.BaseDirectory' "RomVault2.cfg")' FileMode.Open' FileAccess.Read);                  BinaryReader br = new BinaryReader(fs);                    int ver = br.ReadInt32();                  if (ver == 1)                  {                      DatRoot = br.ReadString();                      ScanLevel = eScanLevel.Level1;                      FixLevel = (eFixLevel)br.ReadInt32();                        IgnoreFiles = new List<string>();                      int c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          IgnoreFiles.Add(br.ReadString());                        DirPathMap = new List<DirMap>();                      c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          DirPathMap.Add(new DirMap(br.ReadString()' br.ReadString()));                  }                  if (ver == 2)                  {                      DatRoot = br.ReadString();                      ScanLevel = (eScanLevel)br.ReadInt32();                      FixLevel = (eFixLevel)br.ReadInt32();                        IgnoreFiles = new List<string>();                      int c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          IgnoreFiles.Add(br.ReadString());                        DirPathMap = new List<DirMap>();                      c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          DirPathMap.Add(new DirMap(br.ReadString()' br.ReadString()));                  }                  if (ver == 3)                  {                      DatRoot = br.ReadString();                      ScanLevel = (eScanLevel)br.ReadInt32();                      FixLevel = (eFixLevel)br.ReadInt32();                      DebugLogsEnabled = br.ReadBoolean();                        IgnoreFiles = new List<string>();                      int c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          IgnoreFiles.Add(br.ReadString());                        DirPathMap = new List<DirMap>();                      c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          DirPathMap.Add(new DirMap(br.ReadString()' br.ReadString()));                  }                    if (ver == 4)                  {                      DatRoot = br.ReadString();                      ScanLevel = (eScanLevel)br.ReadInt32();                      FixLevel = (eFixLevel)br.ReadInt32();                      DebugLogsEnabled = br.ReadBoolean();                        IgnoreFiles = new List<string>();                      int c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          IgnoreFiles.Add(br.ReadString());                        DirPathMap = new List<DirMap>();                      c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          DirPathMap.Add(new DirMap(br.ReadString()' br.ReadString()));                        CacheSaveTimerEnabled = br.ReadBoolean();                      CacheSaveTimePeriod = br.ReadInt32();                  }                    if (ver == 5)                  {                      DatRoot = br.ReadString();                      ScanLevel = (eScanLevel)br.ReadInt32();                      FixLevel = (eFixLevel)br.ReadInt32();                      DebugLogsEnabled = br.ReadBoolean();                        IgnoreFiles = new List<string>();                      int c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          IgnoreFiles.Add(br.ReadString());                        DirPathMap = new List<DirMap>();                      c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          DirPathMap.Add(new DirMap(br.ReadString()' br.ReadString()));                        CacheSaveTimerEnabled = br.ReadBoolean();                      CacheSaveTimePeriod = br.ReadInt32();                        DoubleCheckDelete = br.ReadBoolean();                  }                    if (ver == 6)                  {                      DatRoot = br.ReadString();                      ScanLevel = (eScanLevel)br.ReadInt32();                      FixLevel = (eFixLevel)br.ReadInt32();                      DebugLogsEnabled = br.ReadBoolean();                      bool UserLongFilenames = br.ReadBoolean();                        IgnoreFiles = new List<string>();                      int c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          IgnoreFiles.Add(br.ReadString());                        DirPathMap = new List<DirMap>();                      c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          DirPathMap.Add(new DirMap(br.ReadString()' br.ReadString()));                        CacheSaveTimerEnabled = br.ReadBoolean();                      CacheSaveTimePeriod = br.ReadInt32();                        DoubleCheckDelete = br.ReadBoolean();                  }                      br.Close();                  fs.Close();              }
Magic Number,ROMVault2,Settings,C:\repos\gjefferyes_RomVault\ROMVault2\Settings.cs,ReadConfig,The following statement contains a magic number: if (File.Exists(Path.Combine(AppDomain.CurrentDomain.BaseDirectory' "RomVault2.cfg")))              {                    FileStream fs = new FileStream(Path.Combine(AppDomain.CurrentDomain.BaseDirectory' "RomVault2.cfg")' FileMode.Open' FileAccess.Read);                  BinaryReader br = new BinaryReader(fs);                    int ver = br.ReadInt32();                  if (ver == 1)                  {                      DatRoot = br.ReadString();                      ScanLevel = eScanLevel.Level1;                      FixLevel = (eFixLevel)br.ReadInt32();                        IgnoreFiles = new List<string>();                      int c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          IgnoreFiles.Add(br.ReadString());                        DirPathMap = new List<DirMap>();                      c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          DirPathMap.Add(new DirMap(br.ReadString()' br.ReadString()));                  }                  if (ver == 2)                  {                      DatRoot = br.ReadString();                      ScanLevel = (eScanLevel)br.ReadInt32();                      FixLevel = (eFixLevel)br.ReadInt32();                        IgnoreFiles = new List<string>();                      int c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          IgnoreFiles.Add(br.ReadString());                        DirPathMap = new List<DirMap>();                      c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          DirPathMap.Add(new DirMap(br.ReadString()' br.ReadString()));                  }                  if (ver == 3)                  {                      DatRoot = br.ReadString();                      ScanLevel = (eScanLevel)br.ReadInt32();                      FixLevel = (eFixLevel)br.ReadInt32();                      DebugLogsEnabled = br.ReadBoolean();                        IgnoreFiles = new List<string>();                      int c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          IgnoreFiles.Add(br.ReadString());                        DirPathMap = new List<DirMap>();                      c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          DirPathMap.Add(new DirMap(br.ReadString()' br.ReadString()));                  }                    if (ver == 4)                  {                      DatRoot = br.ReadString();                      ScanLevel = (eScanLevel)br.ReadInt32();                      FixLevel = (eFixLevel)br.ReadInt32();                      DebugLogsEnabled = br.ReadBoolean();                        IgnoreFiles = new List<string>();                      int c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          IgnoreFiles.Add(br.ReadString());                        DirPathMap = new List<DirMap>();                      c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          DirPathMap.Add(new DirMap(br.ReadString()' br.ReadString()));                        CacheSaveTimerEnabled = br.ReadBoolean();                      CacheSaveTimePeriod = br.ReadInt32();                  }                    if (ver == 5)                  {                      DatRoot = br.ReadString();                      ScanLevel = (eScanLevel)br.ReadInt32();                      FixLevel = (eFixLevel)br.ReadInt32();                      DebugLogsEnabled = br.ReadBoolean();                        IgnoreFiles = new List<string>();                      int c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          IgnoreFiles.Add(br.ReadString());                        DirPathMap = new List<DirMap>();                      c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          DirPathMap.Add(new DirMap(br.ReadString()' br.ReadString()));                        CacheSaveTimerEnabled = br.ReadBoolean();                      CacheSaveTimePeriod = br.ReadInt32();                        DoubleCheckDelete = br.ReadBoolean();                  }                    if (ver == 6)                  {                      DatRoot = br.ReadString();                      ScanLevel = (eScanLevel)br.ReadInt32();                      FixLevel = (eFixLevel)br.ReadInt32();                      DebugLogsEnabled = br.ReadBoolean();                      bool UserLongFilenames = br.ReadBoolean();                        IgnoreFiles = new List<string>();                      int c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          IgnoreFiles.Add(br.ReadString());                        DirPathMap = new List<DirMap>();                      c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          DirPathMap.Add(new DirMap(br.ReadString()' br.ReadString()));                        CacheSaveTimerEnabled = br.ReadBoolean();                      CacheSaveTimePeriod = br.ReadInt32();                        DoubleCheckDelete = br.ReadBoolean();                  }                      br.Close();                  fs.Close();              }
Magic Number,ROMVault2,Settings,C:\repos\gjefferyes_RomVault\ROMVault2\Settings.cs,ReadConfig,The following statement contains a magic number: if (File.Exists(Path.Combine(AppDomain.CurrentDomain.BaseDirectory' "RomVault2.cfg")))              {                    FileStream fs = new FileStream(Path.Combine(AppDomain.CurrentDomain.BaseDirectory' "RomVault2.cfg")' FileMode.Open' FileAccess.Read);                  BinaryReader br = new BinaryReader(fs);                    int ver = br.ReadInt32();                  if (ver == 1)                  {                      DatRoot = br.ReadString();                      ScanLevel = eScanLevel.Level1;                      FixLevel = (eFixLevel)br.ReadInt32();                        IgnoreFiles = new List<string>();                      int c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          IgnoreFiles.Add(br.ReadString());                        DirPathMap = new List<DirMap>();                      c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          DirPathMap.Add(new DirMap(br.ReadString()' br.ReadString()));                  }                  if (ver == 2)                  {                      DatRoot = br.ReadString();                      ScanLevel = (eScanLevel)br.ReadInt32();                      FixLevel = (eFixLevel)br.ReadInt32();                        IgnoreFiles = new List<string>();                      int c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          IgnoreFiles.Add(br.ReadString());                        DirPathMap = new List<DirMap>();                      c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          DirPathMap.Add(new DirMap(br.ReadString()' br.ReadString()));                  }                  if (ver == 3)                  {                      DatRoot = br.ReadString();                      ScanLevel = (eScanLevel)br.ReadInt32();                      FixLevel = (eFixLevel)br.ReadInt32();                      DebugLogsEnabled = br.ReadBoolean();                        IgnoreFiles = new List<string>();                      int c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          IgnoreFiles.Add(br.ReadString());                        DirPathMap = new List<DirMap>();                      c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          DirPathMap.Add(new DirMap(br.ReadString()' br.ReadString()));                  }                    if (ver == 4)                  {                      DatRoot = br.ReadString();                      ScanLevel = (eScanLevel)br.ReadInt32();                      FixLevel = (eFixLevel)br.ReadInt32();                      DebugLogsEnabled = br.ReadBoolean();                        IgnoreFiles = new List<string>();                      int c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          IgnoreFiles.Add(br.ReadString());                        DirPathMap = new List<DirMap>();                      c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          DirPathMap.Add(new DirMap(br.ReadString()' br.ReadString()));                        CacheSaveTimerEnabled = br.ReadBoolean();                      CacheSaveTimePeriod = br.ReadInt32();                  }                    if (ver == 5)                  {                      DatRoot = br.ReadString();                      ScanLevel = (eScanLevel)br.ReadInt32();                      FixLevel = (eFixLevel)br.ReadInt32();                      DebugLogsEnabled = br.ReadBoolean();                        IgnoreFiles = new List<string>();                      int c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          IgnoreFiles.Add(br.ReadString());                        DirPathMap = new List<DirMap>();                      c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          DirPathMap.Add(new DirMap(br.ReadString()' br.ReadString()));                        CacheSaveTimerEnabled = br.ReadBoolean();                      CacheSaveTimePeriod = br.ReadInt32();                        DoubleCheckDelete = br.ReadBoolean();                  }                    if (ver == 6)                  {                      DatRoot = br.ReadString();                      ScanLevel = (eScanLevel)br.ReadInt32();                      FixLevel = (eFixLevel)br.ReadInt32();                      DebugLogsEnabled = br.ReadBoolean();                      bool UserLongFilenames = br.ReadBoolean();                        IgnoreFiles = new List<string>();                      int c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          IgnoreFiles.Add(br.ReadString());                        DirPathMap = new List<DirMap>();                      c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          DirPathMap.Add(new DirMap(br.ReadString()' br.ReadString()));                        CacheSaveTimerEnabled = br.ReadBoolean();                      CacheSaveTimePeriod = br.ReadInt32();                        DoubleCheckDelete = br.ReadBoolean();                  }                      br.Close();                  fs.Close();              }
Magic Number,ROMVault2,Settings,C:\repos\gjefferyes_RomVault\ROMVault2\Settings.cs,ReadConfig,The following statement contains a magic number: if (File.Exists(Path.Combine(AppDomain.CurrentDomain.BaseDirectory' "RomVault2.cfg")))              {                    FileStream fs = new FileStream(Path.Combine(AppDomain.CurrentDomain.BaseDirectory' "RomVault2.cfg")' FileMode.Open' FileAccess.Read);                  BinaryReader br = new BinaryReader(fs);                    int ver = br.ReadInt32();                  if (ver == 1)                  {                      DatRoot = br.ReadString();                      ScanLevel = eScanLevel.Level1;                      FixLevel = (eFixLevel)br.ReadInt32();                        IgnoreFiles = new List<string>();                      int c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          IgnoreFiles.Add(br.ReadString());                        DirPathMap = new List<DirMap>();                      c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          DirPathMap.Add(new DirMap(br.ReadString()' br.ReadString()));                  }                  if (ver == 2)                  {                      DatRoot = br.ReadString();                      ScanLevel = (eScanLevel)br.ReadInt32();                      FixLevel = (eFixLevel)br.ReadInt32();                        IgnoreFiles = new List<string>();                      int c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          IgnoreFiles.Add(br.ReadString());                        DirPathMap = new List<DirMap>();                      c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          DirPathMap.Add(new DirMap(br.ReadString()' br.ReadString()));                  }                  if (ver == 3)                  {                      DatRoot = br.ReadString();                      ScanLevel = (eScanLevel)br.ReadInt32();                      FixLevel = (eFixLevel)br.ReadInt32();                      DebugLogsEnabled = br.ReadBoolean();                        IgnoreFiles = new List<string>();                      int c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          IgnoreFiles.Add(br.ReadString());                        DirPathMap = new List<DirMap>();                      c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          DirPathMap.Add(new DirMap(br.ReadString()' br.ReadString()));                  }                    if (ver == 4)                  {                      DatRoot = br.ReadString();                      ScanLevel = (eScanLevel)br.ReadInt32();                      FixLevel = (eFixLevel)br.ReadInt32();                      DebugLogsEnabled = br.ReadBoolean();                        IgnoreFiles = new List<string>();                      int c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          IgnoreFiles.Add(br.ReadString());                        DirPathMap = new List<DirMap>();                      c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          DirPathMap.Add(new DirMap(br.ReadString()' br.ReadString()));                        CacheSaveTimerEnabled = br.ReadBoolean();                      CacheSaveTimePeriod = br.ReadInt32();                  }                    if (ver == 5)                  {                      DatRoot = br.ReadString();                      ScanLevel = (eScanLevel)br.ReadInt32();                      FixLevel = (eFixLevel)br.ReadInt32();                      DebugLogsEnabled = br.ReadBoolean();                        IgnoreFiles = new List<string>();                      int c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          IgnoreFiles.Add(br.ReadString());                        DirPathMap = new List<DirMap>();                      c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          DirPathMap.Add(new DirMap(br.ReadString()' br.ReadString()));                        CacheSaveTimerEnabled = br.ReadBoolean();                      CacheSaveTimePeriod = br.ReadInt32();                        DoubleCheckDelete = br.ReadBoolean();                  }                    if (ver == 6)                  {                      DatRoot = br.ReadString();                      ScanLevel = (eScanLevel)br.ReadInt32();                      FixLevel = (eFixLevel)br.ReadInt32();                      DebugLogsEnabled = br.ReadBoolean();                      bool UserLongFilenames = br.ReadBoolean();                        IgnoreFiles = new List<string>();                      int c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          IgnoreFiles.Add(br.ReadString());                        DirPathMap = new List<DirMap>();                      c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          DirPathMap.Add(new DirMap(br.ReadString()' br.ReadString()));                        CacheSaveTimerEnabled = br.ReadBoolean();                      CacheSaveTimePeriod = br.ReadInt32();                        DoubleCheckDelete = br.ReadBoolean();                  }                      br.Close();                  fs.Close();              }
Magic Number,ROMVault2,Settings,C:\repos\gjefferyes_RomVault\ROMVault2\Settings.cs,ReadConfig,The following statement contains a magic number: if (File.Exists(Path.Combine(AppDomain.CurrentDomain.BaseDirectory' "RomVault2.cfg")))              {                    FileStream fs = new FileStream(Path.Combine(AppDomain.CurrentDomain.BaseDirectory' "RomVault2.cfg")' FileMode.Open' FileAccess.Read);                  BinaryReader br = new BinaryReader(fs);                    int ver = br.ReadInt32();                  if (ver == 1)                  {                      DatRoot = br.ReadString();                      ScanLevel = eScanLevel.Level1;                      FixLevel = (eFixLevel)br.ReadInt32();                        IgnoreFiles = new List<string>();                      int c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          IgnoreFiles.Add(br.ReadString());                        DirPathMap = new List<DirMap>();                      c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          DirPathMap.Add(new DirMap(br.ReadString()' br.ReadString()));                  }                  if (ver == 2)                  {                      DatRoot = br.ReadString();                      ScanLevel = (eScanLevel)br.ReadInt32();                      FixLevel = (eFixLevel)br.ReadInt32();                        IgnoreFiles = new List<string>();                      int c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          IgnoreFiles.Add(br.ReadString());                        DirPathMap = new List<DirMap>();                      c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          DirPathMap.Add(new DirMap(br.ReadString()' br.ReadString()));                  }                  if (ver == 3)                  {                      DatRoot = br.ReadString();                      ScanLevel = (eScanLevel)br.ReadInt32();                      FixLevel = (eFixLevel)br.ReadInt32();                      DebugLogsEnabled = br.ReadBoolean();                        IgnoreFiles = new List<string>();                      int c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          IgnoreFiles.Add(br.ReadString());                        DirPathMap = new List<DirMap>();                      c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          DirPathMap.Add(new DirMap(br.ReadString()' br.ReadString()));                  }                    if (ver == 4)                  {                      DatRoot = br.ReadString();                      ScanLevel = (eScanLevel)br.ReadInt32();                      FixLevel = (eFixLevel)br.ReadInt32();                      DebugLogsEnabled = br.ReadBoolean();                        IgnoreFiles = new List<string>();                      int c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          IgnoreFiles.Add(br.ReadString());                        DirPathMap = new List<DirMap>();                      c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          DirPathMap.Add(new DirMap(br.ReadString()' br.ReadString()));                        CacheSaveTimerEnabled = br.ReadBoolean();                      CacheSaveTimePeriod = br.ReadInt32();                  }                    if (ver == 5)                  {                      DatRoot = br.ReadString();                      ScanLevel = (eScanLevel)br.ReadInt32();                      FixLevel = (eFixLevel)br.ReadInt32();                      DebugLogsEnabled = br.ReadBoolean();                        IgnoreFiles = new List<string>();                      int c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          IgnoreFiles.Add(br.ReadString());                        DirPathMap = new List<DirMap>();                      c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          DirPathMap.Add(new DirMap(br.ReadString()' br.ReadString()));                        CacheSaveTimerEnabled = br.ReadBoolean();                      CacheSaveTimePeriod = br.ReadInt32();                        DoubleCheckDelete = br.ReadBoolean();                  }                    if (ver == 6)                  {                      DatRoot = br.ReadString();                      ScanLevel = (eScanLevel)br.ReadInt32();                      FixLevel = (eFixLevel)br.ReadInt32();                      DebugLogsEnabled = br.ReadBoolean();                      bool UserLongFilenames = br.ReadBoolean();                        IgnoreFiles = new List<string>();                      int c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          IgnoreFiles.Add(br.ReadString());                        DirPathMap = new List<DirMap>();                      c = br.ReadInt32();                      for (int i = 0; i < c; i++)                          DirPathMap.Add(new DirMap(br.ReadString()' br.ReadString()));                        CacheSaveTimerEnabled = br.ReadBoolean();                      CacheSaveTimePeriod = br.ReadInt32();                        DoubleCheckDelete = br.ReadBoolean();                  }                      br.Close();                  fs.Close();              }
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIName = new Label { Location = SPoint(6' 15)' Size = SSize(76' 13)' Text = "Name :"' TextAlign = ContentAlignment.TopRight };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIName = new Label { Location = SPoint(6' 15)' Size = SSize(76' 13)' Text = "Name :"' TextAlign = ContentAlignment.TopRight };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIName = new Label { Location = SPoint(6' 15)' Size = SSize(76' 13)' Text = "Name :"' TextAlign = ContentAlignment.TopRight };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIName = new Label { Location = SPoint(6' 15)' Size = SSize(76' 13)' Text = "Name :"' TextAlign = ContentAlignment.TopRight };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITName = new Label { Location = SPoint(84' 14)' Size = SSize(320' 17)' BorderStyle = BorderStyle.FixedSingle };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITName = new Label { Location = SPoint(84' 14)' Size = SSize(320' 17)' BorderStyle = BorderStyle.FixedSingle };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITName = new Label { Location = SPoint(84' 14)' Size = SSize(320' 17)' BorderStyle = BorderStyle.FixedSingle };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITName = new Label { Location = SPoint(84' 14)' Size = SSize(320' 17)' BorderStyle = BorderStyle.FixedSingle };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIDescription = new Label { Location = SPoint(6' 31)' Size = SSize(76' 13)' Text = "Description :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIDescription = new Label { Location = SPoint(6' 31)' Size = SSize(76' 13)' Text = "Description :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIDescription = new Label { Location = SPoint(6' 31)' Size = SSize(76' 13)' Text = "Description :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIDescription = new Label { Location = SPoint(6' 31)' Size = SSize(76' 13)' Text = "Description :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITDescription = new Label { Location = SPoint(84' 30)' Size = SSize(320' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITDescription = new Label { Location = SPoint(84' 30)' Size = SSize(320' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITDescription = new Label { Location = SPoint(84' 30)' Size = SSize(320' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITDescription = new Label { Location = SPoint(84' 30)' Size = SSize(320' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIManufacturer = new Label { Location = SPoint(6' 47)' Size = SSize(76' 13)' Text = "Manufacturer :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIManufacturer = new Label { Location = SPoint(6' 47)' Size = SSize(76' 13)' Text = "Manufacturer :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIManufacturer = new Label { Location = SPoint(6' 47)' Size = SSize(76' 13)' Text = "Manufacturer :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIManufacturer = new Label { Location = SPoint(6' 47)' Size = SSize(76' 13)' Text = "Manufacturer :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITManufacturer = new Label { Location = SPoint(84' 46)' Size = SSize(320' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITManufacturer = new Label { Location = SPoint(84' 46)' Size = SSize(320' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITManufacturer = new Label { Location = SPoint(84' 46)' Size = SSize(320' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITManufacturer = new Label { Location = SPoint(84' 46)' Size = SSize(320' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSICloneOf = new Label { Location = SPoint(6' 63)' Size = SSize(76' 13)' Text = "Clone of :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSICloneOf = new Label { Location = SPoint(6' 63)' Size = SSize(76' 13)' Text = "Clone of :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSICloneOf = new Label { Location = SPoint(6' 63)' Size = SSize(76' 13)' Text = "Clone of :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSICloneOf = new Label { Location = SPoint(6' 63)' Size = SSize(76' 13)' Text = "Clone of :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITCloneOf = new Label { Location = SPoint(84' 62)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITCloneOf = new Label { Location = SPoint(84' 62)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITCloneOf = new Label { Location = SPoint(84' 62)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITCloneOf = new Label { Location = SPoint(84' 62)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIYear = new Label { Location = SPoint(206' 63)' Size = SSize(76' 13)' Text = "Year :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIYear = new Label { Location = SPoint(206' 63)' Size = SSize(76' 13)' Text = "Year :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIYear = new Label { Location = SPoint(206' 63)' Size = SSize(76' 13)' Text = "Year :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIYear = new Label { Location = SPoint(206' 63)' Size = SSize(76' 13)' Text = "Year :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITYear = new Label { Location = SPoint(284' 62)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITYear = new Label { Location = SPoint(284' 62)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITYear = new Label { Location = SPoint(284' 62)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITYear = new Label { Location = SPoint(284' 62)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIRomOf = new Label { Location = SPoint(6' 79)' Size = SSize(76' 13)' Text = "ROM of :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIRomOf = new Label { Location = SPoint(6' 79)' Size = SSize(76' 13)' Text = "ROM of :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIRomOf = new Label { Location = SPoint(6' 79)' Size = SSize(76' 13)' Text = "ROM of :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIRomOf = new Label { Location = SPoint(6' 79)' Size = SSize(76' 13)' Text = "ROM of :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITRomOf = new Label { Location = SPoint(84' 78)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITRomOf = new Label { Location = SPoint(84' 78)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITRomOf = new Label { Location = SPoint(84' 78)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITRomOf = new Label { Location = SPoint(84' 78)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITotalRoms = new Label { Location = SPoint(206' 79)' Size = SSize(76' 13)' Text = "Total ROMs :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITotalRoms = new Label { Location = SPoint(206' 79)' Size = SSize(76' 13)' Text = "Total ROMs :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITotalRoms = new Label { Location = SPoint(206' 79)' Size = SSize(76' 13)' Text = "Total ROMs :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITotalRoms = new Label { Location = SPoint(206' 79)' Size = SSize(76' 13)' Text = "Total ROMs :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITTotalRoms = new Label { Location = SPoint(284' 78)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITTotalRoms = new Label { Location = SPoint(284' 78)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITTotalRoms = new Label { Location = SPoint(284' 78)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITTotalRoms = new Label { Location = SPoint(284' 78)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIPublisher = new Label { Location = SPoint(6' 47)' Size = SSize(76' 13)' Text = "Publisher :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIPublisher = new Label { Location = SPoint(6' 47)' Size = SSize(76' 13)' Text = "Publisher :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIPublisher = new Label { Location = SPoint(6' 47)' Size = SSize(76' 13)' Text = "Publisher :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIPublisher = new Label { Location = SPoint(6' 47)' Size = SSize(76' 13)' Text = "Publisher :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITPublisher = new Label { Location = SPoint(84' 46)' Size = SSize(320' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITPublisher = new Label { Location = SPoint(84' 46)' Size = SSize(320' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITPublisher = new Label { Location = SPoint(84' 46)' Size = SSize(320' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITPublisher = new Label { Location = SPoint(84' 46)' Size = SSize(320' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIDeveloper = new Label { Location = SPoint(6' 63)' Size = SSize(76' 13)' Text = "Developer :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIDeveloper = new Label { Location = SPoint(6' 63)' Size = SSize(76' 13)' Text = "Developer :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIDeveloper = new Label { Location = SPoint(6' 63)' Size = SSize(76' 13)' Text = "Developer :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIDeveloper = new Label { Location = SPoint(6' 63)' Size = SSize(76' 13)' Text = "Developer :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITDeveloper = new Label { Location = SPoint(84' 62)' Size = SSize(320' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITDeveloper = new Label { Location = SPoint(84' 62)' Size = SSize(320' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITDeveloper = new Label { Location = SPoint(84' 62)' Size = SSize(320' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITDeveloper = new Label { Location = SPoint(84' 62)' Size = SSize(320' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIEdition = new Label { Location = SPoint(6' 79)' Size = SSize(76' 13)' Text = "Edition :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIEdition = new Label { Location = SPoint(6' 79)' Size = SSize(76' 13)' Text = "Edition :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIEdition = new Label { Location = SPoint(6' 79)' Size = SSize(76' 13)' Text = "Edition :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIEdition = new Label { Location = SPoint(6' 79)' Size = SSize(76' 13)' Text = "Edition :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITEdition = new Label { Location = SPoint(84' 78)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITEdition = new Label { Location = SPoint(84' 78)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITEdition = new Label { Location = SPoint(84' 78)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITEdition = new Label { Location = SPoint(84' 78)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIVersion = new Label { Location = SPoint(206' 79)' Size = SSize(76' 13)' Text = "Version :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIVersion = new Label { Location = SPoint(206' 79)' Size = SSize(76' 13)' Text = "Version :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIVersion = new Label { Location = SPoint(206' 79)' Size = SSize(76' 13)' Text = "Version :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIVersion = new Label { Location = SPoint(206' 79)' Size = SSize(76' 13)' Text = "Version :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITVersion = new Label { Location = SPoint(284' 78)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITVersion = new Label { Location = SPoint(284' 78)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITVersion = new Label { Location = SPoint(284' 78)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITVersion = new Label { Location = SPoint(284' 78)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIType = new Label { Location = SPoint(406' 79)' Size = SSize(76' 13)' Text = "Type :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIType = new Label { Location = SPoint(406' 79)' Size = SSize(76' 13)' Text = "Type :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIType = new Label { Location = SPoint(406' 79)' Size = SSize(76' 13)' Text = "Type :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIType = new Label { Location = SPoint(406' 79)' Size = SSize(76' 13)' Text = "Type :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITType = new Label { Location = SPoint(484' 78)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITType = new Label { Location = SPoint(484' 78)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITType = new Label { Location = SPoint(484' 78)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITType = new Label { Location = SPoint(484' 78)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIMedia = new Label { Location = SPoint(6' 95)' Size = SSize(76' 13)' Text = "Media :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIMedia = new Label { Location = SPoint(6' 95)' Size = SSize(76' 13)' Text = "Media :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIMedia = new Label { Location = SPoint(6' 95)' Size = SSize(76' 13)' Text = "Media :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIMedia = new Label { Location = SPoint(6' 95)' Size = SSize(76' 13)' Text = "Media :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITMedia = new Label { Location = SPoint(84' 94)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITMedia = new Label { Location = SPoint(84' 94)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITMedia = new Label { Location = SPoint(84' 94)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITMedia = new Label { Location = SPoint(84' 94)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSILanguage = new Label { Location = SPoint(206' 95)' Size = SSize(76' 13)' Text = "Language :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSILanguage = new Label { Location = SPoint(206' 95)' Size = SSize(76' 13)' Text = "Language :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSILanguage = new Label { Location = SPoint(206' 95)' Size = SSize(76' 13)' Text = "Language :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSILanguage = new Label { Location = SPoint(206' 95)' Size = SSize(76' 13)' Text = "Language :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITLanguage = new Label { Location = SPoint(284' 94)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITLanguage = new Label { Location = SPoint(284' 94)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITLanguage = new Label { Location = SPoint(284' 94)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITLanguage = new Label { Location = SPoint(284' 94)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIPlayers = new Label { Location = SPoint(406' 95)' Size = SSize(76' 13)' Text = "Players :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIPlayers = new Label { Location = SPoint(406' 95)' Size = SSize(76' 13)' Text = "Players :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIPlayers = new Label { Location = SPoint(406' 95)' Size = SSize(76' 13)' Text = "Players :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIPlayers = new Label { Location = SPoint(406' 95)' Size = SSize(76' 13)' Text = "Players :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITPlayers = new Label { Location = SPoint(484' 94)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITPlayers = new Label { Location = SPoint(484' 94)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITPlayers = new Label { Location = SPoint(484' 94)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITPlayers = new Label { Location = SPoint(484' 94)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIRatings = new Label { Location = SPoint(6' 111)' Size = SSize(76' 13)' Text = "Ratings :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIRatings = new Label { Location = SPoint(6' 111)' Size = SSize(76' 13)' Text = "Ratings :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIRatings = new Label { Location = SPoint(6' 111)' Size = SSize(76' 13)' Text = "Ratings :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIRatings = new Label { Location = SPoint(6' 111)' Size = SSize(76' 13)' Text = "Ratings :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITRatings = new Label { Location = SPoint(84' 110)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITRatings = new Label { Location = SPoint(84' 110)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITRatings = new Label { Location = SPoint(84' 110)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITRatings = new Label { Location = SPoint(84' 110)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIGenre = new Label { Location = SPoint(206' 111)' Size = SSize(76' 13)' Text = "Genre :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIGenre = new Label { Location = SPoint(206' 111)' Size = SSize(76' 13)' Text = "Genre :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIGenre = new Label { Location = SPoint(206' 111)' Size = SSize(76' 13)' Text = "Genre :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIGenre = new Label { Location = SPoint(206' 111)' Size = SSize(76' 13)' Text = "Genre :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITGenre = new Label { Location = SPoint(284' 110)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITGenre = new Label { Location = SPoint(284' 110)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITGenre = new Label { Location = SPoint(284' 110)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITGenre = new Label { Location = SPoint(284' 110)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIPeripheral  = new Label { Location = SPoint(406' 111)' Size = SSize(76' 13)' Text = "Peripheral :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIPeripheral  = new Label { Location = SPoint(406' 111)' Size = SSize(76' 13)' Text = "Peripheral :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIPeripheral  = new Label { Location = SPoint(406' 111)' Size = SSize(76' 13)' Text = "Peripheral :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIPeripheral  = new Label { Location = SPoint(406' 111)' Size = SSize(76' 13)' Text = "Peripheral :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITPeripheral = new Label { Location = SPoint(484' 110)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITPeripheral = new Label { Location = SPoint(484' 110)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITPeripheral = new Label { Location = SPoint(484' 110)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITPeripheral = new Label { Location = SPoint(484' 110)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIBarCode = new Label { Location = SPoint(6' 127)' Size = SSize(76' 13)' Text = "Barcode :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIBarCode = new Label { Location = SPoint(6' 127)' Size = SSize(76' 13)' Text = "Barcode :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIBarCode = new Label { Location = SPoint(6' 127)' Size = SSize(76' 13)' Text = "Barcode :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIBarCode = new Label { Location = SPoint(6' 127)' Size = SSize(76' 13)' Text = "Barcode :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITBarCode = new Label { Location = SPoint(84' 126)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITBarCode = new Label { Location = SPoint(84' 126)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITBarCode = new Label { Location = SPoint(84' 126)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITBarCode = new Label { Location = SPoint(84' 126)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIMediaCatalogNumber = new Label { Location = SPoint(406' 127)' Size = SSize(76' 13)' Text = "Cat. No. :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIMediaCatalogNumber = new Label { Location = SPoint(406' 127)' Size = SSize(76' 13)' Text = "Cat. No. :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIMediaCatalogNumber = new Label { Location = SPoint(406' 127)' Size = SSize(76' 13)' Text = "Cat. No. :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSIMediaCatalogNumber = new Label { Location = SPoint(406' 127)' Size = SSize(76' 13)' Text = "Cat. No. :"' TextAlign = ContentAlignment.TopRight' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITMediaCatalogNumber = new Label { Location = SPoint(484' 126)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITMediaCatalogNumber = new Label { Location = SPoint(484' 126)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITMediaCatalogNumber = new Label { Location = SPoint(484' 126)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,addGameGrid,The following statement contains a magic number: lblSITMediaCatalogNumber = new Label { Location = SPoint(484' 126)' Size = SSize(120' 17)' BorderStyle = BorderStyle.FixedSingle' Visible = false };
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,splitContainer3_Panel1_Resize,The following statement contains a magic number: gbDatInfo.Width = splitContainer3.Panel1.Width - (gbDatInfo.Left * 2);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,gbDatInfo_Resize,The following statement contains a magic number: const int leftPos = 89;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,gbDatInfo_Resize,The following statement contains a magic number: int rightPos = (int)(gbDatInfo.Width / _scaleFactorX) - 15;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,gbDatInfo_Resize,The following statement contains a magic number: if (rightPos > 600) rightPos = 600;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,gbDatInfo_Resize,The following statement contains a magic number: if (rightPos > 600) rightPos = 600;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,gbDatInfo_Resize,The following statement contains a magic number: int widthB1 = (int)((double)width * 120 / 340);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,gbDatInfo_Resize,The following statement contains a magic number: int widthB1 = (int)((double)width * 120 / 340);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,gbDatInfo_Resize,The following statement contains a magic number: int backD = 97;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,UpdateGameGrid,The following statement contains a magic number: for (int j = 0; j < tDir.ChildCount; j++)              {                    RvDir tChildDir = tDir.Child(j) as RvDir;                  if (tChildDir == null) continue;                    tDirStat = tChildDir.DirStatus;                    bool gCorrect = tDirStat.HasCorrect();                  bool gMissing = tDirStat.HasMissing();                  bool gUnknown = tDirStat.HasUnknown();                  bool gInToSort = tDirStat.HasInToSort();                  bool gFixes = tDirStat.HasFixesNeeded();                    bool show = (chkBoxShowCorrect.Checked && gCorrect && !gMissing && !gFixes);                  show = show || (chkBoxShowMissing.Checked && gMissing);                  show = show || (chkBoxShowFixed.Checked && gFixes);                  show = show || (gUnknown);                  show = show || (gInToSort);                  show = show || (tChildDir.GotStatus == GotStatus.Corrupt);                  show = show || !(gCorrect || gMissing || gUnknown || gInToSort || gFixes);                    if (!show) continue;                    rowCount++;                    int columnIndex = 0;                  for (int l = 0; l < RepairStatus.DisplayOrder.Length; l++)                  {                      if (l >= 13) columnIndex = l;                        if (tDirStat.Get(RepairStatus.DisplayOrder[l]) <= 0) continue;                        int len = DigitLength(tDirStat.Get(RepairStatus.DisplayOrder[l])) * 7 + 26;                      if (len > _gameGridColumnXPositions[columnIndex])                          _gameGridColumnXPositions[columnIndex] = len;                      columnIndex++;                  }              }
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,UpdateGameGrid,The following statement contains a magic number: for (int j = 0; j < tDir.ChildCount; j++)              {                    RvDir tChildDir = tDir.Child(j) as RvDir;                  if (tChildDir == null) continue;                    tDirStat = tChildDir.DirStatus;                    bool gCorrect = tDirStat.HasCorrect();                  bool gMissing = tDirStat.HasMissing();                  bool gUnknown = tDirStat.HasUnknown();                  bool gInToSort = tDirStat.HasInToSort();                  bool gFixes = tDirStat.HasFixesNeeded();                    bool show = (chkBoxShowCorrect.Checked && gCorrect && !gMissing && !gFixes);                  show = show || (chkBoxShowMissing.Checked && gMissing);                  show = show || (chkBoxShowFixed.Checked && gFixes);                  show = show || (gUnknown);                  show = show || (gInToSort);                  show = show || (tChildDir.GotStatus == GotStatus.Corrupt);                  show = show || !(gCorrect || gMissing || gUnknown || gInToSort || gFixes);                    if (!show) continue;                    rowCount++;                    int columnIndex = 0;                  for (int l = 0; l < RepairStatus.DisplayOrder.Length; l++)                  {                      if (l >= 13) columnIndex = l;                        if (tDirStat.Get(RepairStatus.DisplayOrder[l]) <= 0) continue;                        int len = DigitLength(tDirStat.Get(RepairStatus.DisplayOrder[l])) * 7 + 26;                      if (len > _gameGridColumnXPositions[columnIndex])                          _gameGridColumnXPositions[columnIndex] = len;                      columnIndex++;                  }              }
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,UpdateGameGrid,The following statement contains a magic number: for (int j = 0; j < tDir.ChildCount; j++)              {                    RvDir tChildDir = tDir.Child(j) as RvDir;                  if (tChildDir == null) continue;                    tDirStat = tChildDir.DirStatus;                    bool gCorrect = tDirStat.HasCorrect();                  bool gMissing = tDirStat.HasMissing();                  bool gUnknown = tDirStat.HasUnknown();                  bool gInToSort = tDirStat.HasInToSort();                  bool gFixes = tDirStat.HasFixesNeeded();                    bool show = (chkBoxShowCorrect.Checked && gCorrect && !gMissing && !gFixes);                  show = show || (chkBoxShowMissing.Checked && gMissing);                  show = show || (chkBoxShowFixed.Checked && gFixes);                  show = show || (gUnknown);                  show = show || (gInToSort);                  show = show || (tChildDir.GotStatus == GotStatus.Corrupt);                  show = show || !(gCorrect || gMissing || gUnknown || gInToSort || gFixes);                    if (!show) continue;                    rowCount++;                    int columnIndex = 0;                  for (int l = 0; l < RepairStatus.DisplayOrder.Length; l++)                  {                      if (l >= 13) columnIndex = l;                        if (tDirStat.Get(RepairStatus.DisplayOrder[l]) <= 0) continue;                        int len = DigitLength(tDirStat.Get(RepairStatus.DisplayOrder[l])) * 7 + 26;                      if (len > _gameGridColumnXPositions[columnIndex])                          _gameGridColumnXPositions[columnIndex] = len;                      columnIndex++;                  }              }
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,DigitLength,The following statement contains a magic number: while (textNumber > 0)              {                  textNumber = textNumber / 10;                  len++;              }
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,GameGrid_CellFormatting,The following statement contains a magic number: Color bgCol = Color.FromArgb(255' 255' 255);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,GameGrid_CellFormatting,The following statement contains a magic number: Color bgCol = Color.FromArgb(255' 255' 255);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,GameGrid_CellFormatting,The following statement contains a magic number: Color bgCol = Color.FromArgb(255' 255' 255);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,GameGrid_CellFormatting,The following statement contains a magic number: if (GameGrid.Columns[e.ColumnIndex].Name == "Type")              {                  e.CellStyle.BackColor = bgCol;                  e.CellStyle.SelectionBackColor = bgCol;                  e.CellStyle.ForeColor = fgCol;                    Bitmap bmp = new Bitmap(cellBounds.Width' cellBounds.Height);                  Graphics g = Graphics.FromImage(bmp);                    string bitmapName;                  switch (tRvDir.FileType)                  {                      case FileType.Zip:                          if (tRvDir.RepStatus == RepStatus.DirCorrect && tRvDir.ZipStatus == ZipStatus.TrrntZip)                              bitmapName = "ZipTZ";                          else                              bitmapName = "Zip" + tRvDir.RepStatus;                          break;                      default:                          // hack because DirDirInToSort image doesnt exist.                          if (tRvDir.RepStatus ==  RepStatus.DirInToSort)                              bitmapName = "Dir" + RepStatus.DirUnknown;                          else                              bitmapName = "Dir" + tRvDir.RepStatus;                            break;                  }                    Bitmap bm = rvImages.GetBitmap(bitmapName);                  if (bm != null)                  {                      g.DrawImage(bm' (cellBounds.Width - cellBounds.Height) / 2' 0' 18' 18);                      bm.Dispose();                  }                  else                      Debug.WriteLine("Missing Graphic for " + bitmapName);                    e.Value = bmp;                }               else if (GameGrid.Columns[e.ColumnIndex].Name == "CGame")              {                  e.CellStyle.BackColor = bgCol;                  e.CellStyle.ForeColor = fgCol;                    if (String.IsNullOrEmpty(tRvDir.FileName))                      e.Value = tRvDir.Name;                  else                      e.Value = tRvDir.Name + " (Found: " + tRvDir.FileName + ")";              }              else if (GameGrid.Columns[e.ColumnIndex].Name == "CDescription")              {                  e.CellStyle.BackColor = bgCol;                  e.CellStyle.ForeColor = fgCol;                    if (tRvDir.Game != null)                      e.Value = tRvDir.Game.GetData(RvGame.GameData.Description);              }              else if (GameGrid.Columns[e.ColumnIndex].Name == "CCorrect")              {                  e.CellStyle.SelectionBackColor = Color.White;                    Bitmap bmp = new Bitmap(cellBounds.Width' cellBounds.Height);                  Graphics g = Graphics.FromImage(bmp);                  g.Clear(Color.White);                  g.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SingleBitPerPixelGridFit;                  Font drawFont = new Font("Arial"' 9);                  SolidBrush drawBrushBlack = new SolidBrush(Color.Black);                    int gOff;                  int columnIndex = 0;                  for (int l = 0; l < RepairStatus.DisplayOrder.Length; l++)                  {                      if (l >= 13) columnIndex = l;                        if (tRvDir.DirStatus.Get(RepairStatus.DisplayOrder[l]) <= 0) continue;                        gOff = _gameGridColumnXPositions[columnIndex];                      Bitmap bm = rvImages.GetBitmap(@"G_" + RepairStatus.DisplayOrder[l]);                      if (bm != null)                      {                          g.DrawImage(bm' gOff' 0' 21' 18);                          bm.Dispose();                      }                      else                          Debug.WriteLine("Missing Graphics for " + "G_" + RepairStatus.DisplayOrder[l]);                        columnIndex++;                  }                    columnIndex = 0;                  for (int l = 0; l < RepairStatus.DisplayOrder.Length; l++)                  {                      if (l >= 13)                          columnIndex = l;                        if (tRvDir.DirStatus.Get(RepairStatus.DisplayOrder[l]) > 0)                      {                          gOff = _gameGridColumnXPositions[columnIndex];                          g.DrawString(tRvDir.DirStatus.Get(RepairStatus.DisplayOrder[l]).ToString(CultureInfo.InvariantCulture)' drawFont' drawBrushBlack' new PointF(gOff + 20' 3));                          columnIndex++;                      }                  }                  drawBrushBlack.Dispose();                  drawFont.Dispose();                  e.Value = bmp;              }              else                  Console.WriteLine("WARN: GameGrid_CellFormatting() unknown column: {0}"' GameGrid.Columns[e.ColumnIndex].Name);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,GameGrid_CellFormatting,The following statement contains a magic number: if (GameGrid.Columns[e.ColumnIndex].Name == "Type")              {                  e.CellStyle.BackColor = bgCol;                  e.CellStyle.SelectionBackColor = bgCol;                  e.CellStyle.ForeColor = fgCol;                    Bitmap bmp = new Bitmap(cellBounds.Width' cellBounds.Height);                  Graphics g = Graphics.FromImage(bmp);                    string bitmapName;                  switch (tRvDir.FileType)                  {                      case FileType.Zip:                          if (tRvDir.RepStatus == RepStatus.DirCorrect && tRvDir.ZipStatus == ZipStatus.TrrntZip)                              bitmapName = "ZipTZ";                          else                              bitmapName = "Zip" + tRvDir.RepStatus;                          break;                      default:                          // hack because DirDirInToSort image doesnt exist.                          if (tRvDir.RepStatus ==  RepStatus.DirInToSort)                              bitmapName = "Dir" + RepStatus.DirUnknown;                          else                              bitmapName = "Dir" + tRvDir.RepStatus;                            break;                  }                    Bitmap bm = rvImages.GetBitmap(bitmapName);                  if (bm != null)                  {                      g.DrawImage(bm' (cellBounds.Width - cellBounds.Height) / 2' 0' 18' 18);                      bm.Dispose();                  }                  else                      Debug.WriteLine("Missing Graphic for " + bitmapName);                    e.Value = bmp;                }               else if (GameGrid.Columns[e.ColumnIndex].Name == "CGame")              {                  e.CellStyle.BackColor = bgCol;                  e.CellStyle.ForeColor = fgCol;                    if (String.IsNullOrEmpty(tRvDir.FileName))                      e.Value = tRvDir.Name;                  else                      e.Value = tRvDir.Name + " (Found: " + tRvDir.FileName + ")";              }              else if (GameGrid.Columns[e.ColumnIndex].Name == "CDescription")              {                  e.CellStyle.BackColor = bgCol;                  e.CellStyle.ForeColor = fgCol;                    if (tRvDir.Game != null)                      e.Value = tRvDir.Game.GetData(RvGame.GameData.Description);              }              else if (GameGrid.Columns[e.ColumnIndex].Name == "CCorrect")              {                  e.CellStyle.SelectionBackColor = Color.White;                    Bitmap bmp = new Bitmap(cellBounds.Width' cellBounds.Height);                  Graphics g = Graphics.FromImage(bmp);                  g.Clear(Color.White);                  g.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SingleBitPerPixelGridFit;                  Font drawFont = new Font("Arial"' 9);                  SolidBrush drawBrushBlack = new SolidBrush(Color.Black);                    int gOff;                  int columnIndex = 0;                  for (int l = 0; l < RepairStatus.DisplayOrder.Length; l++)                  {                      if (l >= 13) columnIndex = l;                        if (tRvDir.DirStatus.Get(RepairStatus.DisplayOrder[l]) <= 0) continue;                        gOff = _gameGridColumnXPositions[columnIndex];                      Bitmap bm = rvImages.GetBitmap(@"G_" + RepairStatus.DisplayOrder[l]);                      if (bm != null)                      {                          g.DrawImage(bm' gOff' 0' 21' 18);                          bm.Dispose();                      }                      else                          Debug.WriteLine("Missing Graphics for " + "G_" + RepairStatus.DisplayOrder[l]);                        columnIndex++;                  }                    columnIndex = 0;                  for (int l = 0; l < RepairStatus.DisplayOrder.Length; l++)                  {                      if (l >= 13)                          columnIndex = l;                        if (tRvDir.DirStatus.Get(RepairStatus.DisplayOrder[l]) > 0)                      {                          gOff = _gameGridColumnXPositions[columnIndex];                          g.DrawString(tRvDir.DirStatus.Get(RepairStatus.DisplayOrder[l]).ToString(CultureInfo.InvariantCulture)' drawFont' drawBrushBlack' new PointF(gOff + 20' 3));                          columnIndex++;                      }                  }                  drawBrushBlack.Dispose();                  drawFont.Dispose();                  e.Value = bmp;              }              else                  Console.WriteLine("WARN: GameGrid_CellFormatting() unknown column: {0}"' GameGrid.Columns[e.ColumnIndex].Name);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,GameGrid_CellFormatting,The following statement contains a magic number: if (GameGrid.Columns[e.ColumnIndex].Name == "Type")              {                  e.CellStyle.BackColor = bgCol;                  e.CellStyle.SelectionBackColor = bgCol;                  e.CellStyle.ForeColor = fgCol;                    Bitmap bmp = new Bitmap(cellBounds.Width' cellBounds.Height);                  Graphics g = Graphics.FromImage(bmp);                    string bitmapName;                  switch (tRvDir.FileType)                  {                      case FileType.Zip:                          if (tRvDir.RepStatus == RepStatus.DirCorrect && tRvDir.ZipStatus == ZipStatus.TrrntZip)                              bitmapName = "ZipTZ";                          else                              bitmapName = "Zip" + tRvDir.RepStatus;                          break;                      default:                          // hack because DirDirInToSort image doesnt exist.                          if (tRvDir.RepStatus ==  RepStatus.DirInToSort)                              bitmapName = "Dir" + RepStatus.DirUnknown;                          else                              bitmapName = "Dir" + tRvDir.RepStatus;                            break;                  }                    Bitmap bm = rvImages.GetBitmap(bitmapName);                  if (bm != null)                  {                      g.DrawImage(bm' (cellBounds.Width - cellBounds.Height) / 2' 0' 18' 18);                      bm.Dispose();                  }                  else                      Debug.WriteLine("Missing Graphic for " + bitmapName);                    e.Value = bmp;                }               else if (GameGrid.Columns[e.ColumnIndex].Name == "CGame")              {                  e.CellStyle.BackColor = bgCol;                  e.CellStyle.ForeColor = fgCol;                    if (String.IsNullOrEmpty(tRvDir.FileName))                      e.Value = tRvDir.Name;                  else                      e.Value = tRvDir.Name + " (Found: " + tRvDir.FileName + ")";              }              else if (GameGrid.Columns[e.ColumnIndex].Name == "CDescription")              {                  e.CellStyle.BackColor = bgCol;                  e.CellStyle.ForeColor = fgCol;                    if (tRvDir.Game != null)                      e.Value = tRvDir.Game.GetData(RvGame.GameData.Description);              }              else if (GameGrid.Columns[e.ColumnIndex].Name == "CCorrect")              {                  e.CellStyle.SelectionBackColor = Color.White;                    Bitmap bmp = new Bitmap(cellBounds.Width' cellBounds.Height);                  Graphics g = Graphics.FromImage(bmp);                  g.Clear(Color.White);                  g.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SingleBitPerPixelGridFit;                  Font drawFont = new Font("Arial"' 9);                  SolidBrush drawBrushBlack = new SolidBrush(Color.Black);                    int gOff;                  int columnIndex = 0;                  for (int l = 0; l < RepairStatus.DisplayOrder.Length; l++)                  {                      if (l >= 13) columnIndex = l;                        if (tRvDir.DirStatus.Get(RepairStatus.DisplayOrder[l]) <= 0) continue;                        gOff = _gameGridColumnXPositions[columnIndex];                      Bitmap bm = rvImages.GetBitmap(@"G_" + RepairStatus.DisplayOrder[l]);                      if (bm != null)                      {                          g.DrawImage(bm' gOff' 0' 21' 18);                          bm.Dispose();                      }                      else                          Debug.WriteLine("Missing Graphics for " + "G_" + RepairStatus.DisplayOrder[l]);                        columnIndex++;                  }                    columnIndex = 0;                  for (int l = 0; l < RepairStatus.DisplayOrder.Length; l++)                  {                      if (l >= 13)                          columnIndex = l;                        if (tRvDir.DirStatus.Get(RepairStatus.DisplayOrder[l]) > 0)                      {                          gOff = _gameGridColumnXPositions[columnIndex];                          g.DrawString(tRvDir.DirStatus.Get(RepairStatus.DisplayOrder[l]).ToString(CultureInfo.InvariantCulture)' drawFont' drawBrushBlack' new PointF(gOff + 20' 3));                          columnIndex++;                      }                  }                  drawBrushBlack.Dispose();                  drawFont.Dispose();                  e.Value = bmp;              }              else                  Console.WriteLine("WARN: GameGrid_CellFormatting() unknown column: {0}"' GameGrid.Columns[e.ColumnIndex].Name);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,GameGrid_CellFormatting,The following statement contains a magic number: if (GameGrid.Columns[e.ColumnIndex].Name == "Type")              {                  e.CellStyle.BackColor = bgCol;                  e.CellStyle.SelectionBackColor = bgCol;                  e.CellStyle.ForeColor = fgCol;                    Bitmap bmp = new Bitmap(cellBounds.Width' cellBounds.Height);                  Graphics g = Graphics.FromImage(bmp);                    string bitmapName;                  switch (tRvDir.FileType)                  {                      case FileType.Zip:                          if (tRvDir.RepStatus == RepStatus.DirCorrect && tRvDir.ZipStatus == ZipStatus.TrrntZip)                              bitmapName = "ZipTZ";                          else                              bitmapName = "Zip" + tRvDir.RepStatus;                          break;                      default:                          // hack because DirDirInToSort image doesnt exist.                          if (tRvDir.RepStatus ==  RepStatus.DirInToSort)                              bitmapName = "Dir" + RepStatus.DirUnknown;                          else                              bitmapName = "Dir" + tRvDir.RepStatus;                            break;                  }                    Bitmap bm = rvImages.GetBitmap(bitmapName);                  if (bm != null)                  {                      g.DrawImage(bm' (cellBounds.Width - cellBounds.Height) / 2' 0' 18' 18);                      bm.Dispose();                  }                  else                      Debug.WriteLine("Missing Graphic for " + bitmapName);                    e.Value = bmp;                }               else if (GameGrid.Columns[e.ColumnIndex].Name == "CGame")              {                  e.CellStyle.BackColor = bgCol;                  e.CellStyle.ForeColor = fgCol;                    if (String.IsNullOrEmpty(tRvDir.FileName))                      e.Value = tRvDir.Name;                  else                      e.Value = tRvDir.Name + " (Found: " + tRvDir.FileName + ")";              }              else if (GameGrid.Columns[e.ColumnIndex].Name == "CDescription")              {                  e.CellStyle.BackColor = bgCol;                  e.CellStyle.ForeColor = fgCol;                    if (tRvDir.Game != null)                      e.Value = tRvDir.Game.GetData(RvGame.GameData.Description);              }              else if (GameGrid.Columns[e.ColumnIndex].Name == "CCorrect")              {                  e.CellStyle.SelectionBackColor = Color.White;                    Bitmap bmp = new Bitmap(cellBounds.Width' cellBounds.Height);                  Graphics g = Graphics.FromImage(bmp);                  g.Clear(Color.White);                  g.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SingleBitPerPixelGridFit;                  Font drawFont = new Font("Arial"' 9);                  SolidBrush drawBrushBlack = new SolidBrush(Color.Black);                    int gOff;                  int columnIndex = 0;                  for (int l = 0; l < RepairStatus.DisplayOrder.Length; l++)                  {                      if (l >= 13) columnIndex = l;                        if (tRvDir.DirStatus.Get(RepairStatus.DisplayOrder[l]) <= 0) continue;                        gOff = _gameGridColumnXPositions[columnIndex];                      Bitmap bm = rvImages.GetBitmap(@"G_" + RepairStatus.DisplayOrder[l]);                      if (bm != null)                      {                          g.DrawImage(bm' gOff' 0' 21' 18);                          bm.Dispose();                      }                      else                          Debug.WriteLine("Missing Graphics for " + "G_" + RepairStatus.DisplayOrder[l]);                        columnIndex++;                  }                    columnIndex = 0;                  for (int l = 0; l < RepairStatus.DisplayOrder.Length; l++)                  {                      if (l >= 13)                          columnIndex = l;                        if (tRvDir.DirStatus.Get(RepairStatus.DisplayOrder[l]) > 0)                      {                          gOff = _gameGridColumnXPositions[columnIndex];                          g.DrawString(tRvDir.DirStatus.Get(RepairStatus.DisplayOrder[l]).ToString(CultureInfo.InvariantCulture)' drawFont' drawBrushBlack' new PointF(gOff + 20' 3));                          columnIndex++;                      }                  }                  drawBrushBlack.Dispose();                  drawFont.Dispose();                  e.Value = bmp;              }              else                  Console.WriteLine("WARN: GameGrid_CellFormatting() unknown column: {0}"' GameGrid.Columns[e.ColumnIndex].Name);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,GameGrid_CellFormatting,The following statement contains a magic number: if (GameGrid.Columns[e.ColumnIndex].Name == "Type")              {                  e.CellStyle.BackColor = bgCol;                  e.CellStyle.SelectionBackColor = bgCol;                  e.CellStyle.ForeColor = fgCol;                    Bitmap bmp = new Bitmap(cellBounds.Width' cellBounds.Height);                  Graphics g = Graphics.FromImage(bmp);                    string bitmapName;                  switch (tRvDir.FileType)                  {                      case FileType.Zip:                          if (tRvDir.RepStatus == RepStatus.DirCorrect && tRvDir.ZipStatus == ZipStatus.TrrntZip)                              bitmapName = "ZipTZ";                          else                              bitmapName = "Zip" + tRvDir.RepStatus;                          break;                      default:                          // hack because DirDirInToSort image doesnt exist.                          if (tRvDir.RepStatus ==  RepStatus.DirInToSort)                              bitmapName = "Dir" + RepStatus.DirUnknown;                          else                              bitmapName = "Dir" + tRvDir.RepStatus;                            break;                  }                    Bitmap bm = rvImages.GetBitmap(bitmapName);                  if (bm != null)                  {                      g.DrawImage(bm' (cellBounds.Width - cellBounds.Height) / 2' 0' 18' 18);                      bm.Dispose();                  }                  else                      Debug.WriteLine("Missing Graphic for " + bitmapName);                    e.Value = bmp;                }               else if (GameGrid.Columns[e.ColumnIndex].Name == "CGame")              {                  e.CellStyle.BackColor = bgCol;                  e.CellStyle.ForeColor = fgCol;                    if (String.IsNullOrEmpty(tRvDir.FileName))                      e.Value = tRvDir.Name;                  else                      e.Value = tRvDir.Name + " (Found: " + tRvDir.FileName + ")";              }              else if (GameGrid.Columns[e.ColumnIndex].Name == "CDescription")              {                  e.CellStyle.BackColor = bgCol;                  e.CellStyle.ForeColor = fgCol;                    if (tRvDir.Game != null)                      e.Value = tRvDir.Game.GetData(RvGame.GameData.Description);              }              else if (GameGrid.Columns[e.ColumnIndex].Name == "CCorrect")              {                  e.CellStyle.SelectionBackColor = Color.White;                    Bitmap bmp = new Bitmap(cellBounds.Width' cellBounds.Height);                  Graphics g = Graphics.FromImage(bmp);                  g.Clear(Color.White);                  g.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SingleBitPerPixelGridFit;                  Font drawFont = new Font("Arial"' 9);                  SolidBrush drawBrushBlack = new SolidBrush(Color.Black);                    int gOff;                  int columnIndex = 0;                  for (int l = 0; l < RepairStatus.DisplayOrder.Length; l++)                  {                      if (l >= 13) columnIndex = l;                        if (tRvDir.DirStatus.Get(RepairStatus.DisplayOrder[l]) <= 0) continue;                        gOff = _gameGridColumnXPositions[columnIndex];                      Bitmap bm = rvImages.GetBitmap(@"G_" + RepairStatus.DisplayOrder[l]);                      if (bm != null)                      {                          g.DrawImage(bm' gOff' 0' 21' 18);                          bm.Dispose();                      }                      else                          Debug.WriteLine("Missing Graphics for " + "G_" + RepairStatus.DisplayOrder[l]);                        columnIndex++;                  }                    columnIndex = 0;                  for (int l = 0; l < RepairStatus.DisplayOrder.Length; l++)                  {                      if (l >= 13)                          columnIndex = l;                        if (tRvDir.DirStatus.Get(RepairStatus.DisplayOrder[l]) > 0)                      {                          gOff = _gameGridColumnXPositions[columnIndex];                          g.DrawString(tRvDir.DirStatus.Get(RepairStatus.DisplayOrder[l]).ToString(CultureInfo.InvariantCulture)' drawFont' drawBrushBlack' new PointF(gOff + 20' 3));                          columnIndex++;                      }                  }                  drawBrushBlack.Dispose();                  drawFont.Dispose();                  e.Value = bmp;              }              else                  Console.WriteLine("WARN: GameGrid_CellFormatting() unknown column: {0}"' GameGrid.Columns[e.ColumnIndex].Name);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,GameGrid_CellFormatting,The following statement contains a magic number: if (GameGrid.Columns[e.ColumnIndex].Name == "Type")              {                  e.CellStyle.BackColor = bgCol;                  e.CellStyle.SelectionBackColor = bgCol;                  e.CellStyle.ForeColor = fgCol;                    Bitmap bmp = new Bitmap(cellBounds.Width' cellBounds.Height);                  Graphics g = Graphics.FromImage(bmp);                    string bitmapName;                  switch (tRvDir.FileType)                  {                      case FileType.Zip:                          if (tRvDir.RepStatus == RepStatus.DirCorrect && tRvDir.ZipStatus == ZipStatus.TrrntZip)                              bitmapName = "ZipTZ";                          else                              bitmapName = "Zip" + tRvDir.RepStatus;                          break;                      default:                          // hack because DirDirInToSort image doesnt exist.                          if (tRvDir.RepStatus ==  RepStatus.DirInToSort)                              bitmapName = "Dir" + RepStatus.DirUnknown;                          else                              bitmapName = "Dir" + tRvDir.RepStatus;                            break;                  }                    Bitmap bm = rvImages.GetBitmap(bitmapName);                  if (bm != null)                  {                      g.DrawImage(bm' (cellBounds.Width - cellBounds.Height) / 2' 0' 18' 18);                      bm.Dispose();                  }                  else                      Debug.WriteLine("Missing Graphic for " + bitmapName);                    e.Value = bmp;                }               else if (GameGrid.Columns[e.ColumnIndex].Name == "CGame")              {                  e.CellStyle.BackColor = bgCol;                  e.CellStyle.ForeColor = fgCol;                    if (String.IsNullOrEmpty(tRvDir.FileName))                      e.Value = tRvDir.Name;                  else                      e.Value = tRvDir.Name + " (Found: " + tRvDir.FileName + ")";              }              else if (GameGrid.Columns[e.ColumnIndex].Name == "CDescription")              {                  e.CellStyle.BackColor = bgCol;                  e.CellStyle.ForeColor = fgCol;                    if (tRvDir.Game != null)                      e.Value = tRvDir.Game.GetData(RvGame.GameData.Description);              }              else if (GameGrid.Columns[e.ColumnIndex].Name == "CCorrect")              {                  e.CellStyle.SelectionBackColor = Color.White;                    Bitmap bmp = new Bitmap(cellBounds.Width' cellBounds.Height);                  Graphics g = Graphics.FromImage(bmp);                  g.Clear(Color.White);                  g.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SingleBitPerPixelGridFit;                  Font drawFont = new Font("Arial"' 9);                  SolidBrush drawBrushBlack = new SolidBrush(Color.Black);                    int gOff;                  int columnIndex = 0;                  for (int l = 0; l < RepairStatus.DisplayOrder.Length; l++)                  {                      if (l >= 13) columnIndex = l;                        if (tRvDir.DirStatus.Get(RepairStatus.DisplayOrder[l]) <= 0) continue;                        gOff = _gameGridColumnXPositions[columnIndex];                      Bitmap bm = rvImages.GetBitmap(@"G_" + RepairStatus.DisplayOrder[l]);                      if (bm != null)                      {                          g.DrawImage(bm' gOff' 0' 21' 18);                          bm.Dispose();                      }                      else                          Debug.WriteLine("Missing Graphics for " + "G_" + RepairStatus.DisplayOrder[l]);                        columnIndex++;                  }                    columnIndex = 0;                  for (int l = 0; l < RepairStatus.DisplayOrder.Length; l++)                  {                      if (l >= 13)                          columnIndex = l;                        if (tRvDir.DirStatus.Get(RepairStatus.DisplayOrder[l]) > 0)                      {                          gOff = _gameGridColumnXPositions[columnIndex];                          g.DrawString(tRvDir.DirStatus.Get(RepairStatus.DisplayOrder[l]).ToString(CultureInfo.InvariantCulture)' drawFont' drawBrushBlack' new PointF(gOff + 20' 3));                          columnIndex++;                      }                  }                  drawBrushBlack.Dispose();                  drawFont.Dispose();                  e.Value = bmp;              }              else                  Console.WriteLine("WARN: GameGrid_CellFormatting() unknown column: {0}"' GameGrid.Columns[e.ColumnIndex].Name);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,GameGrid_CellFormatting,The following statement contains a magic number: if (GameGrid.Columns[e.ColumnIndex].Name == "Type")              {                  e.CellStyle.BackColor = bgCol;                  e.CellStyle.SelectionBackColor = bgCol;                  e.CellStyle.ForeColor = fgCol;                    Bitmap bmp = new Bitmap(cellBounds.Width' cellBounds.Height);                  Graphics g = Graphics.FromImage(bmp);                    string bitmapName;                  switch (tRvDir.FileType)                  {                      case FileType.Zip:                          if (tRvDir.RepStatus == RepStatus.DirCorrect && tRvDir.ZipStatus == ZipStatus.TrrntZip)                              bitmapName = "ZipTZ";                          else                              bitmapName = "Zip" + tRvDir.RepStatus;                          break;                      default:                          // hack because DirDirInToSort image doesnt exist.                          if (tRvDir.RepStatus ==  RepStatus.DirInToSort)                              bitmapName = "Dir" + RepStatus.DirUnknown;                          else                              bitmapName = "Dir" + tRvDir.RepStatus;                            break;                  }                    Bitmap bm = rvImages.GetBitmap(bitmapName);                  if (bm != null)                  {                      g.DrawImage(bm' (cellBounds.Width - cellBounds.Height) / 2' 0' 18' 18);                      bm.Dispose();                  }                  else                      Debug.WriteLine("Missing Graphic for " + bitmapName);                    e.Value = bmp;                }               else if (GameGrid.Columns[e.ColumnIndex].Name == "CGame")              {                  e.CellStyle.BackColor = bgCol;                  e.CellStyle.ForeColor = fgCol;                    if (String.IsNullOrEmpty(tRvDir.FileName))                      e.Value = tRvDir.Name;                  else                      e.Value = tRvDir.Name + " (Found: " + tRvDir.FileName + ")";              }              else if (GameGrid.Columns[e.ColumnIndex].Name == "CDescription")              {                  e.CellStyle.BackColor = bgCol;                  e.CellStyle.ForeColor = fgCol;                    if (tRvDir.Game != null)                      e.Value = tRvDir.Game.GetData(RvGame.GameData.Description);              }              else if (GameGrid.Columns[e.ColumnIndex].Name == "CCorrect")              {                  e.CellStyle.SelectionBackColor = Color.White;                    Bitmap bmp = new Bitmap(cellBounds.Width' cellBounds.Height);                  Graphics g = Graphics.FromImage(bmp);                  g.Clear(Color.White);                  g.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SingleBitPerPixelGridFit;                  Font drawFont = new Font("Arial"' 9);                  SolidBrush drawBrushBlack = new SolidBrush(Color.Black);                    int gOff;                  int columnIndex = 0;                  for (int l = 0; l < RepairStatus.DisplayOrder.Length; l++)                  {                      if (l >= 13) columnIndex = l;                        if (tRvDir.DirStatus.Get(RepairStatus.DisplayOrder[l]) <= 0) continue;                        gOff = _gameGridColumnXPositions[columnIndex];                      Bitmap bm = rvImages.GetBitmap(@"G_" + RepairStatus.DisplayOrder[l]);                      if (bm != null)                      {                          g.DrawImage(bm' gOff' 0' 21' 18);                          bm.Dispose();                      }                      else                          Debug.WriteLine("Missing Graphics for " + "G_" + RepairStatus.DisplayOrder[l]);                        columnIndex++;                  }                    columnIndex = 0;                  for (int l = 0; l < RepairStatus.DisplayOrder.Length; l++)                  {                      if (l >= 13)                          columnIndex = l;                        if (tRvDir.DirStatus.Get(RepairStatus.DisplayOrder[l]) > 0)                      {                          gOff = _gameGridColumnXPositions[columnIndex];                          g.DrawString(tRvDir.DirStatus.Get(RepairStatus.DisplayOrder[l]).ToString(CultureInfo.InvariantCulture)' drawFont' drawBrushBlack' new PointF(gOff + 20' 3));                          columnIndex++;                      }                  }                  drawBrushBlack.Dispose();                  drawFont.Dispose();                  e.Value = bmp;              }              else                  Console.WriteLine("WARN: GameGrid_CellFormatting() unknown column: {0}"' GameGrid.Columns[e.ColumnIndex].Name);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,GameGrid_CellFormatting,The following statement contains a magic number: if (GameGrid.Columns[e.ColumnIndex].Name == "Type")              {                  e.CellStyle.BackColor = bgCol;                  e.CellStyle.SelectionBackColor = bgCol;                  e.CellStyle.ForeColor = fgCol;                    Bitmap bmp = new Bitmap(cellBounds.Width' cellBounds.Height);                  Graphics g = Graphics.FromImage(bmp);                    string bitmapName;                  switch (tRvDir.FileType)                  {                      case FileType.Zip:                          if (tRvDir.RepStatus == RepStatus.DirCorrect && tRvDir.ZipStatus == ZipStatus.TrrntZip)                              bitmapName = "ZipTZ";                          else                              bitmapName = "Zip" + tRvDir.RepStatus;                          break;                      default:                          // hack because DirDirInToSort image doesnt exist.                          if (tRvDir.RepStatus ==  RepStatus.DirInToSort)                              bitmapName = "Dir" + RepStatus.DirUnknown;                          else                              bitmapName = "Dir" + tRvDir.RepStatus;                            break;                  }                    Bitmap bm = rvImages.GetBitmap(bitmapName);                  if (bm != null)                  {                      g.DrawImage(bm' (cellBounds.Width - cellBounds.Height) / 2' 0' 18' 18);                      bm.Dispose();                  }                  else                      Debug.WriteLine("Missing Graphic for " + bitmapName);                    e.Value = bmp;                }               else if (GameGrid.Columns[e.ColumnIndex].Name == "CGame")              {                  e.CellStyle.BackColor = bgCol;                  e.CellStyle.ForeColor = fgCol;                    if (String.IsNullOrEmpty(tRvDir.FileName))                      e.Value = tRvDir.Name;                  else                      e.Value = tRvDir.Name + " (Found: " + tRvDir.FileName + ")";              }              else if (GameGrid.Columns[e.ColumnIndex].Name == "CDescription")              {                  e.CellStyle.BackColor = bgCol;                  e.CellStyle.ForeColor = fgCol;                    if (tRvDir.Game != null)                      e.Value = tRvDir.Game.GetData(RvGame.GameData.Description);              }              else if (GameGrid.Columns[e.ColumnIndex].Name == "CCorrect")              {                  e.CellStyle.SelectionBackColor = Color.White;                    Bitmap bmp = new Bitmap(cellBounds.Width' cellBounds.Height);                  Graphics g = Graphics.FromImage(bmp);                  g.Clear(Color.White);                  g.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SingleBitPerPixelGridFit;                  Font drawFont = new Font("Arial"' 9);                  SolidBrush drawBrushBlack = new SolidBrush(Color.Black);                    int gOff;                  int columnIndex = 0;                  for (int l = 0; l < RepairStatus.DisplayOrder.Length; l++)                  {                      if (l >= 13) columnIndex = l;                        if (tRvDir.DirStatus.Get(RepairStatus.DisplayOrder[l]) <= 0) continue;                        gOff = _gameGridColumnXPositions[columnIndex];                      Bitmap bm = rvImages.GetBitmap(@"G_" + RepairStatus.DisplayOrder[l]);                      if (bm != null)                      {                          g.DrawImage(bm' gOff' 0' 21' 18);                          bm.Dispose();                      }                      else                          Debug.WriteLine("Missing Graphics for " + "G_" + RepairStatus.DisplayOrder[l]);                        columnIndex++;                  }                    columnIndex = 0;                  for (int l = 0; l < RepairStatus.DisplayOrder.Length; l++)                  {                      if (l >= 13)                          columnIndex = l;                        if (tRvDir.DirStatus.Get(RepairStatus.DisplayOrder[l]) > 0)                      {                          gOff = _gameGridColumnXPositions[columnIndex];                          g.DrawString(tRvDir.DirStatus.Get(RepairStatus.DisplayOrder[l]).ToString(CultureInfo.InvariantCulture)' drawFont' drawBrushBlack' new PointF(gOff + 20' 3));                          columnIndex++;                      }                  }                  drawBrushBlack.Dispose();                  drawFont.Dispose();                  e.Value = bmp;              }              else                  Console.WriteLine("WARN: GameGrid_CellFormatting() unknown column: {0}"' GameGrid.Columns[e.ColumnIndex].Name);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,GameGrid_CellFormatting,The following statement contains a magic number: if (GameGrid.Columns[e.ColumnIndex].Name == "Type")              {                  e.CellStyle.BackColor = bgCol;                  e.CellStyle.SelectionBackColor = bgCol;                  e.CellStyle.ForeColor = fgCol;                    Bitmap bmp = new Bitmap(cellBounds.Width' cellBounds.Height);                  Graphics g = Graphics.FromImage(bmp);                    string bitmapName;                  switch (tRvDir.FileType)                  {                      case FileType.Zip:                          if (tRvDir.RepStatus == RepStatus.DirCorrect && tRvDir.ZipStatus == ZipStatus.TrrntZip)                              bitmapName = "ZipTZ";                          else                              bitmapName = "Zip" + tRvDir.RepStatus;                          break;                      default:                          // hack because DirDirInToSort image doesnt exist.                          if (tRvDir.RepStatus ==  RepStatus.DirInToSort)                              bitmapName = "Dir" + RepStatus.DirUnknown;                          else                              bitmapName = "Dir" + tRvDir.RepStatus;                            break;                  }                    Bitmap bm = rvImages.GetBitmap(bitmapName);                  if (bm != null)                  {                      g.DrawImage(bm' (cellBounds.Width - cellBounds.Height) / 2' 0' 18' 18);                      bm.Dispose();                  }                  else                      Debug.WriteLine("Missing Graphic for " + bitmapName);                    e.Value = bmp;                }               else if (GameGrid.Columns[e.ColumnIndex].Name == "CGame")              {                  e.CellStyle.BackColor = bgCol;                  e.CellStyle.ForeColor = fgCol;                    if (String.IsNullOrEmpty(tRvDir.FileName))                      e.Value = tRvDir.Name;                  else                      e.Value = tRvDir.Name + " (Found: " + tRvDir.FileName + ")";              }              else if (GameGrid.Columns[e.ColumnIndex].Name == "CDescription")              {                  e.CellStyle.BackColor = bgCol;                  e.CellStyle.ForeColor = fgCol;                    if (tRvDir.Game != null)                      e.Value = tRvDir.Game.GetData(RvGame.GameData.Description);              }              else if (GameGrid.Columns[e.ColumnIndex].Name == "CCorrect")              {                  e.CellStyle.SelectionBackColor = Color.White;                    Bitmap bmp = new Bitmap(cellBounds.Width' cellBounds.Height);                  Graphics g = Graphics.FromImage(bmp);                  g.Clear(Color.White);                  g.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SingleBitPerPixelGridFit;                  Font drawFont = new Font("Arial"' 9);                  SolidBrush drawBrushBlack = new SolidBrush(Color.Black);                    int gOff;                  int columnIndex = 0;                  for (int l = 0; l < RepairStatus.DisplayOrder.Length; l++)                  {                      if (l >= 13) columnIndex = l;                        if (tRvDir.DirStatus.Get(RepairStatus.DisplayOrder[l]) <= 0) continue;                        gOff = _gameGridColumnXPositions[columnIndex];                      Bitmap bm = rvImages.GetBitmap(@"G_" + RepairStatus.DisplayOrder[l]);                      if (bm != null)                      {                          g.DrawImage(bm' gOff' 0' 21' 18);                          bm.Dispose();                      }                      else                          Debug.WriteLine("Missing Graphics for " + "G_" + RepairStatus.DisplayOrder[l]);                        columnIndex++;                  }                    columnIndex = 0;                  for (int l = 0; l < RepairStatus.DisplayOrder.Length; l++)                  {                      if (l >= 13)                          columnIndex = l;                        if (tRvDir.DirStatus.Get(RepairStatus.DisplayOrder[l]) > 0)                      {                          gOff = _gameGridColumnXPositions[columnIndex];                          g.DrawString(tRvDir.DirStatus.Get(RepairStatus.DisplayOrder[l]).ToString(CultureInfo.InvariantCulture)' drawFont' drawBrushBlack' new PointF(gOff + 20' 3));                          columnIndex++;                      }                  }                  drawBrushBlack.Dispose();                  drawFont.Dispose();                  e.Value = bmp;              }              else                  Console.WriteLine("WARN: GameGrid_CellFormatting() unknown column: {0}"' GameGrid.Columns[e.ColumnIndex].Name);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,GameGrid_CellFormatting,The following statement contains a magic number: if (GameGrid.Columns[e.ColumnIndex].Name == "Type")              {                  e.CellStyle.BackColor = bgCol;                  e.CellStyle.SelectionBackColor = bgCol;                  e.CellStyle.ForeColor = fgCol;                    Bitmap bmp = new Bitmap(cellBounds.Width' cellBounds.Height);                  Graphics g = Graphics.FromImage(bmp);                    string bitmapName;                  switch (tRvDir.FileType)                  {                      case FileType.Zip:                          if (tRvDir.RepStatus == RepStatus.DirCorrect && tRvDir.ZipStatus == ZipStatus.TrrntZip)                              bitmapName = "ZipTZ";                          else                              bitmapName = "Zip" + tRvDir.RepStatus;                          break;                      default:                          // hack because DirDirInToSort image doesnt exist.                          if (tRvDir.RepStatus ==  RepStatus.DirInToSort)                              bitmapName = "Dir" + RepStatus.DirUnknown;                          else                              bitmapName = "Dir" + tRvDir.RepStatus;                            break;                  }                    Bitmap bm = rvImages.GetBitmap(bitmapName);                  if (bm != null)                  {                      g.DrawImage(bm' (cellBounds.Width - cellBounds.Height) / 2' 0' 18' 18);                      bm.Dispose();                  }                  else                      Debug.WriteLine("Missing Graphic for " + bitmapName);                    e.Value = bmp;                }               else if (GameGrid.Columns[e.ColumnIndex].Name == "CGame")              {                  e.CellStyle.BackColor = bgCol;                  e.CellStyle.ForeColor = fgCol;                    if (String.IsNullOrEmpty(tRvDir.FileName))                      e.Value = tRvDir.Name;                  else                      e.Value = tRvDir.Name + " (Found: " + tRvDir.FileName + ")";              }              else if (GameGrid.Columns[e.ColumnIndex].Name == "CDescription")              {                  e.CellStyle.BackColor = bgCol;                  e.CellStyle.ForeColor = fgCol;                    if (tRvDir.Game != null)                      e.Value = tRvDir.Game.GetData(RvGame.GameData.Description);              }              else if (GameGrid.Columns[e.ColumnIndex].Name == "CCorrect")              {                  e.CellStyle.SelectionBackColor = Color.White;                    Bitmap bmp = new Bitmap(cellBounds.Width' cellBounds.Height);                  Graphics g = Graphics.FromImage(bmp);                  g.Clear(Color.White);                  g.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SingleBitPerPixelGridFit;                  Font drawFont = new Font("Arial"' 9);                  SolidBrush drawBrushBlack = new SolidBrush(Color.Black);                    int gOff;                  int columnIndex = 0;                  for (int l = 0; l < RepairStatus.DisplayOrder.Length; l++)                  {                      if (l >= 13) columnIndex = l;                        if (tRvDir.DirStatus.Get(RepairStatus.DisplayOrder[l]) <= 0) continue;                        gOff = _gameGridColumnXPositions[columnIndex];                      Bitmap bm = rvImages.GetBitmap(@"G_" + RepairStatus.DisplayOrder[l]);                      if (bm != null)                      {                          g.DrawImage(bm' gOff' 0' 21' 18);                          bm.Dispose();                      }                      else                          Debug.WriteLine("Missing Graphics for " + "G_" + RepairStatus.DisplayOrder[l]);                        columnIndex++;                  }                    columnIndex = 0;                  for (int l = 0; l < RepairStatus.DisplayOrder.Length; l++)                  {                      if (l >= 13)                          columnIndex = l;                        if (tRvDir.DirStatus.Get(RepairStatus.DisplayOrder[l]) > 0)                      {                          gOff = _gameGridColumnXPositions[columnIndex];                          g.DrawString(tRvDir.DirStatus.Get(RepairStatus.DisplayOrder[l]).ToString(CultureInfo.InvariantCulture)' drawFont' drawBrushBlack' new PointF(gOff + 20' 3));                          columnIndex++;                      }                  }                  drawBrushBlack.Dispose();                  drawFont.Dispose();                  e.Value = bmp;              }              else                  Console.WriteLine("WARN: GameGrid_CellFormatting() unknown column: {0}"' GameGrid.Columns[e.ColumnIndex].Name);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,GameGridColumnHeaderMouseClick,The following statement contains a magic number: if (e.ColumnIndex != 1 && e.ColumnIndex != 2)                  return;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,splitContainer4_Panel1_Resize,The following statement contains a magic number: int chkLeft = splitContainer4.Panel1.Width - 150;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,splitContainer4_Panel1_Resize,The following statement contains a magic number: if (chkLeft < 430) chkLeft = 430;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,splitContainer4_Panel1_Resize,The following statement contains a magic number: if (chkLeft < 430) chkLeft = 430;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,splitContainer4_Panel1_Resize,The following statement contains a magic number: gbSetInfo.Width = chkLeft - gbSetInfo.Left - 10;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,gbSetInfo_Resize,The following statement contains a magic number: const int leftPos = 84;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,gbSetInfo_Resize,The following statement contains a magic number: int rightPos = gbSetInfo.Width - 15;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,gbSetInfo_Resize,The following statement contains a magic number: if (rightPos > 750) rightPos = 750;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,gbSetInfo_Resize,The following statement contains a magic number: if (rightPos > 750) rightPos = 750;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,gbSetInfo_Resize,The following statement contains a magic number: int widthB1 = (int)((double)width * 120 / 340);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,gbSetInfo_Resize,The following statement contains a magic number: int widthB1 = (int)((double)width * 120 / 340);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,gbSetInfo_Resize,The following statement contains a magic number: lblSIYear.Left = leftB2 - 78;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,gbSetInfo_Resize,The following statement contains a magic number: lblSITotalRoms.Left = leftB2 - 78;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,gbSetInfo_Resize,The following statement contains a magic number: int width3 = (int)((double)width * 0.24);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,gbSetInfo_Resize,The following statement contains a magic number: int p2 = (int)((double)width * 0.38);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,gbSetInfo_Resize,The following statement contains a magic number: int width4 = (int) ((double) width*0.24);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,gbSetInfo_Resize,The following statement contains a magic number: lblSIVersion.Left = leftPos + p2 - 78;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,gbSetInfo_Resize,The following statement contains a magic number: lblSIType.Left = leftPos + width - width3 - 78;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,gbSetInfo_Resize,The following statement contains a magic number: lblSILanguage.Left = leftPos + p2 - 78;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,gbSetInfo_Resize,The following statement contains a magic number: lblSIPlayers.Left = leftPos + width - width3 - 78;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,gbSetInfo_Resize,The following statement contains a magic number: lblSIGenre.Left = leftPos + p2 - 78;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,gbSetInfo_Resize,The following statement contains a magic number: lblSIPeripheral.Left = leftPos + width - width3 - 78;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,gbSetInfo_Resize,The following statement contains a magic number: lblSIMediaCatalogNumber.Left = leftPos + width - width4 - 78;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,Contrasty,The following statement contains a magic number: return (a.R << 1) + a.B + a.G + (a.G << 2) < 1024 ? Color.White : Color.Black;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,Contrasty,The following statement contains a magic number: return (a.R << 1) + a.B + a.G + (a.G << 2) < 1024 ? Color.White : Color.Black;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,RomGrid_CellFormatting,The following statement contains a magic number: if (RomGrid.Columns[e.ColumnIndex].Name == "CGot")              {                  Bitmap bmp = new Bitmap(cellBounds.Width' cellBounds.Height);                  Graphics g = Graphics.FromImage(bmp);                  string bitmapName = "R_" + tRvFile.DatStatus + "_" + tRvFile.RepStatus;                  g.DrawImage(rvImages.GetBitmap(bitmapName)' 0' 0' 54' 18);                  e.Value = bmp;              }
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,RomGrid_CellFormatting,The following statement contains a magic number: if (RomGrid.Columns[e.ColumnIndex].Name == "CGot")              {                  Bitmap bmp = new Bitmap(cellBounds.Width' cellBounds.Height);                  Graphics g = Graphics.FromImage(bmp);                  string bitmapName = "R_" + tRvFile.DatStatus + "_" + tRvFile.RepStatus;                  g.DrawImage(rvImages.GetBitmap(bitmapName)' 0' 0' 54' 18);                  e.Value = bmp;              }
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,RomGridMouseUp,The following statement contains a magic number: string size = RomGrid.Rows[currentMouseOverRow].Cells[2].Value.ToString();
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,RomGridMouseUp,The following statement contains a magic number: string crc = RomGrid.Rows[currentMouseOverRow].Cells[4].Value.ToString();
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,RomGridMouseUp,The following statement contains a magic number: if (crc.Length > 8) crc = crc.Substring(0' 8);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,RomGridMouseUp,The following statement contains a magic number: if (crc.Length > 8) crc = crc.Substring(0' 8);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,RomGridMouseUp,The following statement contains a magic number: string sha1 = RomGrid.Rows[currentMouseOverRow].Cells[5].Value.ToString();
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,RomGridMouseUp,The following statement contains a magic number: if (sha1.Length > 40) sha1 = sha1.Substring(0' 40);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,RomGridMouseUp,The following statement contains a magic number: if (sha1.Length > 40) sha1 = sha1.Substring(0' 40);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,RomGridMouseUp,The following statement contains a magic number: string md5 = RomGrid.Rows[currentMouseOverRow].Cells[6].Value.ToString();
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,RomGridMouseUp,The following statement contains a magic number: if (md5.Length > 32) md5 = md5.Substring(0' 32);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,RomGridMouseUp,The following statement contains a magic number: if (md5.Length > 32) md5 = md5.Substring(0' 32);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,GameGrid_MouseUp,The following statement contains a magic number: object r2 = GameGrid.Rows[currentMouseOverRow].Cells[2].FormattedValue;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,RomGrid_SortCompare,The following statement contains a magic number: try // to sort by 'Size'' then by 'Name'.              {                  if (e.Column.Index != 2) return;                    // compare only the value found before the first space character in each CellValue (excludes " (DHV)"' etc..)                  e.SortResult = int.Parse(e.CellValue1.ToString().Split(' ')[0]).CompareTo(int.Parse(e.CellValue2.ToString().Split(' ')[0]));                  if (e.SortResult == 0) // when sizes are the same' sort by the name in column 1                  {                      e.SortResult = string.CompareOrdinal(                          RomGrid.Rows[e.RowIndex1].Cells[1].Value.ToString()'                          RomGrid.Rows[e.RowIndex2].Cells[1].Value.ToString());                  }                  e.Handled = true; // bypass the default string sort              }              catch              {              }
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.splitContainer1.Location = new System.Drawing.Point(0' 24);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.splitContainer1.Size = new System.Drawing.Size(1264' 738);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.splitContainer1.Size = new System.Drawing.Size(1264' 738);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.splitContainer1.SplitterDistance = 80;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.splitContainer1.TabIndex = 5;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.btnReport.Location = new System.Drawing.Point(0' 320);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.btnReport.Size = new System.Drawing.Size(80' 80);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.btnReport.Size = new System.Drawing.Size(80' 80);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.btnReport.TabIndex = 13;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.btnFixFiles.Location = new System.Drawing.Point(0' 240);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.btnFixFiles.Size = new System.Drawing.Size(80' 80);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.btnFixFiles.Size = new System.Drawing.Size(80' 80);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.btnFixFiles.TabIndex = 10;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.btnFindFixes.Location = new System.Drawing.Point(0' 160);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.btnFindFixes.Size = new System.Drawing.Size(80' 80);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.btnFindFixes.Size = new System.Drawing.Size(80' 80);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.btnFindFixes.TabIndex = 9;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.btnScanRoms.Location = new System.Drawing.Point(0' 80);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.btnScanRoms.Size = new System.Drawing.Size(80' 80);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.btnScanRoms.Size = new System.Drawing.Size(80' 80);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.btnScanRoms.TabIndex = 8;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.btnUpdateDats.Size = new System.Drawing.Size(80' 80);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.btnUpdateDats.Size = new System.Drawing.Size(80' 80);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.splitContainer2.Panel1MinSize = 450;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.splitContainer2.Size = new System.Drawing.Size(1180' 738);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.splitContainer2.Size = new System.Drawing.Size(1180' 738);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.splitContainer2.SplitterDistance = 479;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.splitContainer3.Size = new System.Drawing.Size(479' 738);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.splitContainer3.Size = new System.Drawing.Size(479' 738);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.splitContainer3.SplitterDistance = 148;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.gbDatInfo.Location = new System.Drawing.Point(5' 0);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.gbDatInfo.Size = new System.Drawing.Size(468' 147);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.gbDatInfo.Size = new System.Drawing.Size(468' 147);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.gbDatInfo.TabIndex = 3;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDIRomsUnknown.Location = new System.Drawing.Point(214' 121);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDIRomsUnknown.Location = new System.Drawing.Point(214' 121);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDIRomsUnknown.Size = new System.Drawing.Size(92' 13);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDIRomsUnknown.Size = new System.Drawing.Size(92' 13);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDIRomsUnknown.TabIndex = 26;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.label9.Location = new System.Drawing.Point(10' 105);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.label9.Location = new System.Drawing.Point(10' 105);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.label9.Size = new System.Drawing.Size(75' 13);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.label9.Size = new System.Drawing.Size(75' 13);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.label9.TabIndex = 23;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITRomsUnknown.Location = new System.Drawing.Point(311' 120);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITRomsUnknown.Location = new System.Drawing.Point(311' 120);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITRomsUnknown.Size = new System.Drawing.Size(120' 17);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITRomsUnknown.Size = new System.Drawing.Size(120' 17);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITRomsUnknown.TabIndex = 21;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITRomsFixable.Location = new System.Drawing.Point(311' 104);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITRomsFixable.Location = new System.Drawing.Point(311' 104);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITRomsFixable.Size = new System.Drawing.Size(120' 17);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITRomsFixable.Size = new System.Drawing.Size(120' 17);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITRomsFixable.TabIndex = 20;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITRomsMissing.Location = new System.Drawing.Point(89' 120);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITRomsMissing.Location = new System.Drawing.Point(89' 120);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITRomsMissing.Size = new System.Drawing.Size(120' 17);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITRomsMissing.Size = new System.Drawing.Size(120' 17);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITRomsMissing.TabIndex = 19;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITRomsGot.Location = new System.Drawing.Point(89' 104);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITRomsGot.Location = new System.Drawing.Point(89' 104);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITRomsGot.Size = new System.Drawing.Size(120' 17);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITRomsGot.Size = new System.Drawing.Size(120' 17);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITRomsGot.TabIndex = 18;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITRomPath.Location = new System.Drawing.Point(10' 79);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITRomPath.Location = new System.Drawing.Point(10' 79);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITRomPath.Size = new System.Drawing.Size(75' 13);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITRomPath.Size = new System.Drawing.Size(75' 13);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITRomPath.TabIndex = 15;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITPath.Location = new System.Drawing.Point(89' 78);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITPath.Location = new System.Drawing.Point(89' 78);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITPath.Size = new System.Drawing.Size(342' 17);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITPath.Size = new System.Drawing.Size(342' 17);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITPath.TabIndex = 13;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDIDate.Location = new System.Drawing.Point(214' 63);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDIDate.Location = new System.Drawing.Point(214' 63);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDIDate.Size = new System.Drawing.Size(92' 13);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDIDate.Size = new System.Drawing.Size(92' 13);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDIDate.TabIndex = 12;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDIAuthor.Location = new System.Drawing.Point(10' 63);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDIAuthor.Location = new System.Drawing.Point(10' 63);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDIAuthor.Size = new System.Drawing.Size(75' 13);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDIAuthor.Size = new System.Drawing.Size(75' 13);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDIAuthor.TabIndex = 11;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITDate.Location = new System.Drawing.Point(311' 62);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITDate.Location = new System.Drawing.Point(311' 62);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITDate.Size = new System.Drawing.Size(120' 17);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITDate.Size = new System.Drawing.Size(120' 17);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITDate.TabIndex = 10;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITAuthor.Location = new System.Drawing.Point(89' 62);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITAuthor.Location = new System.Drawing.Point(89' 62);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITAuthor.Size = new System.Drawing.Size(120' 17);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITAuthor.Size = new System.Drawing.Size(120' 17);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITAuthor.TabIndex = 9;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDIVersion.Location = new System.Drawing.Point(214' 47);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDIVersion.Location = new System.Drawing.Point(214' 47);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDIVersion.Size = new System.Drawing.Size(92' 13);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDIVersion.Size = new System.Drawing.Size(92' 13);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDIVersion.TabIndex = 8;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDICategory.Location = new System.Drawing.Point(10' 47);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDICategory.Location = new System.Drawing.Point(10' 47);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDICategory.Size = new System.Drawing.Size(75' 13);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDICategory.Size = new System.Drawing.Size(75' 13);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDICategory.TabIndex = 7;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITVersion.Location = new System.Drawing.Point(311' 46);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITVersion.Location = new System.Drawing.Point(311' 46);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITVersion.Size = new System.Drawing.Size(120' 17);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITVersion.Size = new System.Drawing.Size(120' 17);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITVersion.TabIndex = 6;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITCategory.Location = new System.Drawing.Point(89' 46);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITCategory.Location = new System.Drawing.Point(89' 46);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITCategory.Size = new System.Drawing.Size(120' 17);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITCategory.Size = new System.Drawing.Size(120' 17);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITCategory.TabIndex = 5;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDIDescription.Location = new System.Drawing.Point(10' 31);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDIDescription.Location = new System.Drawing.Point(10' 31);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDIDescription.Size = new System.Drawing.Size(75' 13);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDIDescription.Size = new System.Drawing.Size(75' 13);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDIDescription.TabIndex = 4;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDIName.Location = new System.Drawing.Point(10' 15);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDIName.Location = new System.Drawing.Point(10' 15);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDIName.Size = new System.Drawing.Size(75' 13);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDIName.Size = new System.Drawing.Size(75' 13);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDIName.TabIndex = 3;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITDescription.Location = new System.Drawing.Point(89' 30);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITDescription.Location = new System.Drawing.Point(89' 30);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITDescription.Size = new System.Drawing.Size(342' 17);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITDescription.Size = new System.Drawing.Size(342' 17);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITDescription.TabIndex = 2;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITName.Location = new System.Drawing.Point(89' 14);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITName.Location = new System.Drawing.Point(89' 14);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITName.Size = new System.Drawing.Size(342' 17);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDITName.Size = new System.Drawing.Size(342' 17);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDIRomsFixable.Location = new System.Drawing.Point(214' 105);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDIRomsFixable.Location = new System.Drawing.Point(214' 105);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDIRomsFixable.Size = new System.Drawing.Size(92' 13);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDIRomsFixable.Size = new System.Drawing.Size(92' 13);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDIRomsFixable.TabIndex = 25;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.label8.Location = new System.Drawing.Point(2' 121);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.label8.Location = new System.Drawing.Point(2' 121);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.label8.Size = new System.Drawing.Size(83' 13);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.label8.Size = new System.Drawing.Size(83' 13);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.label8.TabIndex = 24;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.DirTree.Size = new System.Drawing.Size(479' 586);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.DirTree.Size = new System.Drawing.Size(479' 586);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.DirTree.TabIndex = 2;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.splitContainer4.Size = new System.Drawing.Size(697' 738);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.splitContainer4.Size = new System.Drawing.Size(697' 738);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.splitContainer4.SplitterDistance = 148;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.btnColorKey.Location = new System.Drawing.Point(547' 85);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.btnColorKey.Location = new System.Drawing.Point(547' 85);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.btnColorKey.Size = new System.Drawing.Size(89' 23);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.btnColorKey.Size = new System.Drawing.Size(89' 23);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.btnColorKey.TabIndex = 9;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.chkBoxShowMerged.Location = new System.Drawing.Point(547' 68);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.chkBoxShowMerged.Location = new System.Drawing.Point(547' 68);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.chkBoxShowMerged.Size = new System.Drawing.Size(125' 17);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.chkBoxShowMerged.Size = new System.Drawing.Size(125' 17);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.chkBoxShowMerged.TabIndex = 8;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.chkBoxShowFixed.Location = new System.Drawing.Point(547' 52);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.chkBoxShowFixed.Location = new System.Drawing.Point(547' 52);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.chkBoxShowFixed.Size = new System.Drawing.Size(102' 17);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.chkBoxShowFixed.Size = new System.Drawing.Size(102' 17);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.chkBoxShowFixed.TabIndex = 7;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.chkBoxShowMissing.Location = new System.Drawing.Point(547' 36);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.chkBoxShowMissing.Location = new System.Drawing.Point(547' 36);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.chkBoxShowMissing.Size = new System.Drawing.Size(124' 17);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.chkBoxShowMissing.Size = new System.Drawing.Size(124' 17);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.chkBoxShowMissing.TabIndex = 6;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.chkBoxShowCorrect.Location = new System.Drawing.Point(547' 20);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.chkBoxShowCorrect.Location = new System.Drawing.Point(547' 20);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.chkBoxShowCorrect.Size = new System.Drawing.Size(123' 17);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.chkBoxShowCorrect.Size = new System.Drawing.Size(123' 17);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.chkBoxShowCorrect.TabIndex = 5;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.gbSetInfo.Location = new System.Drawing.Point(5' 0);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.gbSetInfo.Size = new System.Drawing.Size(532' 147);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.gbSetInfo.Size = new System.Drawing.Size(532' 147);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.gbSetInfo.TabIndex = 4;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.splitContainer5.Size = new System.Drawing.Size(697' 586);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.splitContainer5.Size = new System.Drawing.Size(697' 586);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.splitContainer5.SplitterDistance = 267;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.GameGrid.GridColor = System.Drawing.Color.FromArgb(((int)(((byte)(224))))' ((int)(((byte)(224))))' ((int)(((byte)(224)))));
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.GameGrid.GridColor = System.Drawing.Color.FromArgb(((int)(((byte)(224))))' ((int)(((byte)(224))))' ((int)(((byte)(224)))));
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.GameGrid.GridColor = System.Drawing.Color.FromArgb(((int)(((byte)(224))))' ((int)(((byte)(224))))' ((int)(((byte)(224)))));
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.GameGrid.RowTemplate.Height = 17;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.GameGrid.Size = new System.Drawing.Size(697' 267);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.GameGrid.Size = new System.Drawing.Size(697' 267);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.GameGrid.TabIndex = 4;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.Type.Width = 40;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.CGame.Width = 220;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.CDescription.Width = 220;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.CCorrect.Width = 500;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.RomGrid.GridColor = System.Drawing.Color.FromArgb(((int)(((byte)(224))))' ((int)(((byte)(224))))' ((int)(((byte)(224)))));
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.RomGrid.GridColor = System.Drawing.Color.FromArgb(((int)(((byte)(224))))' ((int)(((byte)(224))))' ((int)(((byte)(224)))));
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.RomGrid.GridColor = System.Drawing.Color.FromArgb(((int)(((byte)(224))))' ((int)(((byte)(224))))' ((int)(((byte)(224)))));
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.RomGrid.RowTemplate.Height = 19;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.RomGrid.Size = new System.Drawing.Size(697' 315);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.RomGrid.Size = new System.Drawing.Size(697' 315);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.RomGrid.TabIndex = 21;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.CGot.Width = 65;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.CRom.Width = 150;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.CSize.Width = 60;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.CMerge.Width = 60;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.CSHA1.Width = 150;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.CMD5.Width = 150;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.menuStrip1.Size = new System.Drawing.Size(1264' 24);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.menuStrip1.Size = new System.Drawing.Size(1264' 24);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.menuStrip1.TabIndex = 6;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.tsmUpdateDATs.Size = new System.Drawing.Size(86' 20);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.tsmUpdateDATs.Size = new System.Drawing.Size(86' 20);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.tsmScanROMs.Size = new System.Drawing.Size(79' 20);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.tsmScanROMs.Size = new System.Drawing.Size(79' 20);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.tsmScanLevel1.Size = new System.Drawing.Size(300' 22);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.tsmScanLevel1.Size = new System.Drawing.Size(300' 22);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.tsmScanLevel2.Size = new System.Drawing.Size(300' 22);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.tsmScanLevel2.Size = new System.Drawing.Size(300' 22);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.tsmScanLevel3.Size = new System.Drawing.Size(300' 22);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.tsmScanLevel3.Size = new System.Drawing.Size(300' 22);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.tsmFindFixes.Size = new System.Drawing.Size(70' 20);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.tsmFindFixes.Size = new System.Drawing.Size(70' 20);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.FixROMsToolStripMenuItem.Size = new System.Drawing.Size(68' 20);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.FixROMsToolStripMenuItem.Size = new System.Drawing.Size(68' 20);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.settingsToolStripMenuItem.Size = new System.Drawing.Size(61' 20);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.settingsToolStripMenuItem.Size = new System.Drawing.Size(61' 20);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.reportsToolStripMenuItem.Size = new System.Drawing.Size(59' 20);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.reportsToolStripMenuItem.Size = new System.Drawing.Size(59' 20);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.fixDatReportToolStripMenuItem.Size = new System.Drawing.Size(147' 22);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.fixDatReportToolStripMenuItem.Size = new System.Drawing.Size(147' 22);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.fullReportToolStripMenuItem.Size = new System.Drawing.Size(147' 22);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.fullReportToolStripMenuItem.Size = new System.Drawing.Size(147' 22);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.fixReportToolStripMenuItem.Size = new System.Drawing.Size(147' 22);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.fixReportToolStripMenuItem.Size = new System.Drawing.Size(147' 22);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.helpToolStripMenuItem.Size = new System.Drawing.Size(44' 20);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.helpToolStripMenuItem.Size = new System.Drawing.Size(44' 20);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.aboutRomVaultToolStripMenuItem.Size = new System.Drawing.Size(161' 22);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.aboutRomVaultToolStripMenuItem.Size = new System.Drawing.Size(161' 22);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.dataGridViewImageColumn1.Width = 40;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.dataGridViewImageColumn2.Width = 300;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.dataGridViewImageColumn3.Width = 65;
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(1264' 762);
Magic Number,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(1264' 762);
Magic Number,ROMVault2,GameGridRowComparer,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,Compare,The following statement contains a magic number: switch (_columnIndex)                  {                      case 1: // CGame                          result = String.CompareOrdinal(aRvDir.Name' bRvDir.Name);                          break;                      case 2: // CDescription                          String aDes = "";                          String bDes = "";                          if (aRvDir.Game != null)                              aDes = aRvDir.Game.GetData(RvGame.GameData.Description);                          if (bRvDir.Game != null)                              bDes = bRvDir.Game.GetData(RvGame.GameData.Description);                            result = String.CompareOrdinal(aDes' bDes);                            // if desciptions match' fall through to sorting by name                          if (result == 0)                              result = String.CompareOrdinal(aRvDir.Name' bRvDir.Name);                            break;                      default:                          Console.WriteLine("WARN: GameGridRowComparer::Compare() Invalid columnIndex: {0}"' _columnIndex);                          break;                  }
Magic Number,ROMVault2,DBHelper,C:\repos\gjefferyes_RomVault\ROMVault2\DBHelper.cs,DBHelper,The following statement contains a magic number: ZeroByteMD5 = VarFix.CleanMD5SHA1("d41d8cd98f00b204e9800998ecf8427e"' 32);
Magic Number,ROMVault2,DBHelper,C:\repos\gjefferyes_RomVault\ROMVault2\DBHelper.cs,DBHelper,The following statement contains a magic number: ZeroByteSHA1 = VarFix.CleanMD5SHA1("da39a3ee5e6b4b0d3255bfef95601890afd80709"' 40);
Magic Number,ROMVault2,DBHelper,C:\repos\gjefferyes_RomVault\ROMVault2\DBHelper.cs,DBHelper,The following statement contains a magic number: ZeroByteCRC = VarFix.CleanMD5SHA1("00000000"' 8);
Magic Number,ROMVault2,DBHelper,C:\repos\gjefferyes_RomVault\ROMVault2\DBHelper.cs,TrrntZipStringCompare,The following statement contains a magic number: for (; ; )              {                  if (pos1 == bytes1.Length)                      return ((pos2 == bytes2.Length) ? 0 : -1);                  if (pos2 == bytes2.Length)                      return 1;                    int byte1 = bytes1[pos1++];                  int byte2 = bytes2[pos2++];                    if (byte1 >= 65 && byte1 <= 90) byte1 += 0x20;                  if (byte2 >= 65 && byte2 <= 90) byte2 += 0x20;                    if (byte1 < byte2)                      return -1;                  if (byte1 > byte2)                      return 1;              }
Magic Number,ROMVault2,DBHelper,C:\repos\gjefferyes_RomVault\ROMVault2\DBHelper.cs,TrrntZipStringCompare,The following statement contains a magic number: for (; ; )              {                  if (pos1 == bytes1.Length)                      return ((pos2 == bytes2.Length) ? 0 : -1);                  if (pos2 == bytes2.Length)                      return 1;                    int byte1 = bytes1[pos1++];                  int byte2 = bytes2[pos2++];                    if (byte1 >= 65 && byte1 <= 90) byte1 += 0x20;                  if (byte2 >= 65 && byte2 <= 90) byte2 += 0x20;                    if (byte1 < byte2)                      return -1;                  if (byte1 > byte2)                      return 1;              }
Magic Number,ROMVault2,DBHelper,C:\repos\gjefferyes_RomVault\ROMVault2\DBHelper.cs,TrrntZipStringCompare,The following statement contains a magic number: for (; ; )              {                  if (pos1 == bytes1.Length)                      return ((pos2 == bytes2.Length) ? 0 : -1);                  if (pos2 == bytes2.Length)                      return 1;                    int byte1 = bytes1[pos1++];                  int byte2 = bytes2[pos2++];                    if (byte1 >= 65 && byte1 <= 90) byte1 += 0x20;                  if (byte2 >= 65 && byte2 <= 90) byte2 += 0x20;                    if (byte1 < byte2)                      return -1;                  if (byte1 > byte2)                      return 1;              }
Magic Number,ROMVault2,DBHelper,C:\repos\gjefferyes_RomVault\ROMVault2\DBHelper.cs,TrrntZipStringCompare,The following statement contains a magic number: for (; ; )              {                  if (pos1 == bytes1.Length)                      return ((pos2 == bytes2.Length) ? 0 : -1);                  if (pos2 == bytes2.Length)                      return 1;                    int byte1 = bytes1[pos1++];                  int byte2 = bytes2[pos2++];                    if (byte1 >= 65 && byte1 <= 90) byte1 += 0x20;                  if (byte2 >= 65 && byte2 <= 90) byte2 += 0x20;                    if (byte1 < byte2)                      return -1;                  if (byte1 > byte2)                      return 1;              }
Magic Number,ROMVault2,DBHelper,C:\repos\gjefferyes_RomVault\ROMVault2\DBHelper.cs,GetDatPath,The following statement contains a magic number: if (rootPath.Substring(0' 6) == "ToSort")                  return "Error";
Magic Number,ROMVault2,DBHelper,C:\repos\gjefferyes_RomVault\ROMVault2\DBHelper.cs,GetDatPath,The following statement contains a magic number: if (rootPath.Substring(0' 8) == "RomVault")                  return Program.rvSettings.DatRoot + rootPath.Substring(8);
Magic Number,ROMVault2,DBHelper,C:\repos\gjefferyes_RomVault\ROMVault2\DBHelper.cs,GetDatPath,The following statement contains a magic number: if (rootPath.Substring(0' 8) == "RomVault")                  return Program.rvSettings.DatRoot + rootPath.Substring(8);
Magic Number,ROMVault2,DBHelper,C:\repos\gjefferyes_RomVault\ROMVault2\DBHelper.cs,RomSortCRCSize,The following statement contains a magic number: int intMiddle = (intTop + intBase) / 2;
Magic Number,ROMVault2,DBHelper,C:\repos\gjefferyes_RomVault\ROMVault2\DBHelper.cs,RomSearchCRCSize,The following statement contains a magic number: while (intBottom + 1 < intTop)              {                  int intMid = (intBottom + intTop + 1) / 2;                    int intRes = RomSortCRCSizeFunc(lstFiles[intMid]' tRom);                  if (intRes >= 0)                      intTop = intMid;                  else                      intBottom = intMid;                }
Magic Number,ROMVault2,DBHelper,C:\repos\gjefferyes_RomVault\ROMVault2\DBHelper.cs,RomSortSHA1CHD,The following statement contains a magic number: int intMiddle = (intTop + intBase) / 2;
Magic Number,ROMVault2,DBHelper,C:\repos\gjefferyes_RomVault\ROMVault2\DBHelper.cs,RomSearchSHA1CHD,The following statement contains a magic number: while (intBottom + 1 < intTop)              {                  int intMid = (intBottom + intTop + 1) / 2;                    int intRes = RomSortSHA1CHDFunc(lstFiles[intMid]' tRom);                  if (intRes >= 0)                      intTop = intMid;                  else                      intBottom = intMid;                }
Magic Number,ROMVault2.SupportedFiles.CHD,CHD,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\CHD\CHD.cs,CheckFile,The following statement contains a magic number: UInt32 length = ReadUInt32(buff' 8);
Magic Number,ROMVault2.SupportedFiles.CHD,CHD,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\CHD\CHD.cs,CheckFile,The following statement contains a magic number: version = ReadUInt32(buff' 12);
Magic Number,ROMVault2.SupportedFiles.CHD,CHD,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\CHD\CHD.cs,CheckFile,The following statement contains a magic number: if (version > 5)                  return;
Magic Number,ROMVault2.SupportedFiles.CHD,CHD,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\CHD\CHD.cs,CheckFile,The following statement contains a magic number: switch (version)              {                  case 1:                      if (length != 76) return;                        //    V1 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // 512-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] (V1 header length)                        return;                    case 2:                      if (length != 80) return;                        //    V2 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // seclen-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 seclen;        // number of bytes per sector                      //    [ 80] (V2 header length)                      return;                    case 3:                      if (length != 120) return;                        //    V3 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 80] UINT8  sha1[20];      // SHA1 checksum of raw data                      SHA1CHD = ReadBytes(buff' 80' 20);                      //    [100] UINT8  parentsha1[20];// SHA1 checksum of parent file                      //    [120] (V3 header length)                      return;                    case 4:                      if (length != 108) return;                        //    V4 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 48] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 48' 20);                      //    [ 68] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [ 88] UINT8  rawsha1[20];   // raw data SHA1                      //    [108] (V4 header length)                      return;                    case 5:                      if (length != 124) return;                        //    V5 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 compressors[4];// which custom compressors are used?                      UInt32 compression0 = ReadUInt32(buff' 16);                      UInt32 compression1 = ReadUInt32(buff' 20);                      UInt32 compression2 = ReadUInt32(buff' 24);                      UInt32 compression3 = ReadUInt32(buff' 28);                      if (compression0 == 0 && compression1 == 0 && compression2 == 0 && compression3 == 0) return;                      //    [ 32] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 40] UINT64 mapoffset;     // offset to the map                      //    [ 48] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 56] UINT32 hunkbytes;     // number of bytes per hunk (512k maximum)                      //    [ 60] UINT32 unitbytes;     // number of bytes per unit within each hunk                      //    [ 64] UINT8  rawsha1[20];   // raw data SHA1                      //    [ 84] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 84' 20);                      //    [104] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [124] (V5 header length)                      return;              }
Magic Number,ROMVault2.SupportedFiles.CHD,CHD,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\CHD\CHD.cs,CheckFile,The following statement contains a magic number: switch (version)              {                  case 1:                      if (length != 76) return;                        //    V1 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // 512-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] (V1 header length)                        return;                    case 2:                      if (length != 80) return;                        //    V2 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // seclen-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 seclen;        // number of bytes per sector                      //    [ 80] (V2 header length)                      return;                    case 3:                      if (length != 120) return;                        //    V3 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 80] UINT8  sha1[20];      // SHA1 checksum of raw data                      SHA1CHD = ReadBytes(buff' 80' 20);                      //    [100] UINT8  parentsha1[20];// SHA1 checksum of parent file                      //    [120] (V3 header length)                      return;                    case 4:                      if (length != 108) return;                        //    V4 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 48] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 48' 20);                      //    [ 68] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [ 88] UINT8  rawsha1[20];   // raw data SHA1                      //    [108] (V4 header length)                      return;                    case 5:                      if (length != 124) return;                        //    V5 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 compressors[4];// which custom compressors are used?                      UInt32 compression0 = ReadUInt32(buff' 16);                      UInt32 compression1 = ReadUInt32(buff' 20);                      UInt32 compression2 = ReadUInt32(buff' 24);                      UInt32 compression3 = ReadUInt32(buff' 28);                      if (compression0 == 0 && compression1 == 0 && compression2 == 0 && compression3 == 0) return;                      //    [ 32] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 40] UINT64 mapoffset;     // offset to the map                      //    [ 48] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 56] UINT32 hunkbytes;     // number of bytes per hunk (512k maximum)                      //    [ 60] UINT32 unitbytes;     // number of bytes per unit within each hunk                      //    [ 64] UINT8  rawsha1[20];   // raw data SHA1                      //    [ 84] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 84' 20);                      //    [104] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [124] (V5 header length)                      return;              }
Magic Number,ROMVault2.SupportedFiles.CHD,CHD,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\CHD\CHD.cs,CheckFile,The following statement contains a magic number: switch (version)              {                  case 1:                      if (length != 76) return;                        //    V1 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // 512-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] (V1 header length)                        return;                    case 2:                      if (length != 80) return;                        //    V2 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // seclen-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 seclen;        // number of bytes per sector                      //    [ 80] (V2 header length)                      return;                    case 3:                      if (length != 120) return;                        //    V3 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 80] UINT8  sha1[20];      // SHA1 checksum of raw data                      SHA1CHD = ReadBytes(buff' 80' 20);                      //    [100] UINT8  parentsha1[20];// SHA1 checksum of parent file                      //    [120] (V3 header length)                      return;                    case 4:                      if (length != 108) return;                        //    V4 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 48] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 48' 20);                      //    [ 68] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [ 88] UINT8  rawsha1[20];   // raw data SHA1                      //    [108] (V4 header length)                      return;                    case 5:                      if (length != 124) return;                        //    V5 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 compressors[4];// which custom compressors are used?                      UInt32 compression0 = ReadUInt32(buff' 16);                      UInt32 compression1 = ReadUInt32(buff' 20);                      UInt32 compression2 = ReadUInt32(buff' 24);                      UInt32 compression3 = ReadUInt32(buff' 28);                      if (compression0 == 0 && compression1 == 0 && compression2 == 0 && compression3 == 0) return;                      //    [ 32] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 40] UINT64 mapoffset;     // offset to the map                      //    [ 48] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 56] UINT32 hunkbytes;     // number of bytes per hunk (512k maximum)                      //    [ 60] UINT32 unitbytes;     // number of bytes per unit within each hunk                      //    [ 64] UINT8  rawsha1[20];   // raw data SHA1                      //    [ 84] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 84' 20);                      //    [104] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [124] (V5 header length)                      return;              }
Magic Number,ROMVault2.SupportedFiles.CHD,CHD,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\CHD\CHD.cs,CheckFile,The following statement contains a magic number: switch (version)              {                  case 1:                      if (length != 76) return;                        //    V1 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // 512-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] (V1 header length)                        return;                    case 2:                      if (length != 80) return;                        //    V2 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // seclen-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 seclen;        // number of bytes per sector                      //    [ 80] (V2 header length)                      return;                    case 3:                      if (length != 120) return;                        //    V3 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 80] UINT8  sha1[20];      // SHA1 checksum of raw data                      SHA1CHD = ReadBytes(buff' 80' 20);                      //    [100] UINT8  parentsha1[20];// SHA1 checksum of parent file                      //    [120] (V3 header length)                      return;                    case 4:                      if (length != 108) return;                        //    V4 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 48] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 48' 20);                      //    [ 68] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [ 88] UINT8  rawsha1[20];   // raw data SHA1                      //    [108] (V4 header length)                      return;                    case 5:                      if (length != 124) return;                        //    V5 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 compressors[4];// which custom compressors are used?                      UInt32 compression0 = ReadUInt32(buff' 16);                      UInt32 compression1 = ReadUInt32(buff' 20);                      UInt32 compression2 = ReadUInt32(buff' 24);                      UInt32 compression3 = ReadUInt32(buff' 28);                      if (compression0 == 0 && compression1 == 0 && compression2 == 0 && compression3 == 0) return;                      //    [ 32] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 40] UINT64 mapoffset;     // offset to the map                      //    [ 48] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 56] UINT32 hunkbytes;     // number of bytes per hunk (512k maximum)                      //    [ 60] UINT32 unitbytes;     // number of bytes per unit within each hunk                      //    [ 64] UINT8  rawsha1[20];   // raw data SHA1                      //    [ 84] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 84' 20);                      //    [104] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [124] (V5 header length)                      return;              }
Magic Number,ROMVault2.SupportedFiles.CHD,CHD,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\CHD\CHD.cs,CheckFile,The following statement contains a magic number: switch (version)              {                  case 1:                      if (length != 76) return;                        //    V1 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // 512-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] (V1 header length)                        return;                    case 2:                      if (length != 80) return;                        //    V2 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // seclen-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 seclen;        // number of bytes per sector                      //    [ 80] (V2 header length)                      return;                    case 3:                      if (length != 120) return;                        //    V3 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 80] UINT8  sha1[20];      // SHA1 checksum of raw data                      SHA1CHD = ReadBytes(buff' 80' 20);                      //    [100] UINT8  parentsha1[20];// SHA1 checksum of parent file                      //    [120] (V3 header length)                      return;                    case 4:                      if (length != 108) return;                        //    V4 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 48] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 48' 20);                      //    [ 68] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [ 88] UINT8  rawsha1[20];   // raw data SHA1                      //    [108] (V4 header length)                      return;                    case 5:                      if (length != 124) return;                        //    V5 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 compressors[4];// which custom compressors are used?                      UInt32 compression0 = ReadUInt32(buff' 16);                      UInt32 compression1 = ReadUInt32(buff' 20);                      UInt32 compression2 = ReadUInt32(buff' 24);                      UInt32 compression3 = ReadUInt32(buff' 28);                      if (compression0 == 0 && compression1 == 0 && compression2 == 0 && compression3 == 0) return;                      //    [ 32] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 40] UINT64 mapoffset;     // offset to the map                      //    [ 48] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 56] UINT32 hunkbytes;     // number of bytes per hunk (512k maximum)                      //    [ 60] UINT32 unitbytes;     // number of bytes per unit within each hunk                      //    [ 64] UINT8  rawsha1[20];   // raw data SHA1                      //    [ 84] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 84' 20);                      //    [104] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [124] (V5 header length)                      return;              }
Magic Number,ROMVault2.SupportedFiles.CHD,CHD,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\CHD\CHD.cs,CheckFile,The following statement contains a magic number: switch (version)              {                  case 1:                      if (length != 76) return;                        //    V1 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // 512-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] (V1 header length)                        return;                    case 2:                      if (length != 80) return;                        //    V2 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // seclen-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 seclen;        // number of bytes per sector                      //    [ 80] (V2 header length)                      return;                    case 3:                      if (length != 120) return;                        //    V3 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 80] UINT8  sha1[20];      // SHA1 checksum of raw data                      SHA1CHD = ReadBytes(buff' 80' 20);                      //    [100] UINT8  parentsha1[20];// SHA1 checksum of parent file                      //    [120] (V3 header length)                      return;                    case 4:                      if (length != 108) return;                        //    V4 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 48] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 48' 20);                      //    [ 68] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [ 88] UINT8  rawsha1[20];   // raw data SHA1                      //    [108] (V4 header length)                      return;                    case 5:                      if (length != 124) return;                        //    V5 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 compressors[4];// which custom compressors are used?                      UInt32 compression0 = ReadUInt32(buff' 16);                      UInt32 compression1 = ReadUInt32(buff' 20);                      UInt32 compression2 = ReadUInt32(buff' 24);                      UInt32 compression3 = ReadUInt32(buff' 28);                      if (compression0 == 0 && compression1 == 0 && compression2 == 0 && compression3 == 0) return;                      //    [ 32] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 40] UINT64 mapoffset;     // offset to the map                      //    [ 48] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 56] UINT32 hunkbytes;     // number of bytes per hunk (512k maximum)                      //    [ 60] UINT32 unitbytes;     // number of bytes per unit within each hunk                      //    [ 64] UINT8  rawsha1[20];   // raw data SHA1                      //    [ 84] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 84' 20);                      //    [104] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [124] (V5 header length)                      return;              }
Magic Number,ROMVault2.SupportedFiles.CHD,CHD,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\CHD\CHD.cs,CheckFile,The following statement contains a magic number: switch (version)              {                  case 1:                      if (length != 76) return;                        //    V1 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // 512-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] (V1 header length)                        return;                    case 2:                      if (length != 80) return;                        //    V2 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // seclen-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 seclen;        // number of bytes per sector                      //    [ 80] (V2 header length)                      return;                    case 3:                      if (length != 120) return;                        //    V3 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 80] UINT8  sha1[20];      // SHA1 checksum of raw data                      SHA1CHD = ReadBytes(buff' 80' 20);                      //    [100] UINT8  parentsha1[20];// SHA1 checksum of parent file                      //    [120] (V3 header length)                      return;                    case 4:                      if (length != 108) return;                        //    V4 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 48] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 48' 20);                      //    [ 68] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [ 88] UINT8  rawsha1[20];   // raw data SHA1                      //    [108] (V4 header length)                      return;                    case 5:                      if (length != 124) return;                        //    V5 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 compressors[4];// which custom compressors are used?                      UInt32 compression0 = ReadUInt32(buff' 16);                      UInt32 compression1 = ReadUInt32(buff' 20);                      UInt32 compression2 = ReadUInt32(buff' 24);                      UInt32 compression3 = ReadUInt32(buff' 28);                      if (compression0 == 0 && compression1 == 0 && compression2 == 0 && compression3 == 0) return;                      //    [ 32] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 40] UINT64 mapoffset;     // offset to the map                      //    [ 48] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 56] UINT32 hunkbytes;     // number of bytes per hunk (512k maximum)                      //    [ 60] UINT32 unitbytes;     // number of bytes per unit within each hunk                      //    [ 64] UINT8  rawsha1[20];   // raw data SHA1                      //    [ 84] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 84' 20);                      //    [104] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [124] (V5 header length)                      return;              }
Magic Number,ROMVault2.SupportedFiles.CHD,CHD,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\CHD\CHD.cs,CheckFile,The following statement contains a magic number: switch (version)              {                  case 1:                      if (length != 76) return;                        //    V1 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // 512-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] (V1 header length)                        return;                    case 2:                      if (length != 80) return;                        //    V2 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // seclen-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 seclen;        // number of bytes per sector                      //    [ 80] (V2 header length)                      return;                    case 3:                      if (length != 120) return;                        //    V3 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 80] UINT8  sha1[20];      // SHA1 checksum of raw data                      SHA1CHD = ReadBytes(buff' 80' 20);                      //    [100] UINT8  parentsha1[20];// SHA1 checksum of parent file                      //    [120] (V3 header length)                      return;                    case 4:                      if (length != 108) return;                        //    V4 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 48] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 48' 20);                      //    [ 68] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [ 88] UINT8  rawsha1[20];   // raw data SHA1                      //    [108] (V4 header length)                      return;                    case 5:                      if (length != 124) return;                        //    V5 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 compressors[4];// which custom compressors are used?                      UInt32 compression0 = ReadUInt32(buff' 16);                      UInt32 compression1 = ReadUInt32(buff' 20);                      UInt32 compression2 = ReadUInt32(buff' 24);                      UInt32 compression3 = ReadUInt32(buff' 28);                      if (compression0 == 0 && compression1 == 0 && compression2 == 0 && compression3 == 0) return;                      //    [ 32] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 40] UINT64 mapoffset;     // offset to the map                      //    [ 48] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 56] UINT32 hunkbytes;     // number of bytes per hunk (512k maximum)                      //    [ 60] UINT32 unitbytes;     // number of bytes per unit within each hunk                      //    [ 64] UINT8  rawsha1[20];   // raw data SHA1                      //    [ 84] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 84' 20);                      //    [104] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [124] (V5 header length)                      return;              }
Magic Number,ROMVault2.SupportedFiles.CHD,CHD,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\CHD\CHD.cs,CheckFile,The following statement contains a magic number: switch (version)              {                  case 1:                      if (length != 76) return;                        //    V1 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // 512-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] (V1 header length)                        return;                    case 2:                      if (length != 80) return;                        //    V2 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // seclen-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 seclen;        // number of bytes per sector                      //    [ 80] (V2 header length)                      return;                    case 3:                      if (length != 120) return;                        //    V3 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 80] UINT8  sha1[20];      // SHA1 checksum of raw data                      SHA1CHD = ReadBytes(buff' 80' 20);                      //    [100] UINT8  parentsha1[20];// SHA1 checksum of parent file                      //    [120] (V3 header length)                      return;                    case 4:                      if (length != 108) return;                        //    V4 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 48] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 48' 20);                      //    [ 68] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [ 88] UINT8  rawsha1[20];   // raw data SHA1                      //    [108] (V4 header length)                      return;                    case 5:                      if (length != 124) return;                        //    V5 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 compressors[4];// which custom compressors are used?                      UInt32 compression0 = ReadUInt32(buff' 16);                      UInt32 compression1 = ReadUInt32(buff' 20);                      UInt32 compression2 = ReadUInt32(buff' 24);                      UInt32 compression3 = ReadUInt32(buff' 28);                      if (compression0 == 0 && compression1 == 0 && compression2 == 0 && compression3 == 0) return;                      //    [ 32] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 40] UINT64 mapoffset;     // offset to the map                      //    [ 48] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 56] UINT32 hunkbytes;     // number of bytes per hunk (512k maximum)                      //    [ 60] UINT32 unitbytes;     // number of bytes per unit within each hunk                      //    [ 64] UINT8  rawsha1[20];   // raw data SHA1                      //    [ 84] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 84' 20);                      //    [104] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [124] (V5 header length)                      return;              }
Magic Number,ROMVault2.SupportedFiles.CHD,CHD,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\CHD\CHD.cs,CheckFile,The following statement contains a magic number: switch (version)              {                  case 1:                      if (length != 76) return;                        //    V1 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // 512-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] (V1 header length)                        return;                    case 2:                      if (length != 80) return;                        //    V2 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // seclen-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 seclen;        // number of bytes per sector                      //    [ 80] (V2 header length)                      return;                    case 3:                      if (length != 120) return;                        //    V3 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 80] UINT8  sha1[20];      // SHA1 checksum of raw data                      SHA1CHD = ReadBytes(buff' 80' 20);                      //    [100] UINT8  parentsha1[20];// SHA1 checksum of parent file                      //    [120] (V3 header length)                      return;                    case 4:                      if (length != 108) return;                        //    V4 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 48] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 48' 20);                      //    [ 68] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [ 88] UINT8  rawsha1[20];   // raw data SHA1                      //    [108] (V4 header length)                      return;                    case 5:                      if (length != 124) return;                        //    V5 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 compressors[4];// which custom compressors are used?                      UInt32 compression0 = ReadUInt32(buff' 16);                      UInt32 compression1 = ReadUInt32(buff' 20);                      UInt32 compression2 = ReadUInt32(buff' 24);                      UInt32 compression3 = ReadUInt32(buff' 28);                      if (compression0 == 0 && compression1 == 0 && compression2 == 0 && compression3 == 0) return;                      //    [ 32] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 40] UINT64 mapoffset;     // offset to the map                      //    [ 48] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 56] UINT32 hunkbytes;     // number of bytes per hunk (512k maximum)                      //    [ 60] UINT32 unitbytes;     // number of bytes per unit within each hunk                      //    [ 64] UINT8  rawsha1[20];   // raw data SHA1                      //    [ 84] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 84' 20);                      //    [104] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [124] (V5 header length)                      return;              }
Magic Number,ROMVault2.SupportedFiles.CHD,CHD,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\CHD\CHD.cs,CheckFile,The following statement contains a magic number: switch (version)              {                  case 1:                      if (length != 76) return;                        //    V1 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // 512-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] (V1 header length)                        return;                    case 2:                      if (length != 80) return;                        //    V2 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // seclen-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 seclen;        // number of bytes per sector                      //    [ 80] (V2 header length)                      return;                    case 3:                      if (length != 120) return;                        //    V3 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 80] UINT8  sha1[20];      // SHA1 checksum of raw data                      SHA1CHD = ReadBytes(buff' 80' 20);                      //    [100] UINT8  parentsha1[20];// SHA1 checksum of parent file                      //    [120] (V3 header length)                      return;                    case 4:                      if (length != 108) return;                        //    V4 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 48] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 48' 20);                      //    [ 68] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [ 88] UINT8  rawsha1[20];   // raw data SHA1                      //    [108] (V4 header length)                      return;                    case 5:                      if (length != 124) return;                        //    V5 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 compressors[4];// which custom compressors are used?                      UInt32 compression0 = ReadUInt32(buff' 16);                      UInt32 compression1 = ReadUInt32(buff' 20);                      UInt32 compression2 = ReadUInt32(buff' 24);                      UInt32 compression3 = ReadUInt32(buff' 28);                      if (compression0 == 0 && compression1 == 0 && compression2 == 0 && compression3 == 0) return;                      //    [ 32] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 40] UINT64 mapoffset;     // offset to the map                      //    [ 48] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 56] UINT32 hunkbytes;     // number of bytes per hunk (512k maximum)                      //    [ 60] UINT32 unitbytes;     // number of bytes per unit within each hunk                      //    [ 64] UINT8  rawsha1[20];   // raw data SHA1                      //    [ 84] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 84' 20);                      //    [104] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [124] (V5 header length)                      return;              }
Magic Number,ROMVault2.SupportedFiles.CHD,CHD,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\CHD\CHD.cs,CheckFile,The following statement contains a magic number: switch (version)              {                  case 1:                      if (length != 76) return;                        //    V1 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // 512-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] (V1 header length)                        return;                    case 2:                      if (length != 80) return;                        //    V2 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // seclen-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 seclen;        // number of bytes per sector                      //    [ 80] (V2 header length)                      return;                    case 3:                      if (length != 120) return;                        //    V3 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 80] UINT8  sha1[20];      // SHA1 checksum of raw data                      SHA1CHD = ReadBytes(buff' 80' 20);                      //    [100] UINT8  parentsha1[20];// SHA1 checksum of parent file                      //    [120] (V3 header length)                      return;                    case 4:                      if (length != 108) return;                        //    V4 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 48] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 48' 20);                      //    [ 68] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [ 88] UINT8  rawsha1[20];   // raw data SHA1                      //    [108] (V4 header length)                      return;                    case 5:                      if (length != 124) return;                        //    V5 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 compressors[4];// which custom compressors are used?                      UInt32 compression0 = ReadUInt32(buff' 16);                      UInt32 compression1 = ReadUInt32(buff' 20);                      UInt32 compression2 = ReadUInt32(buff' 24);                      UInt32 compression3 = ReadUInt32(buff' 28);                      if (compression0 == 0 && compression1 == 0 && compression2 == 0 && compression3 == 0) return;                      //    [ 32] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 40] UINT64 mapoffset;     // offset to the map                      //    [ 48] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 56] UINT32 hunkbytes;     // number of bytes per hunk (512k maximum)                      //    [ 60] UINT32 unitbytes;     // number of bytes per unit within each hunk                      //    [ 64] UINT8  rawsha1[20];   // raw data SHA1                      //    [ 84] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 84' 20);                      //    [104] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [124] (V5 header length)                      return;              }
Magic Number,ROMVault2.SupportedFiles.CHD,CHD,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\CHD\CHD.cs,CheckFile,The following statement contains a magic number: switch (version)              {                  case 1:                      if (length != 76) return;                        //    V1 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // 512-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] (V1 header length)                        return;                    case 2:                      if (length != 80) return;                        //    V2 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // seclen-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 seclen;        // number of bytes per sector                      //    [ 80] (V2 header length)                      return;                    case 3:                      if (length != 120) return;                        //    V3 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 80] UINT8  sha1[20];      // SHA1 checksum of raw data                      SHA1CHD = ReadBytes(buff' 80' 20);                      //    [100] UINT8  parentsha1[20];// SHA1 checksum of parent file                      //    [120] (V3 header length)                      return;                    case 4:                      if (length != 108) return;                        //    V4 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 48] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 48' 20);                      //    [ 68] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [ 88] UINT8  rawsha1[20];   // raw data SHA1                      //    [108] (V4 header length)                      return;                    case 5:                      if (length != 124) return;                        //    V5 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 compressors[4];// which custom compressors are used?                      UInt32 compression0 = ReadUInt32(buff' 16);                      UInt32 compression1 = ReadUInt32(buff' 20);                      UInt32 compression2 = ReadUInt32(buff' 24);                      UInt32 compression3 = ReadUInt32(buff' 28);                      if (compression0 == 0 && compression1 == 0 && compression2 == 0 && compression3 == 0) return;                      //    [ 32] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 40] UINT64 mapoffset;     // offset to the map                      //    [ 48] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 56] UINT32 hunkbytes;     // number of bytes per hunk (512k maximum)                      //    [ 60] UINT32 unitbytes;     // number of bytes per unit within each hunk                      //    [ 64] UINT8  rawsha1[20];   // raw data SHA1                      //    [ 84] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 84' 20);                      //    [104] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [124] (V5 header length)                      return;              }
Magic Number,ROMVault2.SupportedFiles.CHD,CHD,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\CHD\CHD.cs,CheckFile,The following statement contains a magic number: switch (version)              {                  case 1:                      if (length != 76) return;                        //    V1 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // 512-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] (V1 header length)                        return;                    case 2:                      if (length != 80) return;                        //    V2 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // seclen-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 seclen;        // number of bytes per sector                      //    [ 80] (V2 header length)                      return;                    case 3:                      if (length != 120) return;                        //    V3 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 80] UINT8  sha1[20];      // SHA1 checksum of raw data                      SHA1CHD = ReadBytes(buff' 80' 20);                      //    [100] UINT8  parentsha1[20];// SHA1 checksum of parent file                      //    [120] (V3 header length)                      return;                    case 4:                      if (length != 108) return;                        //    V4 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 48] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 48' 20);                      //    [ 68] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [ 88] UINT8  rawsha1[20];   // raw data SHA1                      //    [108] (V4 header length)                      return;                    case 5:                      if (length != 124) return;                        //    V5 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 compressors[4];// which custom compressors are used?                      UInt32 compression0 = ReadUInt32(buff' 16);                      UInt32 compression1 = ReadUInt32(buff' 20);                      UInt32 compression2 = ReadUInt32(buff' 24);                      UInt32 compression3 = ReadUInt32(buff' 28);                      if (compression0 == 0 && compression1 == 0 && compression2 == 0 && compression3 == 0) return;                      //    [ 32] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 40] UINT64 mapoffset;     // offset to the map                      //    [ 48] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 56] UINT32 hunkbytes;     // number of bytes per hunk (512k maximum)                      //    [ 60] UINT32 unitbytes;     // number of bytes per unit within each hunk                      //    [ 64] UINT8  rawsha1[20];   // raw data SHA1                      //    [ 84] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 84' 20);                      //    [104] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [124] (V5 header length)                      return;              }
Magic Number,ROMVault2.SupportedFiles.CHD,CHD,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\CHD\CHD.cs,CheckFile,The following statement contains a magic number: switch (version)              {                  case 1:                      if (length != 76) return;                        //    V1 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // 512-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] (V1 header length)                        return;                    case 2:                      if (length != 80) return;                        //    V2 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // seclen-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 seclen;        // number of bytes per sector                      //    [ 80] (V2 header length)                      return;                    case 3:                      if (length != 120) return;                        //    V3 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 80] UINT8  sha1[20];      // SHA1 checksum of raw data                      SHA1CHD = ReadBytes(buff' 80' 20);                      //    [100] UINT8  parentsha1[20];// SHA1 checksum of parent file                      //    [120] (V3 header length)                      return;                    case 4:                      if (length != 108) return;                        //    V4 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 48] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 48' 20);                      //    [ 68] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [ 88] UINT8  rawsha1[20];   // raw data SHA1                      //    [108] (V4 header length)                      return;                    case 5:                      if (length != 124) return;                        //    V5 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 compressors[4];// which custom compressors are used?                      UInt32 compression0 = ReadUInt32(buff' 16);                      UInt32 compression1 = ReadUInt32(buff' 20);                      UInt32 compression2 = ReadUInt32(buff' 24);                      UInt32 compression3 = ReadUInt32(buff' 28);                      if (compression0 == 0 && compression1 == 0 && compression2 == 0 && compression3 == 0) return;                      //    [ 32] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 40] UINT64 mapoffset;     // offset to the map                      //    [ 48] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 56] UINT32 hunkbytes;     // number of bytes per hunk (512k maximum)                      //    [ 60] UINT32 unitbytes;     // number of bytes per unit within each hunk                      //    [ 64] UINT8  rawsha1[20];   // raw data SHA1                      //    [ 84] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 84' 20);                      //    [104] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [124] (V5 header length)                      return;              }
Magic Number,ROMVault2.SupportedFiles.CHD,CHD,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\CHD\CHD.cs,CheckFile,The following statement contains a magic number: switch (version)              {                  case 1:                      if (length != 76) return;                        //    V1 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // 512-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] (V1 header length)                        return;                    case 2:                      if (length != 80) return;                        //    V2 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // seclen-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 seclen;        // number of bytes per sector                      //    [ 80] (V2 header length)                      return;                    case 3:                      if (length != 120) return;                        //    V3 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 80] UINT8  sha1[20];      // SHA1 checksum of raw data                      SHA1CHD = ReadBytes(buff' 80' 20);                      //    [100] UINT8  parentsha1[20];// SHA1 checksum of parent file                      //    [120] (V3 header length)                      return;                    case 4:                      if (length != 108) return;                        //    V4 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 48] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 48' 20);                      //    [ 68] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [ 88] UINT8  rawsha1[20];   // raw data SHA1                      //    [108] (V4 header length)                      return;                    case 5:                      if (length != 124) return;                        //    V5 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 compressors[4];// which custom compressors are used?                      UInt32 compression0 = ReadUInt32(buff' 16);                      UInt32 compression1 = ReadUInt32(buff' 20);                      UInt32 compression2 = ReadUInt32(buff' 24);                      UInt32 compression3 = ReadUInt32(buff' 28);                      if (compression0 == 0 && compression1 == 0 && compression2 == 0 && compression3 == 0) return;                      //    [ 32] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 40] UINT64 mapoffset;     // offset to the map                      //    [ 48] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 56] UINT32 hunkbytes;     // number of bytes per hunk (512k maximum)                      //    [ 60] UINT32 unitbytes;     // number of bytes per unit within each hunk                      //    [ 64] UINT8  rawsha1[20];   // raw data SHA1                      //    [ 84] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 84' 20);                      //    [104] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [124] (V5 header length)                      return;              }
Magic Number,ROMVault2.SupportedFiles.CHD,CHD,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\CHD\CHD.cs,CheckFile,The following statement contains a magic number: switch (version)              {                  case 1:                      if (length != 76) return;                        //    V1 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // 512-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] (V1 header length)                        return;                    case 2:                      if (length != 80) return;                        //    V2 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // seclen-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 seclen;        // number of bytes per sector                      //    [ 80] (V2 header length)                      return;                    case 3:                      if (length != 120) return;                        //    V3 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 80] UINT8  sha1[20];      // SHA1 checksum of raw data                      SHA1CHD = ReadBytes(buff' 80' 20);                      //    [100] UINT8  parentsha1[20];// SHA1 checksum of parent file                      //    [120] (V3 header length)                      return;                    case 4:                      if (length != 108) return;                        //    V4 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 48] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 48' 20);                      //    [ 68] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [ 88] UINT8  rawsha1[20];   // raw data SHA1                      //    [108] (V4 header length)                      return;                    case 5:                      if (length != 124) return;                        //    V5 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 compressors[4];// which custom compressors are used?                      UInt32 compression0 = ReadUInt32(buff' 16);                      UInt32 compression1 = ReadUInt32(buff' 20);                      UInt32 compression2 = ReadUInt32(buff' 24);                      UInt32 compression3 = ReadUInt32(buff' 28);                      if (compression0 == 0 && compression1 == 0 && compression2 == 0 && compression3 == 0) return;                      //    [ 32] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 40] UINT64 mapoffset;     // offset to the map                      //    [ 48] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 56] UINT32 hunkbytes;     // number of bytes per hunk (512k maximum)                      //    [ 60] UINT32 unitbytes;     // number of bytes per unit within each hunk                      //    [ 64] UINT8  rawsha1[20];   // raw data SHA1                      //    [ 84] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 84' 20);                      //    [104] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [124] (V5 header length)                      return;              }
Magic Number,ROMVault2.SupportedFiles.CHD,CHD,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\CHD\CHD.cs,CheckFile,The following statement contains a magic number: switch (version)              {                  case 1:                      if (length != 76) return;                        //    V1 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // 512-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] (V1 header length)                        return;                    case 2:                      if (length != 80) return;                        //    V2 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // seclen-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 seclen;        // number of bytes per sector                      //    [ 80] (V2 header length)                      return;                    case 3:                      if (length != 120) return;                        //    V3 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 80] UINT8  sha1[20];      // SHA1 checksum of raw data                      SHA1CHD = ReadBytes(buff' 80' 20);                      //    [100] UINT8  parentsha1[20];// SHA1 checksum of parent file                      //    [120] (V3 header length)                      return;                    case 4:                      if (length != 108) return;                        //    V4 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 48] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 48' 20);                      //    [ 68] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [ 88] UINT8  rawsha1[20];   // raw data SHA1                      //    [108] (V4 header length)                      return;                    case 5:                      if (length != 124) return;                        //    V5 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 compressors[4];// which custom compressors are used?                      UInt32 compression0 = ReadUInt32(buff' 16);                      UInt32 compression1 = ReadUInt32(buff' 20);                      UInt32 compression2 = ReadUInt32(buff' 24);                      UInt32 compression3 = ReadUInt32(buff' 28);                      if (compression0 == 0 && compression1 == 0 && compression2 == 0 && compression3 == 0) return;                      //    [ 32] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 40] UINT64 mapoffset;     // offset to the map                      //    [ 48] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 56] UINT32 hunkbytes;     // number of bytes per hunk (512k maximum)                      //    [ 60] UINT32 unitbytes;     // number of bytes per unit within each hunk                      //    [ 64] UINT8  rawsha1[20];   // raw data SHA1                      //    [ 84] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 84' 20);                      //    [104] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [124] (V5 header length)                      return;              }
Magic Number,ROMVault2.SupportedFiles.CHD,CHD,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\CHD\CHD.cs,CheckFile,The following statement contains a magic number: switch (version)              {                  case 1:                      if (length != 76) return;                        //    V1 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // 512-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] (V1 header length)                        return;                    case 2:                      if (length != 80) return;                        //    V2 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // seclen-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 seclen;        // number of bytes per sector                      //    [ 80] (V2 header length)                      return;                    case 3:                      if (length != 120) return;                        //    V3 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 80] UINT8  sha1[20];      // SHA1 checksum of raw data                      SHA1CHD = ReadBytes(buff' 80' 20);                      //    [100] UINT8  parentsha1[20];// SHA1 checksum of parent file                      //    [120] (V3 header length)                      return;                    case 4:                      if (length != 108) return;                        //    V4 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 48] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 48' 20);                      //    [ 68] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [ 88] UINT8  rawsha1[20];   // raw data SHA1                      //    [108] (V4 header length)                      return;                    case 5:                      if (length != 124) return;                        //    V5 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 compressors[4];// which custom compressors are used?                      UInt32 compression0 = ReadUInt32(buff' 16);                      UInt32 compression1 = ReadUInt32(buff' 20);                      UInt32 compression2 = ReadUInt32(buff' 24);                      UInt32 compression3 = ReadUInt32(buff' 28);                      if (compression0 == 0 && compression1 == 0 && compression2 == 0 && compression3 == 0) return;                      //    [ 32] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 40] UINT64 mapoffset;     // offset to the map                      //    [ 48] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 56] UINT32 hunkbytes;     // number of bytes per hunk (512k maximum)                      //    [ 60] UINT32 unitbytes;     // number of bytes per unit within each hunk                      //    [ 64] UINT8  rawsha1[20];   // raw data SHA1                      //    [ 84] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 84' 20);                      //    [104] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [124] (V5 header length)                      return;              }
Magic Number,ROMVault2.SupportedFiles.CHD,CHD,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\CHD\CHD.cs,CheckFile,The following statement contains a magic number: switch (version)              {                  case 1:                      if (length != 76) return;                        //    V1 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // 512-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] (V1 header length)                        return;                    case 2:                      if (length != 80) return;                        //    V2 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // seclen-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 seclen;        // number of bytes per sector                      //    [ 80] (V2 header length)                      return;                    case 3:                      if (length != 120) return;                        //    V3 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 80] UINT8  sha1[20];      // SHA1 checksum of raw data                      SHA1CHD = ReadBytes(buff' 80' 20);                      //    [100] UINT8  parentsha1[20];// SHA1 checksum of parent file                      //    [120] (V3 header length)                      return;                    case 4:                      if (length != 108) return;                        //    V4 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 48] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 48' 20);                      //    [ 68] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [ 88] UINT8  rawsha1[20];   // raw data SHA1                      //    [108] (V4 header length)                      return;                    case 5:                      if (length != 124) return;                        //    V5 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 compressors[4];// which custom compressors are used?                      UInt32 compression0 = ReadUInt32(buff' 16);                      UInt32 compression1 = ReadUInt32(buff' 20);                      UInt32 compression2 = ReadUInt32(buff' 24);                      UInt32 compression3 = ReadUInt32(buff' 28);                      if (compression0 == 0 && compression1 == 0 && compression2 == 0 && compression3 == 0) return;                      //    [ 32] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 40] UINT64 mapoffset;     // offset to the map                      //    [ 48] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 56] UINT32 hunkbytes;     // number of bytes per hunk (512k maximum)                      //    [ 60] UINT32 unitbytes;     // number of bytes per unit within each hunk                      //    [ 64] UINT8  rawsha1[20];   // raw data SHA1                      //    [ 84] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 84' 20);                      //    [104] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [124] (V5 header length)                      return;              }
Magic Number,ROMVault2.SupportedFiles.CHD,CHD,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\CHD\CHD.cs,CheckFile,The following statement contains a magic number: switch (version)              {                  case 1:                      if (length != 76) return;                        //    V1 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // 512-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] (V1 header length)                        return;                    case 2:                      if (length != 80) return;                        //    V2 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // seclen-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 seclen;        // number of bytes per sector                      //    [ 80] (V2 header length)                      return;                    case 3:                      if (length != 120) return;                        //    V3 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 80] UINT8  sha1[20];      // SHA1 checksum of raw data                      SHA1CHD = ReadBytes(buff' 80' 20);                      //    [100] UINT8  parentsha1[20];// SHA1 checksum of parent file                      //    [120] (V3 header length)                      return;                    case 4:                      if (length != 108) return;                        //    V4 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 48] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 48' 20);                      //    [ 68] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [ 88] UINT8  rawsha1[20];   // raw data SHA1                      //    [108] (V4 header length)                      return;                    case 5:                      if (length != 124) return;                        //    V5 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 compressors[4];// which custom compressors are used?                      UInt32 compression0 = ReadUInt32(buff' 16);                      UInt32 compression1 = ReadUInt32(buff' 20);                      UInt32 compression2 = ReadUInt32(buff' 24);                      UInt32 compression3 = ReadUInt32(buff' 28);                      if (compression0 == 0 && compression1 == 0 && compression2 == 0 && compression3 == 0) return;                      //    [ 32] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 40] UINT64 mapoffset;     // offset to the map                      //    [ 48] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 56] UINT32 hunkbytes;     // number of bytes per hunk (512k maximum)                      //    [ 60] UINT32 unitbytes;     // number of bytes per unit within each hunk                      //    [ 64] UINT8  rawsha1[20];   // raw data SHA1                      //    [ 84] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 84' 20);                      //    [104] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [124] (V5 header length)                      return;              }
Magic Number,ROMVault2.SupportedFiles.CHD,CHD,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\CHD\CHD.cs,CheckFile,The following statement contains a magic number: switch (version)              {                  case 1:                      if (length != 76) return;                        //    V1 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // 512-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] (V1 header length)                        return;                    case 2:                      if (length != 80) return;                        //    V2 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // seclen-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 seclen;        // number of bytes per sector                      //    [ 80] (V2 header length)                      return;                    case 3:                      if (length != 120) return;                        //    V3 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 80] UINT8  sha1[20];      // SHA1 checksum of raw data                      SHA1CHD = ReadBytes(buff' 80' 20);                      //    [100] UINT8  parentsha1[20];// SHA1 checksum of parent file                      //    [120] (V3 header length)                      return;                    case 4:                      if (length != 108) return;                        //    V4 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 48] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 48' 20);                      //    [ 68] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [ 88] UINT8  rawsha1[20];   // raw data SHA1                      //    [108] (V4 header length)                      return;                    case 5:                      if (length != 124) return;                        //    V5 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 compressors[4];// which custom compressors are used?                      UInt32 compression0 = ReadUInt32(buff' 16);                      UInt32 compression1 = ReadUInt32(buff' 20);                      UInt32 compression2 = ReadUInt32(buff' 24);                      UInt32 compression3 = ReadUInt32(buff' 28);                      if (compression0 == 0 && compression1 == 0 && compression2 == 0 && compression3 == 0) return;                      //    [ 32] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 40] UINT64 mapoffset;     // offset to the map                      //    [ 48] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 56] UINT32 hunkbytes;     // number of bytes per hunk (512k maximum)                      //    [ 60] UINT32 unitbytes;     // number of bytes per unit within each hunk                      //    [ 64] UINT8  rawsha1[20];   // raw data SHA1                      //    [ 84] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 84' 20);                      //    [104] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [124] (V5 header length)                      return;              }
Magic Number,ROMVault2.SupportedFiles.CHD,CHD,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\CHD\CHD.cs,CheckFile,The following statement contains a magic number: switch (version)              {                  case 1:                      if (length != 76) return;                        //    V1 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // 512-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] (V1 header length)                        return;                    case 2:                      if (length != 80) return;                        //    V2 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // seclen-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 seclen;        // number of bytes per sector                      //    [ 80] (V2 header length)                      return;                    case 3:                      if (length != 120) return;                        //    V3 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 80] UINT8  sha1[20];      // SHA1 checksum of raw data                      SHA1CHD = ReadBytes(buff' 80' 20);                      //    [100] UINT8  parentsha1[20];// SHA1 checksum of parent file                      //    [120] (V3 header length)                      return;                    case 4:                      if (length != 108) return;                        //    V4 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 48] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 48' 20);                      //    [ 68] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [ 88] UINT8  rawsha1[20];   // raw data SHA1                      //    [108] (V4 header length)                      return;                    case 5:                      if (length != 124) return;                        //    V5 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 compressors[4];// which custom compressors are used?                      UInt32 compression0 = ReadUInt32(buff' 16);                      UInt32 compression1 = ReadUInt32(buff' 20);                      UInt32 compression2 = ReadUInt32(buff' 24);                      UInt32 compression3 = ReadUInt32(buff' 28);                      if (compression0 == 0 && compression1 == 0 && compression2 == 0 && compression3 == 0) return;                      //    [ 32] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 40] UINT64 mapoffset;     // offset to the map                      //    [ 48] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 56] UINT32 hunkbytes;     // number of bytes per hunk (512k maximum)                      //    [ 60] UINT32 unitbytes;     // number of bytes per unit within each hunk                      //    [ 64] UINT8  rawsha1[20];   // raw data SHA1                      //    [ 84] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 84' 20);                      //    [104] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [124] (V5 header length)                      return;              }
Magic Number,ROMVault2.SupportedFiles.CHD,CHD,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\CHD\CHD.cs,CheckFile,The following statement contains a magic number: switch (version)              {                  case 1:                      if (length != 76) return;                        //    V1 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // 512-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] (V1 header length)                        return;                    case 2:                      if (length != 80) return;                        //    V2 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // seclen-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 seclen;        // number of bytes per sector                      //    [ 80] (V2 header length)                      return;                    case 3:                      if (length != 120) return;                        //    V3 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 80] UINT8  sha1[20];      // SHA1 checksum of raw data                      SHA1CHD = ReadBytes(buff' 80' 20);                      //    [100] UINT8  parentsha1[20];// SHA1 checksum of parent file                      //    [120] (V3 header length)                      return;                    case 4:                      if (length != 108) return;                        //    V4 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 48] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 48' 20);                      //    [ 68] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [ 88] UINT8  rawsha1[20];   // raw data SHA1                      //    [108] (V4 header length)                      return;                    case 5:                      if (length != 124) return;                        //    V5 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 compressors[4];// which custom compressors are used?                      UInt32 compression0 = ReadUInt32(buff' 16);                      UInt32 compression1 = ReadUInt32(buff' 20);                      UInt32 compression2 = ReadUInt32(buff' 24);                      UInt32 compression3 = ReadUInt32(buff' 28);                      if (compression0 == 0 && compression1 == 0 && compression2 == 0 && compression3 == 0) return;                      //    [ 32] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 40] UINT64 mapoffset;     // offset to the map                      //    [ 48] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 56] UINT32 hunkbytes;     // number of bytes per hunk (512k maximum)                      //    [ 60] UINT32 unitbytes;     // number of bytes per unit within each hunk                      //    [ 64] UINT8  rawsha1[20];   // raw data SHA1                      //    [ 84] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 84' 20);                      //    [104] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [124] (V5 header length)                      return;              }
Magic Number,ROMVault2.SupportedFiles.CHD,CHD,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\CHD\CHD.cs,CheckFile,The following statement contains a magic number: switch (version)              {                  case 1:                      if (length != 76) return;                        //    V1 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // 512-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] (V1 header length)                        return;                    case 2:                      if (length != 80) return;                        //    V2 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // seclen-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 seclen;        // number of bytes per sector                      //    [ 80] (V2 header length)                      return;                    case 3:                      if (length != 120) return;                        //    V3 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 80] UINT8  sha1[20];      // SHA1 checksum of raw data                      SHA1CHD = ReadBytes(buff' 80' 20);                      //    [100] UINT8  parentsha1[20];// SHA1 checksum of parent file                      //    [120] (V3 header length)                      return;                    case 4:                      if (length != 108) return;                        //    V4 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 48] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 48' 20);                      //    [ 68] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [ 88] UINT8  rawsha1[20];   // raw data SHA1                      //    [108] (V4 header length)                      return;                    case 5:                      if (length != 124) return;                        //    V5 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 compressors[4];// which custom compressors are used?                      UInt32 compression0 = ReadUInt32(buff' 16);                      UInt32 compression1 = ReadUInt32(buff' 20);                      UInt32 compression2 = ReadUInt32(buff' 24);                      UInt32 compression3 = ReadUInt32(buff' 28);                      if (compression0 == 0 && compression1 == 0 && compression2 == 0 && compression3 == 0) return;                      //    [ 32] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 40] UINT64 mapoffset;     // offset to the map                      //    [ 48] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 56] UINT32 hunkbytes;     // number of bytes per hunk (512k maximum)                      //    [ 60] UINT32 unitbytes;     // number of bytes per unit within each hunk                      //    [ 64] UINT8  rawsha1[20];   // raw data SHA1                      //    [ 84] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 84' 20);                      //    [104] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [124] (V5 header length)                      return;              }
Magic Number,ROMVault2.SupportedFiles.CHD,CHD,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\CHD\CHD.cs,CheckFile,The following statement contains a magic number: switch (version)              {                  case 1:                      if (length != 76) return;                        //    V1 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // 512-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] (V1 header length)                        return;                    case 2:                      if (length != 80) return;                        //    V2 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // seclen-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 seclen;        // number of bytes per sector                      //    [ 80] (V2 header length)                      return;                    case 3:                      if (length != 120) return;                        //    V3 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 80] UINT8  sha1[20];      // SHA1 checksum of raw data                      SHA1CHD = ReadBytes(buff' 80' 20);                      //    [100] UINT8  parentsha1[20];// SHA1 checksum of parent file                      //    [120] (V3 header length)                      return;                    case 4:                      if (length != 108) return;                        //    V4 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 48] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 48' 20);                      //    [ 68] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [ 88] UINT8  rawsha1[20];   // raw data SHA1                      //    [108] (V4 header length)                      return;                    case 5:                      if (length != 124) return;                        //    V5 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 compressors[4];// which custom compressors are used?                      UInt32 compression0 = ReadUInt32(buff' 16);                      UInt32 compression1 = ReadUInt32(buff' 20);                      UInt32 compression2 = ReadUInt32(buff' 24);                      UInt32 compression3 = ReadUInt32(buff' 28);                      if (compression0 == 0 && compression1 == 0 && compression2 == 0 && compression3 == 0) return;                      //    [ 32] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 40] UINT64 mapoffset;     // offset to the map                      //    [ 48] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 56] UINT32 hunkbytes;     // number of bytes per hunk (512k maximum)                      //    [ 60] UINT32 unitbytes;     // number of bytes per unit within each hunk                      //    [ 64] UINT8  rawsha1[20];   // raw data SHA1                      //    [ 84] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 84' 20);                      //    [104] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [124] (V5 header length)                      return;              }
Magic Number,ROMVault2.SupportedFiles.CHD,CHD,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\CHD\CHD.cs,CheckFile,The following statement contains a magic number: switch (version)              {                  case 1:                      if (length != 76) return;                        //    V1 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // 512-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] (V1 header length)                        return;                    case 2:                      if (length != 80) return;                        //    V2 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // seclen-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 seclen;        // number of bytes per sector                      //    [ 80] (V2 header length)                      return;                    case 3:                      if (length != 120) return;                        //    V3 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 80] UINT8  sha1[20];      // SHA1 checksum of raw data                      SHA1CHD = ReadBytes(buff' 80' 20);                      //    [100] UINT8  parentsha1[20];// SHA1 checksum of parent file                      //    [120] (V3 header length)                      return;                    case 4:                      if (length != 108) return;                        //    V4 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 48] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 48' 20);                      //    [ 68] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [ 88] UINT8  rawsha1[20];   // raw data SHA1                      //    [108] (V4 header length)                      return;                    case 5:                      if (length != 124) return;                        //    V5 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 compressors[4];// which custom compressors are used?                      UInt32 compression0 = ReadUInt32(buff' 16);                      UInt32 compression1 = ReadUInt32(buff' 20);                      UInt32 compression2 = ReadUInt32(buff' 24);                      UInt32 compression3 = ReadUInt32(buff' 28);                      if (compression0 == 0 && compression1 == 0 && compression2 == 0 && compression3 == 0) return;                      //    [ 32] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 40] UINT64 mapoffset;     // offset to the map                      //    [ 48] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 56] UINT32 hunkbytes;     // number of bytes per hunk (512k maximum)                      //    [ 60] UINT32 unitbytes;     // number of bytes per unit within each hunk                      //    [ 64] UINT8  rawsha1[20];   // raw data SHA1                      //    [ 84] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 84' 20);                      //    [104] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [124] (V5 header length)                      return;              }
Magic Number,ROMVault2.SupportedFiles.CHD,CHD,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\CHD\CHD.cs,CheckFile,The following statement contains a magic number: switch (version)              {                  case 1:                      if (length != 76) return;                        //    V1 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // 512-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] (V1 header length)                        return;                    case 2:                      if (length != 80) return;                        //    V2 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // seclen-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 seclen;        // number of bytes per sector                      //    [ 80] (V2 header length)                      return;                    case 3:                      if (length != 120) return;                        //    V3 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 80] UINT8  sha1[20];      // SHA1 checksum of raw data                      SHA1CHD = ReadBytes(buff' 80' 20);                      //    [100] UINT8  parentsha1[20];// SHA1 checksum of parent file                      //    [120] (V3 header length)                      return;                    case 4:                      if (length != 108) return;                        //    V4 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 48] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 48' 20);                      //    [ 68] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [ 88] UINT8  rawsha1[20];   // raw data SHA1                      //    [108] (V4 header length)                      return;                    case 5:                      if (length != 124) return;                        //    V5 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 compressors[4];// which custom compressors are used?                      UInt32 compression0 = ReadUInt32(buff' 16);                      UInt32 compression1 = ReadUInt32(buff' 20);                      UInt32 compression2 = ReadUInt32(buff' 24);                      UInt32 compression3 = ReadUInt32(buff' 28);                      if (compression0 == 0 && compression1 == 0 && compression2 == 0 && compression3 == 0) return;                      //    [ 32] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 40] UINT64 mapoffset;     // offset to the map                      //    [ 48] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 56] UINT32 hunkbytes;     // number of bytes per hunk (512k maximum)                      //    [ 60] UINT32 unitbytes;     // number of bytes per unit within each hunk                      //    [ 64] UINT8  rawsha1[20];   // raw data SHA1                      //    [ 84] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 84' 20);                      //    [104] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [124] (V5 header length)                      return;              }
Magic Number,ROMVault2.SupportedFiles.CHD,CHD,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\CHD\CHD.cs,CheckFile,The following statement contains a magic number: switch (version)              {                  case 1:                      if (length != 76) return;                        //    V1 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // 512-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] (V1 header length)                        return;                    case 2:                      if (length != 80) return;                        //    V2 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // seclen-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 seclen;        // number of bytes per sector                      //    [ 80] (V2 header length)                      return;                    case 3:                      if (length != 120) return;                        //    V3 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 80] UINT8  sha1[20];      // SHA1 checksum of raw data                      SHA1CHD = ReadBytes(buff' 80' 20);                      //    [100] UINT8  parentsha1[20];// SHA1 checksum of parent file                      //    [120] (V3 header length)                      return;                    case 4:                      if (length != 108) return;                        //    V4 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 48] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 48' 20);                      //    [ 68] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [ 88] UINT8  rawsha1[20];   // raw data SHA1                      //    [108] (V4 header length)                      return;                    case 5:                      if (length != 124) return;                        //    V5 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 compressors[4];// which custom compressors are used?                      UInt32 compression0 = ReadUInt32(buff' 16);                      UInt32 compression1 = ReadUInt32(buff' 20);                      UInt32 compression2 = ReadUInt32(buff' 24);                      UInt32 compression3 = ReadUInt32(buff' 28);                      if (compression0 == 0 && compression1 == 0 && compression2 == 0 && compression3 == 0) return;                      //    [ 32] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 40] UINT64 mapoffset;     // offset to the map                      //    [ 48] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 56] UINT32 hunkbytes;     // number of bytes per hunk (512k maximum)                      //    [ 60] UINT32 unitbytes;     // number of bytes per unit within each hunk                      //    [ 64] UINT8  rawsha1[20];   // raw data SHA1                      //    [ 84] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 84' 20);                      //    [104] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [124] (V5 header length)                      return;              }
Magic Number,ROMVault2.SupportedFiles.CHD,CHD,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\CHD\CHD.cs,ReadUInt32,The following statement contains a magic number: return                  ((UInt32)b[p + 0]) << 24 |                  ((UInt32)b[p + 1]) << 16 |                  ((UInt32)b[p + 2]) << 8 |                  (b[p + 3]);
Magic Number,ROMVault2.SupportedFiles.CHD,CHD,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\CHD\CHD.cs,ReadUInt32,The following statement contains a magic number: return                  ((UInt32)b[p + 0]) << 24 |                  ((UInt32)b[p + 1]) << 16 |                  ((UInt32)b[p + 2]) << 8 |                  (b[p + 3]);
Magic Number,ROMVault2.SupportedFiles.CHD,CHD,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\CHD\CHD.cs,ReadUInt32,The following statement contains a magic number: return                  ((UInt32)b[p + 0]) << 24 |                  ((UInt32)b[p + 1]) << 16 |                  ((UInt32)b[p + 2]) << 8 |                  (b[p + 3]);
Magic Number,ROMVault2.SupportedFiles.CHD,CHD,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\CHD\CHD.cs,ReadUInt32,The following statement contains a magic number: return                  ((UInt32)b[p + 0]) << 24 |                  ((UInt32)b[p + 1]) << 16 |                  ((UInt32)b[p + 2]) << 8 |                  (b[p + 3]);
Magic Number,ROMVault2.SupportedFiles.CHD,CHD,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\CHD\CHD.cs,ReadUInt32,The following statement contains a magic number: return                  ((UInt32)b[p + 0]) << 24 |                  ((UInt32)b[p + 1]) << 16 |                  ((UInt32)b[p + 2]) << 8 |                  (b[p + 3]);
Magic Number,ROMVault2.SupportedFiles.CHD,CHD,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\CHD\CHD.cs,CHDOutputHandler,The following statement contains a magic number: switch (_outputLineCount)              {                  case 0:                      if (!System.Text.RegularExpressions.Regex.IsMatch(sOut' @"^chdman - MAME Compressed Hunks of Data \(CHD\) manager ([0-9\.]+) \(.*\)"))                       {                          _result = "Incorrect startup of CHDMan :" + sOut;                          _resultType = CHDManCheck.CHDReturnError;                      }                      break;                  case 1:                      if (sOut != "Raw SHA1 verification successful!")                      {                          _result = "Raw SHA1 check failed :" + sOut;                          _resultType = CHDManCheck.CHDReturnError;                      }                      break;                  case 2:                      if (sOut != "Overall SHA1 verification successful!")                      {                          _result = "Overall SHA1 check failed :" + sOut;                          _resultType = CHDManCheck.CHDReturnError;                      }                      break;                  default:                      _result = "Unexpected output from chdman :" + sOut;                      _resultType = CHDManCheck.CHDUnknownError;                      break;              }
Magic Number,ROMVault2.DatReaders,DatDOSReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatDOSReader.cs,LoadHeaderFromDat,The following statement contains a magic number: while (DatFileLoader.Next != ")")              {                  string nextstr = DatFileLoader.Next.ToLower();                  if (nextstr.Length > 5 && nextstr.Substring(0' 5) == "name:")                  {                      tDat.AddData(RvDat.DatData.DatName'  VarFix.CleanFileName(DatFileLoader.Next.Substring(5) + " " + DatFileLoader.GnRest()).Trim()); DatFileLoader.Gn();                  }                  else                  {                      switch (nextstr)                      {                          case "name:": tDat.AddData(RvDat.DatData.DatName' VarFix.CleanFileName(DatFileLoader.GnRest())); DatFileLoader.Gn(); break;                          case "description:": tDat.AddData(RvDat.DatData.Description ' DatFileLoader.GnRest()); DatFileLoader.Gn(); break;                          case "version:": tDat.AddData(RvDat.DatData.Version ' DatFileLoader.GnRest()); DatFileLoader.Gn(); break;                          case "date:": tDat.AddData(RvDat.DatData.Date ' DatFileLoader.GnRest()); DatFileLoader.Gn(); break;                          case "author:": tDat.AddData(RvDat.DatData.Author ' DatFileLoader.GnRest()); DatFileLoader.Gn(); break;                          case "homepage:": tDat.AddData(RvDat.DatData.HomePage ' DatFileLoader.GnRest()); DatFileLoader.Gn(); break;                            case "comment:": DatFileLoader.GnRest(); DatFileLoader.Gn(); break;                          default:                              DatUpdate.SendAndShowDat(Resources.DatCmpReader_ReadDat_Error_keyword + DatFileLoader.Next + Resources.DatCmpReader_LoadHeaderFromDat_not_known_in_clrmamepro' DatFileLoader.Filename);                              DatFileLoader.Gn();                              break;                      }                  }              }
Magic Number,ROMVault2.DatReaders,DatDOSReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatDOSReader.cs,LoadHeaderFromDat,The following statement contains a magic number: while (DatFileLoader.Next != ")")              {                  string nextstr = DatFileLoader.Next.ToLower();                  if (nextstr.Length > 5 && nextstr.Substring(0' 5) == "name:")                  {                      tDat.AddData(RvDat.DatData.DatName'  VarFix.CleanFileName(DatFileLoader.Next.Substring(5) + " " + DatFileLoader.GnRest()).Trim()); DatFileLoader.Gn();                  }                  else                  {                      switch (nextstr)                      {                          case "name:": tDat.AddData(RvDat.DatData.DatName' VarFix.CleanFileName(DatFileLoader.GnRest())); DatFileLoader.Gn(); break;                          case "description:": tDat.AddData(RvDat.DatData.Description ' DatFileLoader.GnRest()); DatFileLoader.Gn(); break;                          case "version:": tDat.AddData(RvDat.DatData.Version ' DatFileLoader.GnRest()); DatFileLoader.Gn(); break;                          case "date:": tDat.AddData(RvDat.DatData.Date ' DatFileLoader.GnRest()); DatFileLoader.Gn(); break;                          case "author:": tDat.AddData(RvDat.DatData.Author ' DatFileLoader.GnRest()); DatFileLoader.Gn(); break;                          case "homepage:": tDat.AddData(RvDat.DatData.HomePage ' DatFileLoader.GnRest()); DatFileLoader.Gn(); break;                            case "comment:": DatFileLoader.GnRest(); DatFileLoader.Gn(); break;                          default:                              DatUpdate.SendAndShowDat(Resources.DatCmpReader_ReadDat_Error_keyword + DatFileLoader.Next + Resources.DatCmpReader_LoadHeaderFromDat_not_known_in_clrmamepro' DatFileLoader.Filename);                              DatFileLoader.Gn();                              break;                      }                  }              }
Magic Number,ROMVault2.DatReaders,DatDOSReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatDOSReader.cs,LoadHeaderFromDat,The following statement contains a magic number: while (DatFileLoader.Next != ")")              {                  string nextstr = DatFileLoader.Next.ToLower();                  if (nextstr.Length > 5 && nextstr.Substring(0' 5) == "name:")                  {                      tDat.AddData(RvDat.DatData.DatName'  VarFix.CleanFileName(DatFileLoader.Next.Substring(5) + " " + DatFileLoader.GnRest()).Trim()); DatFileLoader.Gn();                  }                  else                  {                      switch (nextstr)                      {                          case "name:": tDat.AddData(RvDat.DatData.DatName' VarFix.CleanFileName(DatFileLoader.GnRest())); DatFileLoader.Gn(); break;                          case "description:": tDat.AddData(RvDat.DatData.Description ' DatFileLoader.GnRest()); DatFileLoader.Gn(); break;                          case "version:": tDat.AddData(RvDat.DatData.Version ' DatFileLoader.GnRest()); DatFileLoader.Gn(); break;                          case "date:": tDat.AddData(RvDat.DatData.Date ' DatFileLoader.GnRest()); DatFileLoader.Gn(); break;                          case "author:": tDat.AddData(RvDat.DatData.Author ' DatFileLoader.GnRest()); DatFileLoader.Gn(); break;                          case "homepage:": tDat.AddData(RvDat.DatData.HomePage ' DatFileLoader.GnRest()); DatFileLoader.Gn(); break;                            case "comment:": DatFileLoader.GnRest(); DatFileLoader.Gn(); break;                          default:                              DatUpdate.SendAndShowDat(Resources.DatCmpReader_ReadDat_Error_keyword + DatFileLoader.Next + Resources.DatCmpReader_LoadHeaderFromDat_not_known_in_clrmamepro' DatFileLoader.Filename);                              DatFileLoader.Gn();                              break;                      }                  }              }
Magic Number,ROMVault2.DatReaders,DatDOSReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatDOSReader.cs,LoadGameFromDat,The following statement contains a magic number: if (fullname.Length > 4 && fullname.ToLower().Substring(fullname.Length - 4' 4) == ".zip")                  fullname = fullname.Substring(0' fullname.Length - 4);
Magic Number,ROMVault2.DatReaders,DatDOSReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatDOSReader.cs,LoadGameFromDat,The following statement contains a magic number: if (fullname.Length > 4 && fullname.ToLower().Substring(fullname.Length - 4' 4) == ".zip")                  fullname = fullname.Substring(0' fullname.Length - 4);
Magic Number,ROMVault2.DatReaders,DatDOSReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatDOSReader.cs,LoadGameFromDat,The following statement contains a magic number: if (fullname.Length > 4 && fullname.ToLower().Substring(fullname.Length - 4' 4) == ".zip")                  fullname = fullname.Substring(0' fullname.Length - 4);
Magic Number,ROMVault2.DatReaders,DatDOSReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatDOSReader.cs,LoadGameFromDat,The following statement contains a magic number: if (fullname.Length > 4 && fullname.ToLower().Substring(fullname.Length - 4' 4) == ".zip")                  fullname = fullname.Substring(0' fullname.Length - 4);
Magic Number,ROMVault2.DatReaders,DatDOSReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatDOSReader.cs,LoadRomFromDat,The following statement contains a magic number: int posSize = linelc.IndexOf(" size "' posName+5'StringComparison.Ordinal);
Magic Number,ROMVault2.DatReaders,DatDOSReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatDOSReader.cs,LoadRomFromDat,The following statement contains a magic number: int posDate = linelc.IndexOf(" date "' posSize+6'StringComparison.Ordinal);
Magic Number,ROMVault2.DatReaders,DatDOSReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatDOSReader.cs,LoadRomFromDat,The following statement contains a magic number: int posCrc = linelc.IndexOf(" crc "' posDate+6'StringComparison.Ordinal);
Magic Number,ROMVault2.DatReaders,DatDOSReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatDOSReader.cs,LoadRomFromDat,The following statement contains a magic number: int posEnd = linelc.IndexOf(" )"' posCrc+5'StringComparison.Ordinal);
Magic Number,ROMVault2.DatReaders,DatDOSReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatDOSReader.cs,LoadRomFromDat,The following statement contains a magic number: string name = line.Substring(posName + 5' posSize - (posName + 5));
Magic Number,ROMVault2.DatReaders,DatDOSReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatDOSReader.cs,LoadRomFromDat,The following statement contains a magic number: string name = line.Substring(posName + 5' posSize - (posName + 5));
Magic Number,ROMVault2.DatReaders,DatDOSReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatDOSReader.cs,LoadRomFromDat,The following statement contains a magic number: string size = line.Substring(posSize + 6' posDate - (posSize + 6));
Magic Number,ROMVault2.DatReaders,DatDOSReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatDOSReader.cs,LoadRomFromDat,The following statement contains a magic number: string size = line.Substring(posSize + 6' posDate - (posSize + 6));
Magic Number,ROMVault2.DatReaders,DatDOSReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatDOSReader.cs,LoadRomFromDat,The following statement contains a magic number: string crc = line.Substring(posCrc + 5' posEnd - (posCrc + 5));
Magic Number,ROMVault2.DatReaders,DatDOSReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatDOSReader.cs,LoadRomFromDat,The following statement contains a magic number: string crc = line.Substring(posCrc + 5' posEnd - (posCrc + 5));
Magic Number,ROMVault2.DatReaders,DatDOSReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatDOSReader.cs,LoadRomFromDat,The following statement contains a magic number: RvFile tRom = new RvFile(thisFileType)                                {                                    Dat = tGame.Dat'                                     Name = VarFix.CleanFullFileName(name.Trim())'                                     Size = VarFix.ULong(size.Trim())'                                     CRC = VarFix.CleanMD5SHA1(crc.Trim()' 8)                                };
Magic Number,ROMVault2.DatReaders,DatFileLoader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatDOSReader.cs,Gn,The following statement contains a magic number: while ((_line.Trim().Length == 0) && (!_streamReader.EndOfStream))                  {                      _line = _streamReader.ReadLine();                      if (String.IsNullOrEmpty(_line)) _line = "";                      _line = _line.Replace("" + (char)9' " ");                      _line = _line.Trim() + " ";                  }
Magic Number,ROMVault2.DatReaders,DatFileLoader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatDOSReader.cs,Gn,The following statement contains a magic number: while ((_line.Trim().Length == 0) && (!_streamReader.EndOfStream))                  {                      _line = _streamReader.ReadLine();                      _line = (_line??"").Replace("" + (char)9' " ");                      if (_line.TrimStart().Length > 2 && _line.TrimStart().Substring(0' 2) == @"//") _line = "";                      if (_line.TrimStart().Length > 1 && _line.TrimStart().Substring(0' 1) == @"#") _line = "";                      if (_line.TrimStart().Length > 1 && _line.TrimStart().Substring(0' 1) == @";") _line = "";                      _line = _line.Trim() + " ";                  }
Magic Number,ROMVault2.DatReaders,DatFileLoader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatDOSReader.cs,Gn,The following statement contains a magic number: while ((_line.Trim().Length == 0) && (!_streamReader.EndOfStream))                  {                      _line = _streamReader.ReadLine();                      _line = (_line??"").Replace("" + (char)9' " ");                      if (_line.TrimStart().Length > 2 && _line.TrimStart().Substring(0' 2) == @"//") _line = "";                      if (_line.TrimStart().Length > 1 && _line.TrimStart().Substring(0' 1) == @"#") _line = "";                      if (_line.TrimStart().Length > 1 && _line.TrimStart().Substring(0' 1) == @";") _line = "";                      _line = _line.Trim() + " ";                  }
Magic Number,ROMVault2.DatReaders,DatFileLoader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatDOSReader.cs,Gn,The following statement contains a magic number: while ((_line.Trim().Length == 0) && (!_streamReader.EndOfStream))                  {                      _line = _streamReader.ReadLine();                      _line = (_line??"").Replace("" + (char)9' " ");                      if (_line.TrimStart().Length > 2 && _line.TrimStart().Substring(0' 2) == @"//") _line = "";                      if (_line.TrimStart().Length > 1 && _line.TrimStart().Substring(0' 1) == @"#") _line = "";                      if (_line.TrimStart().Length > 1 && _line.TrimStart().Substring(0' 1) == @";") _line = "";                      _line = _line.Trim() + " ";                  }
Magic Number,ROMVault2.DatReaders,DatCmpReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatCmpReader.cs,LoadRomFromDat,The following statement contains a magic number: while (DatFileLoader.Next != ")")              {                  switch (DatFileLoader.Next.ToLower())                  {                      case "size": tRom.Size = VarFix.ULong(DatFileLoader.Gn()); DatFileLoader.Gn(); break;                      case "crc": tRom.CRC = VarFix.CleanMD5SHA1(DatFileLoader.Gn()' 8); DatFileLoader.Gn(); break;                      case "sha1": tRom.SHA1 = VarFix.CleanMD5SHA1(DatFileLoader.Gn()' 40); DatFileLoader.Gn(); break;                      case "md5": tRom.MD5 = VarFix.CleanMD5SHA1(DatFileLoader.Gn()' 32); DatFileLoader.Gn(); break;                      case "merge": tRom.Merge = VarFix.CleanFullFileName(DatFileLoader.Gn()); DatFileLoader.Gn(); break;                      case "flags": tRom.Status = VarFix.ToLower(DatFileLoader.Gn()); DatFileLoader.Gn(); break;                      case "date": DatFileLoader.Gn(); DatFileLoader.Gn(); break;                      case "bios": DatFileLoader.Gn(); DatFileLoader.Gn(); break;                      case "region": DatFileLoader.Gn(); DatFileLoader.Gn(); break;                      case "offs": DatFileLoader.Gn(); DatFileLoader.Gn(); break;                      case "nodump": tRom.Status = "nodump"; DatFileLoader.Gn(); break;                      default:                          DatUpdate.SendAndShowDat(Resources.DatCmpReader_ReadDat_Error_keyword + DatFileLoader.Next + Resources.DatCmpReader_LoadRomFromDat_not_known_in_rom' DatFileLoader.Filename);                          DatFileLoader.Gn();                          break;                  }              }
Magic Number,ROMVault2.DatReaders,DatCmpReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatCmpReader.cs,LoadRomFromDat,The following statement contains a magic number: while (DatFileLoader.Next != ")")              {                  switch (DatFileLoader.Next.ToLower())                  {                      case "size": tRom.Size = VarFix.ULong(DatFileLoader.Gn()); DatFileLoader.Gn(); break;                      case "crc": tRom.CRC = VarFix.CleanMD5SHA1(DatFileLoader.Gn()' 8); DatFileLoader.Gn(); break;                      case "sha1": tRom.SHA1 = VarFix.CleanMD5SHA1(DatFileLoader.Gn()' 40); DatFileLoader.Gn(); break;                      case "md5": tRom.MD5 = VarFix.CleanMD5SHA1(DatFileLoader.Gn()' 32); DatFileLoader.Gn(); break;                      case "merge": tRom.Merge = VarFix.CleanFullFileName(DatFileLoader.Gn()); DatFileLoader.Gn(); break;                      case "flags": tRom.Status = VarFix.ToLower(DatFileLoader.Gn()); DatFileLoader.Gn(); break;                      case "date": DatFileLoader.Gn(); DatFileLoader.Gn(); break;                      case "bios": DatFileLoader.Gn(); DatFileLoader.Gn(); break;                      case "region": DatFileLoader.Gn(); DatFileLoader.Gn(); break;                      case "offs": DatFileLoader.Gn(); DatFileLoader.Gn(); break;                      case "nodump": tRom.Status = "nodump"; DatFileLoader.Gn(); break;                      default:                          DatUpdate.SendAndShowDat(Resources.DatCmpReader_ReadDat_Error_keyword + DatFileLoader.Next + Resources.DatCmpReader_LoadRomFromDat_not_known_in_rom' DatFileLoader.Filename);                          DatFileLoader.Gn();                          break;                  }              }
Magic Number,ROMVault2.DatReaders,DatCmpReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatCmpReader.cs,LoadRomFromDat,The following statement contains a magic number: while (DatFileLoader.Next != ")")              {                  switch (DatFileLoader.Next.ToLower())                  {                      case "size": tRom.Size = VarFix.ULong(DatFileLoader.Gn()); DatFileLoader.Gn(); break;                      case "crc": tRom.CRC = VarFix.CleanMD5SHA1(DatFileLoader.Gn()' 8); DatFileLoader.Gn(); break;                      case "sha1": tRom.SHA1 = VarFix.CleanMD5SHA1(DatFileLoader.Gn()' 40); DatFileLoader.Gn(); break;                      case "md5": tRom.MD5 = VarFix.CleanMD5SHA1(DatFileLoader.Gn()' 32); DatFileLoader.Gn(); break;                      case "merge": tRom.Merge = VarFix.CleanFullFileName(DatFileLoader.Gn()); DatFileLoader.Gn(); break;                      case "flags": tRom.Status = VarFix.ToLower(DatFileLoader.Gn()); DatFileLoader.Gn(); break;                      case "date": DatFileLoader.Gn(); DatFileLoader.Gn(); break;                      case "bios": DatFileLoader.Gn(); DatFileLoader.Gn(); break;                      case "region": DatFileLoader.Gn(); DatFileLoader.Gn(); break;                      case "offs": DatFileLoader.Gn(); DatFileLoader.Gn(); break;                      case "nodump": tRom.Status = "nodump"; DatFileLoader.Gn(); break;                      default:                          DatUpdate.SendAndShowDat(Resources.DatCmpReader_ReadDat_Error_keyword + DatFileLoader.Next + Resources.DatCmpReader_LoadRomFromDat_not_known_in_rom' DatFileLoader.Filename);                          DatFileLoader.Gn();                          break;                  }              }
Magic Number,ROMVault2.DatReaders,DatCmpReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatCmpReader.cs,LoadDiskFromDat,The following statement contains a magic number: while (DatFileLoader.Next != ")")              {                  switch (DatFileLoader.Next.ToLower())                  {                      case "sha1": tRom.SHA1CHD = VarFix.CleanMD5SHA1(DatFileLoader.Gn()' 40); DatFileLoader.Gn(); break;                      case "md5": tRom.MD5CHD = VarFix.CleanMD5SHA1(DatFileLoader.Gn()' 32); DatFileLoader.Gn(); break;                      case "merge": tRom.Merge = VarFix.CleanFullFileName(DatFileLoader.Gn()); DatFileLoader.Gn(); break;                      case "flags": tRom.Status = VarFix.ToLower(DatFileLoader.Gn()); DatFileLoader.Gn(); break;                      case "nodump": tRom.Status = "nodump"; DatFileLoader.Gn(); break;                      default:                          DatUpdate.SendAndShowDat(Resources.DatCmpReader_ReadDat_Error_keyword + DatFileLoader.Next + Resources.DatCmpReader_LoadRomFromDat_not_known_in_rom' DatFileLoader.Filename);                          DatFileLoader.Gn();                          break;                  }              }
Magic Number,ROMVault2.DatReaders,DatCmpReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatCmpReader.cs,LoadDiskFromDat,The following statement contains a magic number: while (DatFileLoader.Next != ")")              {                  switch (DatFileLoader.Next.ToLower())                  {                      case "sha1": tRom.SHA1CHD = VarFix.CleanMD5SHA1(DatFileLoader.Gn()' 40); DatFileLoader.Gn(); break;                      case "md5": tRom.MD5CHD = VarFix.CleanMD5SHA1(DatFileLoader.Gn()' 32); DatFileLoader.Gn(); break;                      case "merge": tRom.Merge = VarFix.CleanFullFileName(DatFileLoader.Gn()); DatFileLoader.Gn(); break;                      case "flags": tRom.Status = VarFix.ToLower(DatFileLoader.Gn()); DatFileLoader.Gn(); break;                      case "nodump": tRom.Status = "nodump"; DatFileLoader.Gn(); break;                      default:                          DatUpdate.SendAndShowDat(Resources.DatCmpReader_ReadDat_Error_keyword + DatFileLoader.Next + Resources.DatCmpReader_LoadRomFromDat_not_known_in_rom' DatFileLoader.Filename);                          DatFileLoader.Gn();                          break;                  }              }
Magic Number,ROMVault2.DatReaders,DatMessXmlReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatMessXMLReader.cs,LoadRomFromDat,The following statement contains a magic number: if (name != null)              {                  RvFile tRom = new RvFile(thisFileType) // changed                  {                      Name = VarFix.CleanFullFileName(name)'                      Size = VarFix.ULong(romNode.Attributes.GetNamedItem("size"))'                      CRC = VarFix.CleanMD5SHA1(romNode.Attributes.GetNamedItem("crc")' 8)'                      SHA1 = VarFix.CleanMD5SHA1(romNode.Attributes.GetNamedItem("sha1")' 40)'                      Status = VarFix.ToLower(romNode.Attributes.GetNamedItem("status"))'                        Dat = tGame.Dat                  };                    if (tRom.Size != null) tRom.FileStatusSet(FileStatus.SizeFromDAT);                  if (tRom.CRC != null) tRom.FileStatusSet(FileStatus.CRCFromDAT);                  if (tRom.SHA1 != null) tRom.FileStatusSet(FileStatus.SHA1FromDAT);                    _indexContinue = tGame.ChildAdd(tRom);              }              else if (loadflag.ToLower() == "continue" || loadflag.ToLower()=="ignore")              {                  RvFile tZippedFile = (RvFile)tGame.Child(_indexContinue);                  tZippedFile.Size += VarFix.ULong(romNode.Attributes.GetNamedItem("size"));              }
Magic Number,ROMVault2.DatReaders,DatMessXmlReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatMessXMLReader.cs,LoadRomFromDat,The following statement contains a magic number: if (name != null)              {                  RvFile tRom = new RvFile(thisFileType) // changed                  {                      Name = VarFix.CleanFullFileName(name)'                      Size = VarFix.ULong(romNode.Attributes.GetNamedItem("size"))'                      CRC = VarFix.CleanMD5SHA1(romNode.Attributes.GetNamedItem("crc")' 8)'                      SHA1 = VarFix.CleanMD5SHA1(romNode.Attributes.GetNamedItem("sha1")' 40)'                      Status = VarFix.ToLower(romNode.Attributes.GetNamedItem("status"))'                        Dat = tGame.Dat                  };                    if (tRom.Size != null) tRom.FileStatusSet(FileStatus.SizeFromDAT);                  if (tRom.CRC != null) tRom.FileStatusSet(FileStatus.CRCFromDAT);                  if (tRom.SHA1 != null) tRom.FileStatusSet(FileStatus.SHA1FromDAT);                    _indexContinue = tGame.ChildAdd(tRom);              }              else if (loadflag.ToLower() == "continue" || loadflag.ToLower()=="ignore")              {                  RvFile tZippedFile = (RvFile)tGame.Child(_indexContinue);                  tZippedFile.Size += VarFix.ULong(romNode.Attributes.GetNamedItem("size"));              }
Magic Number,ROMVault2.DatReaders,DatMessXmlReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatMessXMLReader.cs,LoadDiskFromDat,The following statement contains a magic number: RvFile tRom = new RvFile(FileType.File)              {                  Name = VarFix.CleanFullFileName(name) + ".chd"'                  SHA1CHD = VarFix.CleanMD5SHA1(romNode.Attributes.GetNamedItem("sha1")' 40)'                  Status = VarFix.ToLower(romNode.Attributes.GetNamedItem("status"))'                    Dat = tGame.Dat              };
Magic Number,ROMVault2.DatReaders,DatXmlReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatXMLReader.cs,LoadRomFromDat,The following statement contains a magic number: RvFile tRom = new RvFile(thisFileType)                                {                                    Dat = tGame.Dat'                                    Size = VarFix.ULong(romNode.Attributes.GetNamedItem("size"))'                                    Name = VarFix.CleanFullFileName(romNode.Attributes.GetNamedItem("name"))'                                    CRC = VarFix.CleanMD5SHA1(romNode.Attributes.GetNamedItem("crc")' 8)'                                    SHA1 = VarFix.CleanMD5SHA1(romNode.Attributes.GetNamedItem("sha1")' 40)'                                    MD5 = VarFix.CleanMD5SHA1(romNode.Attributes.GetNamedItem("md5")' 32)'                                    Merge = VarFix.CleanFullFileName(romNode.Attributes.GetNamedItem("merge"))'                                    Status = VarFix.ToLower(romNode.Attributes.GetNamedItem("status"))                                };
Magic Number,ROMVault2.DatReaders,DatXmlReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatXMLReader.cs,LoadRomFromDat,The following statement contains a magic number: RvFile tRom = new RvFile(thisFileType)                                {                                    Dat = tGame.Dat'                                    Size = VarFix.ULong(romNode.Attributes.GetNamedItem("size"))'                                    Name = VarFix.CleanFullFileName(romNode.Attributes.GetNamedItem("name"))'                                    CRC = VarFix.CleanMD5SHA1(romNode.Attributes.GetNamedItem("crc")' 8)'                                    SHA1 = VarFix.CleanMD5SHA1(romNode.Attributes.GetNamedItem("sha1")' 40)'                                    MD5 = VarFix.CleanMD5SHA1(romNode.Attributes.GetNamedItem("md5")' 32)'                                    Merge = VarFix.CleanFullFileName(romNode.Attributes.GetNamedItem("merge"))'                                    Status = VarFix.ToLower(romNode.Attributes.GetNamedItem("status"))                                };
Magic Number,ROMVault2.DatReaders,DatXmlReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatXMLReader.cs,LoadRomFromDat,The following statement contains a magic number: RvFile tRom = new RvFile(thisFileType)                                {                                    Dat = tGame.Dat'                                    Size = VarFix.ULong(romNode.Attributes.GetNamedItem("size"))'                                    Name = VarFix.CleanFullFileName(romNode.Attributes.GetNamedItem("name"))'                                    CRC = VarFix.CleanMD5SHA1(romNode.Attributes.GetNamedItem("crc")' 8)'                                    SHA1 = VarFix.CleanMD5SHA1(romNode.Attributes.GetNamedItem("sha1")' 40)'                                    MD5 = VarFix.CleanMD5SHA1(romNode.Attributes.GetNamedItem("md5")' 32)'                                    Merge = VarFix.CleanFullFileName(romNode.Attributes.GetNamedItem("merge"))'                                    Status = VarFix.ToLower(romNode.Attributes.GetNamedItem("status"))                                };
Magic Number,ROMVault2.DatReaders,DatXmlReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatXMLReader.cs,LoadDiskFromDat,The following statement contains a magic number: RvFile tRom = new RvFile(FileType.File)              {                  Dat = tGame.Dat'                  Name = VarFix.CleanFullFileName(romNode.Attributes.GetNamedItem("name")) + ".chd"'                  SHA1CHD = VarFix.CleanMD5SHA1(romNode.Attributes.GetNamedItem("sha1")' 40)'                  MD5CHD = VarFix.CleanMD5SHA1(romNode.Attributes.GetNamedItem("md5")' 32)'                  Merge = VarFix.CleanFullFileName(romNode.Attributes.GetNamedItem("merge"))'                  Status = VarFix.ToLower(romNode.Attributes.GetNamedItem("status"))              };
Magic Number,ROMVault2.DatReaders,DatXmlReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatXMLReader.cs,LoadDiskFromDat,The following statement contains a magic number: RvFile tRom = new RvFile(FileType.File)              {                  Dat = tGame.Dat'                  Name = VarFix.CleanFullFileName(romNode.Attributes.GetNamedItem("name")) + ".chd"'                  SHA1CHD = VarFix.CleanMD5SHA1(romNode.Attributes.GetNamedItem("sha1")' 40)'                  MD5CHD = VarFix.CleanMD5SHA1(romNode.Attributes.GetNamedItem("md5")' 32)'                  Merge = VarFix.CleanFullFileName(romNode.Attributes.GetNamedItem("merge"))'                  Status = VarFix.ToLower(romNode.Attributes.GetNamedItem("status"))              };
Magic Number,ROMVault2.RvDB,RvDir,C:\repos\gjefferyes_RomVault\ROMVault2\RvDB\RvDir.cs,Read,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  RvDat dat = new RvDat { DatIndex = i };                  dat.Read(br);                  _dirDats.Add(dat);                    string datname = TreeFullName + @"\" + dat.GetData(RvDat.DatData.DatName);                  if (datname.Length >= 9 && datname.Substring(0' 9) == @"RomVault\")                      datname = datname.Substring(9);                    DB.Bgw.ReportProgress(0' new bgwText("Loading: " + datname));                  DB.Bgw.ReportProgress((int)br.BaseStream.Position);                }
Magic Number,ROMVault2.RvDB,RvDir,C:\repos\gjefferyes_RomVault\ROMVault2\RvDB\RvDir.cs,Read,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  RvDat dat = new RvDat { DatIndex = i };                  dat.Read(br);                  _dirDats.Add(dat);                    string datname = TreeFullName + @"\" + dat.GetData(RvDat.DatData.DatName);                  if (datname.Length >= 9 && datname.Substring(0' 9) == @"RomVault\")                      datname = datname.Substring(9);                    DB.Bgw.ReportProgress(0' new bgwText("Loading: " + datname));                  DB.Bgw.ReportProgress((int)br.BaseStream.Position);                }
Magic Number,ROMVault2.RvDB,RvDir,C:\repos\gjefferyes_RomVault\ROMVault2\RvDB\RvDir.cs,Read,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  RvDat dat = new RvDat { DatIndex = i };                  dat.Read(br);                  _dirDats.Add(dat);                    string datname = TreeFullName + @"\" + dat.GetData(RvDat.DatData.DatName);                  if (datname.Length >= 9 && datname.Substring(0' 9) == @"RomVault\")                      datname = datname.Substring(9);                    DB.Bgw.ReportProgress(0' new bgwText("Loading: " + datname));                  DB.Bgw.ReportProgress((int)br.BaseStream.Position);                }
Magic Number,ROMVault2.RvDB,RvDir,C:\repos\gjefferyes_RomVault\ROMVault2\RvDB\RvDir.cs,DirDatSearch,The following statement contains a magic number: while (intBottom < intTop && intRes != 0)              {                  intMid = (intBottom + intTop) / 2;                    intRes = DBHelper.DatCompare(dat' _dirDats[intMid]);                  if (intRes < 0)                      intTop = intMid;                  else if (intRes > 0)                      intBottom = intMid + 1;              }
Magic Number,ROMVault2.RvDB,RvDir,C:\repos\gjefferyes_RomVault\ROMVault2\RvDB\RvDir.cs,ChildNameSearch,The following statement contains a magic number: while (intBottom < intTop && intRes != 0)              {                  intMid = (intBottom + intTop) / 2;                    intRes = DBHelper.CompareName(lName' _children[intMid]);                  if (intRes < 0)                      intTop = intMid;                  else if (intRes > 0)                      intBottom = intMid + 1;              }
Magic Number,ROMVault2.RvDB,DB,C:\repos\gjefferyes_RomVault\ROMVault2\RvDB\DB.cs,Read,The following statement contains a magic number: if (fs.Length < 4)                  ReportError.UnhandledExceptionHandler("Cache is Corrupt' revert to Backup.");
Magic Number,ROMVault2.RvDB,DB,C:\repos\gjefferyes_RomVault\ROMVault2\RvDB\DB.cs,Read,The following statement contains a magic number: if (fs.Position > fs.Length - 8)                  ReportError.UnhandledExceptionHandler("Cache is Corrupt' revert to Backup.");
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,CRC32,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Crc32.cs,_InternalComputeCrc32,The following statement contains a magic number: return (Int32)(crc32Table[(W ^ B) & 0xFF] ^ (W >> 8));
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,CRC32,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Crc32.cs,SlurpBlock,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int x = offset + i;                  byte b = block[x];                  if (this.reverseBits)                  {                      UInt32 temp = (_register >> 24) ^ b;                      _register = (_register << 8) ^ crc32Table[temp];                  }                  else                  {                      UInt32 temp = (_register & 0x000000FF) ^ b;                      _register = (_register >> 8) ^ crc32Table[temp];                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,CRC32,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Crc32.cs,SlurpBlock,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int x = offset + i;                  byte b = block[x];                  if (this.reverseBits)                  {                      UInt32 temp = (_register >> 24) ^ b;                      _register = (_register << 8) ^ crc32Table[temp];                  }                  else                  {                      UInt32 temp = (_register & 0x000000FF) ^ b;                      _register = (_register >> 8) ^ crc32Table[temp];                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,CRC32,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Crc32.cs,SlurpBlock,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int x = offset + i;                  byte b = block[x];                  if (this.reverseBits)                  {                      UInt32 temp = (_register >> 24) ^ b;                      _register = (_register << 8) ^ crc32Table[temp];                  }                  else                  {                      UInt32 temp = (_register & 0x000000FF) ^ b;                      _register = (_register >> 8) ^ crc32Table[temp];                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,CRC32,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Crc32.cs,UpdateCRC,The following statement contains a magic number: if (this.reverseBits)              {                  UInt32 temp = (_register >> 24) ^ b;                  _register = (_register << 8) ^ crc32Table[temp];              }              else              {                  UInt32 temp = (_register & 0x000000FF) ^ b;                  _register = (_register >> 8) ^ crc32Table[temp];              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,CRC32,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Crc32.cs,UpdateCRC,The following statement contains a magic number: if (this.reverseBits)              {                  UInt32 temp = (_register >> 24) ^ b;                  _register = (_register << 8) ^ crc32Table[temp];              }              else              {                  UInt32 temp = (_register & 0x000000FF) ^ b;                  _register = (_register >> 8) ^ crc32Table[temp];              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,CRC32,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Crc32.cs,UpdateCRC,The following statement contains a magic number: if (this.reverseBits)              {                  UInt32 temp = (_register >> 24) ^ b;                  _register = (_register << 8) ^ crc32Table[temp];              }              else              {                  UInt32 temp = (_register & 0x000000FF) ^ b;                  _register = (_register >> 8) ^ crc32Table[temp];              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,CRC32,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Crc32.cs,UpdateCRC,The following statement contains a magic number: while (n-- > 0)              {                  if (this.reverseBits)                  {                      uint temp = (_register >> 24) ^ b;                      _register = (_register << 8) ^ crc32Table[(temp >= 0)                                                                ? temp                                                                : (temp + 256)];                  }                  else                  {                      UInt32 temp = (_register & 0x000000FF) ^ b;                      _register = (_register >> 8) ^ crc32Table[(temp >= 0)                                                                ? temp                                                                : (temp + 256)];                    }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,CRC32,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Crc32.cs,UpdateCRC,The following statement contains a magic number: while (n-- > 0)              {                  if (this.reverseBits)                  {                      uint temp = (_register >> 24) ^ b;                      _register = (_register << 8) ^ crc32Table[(temp >= 0)                                                                ? temp                                                                : (temp + 256)];                  }                  else                  {                      UInt32 temp = (_register & 0x000000FF) ^ b;                      _register = (_register >> 8) ^ crc32Table[(temp >= 0)                                                                ? temp                                                                : (temp + 256)];                    }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,CRC32,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Crc32.cs,UpdateCRC,The following statement contains a magic number: while (n-- > 0)              {                  if (this.reverseBits)                  {                      uint temp = (_register >> 24) ^ b;                      _register = (_register << 8) ^ crc32Table[(temp >= 0)                                                                ? temp                                                                : (temp + 256)];                  }                  else                  {                      UInt32 temp = (_register & 0x000000FF) ^ b;                      _register = (_register >> 8) ^ crc32Table[(temp >= 0)                                                                ? temp                                                                : (temp + 256)];                    }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,CRC32,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Crc32.cs,UpdateCRC,The following statement contains a magic number: while (n-- > 0)              {                  if (this.reverseBits)                  {                      uint temp = (_register >> 24) ^ b;                      _register = (_register << 8) ^ crc32Table[(temp >= 0)                                                                ? temp                                                                : (temp + 256)];                  }                  else                  {                      UInt32 temp = (_register & 0x000000FF) ^ b;                      _register = (_register >> 8) ^ crc32Table[(temp >= 0)                                                                ? temp                                                                : (temp + 256)];                    }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,CRC32,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Crc32.cs,UpdateCRC,The following statement contains a magic number: while (n-- > 0)              {                  if (this.reverseBits)                  {                      uint temp = (_register >> 24) ^ b;                      _register = (_register << 8) ^ crc32Table[(temp >= 0)                                                                ? temp                                                                : (temp + 256)];                  }                  else                  {                      UInt32 temp = (_register & 0x000000FF) ^ b;                      _register = (_register >> 8) ^ crc32Table[(temp >= 0)                                                                ? temp                                                                : (temp + 256)];                    }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,CRC32,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Crc32.cs,ReverseBits,The following statement contains a magic number: unchecked              {                  uint ret = data;                  ret = (ret & 0x55555555) << 1 | (ret >> 1) & 0x55555555;                  ret = (ret & 0x33333333) << 2 | (ret >> 2) & 0x33333333;                  ret = (ret & 0x0F0F0F0F) << 4 | (ret >> 4) & 0x0F0F0F0F;                  ret = (ret << 24) | ((ret & 0xFF00) << 8) | ((ret >> 8) & 0xFF00) | (ret >> 24);                  return ret;              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,CRC32,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Crc32.cs,ReverseBits,The following statement contains a magic number: unchecked              {                  uint ret = data;                  ret = (ret & 0x55555555) << 1 | (ret >> 1) & 0x55555555;                  ret = (ret & 0x33333333) << 2 | (ret >> 2) & 0x33333333;                  ret = (ret & 0x0F0F0F0F) << 4 | (ret >> 4) & 0x0F0F0F0F;                  ret = (ret << 24) | ((ret & 0xFF00) << 8) | ((ret >> 8) & 0xFF00) | (ret >> 24);                  return ret;              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,CRC32,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Crc32.cs,ReverseBits,The following statement contains a magic number: unchecked              {                  uint ret = data;                  ret = (ret & 0x55555555) << 1 | (ret >> 1) & 0x55555555;                  ret = (ret & 0x33333333) << 2 | (ret >> 2) & 0x33333333;                  ret = (ret & 0x0F0F0F0F) << 4 | (ret >> 4) & 0x0F0F0F0F;                  ret = (ret << 24) | ((ret & 0xFF00) << 8) | ((ret >> 8) & 0xFF00) | (ret >> 24);                  return ret;              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,CRC32,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Crc32.cs,ReverseBits,The following statement contains a magic number: unchecked              {                  uint ret = data;                  ret = (ret & 0x55555555) << 1 | (ret >> 1) & 0x55555555;                  ret = (ret & 0x33333333) << 2 | (ret >> 2) & 0x33333333;                  ret = (ret & 0x0F0F0F0F) << 4 | (ret >> 4) & 0x0F0F0F0F;                  ret = (ret << 24) | ((ret & 0xFF00) << 8) | ((ret >> 8) & 0xFF00) | (ret >> 24);                  return ret;              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,CRC32,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Crc32.cs,ReverseBits,The following statement contains a magic number: unchecked              {                  uint ret = data;                  ret = (ret & 0x55555555) << 1 | (ret >> 1) & 0x55555555;                  ret = (ret & 0x33333333) << 2 | (ret >> 2) & 0x33333333;                  ret = (ret & 0x0F0F0F0F) << 4 | (ret >> 4) & 0x0F0F0F0F;                  ret = (ret << 24) | ((ret & 0xFF00) << 8) | ((ret >> 8) & 0xFF00) | (ret >> 24);                  return ret;              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,CRC32,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Crc32.cs,ReverseBits,The following statement contains a magic number: unchecked              {                  uint ret = data;                  ret = (ret & 0x55555555) << 1 | (ret >> 1) & 0x55555555;                  ret = (ret & 0x33333333) << 2 | (ret >> 2) & 0x33333333;                  ret = (ret & 0x0F0F0F0F) << 4 | (ret >> 4) & 0x0F0F0F0F;                  ret = (ret << 24) | ((ret & 0xFF00) << 8) | ((ret >> 8) & 0xFF00) | (ret >> 24);                  return ret;              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,CRC32,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Crc32.cs,ReverseBits,The following statement contains a magic number: unchecked              {                  uint ret = data;                  ret = (ret & 0x55555555) << 1 | (ret >> 1) & 0x55555555;                  ret = (ret & 0x33333333) << 2 | (ret >> 2) & 0x33333333;                  ret = (ret & 0x0F0F0F0F) << 4 | (ret >> 4) & 0x0F0F0F0F;                  ret = (ret << 24) | ((ret & 0xFF00) << 8) | ((ret >> 8) & 0xFF00) | (ret >> 24);                  return ret;              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,CRC32,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Crc32.cs,ReverseBits,The following statement contains a magic number: unchecked              {                  uint ret = data;                  ret = (ret & 0x55555555) << 1 | (ret >> 1) & 0x55555555;                  ret = (ret & 0x33333333) << 2 | (ret >> 2) & 0x33333333;                  ret = (ret & 0x0F0F0F0F) << 4 | (ret >> 4) & 0x0F0F0F0F;                  ret = (ret << 24) | ((ret & 0xFF00) << 8) | ((ret >> 8) & 0xFF00) | (ret >> 24);                  return ret;              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,CRC32,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Crc32.cs,ReverseBits,The following statement contains a magic number: unchecked              {                  uint u = (uint)data * 0x00020202;                  uint m = 0x01044010;                  uint s = u & m;                  uint t = (u << 2) & (m << 1);                  return (byte)((0x01001001 * (s + t)) >> 24);              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,CRC32,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Crc32.cs,ReverseBits,The following statement contains a magic number: unchecked              {                  uint u = (uint)data * 0x00020202;                  uint m = 0x01044010;                  uint s = u & m;                  uint t = (u << 2) & (m << 1);                  return (byte)((0x01001001 * (s + t)) >> 24);              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,CRC32,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Crc32.cs,GenerateLookupTable,The following statement contains a magic number: crc32Table = new UInt32[256];
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,CRC32,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Crc32.cs,GenerateLookupTable,The following statement contains a magic number: unchecked              {                  UInt32 dwCrc;                  byte i = 0;                  do                  {                      dwCrc = i;                      for (byte j = 8; j > 0; j--)                      {                          if ((dwCrc & 1) == 1)                          {                              dwCrc = (dwCrc >> 1) ^ dwPolynomial;                          }                          else                          {                              dwCrc >>= 1;                          }                      }                      if (reverseBits)                      {                          crc32Table[ReverseBits(i)] = ReverseBits(dwCrc);                      }                      else                      {                          crc32Table[i] = dwCrc;                      }                      i++;                  } while (i != 0);              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,CRC32,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Crc32.cs,gf2_matrix_square,The following statement contains a magic number: for (int i = 0; i < 32; i++)                  square[i] = gf2_matrix_times(mat' mat[i]);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,CRC32,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Crc32.cs,Combine,The following statement contains a magic number: uint[] even = new uint[32];
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,CRC32,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Crc32.cs,Combine,The following statement contains a magic number: uint[] odd = new uint[32];
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,CRC32,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Crc32.cs,Combine,The following statement contains a magic number: for (int i = 1; i < 32; i++)              {                  odd[i] = row;                  row <<= 1;              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,CRC32Hash,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Crc32.cs,HashFinal,The following statement contains a magic number: HashValue = new[]                                   {                                       (byte) ((crcValue >> 24) & 0xff)'                                       (byte) ((crcValue >> 16) & 0xff)'                                       (byte) ((crcValue >> 8) & 0xff)'                                       (byte) (crcValue & 0xff)                                   };
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,CRC32Hash,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Crc32.cs,HashFinal,The following statement contains a magic number: HashValue = new[]                                   {                                       (byte) ((crcValue >> 24) & 0xff)'                                       (byte) ((crcValue >> 16) & 0xff)'                                       (byte) ((crcValue >> 8) & 0xff)'                                       (byte) (crcValue & 0xff)                                   };
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,CRC32Hash,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Crc32.cs,HashFinal,The following statement contains a magic number: HashValue = new[]                                   {                                       (byte) ((crcValue >> 24) & 0xff)'                                       (byte) ((crcValue >> 16) & 0xff)'                                       (byte) ((crcValue >> 8) & 0xff)'                                       (byte) (crcValue & 0xff)                                   };
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,DeflateManager,The following statement contains a magic number: dyn_ltree = new short[HEAP_SIZE * 2];
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,DeflateManager,The following statement contains a magic number: dyn_dtree = new short[(2 * InternalConstants.D_CODES + 1) * 2];
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,DeflateManager,The following statement contains a magic number: dyn_dtree = new short[(2 * InternalConstants.D_CODES + 1) * 2];
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,DeflateManager,The following statement contains a magic number: bl_tree = new short[(2 * InternalConstants.BL_CODES + 1) * 2];
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,DeflateManager,The following statement contains a magic number: bl_tree = new short[(2 * InternalConstants.BL_CODES + 1) * 2];
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,_InitializeLazyMatch,The following statement contains a magic number: window_size = 2 * w_size;
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,_InitializeTreeData,The following statement contains a magic number: last_eob_len = 8;
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,_InitializeBlocks,The following statement contains a magic number: for (int i = 0; i < InternalConstants.L_CODES; i++)                  dyn_ltree[i * 2] = 0;
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,_InitializeBlocks,The following statement contains a magic number: for (int i = 0; i < InternalConstants.D_CODES; i++)                  dyn_dtree[i * 2] = 0;
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,_InitializeBlocks,The following statement contains a magic number: for (int i = 0; i < InternalConstants.BL_CODES; i++)                  bl_tree[i * 2] = 0;
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,_InitializeBlocks,The following statement contains a magic number: dyn_ltree[END_BLOCK * 2] = 1;
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,_IsSmaller,The following statement contains a magic number: short tn2 = tree[n * 2];
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,_IsSmaller,The following statement contains a magic number: short tm2 = tree[m * 2];
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,scan_tree,The following statement contains a magic number: int nextlen = (int)tree[0 * 2 + 1];
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,scan_tree,The following statement contains a magic number: int max_count = 7;
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,scan_tree,The following statement contains a magic number: int min_count = 4;
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,scan_tree,The following statement contains a magic number: if (nextlen == 0)              {                  max_count = 138; min_count = 3;              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,scan_tree,The following statement contains a magic number: if (nextlen == 0)              {                  max_count = 138; min_count = 3;              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,scan_tree,The following statement contains a magic number: tree[(max_code + 1) * 2 + 1] = (short)0x7fff;
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = (int)tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short)(bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[InternalConstants.REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[InternalConstants.REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[InternalConstants.REPZ_11_138 * 2]++;                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = (int)tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short)(bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[InternalConstants.REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[InternalConstants.REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[InternalConstants.REPZ_11_138 * 2]++;                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = (int)tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short)(bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[InternalConstants.REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[InternalConstants.REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[InternalConstants.REPZ_11_138 * 2]++;                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = (int)tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short)(bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[InternalConstants.REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[InternalConstants.REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[InternalConstants.REPZ_11_138 * 2]++;                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = (int)tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short)(bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[InternalConstants.REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[InternalConstants.REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[InternalConstants.REPZ_11_138 * 2]++;                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = (int)tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short)(bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[InternalConstants.REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[InternalConstants.REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[InternalConstants.REPZ_11_138 * 2]++;                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = (int)tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short)(bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[InternalConstants.REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[InternalConstants.REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[InternalConstants.REPZ_11_138 * 2]++;                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = (int)tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short)(bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[InternalConstants.REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[InternalConstants.REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[InternalConstants.REPZ_11_138 * 2]++;                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = (int)tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short)(bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[InternalConstants.REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[InternalConstants.REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[InternalConstants.REPZ_11_138 * 2]++;                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = (int)tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short)(bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[InternalConstants.REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[InternalConstants.REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[InternalConstants.REPZ_11_138 * 2]++;                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = (int)tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short)(bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[InternalConstants.REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[InternalConstants.REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[InternalConstants.REPZ_11_138 * 2]++;                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = (int)tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short)(bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[InternalConstants.REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[InternalConstants.REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[InternalConstants.REPZ_11_138 * 2]++;                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = (int)tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short)(bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[InternalConstants.REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[InternalConstants.REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[InternalConstants.REPZ_11_138 * 2]++;                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = (int)tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short)(bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[InternalConstants.REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[InternalConstants.REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[InternalConstants.REPZ_11_138 * 2]++;                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,build_bl_tree,The following statement contains a magic number: for (max_blindex = InternalConstants.BL_CODES - 1; max_blindex >= 3; max_blindex--)              {                  if (bl_tree[Tree.bl_order[max_blindex] * 2 + 1] != 0)                      break;              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,build_bl_tree,The following statement contains a magic number: for (max_blindex = InternalConstants.BL_CODES - 1; max_blindex >= 3; max_blindex--)              {                  if (bl_tree[Tree.bl_order[max_blindex] * 2 + 1] != 0)                      break;              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(lcodes - 257' 5);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(lcodes - 257' 5);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(dcodes - 1' 5);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(blcodes - 4' 4);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(blcodes - 4' 4);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,send_all_trees,The following statement contains a magic number: for (rank = 0; rank < blcodes; rank++)              {                  send_bits(bl_tree[Tree.bl_order[rank] * 2 + 1]' 3);              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,send_all_trees,The following statement contains a magic number: for (rank = 0; rank < blcodes; rank++)              {                  send_bits(bl_tree[Tree.bl_order[rank] * 2 + 1]' 3);              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,send_tree,The following statement contains a magic number: int nextlen   = tree[0 * 2 + 1];
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,send_tree,The following statement contains a magic number: int max_count = 7;
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,send_tree,The following statement contains a magic number: int min_count = 4;
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,send_tree,The following statement contains a magic number: if (nextlen == 0)              {                  max_count = 138; min_count = 3;              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,send_tree,The following statement contains a magic number: if (nextlen == 0)              {                  max_count = 138; min_count = 3;              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      }                      while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree); count--;                      }                      send_code(InternalConstants.REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(InternalConstants.REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(InternalConstants.REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      }                      while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree); count--;                      }                      send_code(InternalConstants.REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(InternalConstants.REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(InternalConstants.REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      }                      while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree); count--;                      }                      send_code(InternalConstants.REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(InternalConstants.REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(InternalConstants.REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      }                      while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree); count--;                      }                      send_code(InternalConstants.REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(InternalConstants.REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(InternalConstants.REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      }                      while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree); count--;                      }                      send_code(InternalConstants.REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(InternalConstants.REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(InternalConstants.REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      }                      while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree); count--;                      }                      send_code(InternalConstants.REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(InternalConstants.REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(InternalConstants.REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      }                      while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree); count--;                      }                      send_code(InternalConstants.REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(InternalConstants.REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(InternalConstants.REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      }                      while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree); count--;                      }                      send_code(InternalConstants.REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(InternalConstants.REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(InternalConstants.REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      }                      while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree); count--;                      }                      send_code(InternalConstants.REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(InternalConstants.REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(InternalConstants.REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      }                      while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree); count--;                      }                      send_code(InternalConstants.REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(InternalConstants.REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(InternalConstants.REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      }                      while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree); count--;                      }                      send_code(InternalConstants.REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(InternalConstants.REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(InternalConstants.REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      }                      while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree); count--;                      }                      send_code(InternalConstants.REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(InternalConstants.REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(InternalConstants.REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      }                      while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree); count--;                      }                      send_code(InternalConstants.REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(InternalConstants.REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(InternalConstants.REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      }                      while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree); count--;                      }                      send_code(InternalConstants.REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(InternalConstants.REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(InternalConstants.REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,send_code,The following statement contains a magic number: int c2 = c * 2;
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,send_bits,The following statement contains a magic number: unchecked              {                  if (bi_valid > (int)Buf_size - len)                  {                      //int val = value;                      //      bi_buf |= (val << bi_valid);                        bi_buf |= (short)((value << bi_valid) & 0xffff);                      //put_short(bi_buf);                      pending[pendingCount++] = (byte)bi_buf;                      pending[pendingCount++] = (byte)(bi_buf >> 8);                          bi_buf = (short)((uint)value >> (Buf_size - bi_valid));                      bi_valid += len - Buf_size;                  }                  else                  {                      //      bi_buf |= (value) << bi_valid;                      bi_buf |= (short)((value << bi_valid) & 0xffff);                      bi_valid += len;                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,_tr_align,The following statement contains a magic number: send_bits(STATIC_TREES << 1' 3);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,_tr_align,The following statement contains a magic number: if (1 + last_eob_len + 10 - bi_valid < 9)              {                  send_bits(STATIC_TREES << 1' 3);                  send_code(END_BLOCK' StaticTree.lengthAndLiteralsTreeCodes);                  bi_flush();              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,_tr_align,The following statement contains a magic number: if (1 + last_eob_len + 10 - bi_valid < 9)              {                  send_bits(STATIC_TREES << 1' 3);                  send_code(END_BLOCK' StaticTree.lengthAndLiteralsTreeCodes);                  bi_flush();              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,_tr_align,The following statement contains a magic number: if (1 + last_eob_len + 10 - bi_valid < 9)              {                  send_bits(STATIC_TREES << 1' 3);                  send_code(END_BLOCK' StaticTree.lengthAndLiteralsTreeCodes);                  bi_flush();              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,_tr_align,The following statement contains a magic number: last_eob_len = 7;
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,_tr_tally,The following statement contains a magic number: pending[_distanceOffset + last_lit * 2] = unchecked((byte)((uint)dist >> 8));
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,_tr_tally,The following statement contains a magic number: pending[_distanceOffset + last_lit * 2] = unchecked((byte)((uint)dist >> 8));
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,_tr_tally,The following statement contains a magic number: pending[_distanceOffset + last_lit * 2 + 1] = unchecked((byte)dist);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,_tr_tally,The following statement contains a magic number: if (dist == 0)              {                  // lc is the unmatched char                  dyn_ltree[lc * 2]++;              }              else              {                  matches++;                  // Here' lc is the match length - MIN_MATCH                  dist--; // dist = match distance - 1                  dyn_ltree[(Tree.LengthCode[lc] + InternalConstants.LITERALS + 1) * 2]++;                  dyn_dtree[Tree.DistanceCode(dist) * 2]++;              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,_tr_tally,The following statement contains a magic number: if (dist == 0)              {                  // lc is the unmatched char                  dyn_ltree[lc * 2]++;              }              else              {                  matches++;                  // Here' lc is the match length - MIN_MATCH                  dist--; // dist = match distance - 1                  dyn_ltree[(Tree.LengthCode[lc] + InternalConstants.LITERALS + 1) * 2]++;                  dyn_dtree[Tree.DistanceCode(dist) * 2]++;              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,_tr_tally,The following statement contains a magic number: if (dist == 0)              {                  // lc is the unmatched char                  dyn_ltree[lc * 2]++;              }              else              {                  matches++;                  // Here' lc is the match length - MIN_MATCH                  dist--; // dist = match distance - 1                  dyn_ltree[(Tree.LengthCode[lc] + InternalConstants.LITERALS + 1) * 2]++;                  dyn_dtree[Tree.DistanceCode(dist) * 2]++;              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,send_compressed_block,The following statement contains a magic number: if (last_lit != 0)              {                  do                  {                      int ix = _distanceOffset + lx * 2;                      distance = ((pending[ix] << 8) & 0xff00) |                          (pending[ix + 1] & 0xff);                      lc = (pending[_lengthOffset + lx]) & 0xff;                      lx++;                        if (distance == 0)                      {                          send_code(lc' ltree); // send a literal byte                      }                      else                      {                          // literal or match pair                          // Here' lc is the match length - MIN_MATCH                          code = Tree.LengthCode[lc];                            // send the length code                          send_code(code + InternalConstants.LITERALS + 1' ltree);                          extra = Tree.ExtraLengthBits[code];                          if (extra != 0)                          {                              // send the extra length bits                              lc -= Tree.LengthBase[code];                              send_bits(lc' extra);                          }                          distance--; // dist is now the match distance - 1                          code = Tree.DistanceCode(distance);                            // send the distance code                          send_code(code' dtree);                            extra = Tree.ExtraDistanceBits[code];                          if (extra != 0)                          {                              // send the extra distance bits                              distance -= Tree.DistanceBase[code];                              send_bits(distance' extra);                          }                      }                        // Check that the overlay between pending and d_buf+l_buf is ok:                  }                  while (lx < last_lit);              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,send_compressed_block,The following statement contains a magic number: if (last_lit != 0)              {                  do                  {                      int ix = _distanceOffset + lx * 2;                      distance = ((pending[ix] << 8) & 0xff00) |                          (pending[ix + 1] & 0xff);                      lc = (pending[_lengthOffset + lx]) & 0xff;                      lx++;                        if (distance == 0)                      {                          send_code(lc' ltree); // send a literal byte                      }                      else                      {                          // literal or match pair                          // Here' lc is the match length - MIN_MATCH                          code = Tree.LengthCode[lc];                            // send the length code                          send_code(code + InternalConstants.LITERALS + 1' ltree);                          extra = Tree.ExtraLengthBits[code];                          if (extra != 0)                          {                              // send the extra length bits                              lc -= Tree.LengthBase[code];                              send_bits(lc' extra);                          }                          distance--; // dist is now the match distance - 1                          code = Tree.DistanceCode(distance);                            // send the distance code                          send_code(code' dtree);                            extra = Tree.ExtraDistanceBits[code];                          if (extra != 0)                          {                              // send the extra distance bits                              distance -= Tree.DistanceBase[code];                              send_bits(distance' extra);                          }                      }                        // Check that the overlay between pending and d_buf+l_buf is ok:                  }                  while (lx < last_lit);              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,send_compressed_block,The following statement contains a magic number: last_eob_len = ltree[END_BLOCK * 2 + 1];
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,set_data_type,The following statement contains a magic number: while (n < 7)              {                  bin_freq += dyn_ltree[n * 2]; n++;              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,set_data_type,The following statement contains a magic number: while (n < 7)              {                  bin_freq += dyn_ltree[n * 2]; n++;              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,set_data_type,The following statement contains a magic number: while (n < 128)              {                  ascii_freq += dyn_ltree[n * 2]; n++;              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,set_data_type,The following statement contains a magic number: while (n < 128)              {                  ascii_freq += dyn_ltree[n * 2]; n++;              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,set_data_type,The following statement contains a magic number: while (n < InternalConstants.LITERALS)              {                  bin_freq += dyn_ltree[n * 2]; n++;              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,set_data_type,The following statement contains a magic number: data_type = (sbyte)(bin_freq > (ascii_freq >> 2) ? Z_BINARY : Z_ASCII);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,bi_flush,The following statement contains a magic number: if (bi_valid == 16)              {                  pending[pendingCount++] = (byte)bi_buf;                  pending[pendingCount++] = (byte)(bi_buf >> 8);                  bi_buf = 0;                  bi_valid = 0;              }              else if (bi_valid >= 8)              {                  //put_byte((byte)bi_buf);                  pending[pendingCount++] = (byte)bi_buf;                  bi_buf >>= 8;                  bi_valid -= 8;              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,bi_flush,The following statement contains a magic number: if (bi_valid == 16)              {                  pending[pendingCount++] = (byte)bi_buf;                  pending[pendingCount++] = (byte)(bi_buf >> 8);                  bi_buf = 0;                  bi_valid = 0;              }              else if (bi_valid >= 8)              {                  //put_byte((byte)bi_buf);                  pending[pendingCount++] = (byte)bi_buf;                  bi_buf >>= 8;                  bi_valid -= 8;              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,bi_flush,The following statement contains a magic number: if (bi_valid == 16)              {                  pending[pendingCount++] = (byte)bi_buf;                  pending[pendingCount++] = (byte)(bi_buf >> 8);                  bi_buf = 0;                  bi_valid = 0;              }              else if (bi_valid >= 8)              {                  //put_byte((byte)bi_buf);                  pending[pendingCount++] = (byte)bi_buf;                  bi_buf >>= 8;                  bi_valid -= 8;              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,bi_flush,The following statement contains a magic number: if (bi_valid == 16)              {                  pending[pendingCount++] = (byte)bi_buf;                  pending[pendingCount++] = (byte)(bi_buf >> 8);                  bi_buf = 0;                  bi_valid = 0;              }              else if (bi_valid >= 8)              {                  //put_byte((byte)bi_buf);                  pending[pendingCount++] = (byte)bi_buf;                  bi_buf >>= 8;                  bi_valid -= 8;              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,bi_flush,The following statement contains a magic number: if (bi_valid == 16)              {                  pending[pendingCount++] = (byte)bi_buf;                  pending[pendingCount++] = (byte)(bi_buf >> 8);                  bi_buf = 0;                  bi_valid = 0;              }              else if (bi_valid >= 8)              {                  //put_byte((byte)bi_buf);                  pending[pendingCount++] = (byte)bi_buf;                  bi_buf >>= 8;                  bi_valid -= 8;              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,bi_windup,The following statement contains a magic number: if (bi_valid > 8)              {                  pending[pendingCount++] = (byte)bi_buf;                  pending[pendingCount++] = (byte)(bi_buf >> 8);              }              else if (bi_valid > 0)              {                  //put_byte((byte)bi_buf);                  pending[pendingCount++] = (byte)bi_buf;              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,bi_windup,The following statement contains a magic number: if (bi_valid > 8)              {                  pending[pendingCount++] = (byte)bi_buf;                  pending[pendingCount++] = (byte)(bi_buf >> 8);              }              else if (bi_valid > 0)              {                  //put_byte((byte)bi_buf);                  pending[pendingCount++] = (byte)bi_buf;              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,copy_block,The following statement contains a magic number: last_eob_len = 8;
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,copy_block,The following statement contains a magic number: if (header)                  unchecked                  {                      //put_short((short)len);                      pending[pendingCount++] = (byte)len;                      pending[pendingCount++] = (byte)(len >> 8);                      //put_short((short)~len);                      pending[pendingCount++] = (byte)~len;                      pending[pendingCount++] = (byte)(~len >> 8);                  }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,copy_block,The following statement contains a magic number: if (header)                  unchecked                  {                      //put_short((short)len);                      pending[pendingCount++] = (byte)len;                      pending[pendingCount++] = (byte)(len >> 8);                      //put_short((short)~len);                      pending[pendingCount++] = (byte)~len;                      pending[pendingCount++] = (byte)(~len >> 8);                  }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,DeflateNone,The following statement contains a magic number: if (max_block_size > pending.Length - 5)              {                  max_block_size = pending.Length - 5;              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,DeflateNone,The following statement contains a magic number: if (max_block_size > pending.Length - 5)              {                  max_block_size = pending.Length - 5;              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,_tr_stored_block,The following statement contains a magic number: send_bits((STORED_BLOCK << 1) + (eof ? 1 : 0)' 3);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (compressionLevel > 0)              {                  // Check if the file is ascii or binary                  if (data_type == Z_UNKNOWN)                      set_data_type();                    // Construct the literal and distance trees                  treeLiterals.build_tree(this);                    treeDistances.build_tree(this);                    // At this point' opt_len and static_len are the total bit lengths of                  // the compressed block data' excluding the tree representations.                    // Build the bit length tree for the above two trees' and get the index                  // in bl_order of the last bit length code to send.                  max_blindex = build_bl_tree();                    // Determine the best encoding. Compute first the block length in bytes                  opt_lenb = (opt_len + 3 + 7) >> 3;                  static_lenb = (static_len + 3 + 7) >> 3;                    if (static_lenb <= opt_lenb)                      opt_lenb = static_lenb;              }              else              {                  opt_lenb = static_lenb = stored_len + 5; // force a stored block              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (compressionLevel > 0)              {                  // Check if the file is ascii or binary                  if (data_type == Z_UNKNOWN)                      set_data_type();                    // Construct the literal and distance trees                  treeLiterals.build_tree(this);                    treeDistances.build_tree(this);                    // At this point' opt_len and static_len are the total bit lengths of                  // the compressed block data' excluding the tree representations.                    // Build the bit length tree for the above two trees' and get the index                  // in bl_order of the last bit length code to send.                  max_blindex = build_bl_tree();                    // Determine the best encoding. Compute first the block length in bytes                  opt_lenb = (opt_len + 3 + 7) >> 3;                  static_lenb = (static_len + 3 + 7) >> 3;                    if (static_lenb <= opt_lenb)                      opt_lenb = static_lenb;              }              else              {                  opt_lenb = static_lenb = stored_len + 5; // force a stored block              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (compressionLevel > 0)              {                  // Check if the file is ascii or binary                  if (data_type == Z_UNKNOWN)                      set_data_type();                    // Construct the literal and distance trees                  treeLiterals.build_tree(this);                    treeDistances.build_tree(this);                    // At this point' opt_len and static_len are the total bit lengths of                  // the compressed block data' excluding the tree representations.                    // Build the bit length tree for the above two trees' and get the index                  // in bl_order of the last bit length code to send.                  max_blindex = build_bl_tree();                    // Determine the best encoding. Compute first the block length in bytes                  opt_lenb = (opt_len + 3 + 7) >> 3;                  static_lenb = (static_len + 3 + 7) >> 3;                    if (static_lenb <= opt_lenb)                      opt_lenb = static_lenb;              }              else              {                  opt_lenb = static_lenb = stored_len + 5; // force a stored block              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (compressionLevel > 0)              {                  // Check if the file is ascii or binary                  if (data_type == Z_UNKNOWN)                      set_data_type();                    // Construct the literal and distance trees                  treeLiterals.build_tree(this);                    treeDistances.build_tree(this);                    // At this point' opt_len and static_len are the total bit lengths of                  // the compressed block data' excluding the tree representations.                    // Build the bit length tree for the above two trees' and get the index                  // in bl_order of the last bit length code to send.                  max_blindex = build_bl_tree();                    // Determine the best encoding. Compute first the block length in bytes                  opt_lenb = (opt_len + 3 + 7) >> 3;                  static_lenb = (static_len + 3 + 7) >> 3;                    if (static_lenb <= opt_lenb)                      opt_lenb = static_lenb;              }              else              {                  opt_lenb = static_lenb = stored_len + 5; // force a stored block              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (compressionLevel > 0)              {                  // Check if the file is ascii or binary                  if (data_type == Z_UNKNOWN)                      set_data_type();                    // Construct the literal and distance trees                  treeLiterals.build_tree(this);                    treeDistances.build_tree(this);                    // At this point' opt_len and static_len are the total bit lengths of                  // the compressed block data' excluding the tree representations.                    // Build the bit length tree for the above two trees' and get the index                  // in bl_order of the last bit length code to send.                  max_blindex = build_bl_tree();                    // Determine the best encoding. Compute first the block length in bytes                  opt_lenb = (opt_len + 3 + 7) >> 3;                  static_lenb = (static_len + 3 + 7) >> 3;                    if (static_lenb <= opt_lenb)                      opt_lenb = static_lenb;              }              else              {                  opt_lenb = static_lenb = stored_len + 5; // force a stored block              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (compressionLevel > 0)              {                  // Check if the file is ascii or binary                  if (data_type == Z_UNKNOWN)                      set_data_type();                    // Construct the literal and distance trees                  treeLiterals.build_tree(this);                    treeDistances.build_tree(this);                    // At this point' opt_len and static_len are the total bit lengths of                  // the compressed block data' excluding the tree representations.                    // Build the bit length tree for the above two trees' and get the index                  // in bl_order of the last bit length code to send.                  max_blindex = build_bl_tree();                    // Determine the best encoding. Compute first the block length in bytes                  opt_lenb = (opt_len + 3 + 7) >> 3;                  static_lenb = (static_len + 3 + 7) >> 3;                    if (static_lenb <= opt_lenb)                      opt_lenb = static_lenb;              }              else              {                  opt_lenb = static_lenb = stored_len + 5; // force a stored block              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (compressionLevel > 0)              {                  // Check if the file is ascii or binary                  if (data_type == Z_UNKNOWN)                      set_data_type();                    // Construct the literal and distance trees                  treeLiterals.build_tree(this);                    treeDistances.build_tree(this);                    // At this point' opt_len and static_len are the total bit lengths of                  // the compressed block data' excluding the tree representations.                    // Build the bit length tree for the above two trees' and get the index                  // in bl_order of the last bit length code to send.                  max_blindex = build_bl_tree();                    // Determine the best encoding. Compute first the block length in bytes                  opt_lenb = (opt_len + 3 + 7) >> 3;                  static_lenb = (static_len + 3 + 7) >> 3;                    if (static_lenb <= opt_lenb)                      opt_lenb = static_lenb;              }              else              {                  opt_lenb = static_lenb = stored_len + 5; // force a stored block              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (stored_len + 4 <= opt_lenb && buf != -1)              {                  // 4: two words for the lengths                  // The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.                  // Otherwise we can't have processed more than WSIZE input bytes since                  // the last block flush' because compression would have been                  // successful. If LIT_BUFSIZE <= WSIZE' it is never too late to                  // transform a block into a stored block.                  _tr_stored_block(buf' stored_len' eof);              }              else if (static_lenb == opt_lenb)              {                  send_bits((STATIC_TREES << 1) + (eof ? 1 : 0)' 3);                  send_compressed_block(StaticTree.lengthAndLiteralsTreeCodes' StaticTree.distTreeCodes);              }              else              {                  send_bits((DYN_TREES << 1) + (eof ? 1 : 0)' 3);                  send_all_trees(treeLiterals.max_code + 1' treeDistances.max_code + 1' max_blindex + 1);                  send_compressed_block(dyn_ltree' dyn_dtree);              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (stored_len + 4 <= opt_lenb && buf != -1)              {                  // 4: two words for the lengths                  // The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.                  // Otherwise we can't have processed more than WSIZE input bytes since                  // the last block flush' because compression would have been                  // successful. If LIT_BUFSIZE <= WSIZE' it is never too late to                  // transform a block into a stored block.                  _tr_stored_block(buf' stored_len' eof);              }              else if (static_lenb == opt_lenb)              {                  send_bits((STATIC_TREES << 1) + (eof ? 1 : 0)' 3);                  send_compressed_block(StaticTree.lengthAndLiteralsTreeCodes' StaticTree.distTreeCodes);              }              else              {                  send_bits((DYN_TREES << 1) + (eof ? 1 : 0)' 3);                  send_all_trees(treeLiterals.max_code + 1' treeDistances.max_code + 1' max_blindex + 1);                  send_compressed_block(dyn_ltree' dyn_dtree);              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (stored_len + 4 <= opt_lenb && buf != -1)              {                  // 4: two words for the lengths                  // The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.                  // Otherwise we can't have processed more than WSIZE input bytes since                  // the last block flush' because compression would have been                  // successful. If LIT_BUFSIZE <= WSIZE' it is never too late to                  // transform a block into a stored block.                  _tr_stored_block(buf' stored_len' eof);              }              else if (static_lenb == opt_lenb)              {                  send_bits((STATIC_TREES << 1) + (eof ? 1 : 0)' 3);                  send_compressed_block(StaticTree.lengthAndLiteralsTreeCodes' StaticTree.distTreeCodes);              }              else              {                  send_bits((DYN_TREES << 1) + (eof ? 1 : 0)' 3);                  send_all_trees(treeLiterals.max_code + 1' treeDistances.max_code + 1' max_blindex + 1);                  send_compressed_block(dyn_ltree' dyn_dtree);              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,DeflateSlow,The following statement contains a magic number: while (true)              {                  // Make sure that we always have enough lookahead' except                  // at the end of the input file. We need MAX_MATCH bytes                  // for the next match' plus MIN_MATCH bytes to insert the                  // string following the next match.                    if (lookahead < MIN_LOOKAHEAD)                  {                      _fillWindow();                      if (lookahead < MIN_LOOKAHEAD && flush == FlushType.None)                          return BlockState.NeedMore;                        if (lookahead == 0)                          break; // flush the current block                  }                    // Insert the string window[strstart .. strstart+2] in the                  // dictionary' and set hash_head to the head of the hash chain:                    if (lookahead >= MIN_MATCH)                  {                      ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;                      //  prev[strstart&w_mask]=hash_head=head[ins_h];                      hash_head = (head[ins_h] & 0xffff);                      prev[strstart & w_mask] = head[ins_h];                      head[ins_h] = unchecked((short)strstart);                  }                    // Find the longest match' discarding those <= prev_length.                  prev_length = match_length;                  prev_match = match_start;                  match_length = MIN_MATCH - 1;                    if (hash_head != 0 && prev_length < config.MaxLazy &&                      ((strstart - hash_head) & 0xffff) <= w_size - MIN_LOOKAHEAD)                  {                      // To simplify the code' we prevent matches with the string                      // of window index 0 (in particular we have to avoid a match                      // of the string with itself at the start of the input file).                        if (compressionStrategy != CompressionStrategy.HuffmanOnly)                      {                          match_length = longest_match(hash_head);                      }                      // longest_match() sets match_start                        if (match_length <= 5 && (compressionStrategy == CompressionStrategy.Filtered ||                                                (match_length == MIN_MATCH && strstart - match_start > 4096)))                      {                            // If prev_match is also MIN_MATCH' match_start is garbage                          // but we will ignore the current match anyway.                          match_length = MIN_MATCH - 1;                      }                  }                    // If there was a match at the previous step and the current                  // match is not better' output the previous match:                  if (prev_length >= MIN_MATCH && match_length <= prev_length)                  {                      int max_insert = strstart + lookahead - MIN_MATCH;                      // Do not insert strings in hash table beyond this.                        //          check_match(strstart-1' prev_match' prev_length);                        bflush = _tr_tally(strstart - 1 - prev_match' prev_length - MIN_MATCH);                        // Insert in hash table all strings up to the end of the match.                      // strstart-1 and strstart are already inserted. If there is not                      // enough lookahead' the last two strings are not inserted in                      // the hash table.                      lookahead -= (prev_length - 1);                      prev_length -= 2;                      do                      {                          if (++strstart <= max_insert)                          {                              ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;                              //prev[strstart&w_mask]=hash_head=head[ins_h];                              hash_head = (head[ins_h] & 0xffff);                              prev[strstart & w_mask] = head[ins_h];                              head[ins_h] = unchecked((short)strstart);                          }                      }                      while (--prev_length != 0);                      match_available = 0;                      match_length = MIN_MATCH - 1;                      strstart++;                        if (bflush)                      {                          flush_block_only(false);                          if (_codec.AvailableBytesOut == 0)                              return BlockState.NeedMore;                      }                  }                  else if (match_available != 0)                  {                        // If there was no match at the previous position' output a                      // single literal. If there was a match but the current match                      // is longer' truncate the previous match to a single literal.                        bflush = _tr_tally(0' window[strstart - 1] & 0xff);                        if (bflush)                      {                          flush_block_only(false);                      }                      strstart++;                      lookahead--;                      if (_codec.AvailableBytesOut == 0)                          return BlockState.NeedMore;                  }                  else                  {                      // There is no previous match to compare with' wait for                      // the next step to decide.                        match_available = 1;                      strstart++;                      lookahead--;                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,DeflateSlow,The following statement contains a magic number: while (true)              {                  // Make sure that we always have enough lookahead' except                  // at the end of the input file. We need MAX_MATCH bytes                  // for the next match' plus MIN_MATCH bytes to insert the                  // string following the next match.                    if (lookahead < MIN_LOOKAHEAD)                  {                      _fillWindow();                      if (lookahead < MIN_LOOKAHEAD && flush == FlushType.None)                          return BlockState.NeedMore;                        if (lookahead == 0)                          break; // flush the current block                  }                    // Insert the string window[strstart .. strstart+2] in the                  // dictionary' and set hash_head to the head of the hash chain:                    if (lookahead >= MIN_MATCH)                  {                      ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;                      //  prev[strstart&w_mask]=hash_head=head[ins_h];                      hash_head = (head[ins_h] & 0xffff);                      prev[strstart & w_mask] = head[ins_h];                      head[ins_h] = unchecked((short)strstart);                  }                    // Find the longest match' discarding those <= prev_length.                  prev_length = match_length;                  prev_match = match_start;                  match_length = MIN_MATCH - 1;                    if (hash_head != 0 && prev_length < config.MaxLazy &&                      ((strstart - hash_head) & 0xffff) <= w_size - MIN_LOOKAHEAD)                  {                      // To simplify the code' we prevent matches with the string                      // of window index 0 (in particular we have to avoid a match                      // of the string with itself at the start of the input file).                        if (compressionStrategy != CompressionStrategy.HuffmanOnly)                      {                          match_length = longest_match(hash_head);                      }                      // longest_match() sets match_start                        if (match_length <= 5 && (compressionStrategy == CompressionStrategy.Filtered ||                                                (match_length == MIN_MATCH && strstart - match_start > 4096)))                      {                            // If prev_match is also MIN_MATCH' match_start is garbage                          // but we will ignore the current match anyway.                          match_length = MIN_MATCH - 1;                      }                  }                    // If there was a match at the previous step and the current                  // match is not better' output the previous match:                  if (prev_length >= MIN_MATCH && match_length <= prev_length)                  {                      int max_insert = strstart + lookahead - MIN_MATCH;                      // Do not insert strings in hash table beyond this.                        //          check_match(strstart-1' prev_match' prev_length);                        bflush = _tr_tally(strstart - 1 - prev_match' prev_length - MIN_MATCH);                        // Insert in hash table all strings up to the end of the match.                      // strstart-1 and strstart are already inserted. If there is not                      // enough lookahead' the last two strings are not inserted in                      // the hash table.                      lookahead -= (prev_length - 1);                      prev_length -= 2;                      do                      {                          if (++strstart <= max_insert)                          {                              ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;                              //prev[strstart&w_mask]=hash_head=head[ins_h];                              hash_head = (head[ins_h] & 0xffff);                              prev[strstart & w_mask] = head[ins_h];                              head[ins_h] = unchecked((short)strstart);                          }                      }                      while (--prev_length != 0);                      match_available = 0;                      match_length = MIN_MATCH - 1;                      strstart++;                        if (bflush)                      {                          flush_block_only(false);                          if (_codec.AvailableBytesOut == 0)                              return BlockState.NeedMore;                      }                  }                  else if (match_available != 0)                  {                        // If there was no match at the previous position' output a                      // single literal. If there was a match but the current match                      // is longer' truncate the previous match to a single literal.                        bflush = _tr_tally(0' window[strstart - 1] & 0xff);                        if (bflush)                      {                          flush_block_only(false);                      }                      strstart++;                      lookahead--;                      if (_codec.AvailableBytesOut == 0)                          return BlockState.NeedMore;                  }                  else                  {                      // There is no previous match to compare with' wait for                      // the next step to decide.                        match_available = 1;                      strstart++;                      lookahead--;                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,DeflateSlow,The following statement contains a magic number: while (true)              {                  // Make sure that we always have enough lookahead' except                  // at the end of the input file. We need MAX_MATCH bytes                  // for the next match' plus MIN_MATCH bytes to insert the                  // string following the next match.                    if (lookahead < MIN_LOOKAHEAD)                  {                      _fillWindow();                      if (lookahead < MIN_LOOKAHEAD && flush == FlushType.None)                          return BlockState.NeedMore;                        if (lookahead == 0)                          break; // flush the current block                  }                    // Insert the string window[strstart .. strstart+2] in the                  // dictionary' and set hash_head to the head of the hash chain:                    if (lookahead >= MIN_MATCH)                  {                      ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;                      //  prev[strstart&w_mask]=hash_head=head[ins_h];                      hash_head = (head[ins_h] & 0xffff);                      prev[strstart & w_mask] = head[ins_h];                      head[ins_h] = unchecked((short)strstart);                  }                    // Find the longest match' discarding those <= prev_length.                  prev_length = match_length;                  prev_match = match_start;                  match_length = MIN_MATCH - 1;                    if (hash_head != 0 && prev_length < config.MaxLazy &&                      ((strstart - hash_head) & 0xffff) <= w_size - MIN_LOOKAHEAD)                  {                      // To simplify the code' we prevent matches with the string                      // of window index 0 (in particular we have to avoid a match                      // of the string with itself at the start of the input file).                        if (compressionStrategy != CompressionStrategy.HuffmanOnly)                      {                          match_length = longest_match(hash_head);                      }                      // longest_match() sets match_start                        if (match_length <= 5 && (compressionStrategy == CompressionStrategy.Filtered ||                                                (match_length == MIN_MATCH && strstart - match_start > 4096)))                      {                            // If prev_match is also MIN_MATCH' match_start is garbage                          // but we will ignore the current match anyway.                          match_length = MIN_MATCH - 1;                      }                  }                    // If there was a match at the previous step and the current                  // match is not better' output the previous match:                  if (prev_length >= MIN_MATCH && match_length <= prev_length)                  {                      int max_insert = strstart + lookahead - MIN_MATCH;                      // Do not insert strings in hash table beyond this.                        //          check_match(strstart-1' prev_match' prev_length);                        bflush = _tr_tally(strstart - 1 - prev_match' prev_length - MIN_MATCH);                        // Insert in hash table all strings up to the end of the match.                      // strstart-1 and strstart are already inserted. If there is not                      // enough lookahead' the last two strings are not inserted in                      // the hash table.                      lookahead -= (prev_length - 1);                      prev_length -= 2;                      do                      {                          if (++strstart <= max_insert)                          {                              ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;                              //prev[strstart&w_mask]=hash_head=head[ins_h];                              hash_head = (head[ins_h] & 0xffff);                              prev[strstart & w_mask] = head[ins_h];                              head[ins_h] = unchecked((short)strstart);                          }                      }                      while (--prev_length != 0);                      match_available = 0;                      match_length = MIN_MATCH - 1;                      strstart++;                        if (bflush)                      {                          flush_block_only(false);                          if (_codec.AvailableBytesOut == 0)                              return BlockState.NeedMore;                      }                  }                  else if (match_available != 0)                  {                        // If there was no match at the previous position' output a                      // single literal. If there was a match but the current match                      // is longer' truncate the previous match to a single literal.                        bflush = _tr_tally(0' window[strstart - 1] & 0xff);                        if (bflush)                      {                          flush_block_only(false);                      }                      strstart++;                      lookahead--;                      if (_codec.AvailableBytesOut == 0)                          return BlockState.NeedMore;                  }                  else                  {                      // There is no previous match to compare with' wait for                      // the next step to decide.                        match_available = 1;                      strstart++;                      lookahead--;                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,longest_match,The following statement contains a magic number: if (prev_length >= config.GoodLength)              {                  chain_length >>= 2;              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,longest_match,The following statement contains a magic number: do              {                  match = cur_match;                    // Skip to next match if the match length cannot increase                  // or if the match length is less than 2:                  if (window[match + best_len] != scan_end ||                      window[match + best_len - 1] != scan_end1 ||                      window[match] != window[scan] ||                      window[++match] != window[scan + 1])                      continue;                    // The check at best_len-1 can be removed because it will be made                  // again later. (This heuristic is not always a win.)                  // It is not necessary to compare scan[2] and match[2] since they                  // are always equal when the other bytes match' given that                  // the hash keys are equal and that HASH_BITS >= 8.                  scan += 2; match++;                    // We check for insufficient lookahead only every 8th comparison;                  // the 256th check will be made at strstart+258.                  do                  {                  }                  while (window[++scan] == window[++match] &&                         window[++scan] == window[++match] &&                         window[++scan] == window[++match] &&                         window[++scan] == window[++match] &&                         window[++scan] == window[++match] &&                         window[++scan] == window[++match] &&                         window[++scan] == window[++match] &&                         window[++scan] == window[++match] && scan < strend);                    len = MAX_MATCH - (int)(strend - scan);                  scan = strend - MAX_MATCH;                    if (len > best_len)                  {                      match_start = cur_match;                      best_len = len;                      if (len >= niceLength)                          break;                      scan_end1 = window[scan + best_len - 1];                      scan_end = window[scan + best_len];                  }              }              while ((cur_match = (prev[cur_match & wmask] & 0xffff)) > limit && --chain_length != 0);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Initialize,The following statement contains a magic number: if (windowBits < 9 || windowBits > 15)                  throw new ZlibException("windowBits must be in the range 9..15.");
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Initialize,The following statement contains a magic number: if (windowBits < 9 || windowBits > 15)                  throw new ZlibException("windowBits must be in the range 9..15.");
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Initialize,The following statement contains a magic number: hash_bits = memLevel + 7;
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Initialize,The following statement contains a magic number: window = new byte[w_size * 2];
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Initialize,The following statement contains a magic number: lit_bufsize = 1 << (memLevel + 6);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Initialize,The following statement contains a magic number: pending = new byte[lit_bufsize * 4];
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Initialize,The following statement contains a magic number: _lengthOffset = (1 + 2) * lit_bufsize;
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Deflate,The following statement contains a magic number: if (status == INIT_STATE)              {                  int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;                  int level_flags = (((int)compressionLevel - 1) & 0xff) >> 1;                    if (level_flags > 3)                      level_flags = 3;                  header |= (level_flags << 6);                  if (strstart != 0)                      header |= PRESET_DICT;                  header += 31 - (header % 31);                    status = BUSY_STATE;                  //putShortMSB(header);                  unchecked                  {                      pending[pendingCount++] = (byte)(header >> 8);                      pending[pendingCount++] = (byte)header;                  }                  // Save the adler32 of the preset dictionary:                  if (strstart != 0)                  {                      pending[pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000) >> 24);                      pending[pendingCount++] = (byte)((_codec._Adler32 & 0x00FF0000) >> 16);                      pending[pendingCount++] = (byte)((_codec._Adler32 & 0x0000FF00) >> 8);                      pending[pendingCount++] = (byte)(_codec._Adler32 & 0x000000FF);                  }                  _codec._Adler32 = Adler.Adler32(0' null' 0' 0);              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Deflate,The following statement contains a magic number: if (status == INIT_STATE)              {                  int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;                  int level_flags = (((int)compressionLevel - 1) & 0xff) >> 1;                    if (level_flags > 3)                      level_flags = 3;                  header |= (level_flags << 6);                  if (strstart != 0)                      header |= PRESET_DICT;                  header += 31 - (header % 31);                    status = BUSY_STATE;                  //putShortMSB(header);                  unchecked                  {                      pending[pendingCount++] = (byte)(header >> 8);                      pending[pendingCount++] = (byte)header;                  }                  // Save the adler32 of the preset dictionary:                  if (strstart != 0)                  {                      pending[pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000) >> 24);                      pending[pendingCount++] = (byte)((_codec._Adler32 & 0x00FF0000) >> 16);                      pending[pendingCount++] = (byte)((_codec._Adler32 & 0x0000FF00) >> 8);                      pending[pendingCount++] = (byte)(_codec._Adler32 & 0x000000FF);                  }                  _codec._Adler32 = Adler.Adler32(0' null' 0' 0);              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Deflate,The following statement contains a magic number: if (status == INIT_STATE)              {                  int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;                  int level_flags = (((int)compressionLevel - 1) & 0xff) >> 1;                    if (level_flags > 3)                      level_flags = 3;                  header |= (level_flags << 6);                  if (strstart != 0)                      header |= PRESET_DICT;                  header += 31 - (header % 31);                    status = BUSY_STATE;                  //putShortMSB(header);                  unchecked                  {                      pending[pendingCount++] = (byte)(header >> 8);                      pending[pendingCount++] = (byte)header;                  }                  // Save the adler32 of the preset dictionary:                  if (strstart != 0)                  {                      pending[pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000) >> 24);                      pending[pendingCount++] = (byte)((_codec._Adler32 & 0x00FF0000) >> 16);                      pending[pendingCount++] = (byte)((_codec._Adler32 & 0x0000FF00) >> 8);                      pending[pendingCount++] = (byte)(_codec._Adler32 & 0x000000FF);                  }                  _codec._Adler32 = Adler.Adler32(0' null' 0' 0);              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Deflate,The following statement contains a magic number: if (status == INIT_STATE)              {                  int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;                  int level_flags = (((int)compressionLevel - 1) & 0xff) >> 1;                    if (level_flags > 3)                      level_flags = 3;                  header |= (level_flags << 6);                  if (strstart != 0)                      header |= PRESET_DICT;                  header += 31 - (header % 31);                    status = BUSY_STATE;                  //putShortMSB(header);                  unchecked                  {                      pending[pendingCount++] = (byte)(header >> 8);                      pending[pendingCount++] = (byte)header;                  }                  // Save the adler32 of the preset dictionary:                  if (strstart != 0)                  {                      pending[pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000) >> 24);                      pending[pendingCount++] = (byte)((_codec._Adler32 & 0x00FF0000) >> 16);                      pending[pendingCount++] = (byte)((_codec._Adler32 & 0x0000FF00) >> 8);                      pending[pendingCount++] = (byte)(_codec._Adler32 & 0x000000FF);                  }                  _codec._Adler32 = Adler.Adler32(0' null' 0' 0);              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Deflate,The following statement contains a magic number: if (status == INIT_STATE)              {                  int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;                  int level_flags = (((int)compressionLevel - 1) & 0xff) >> 1;                    if (level_flags > 3)                      level_flags = 3;                  header |= (level_flags << 6);                  if (strstart != 0)                      header |= PRESET_DICT;                  header += 31 - (header % 31);                    status = BUSY_STATE;                  //putShortMSB(header);                  unchecked                  {                      pending[pendingCount++] = (byte)(header >> 8);                      pending[pendingCount++] = (byte)header;                  }                  // Save the adler32 of the preset dictionary:                  if (strstart != 0)                  {                      pending[pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000) >> 24);                      pending[pendingCount++] = (byte)((_codec._Adler32 & 0x00FF0000) >> 16);                      pending[pendingCount++] = (byte)((_codec._Adler32 & 0x0000FF00) >> 8);                      pending[pendingCount++] = (byte)(_codec._Adler32 & 0x000000FF);                  }                  _codec._Adler32 = Adler.Adler32(0' null' 0' 0);              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Deflate,The following statement contains a magic number: if (status == INIT_STATE)              {                  int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;                  int level_flags = (((int)compressionLevel - 1) & 0xff) >> 1;                    if (level_flags > 3)                      level_flags = 3;                  header |= (level_flags << 6);                  if (strstart != 0)                      header |= PRESET_DICT;                  header += 31 - (header % 31);                    status = BUSY_STATE;                  //putShortMSB(header);                  unchecked                  {                      pending[pendingCount++] = (byte)(header >> 8);                      pending[pendingCount++] = (byte)header;                  }                  // Save the adler32 of the preset dictionary:                  if (strstart != 0)                  {                      pending[pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000) >> 24);                      pending[pendingCount++] = (byte)((_codec._Adler32 & 0x00FF0000) >> 16);                      pending[pendingCount++] = (byte)((_codec._Adler32 & 0x0000FF00) >> 8);                      pending[pendingCount++] = (byte)(_codec._Adler32 & 0x000000FF);                  }                  _codec._Adler32 = Adler.Adler32(0' null' 0' 0);              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Deflate,The following statement contains a magic number: if (status == INIT_STATE)              {                  int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;                  int level_flags = (((int)compressionLevel - 1) & 0xff) >> 1;                    if (level_flags > 3)                      level_flags = 3;                  header |= (level_flags << 6);                  if (strstart != 0)                      header |= PRESET_DICT;                  header += 31 - (header % 31);                    status = BUSY_STATE;                  //putShortMSB(header);                  unchecked                  {                      pending[pendingCount++] = (byte)(header >> 8);                      pending[pendingCount++] = (byte)header;                  }                  // Save the adler32 of the preset dictionary:                  if (strstart != 0)                  {                      pending[pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000) >> 24);                      pending[pendingCount++] = (byte)((_codec._Adler32 & 0x00FF0000) >> 16);                      pending[pendingCount++] = (byte)((_codec._Adler32 & 0x0000FF00) >> 8);                      pending[pendingCount++] = (byte)(_codec._Adler32 & 0x000000FF);                  }                  _codec._Adler32 = Adler.Adler32(0' null' 0' 0);              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Deflate,The following statement contains a magic number: if (status == INIT_STATE)              {                  int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;                  int level_flags = (((int)compressionLevel - 1) & 0xff) >> 1;                    if (level_flags > 3)                      level_flags = 3;                  header |= (level_flags << 6);                  if (strstart != 0)                      header |= PRESET_DICT;                  header += 31 - (header % 31);                    status = BUSY_STATE;                  //putShortMSB(header);                  unchecked                  {                      pending[pendingCount++] = (byte)(header >> 8);                      pending[pendingCount++] = (byte)header;                  }                  // Save the adler32 of the preset dictionary:                  if (strstart != 0)                  {                      pending[pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000) >> 24);                      pending[pendingCount++] = (byte)((_codec._Adler32 & 0x00FF0000) >> 16);                      pending[pendingCount++] = (byte)((_codec._Adler32 & 0x0000FF00) >> 8);                      pending[pendingCount++] = (byte)(_codec._Adler32 & 0x000000FF);                  }                  _codec._Adler32 = Adler.Adler32(0' null' 0' 0);              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Deflate,The following statement contains a magic number: if (status == INIT_STATE)              {                  int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;                  int level_flags = (((int)compressionLevel - 1) & 0xff) >> 1;                    if (level_flags > 3)                      level_flags = 3;                  header |= (level_flags << 6);                  if (strstart != 0)                      header |= PRESET_DICT;                  header += 31 - (header % 31);                    status = BUSY_STATE;                  //putShortMSB(header);                  unchecked                  {                      pending[pendingCount++] = (byte)(header >> 8);                      pending[pendingCount++] = (byte)header;                  }                  // Save the adler32 of the preset dictionary:                  if (strstart != 0)                  {                      pending[pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000) >> 24);                      pending[pendingCount++] = (byte)((_codec._Adler32 & 0x00FF0000) >> 16);                      pending[pendingCount++] = (byte)((_codec._Adler32 & 0x0000FF00) >> 8);                      pending[pendingCount++] = (byte)(_codec._Adler32 & 0x000000FF);                  }                  _codec._Adler32 = Adler.Adler32(0' null' 0' 0);              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Deflate,The following statement contains a magic number: if (status == INIT_STATE)              {                  int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;                  int level_flags = (((int)compressionLevel - 1) & 0xff) >> 1;                    if (level_flags > 3)                      level_flags = 3;                  header |= (level_flags << 6);                  if (strstart != 0)                      header |= PRESET_DICT;                  header += 31 - (header % 31);                    status = BUSY_STATE;                  //putShortMSB(header);                  unchecked                  {                      pending[pendingCount++] = (byte)(header >> 8);                      pending[pendingCount++] = (byte)header;                  }                  // Save the adler32 of the preset dictionary:                  if (strstart != 0)                  {                      pending[pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000) >> 24);                      pending[pendingCount++] = (byte)((_codec._Adler32 & 0x00FF0000) >> 16);                      pending[pendingCount++] = (byte)((_codec._Adler32 & 0x0000FF00) >> 8);                      pending[pendingCount++] = (byte)(_codec._Adler32 & 0x000000FF);                  }                  _codec._Adler32 = Adler.Adler32(0' null' 0' 0);              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Deflate,The following statement contains a magic number: if (status == INIT_STATE)              {                  int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;                  int level_flags = (((int)compressionLevel - 1) & 0xff) >> 1;                    if (level_flags > 3)                      level_flags = 3;                  header |= (level_flags << 6);                  if (strstart != 0)                      header |= PRESET_DICT;                  header += 31 - (header % 31);                    status = BUSY_STATE;                  //putShortMSB(header);                  unchecked                  {                      pending[pendingCount++] = (byte)(header >> 8);                      pending[pendingCount++] = (byte)header;                  }                  // Save the adler32 of the preset dictionary:                  if (strstart != 0)                  {                      pending[pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000) >> 24);                      pending[pendingCount++] = (byte)((_codec._Adler32 & 0x00FF0000) >> 16);                      pending[pendingCount++] = (byte)((_codec._Adler32 & 0x0000FF00) >> 8);                      pending[pendingCount++] = (byte)(_codec._Adler32 & 0x000000FF);                  }                  _codec._Adler32 = Adler.Adler32(0' null' 0' 0);              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Deflate,The following statement contains a magic number: if (status == INIT_STATE)              {                  int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;                  int level_flags = (((int)compressionLevel - 1) & 0xff) >> 1;                    if (level_flags > 3)                      level_flags = 3;                  header |= (level_flags << 6);                  if (strstart != 0)                      header |= PRESET_DICT;                  header += 31 - (header % 31);                    status = BUSY_STATE;                  //putShortMSB(header);                  unchecked                  {                      pending[pendingCount++] = (byte)(header >> 8);                      pending[pendingCount++] = (byte)header;                  }                  // Save the adler32 of the preset dictionary:                  if (strstart != 0)                  {                      pending[pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000) >> 24);                      pending[pendingCount++] = (byte)((_codec._Adler32 & 0x00FF0000) >> 16);                      pending[pendingCount++] = (byte)((_codec._Adler32 & 0x0000FF00) >> 8);                      pending[pendingCount++] = (byte)(_codec._Adler32 & 0x000000FF);                  }                  _codec._Adler32 = Adler.Adler32(0' null' 0' 0);              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Deflate,The following statement contains a magic number: pending[pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000) >> 24);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Deflate,The following statement contains a magic number: pending[pendingCount++] = (byte)((_codec._Adler32 & 0x00FF0000) >> 16);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Deflate,The following statement contains a magic number: pending[pendingCount++] = (byte)((_codec._Adler32 & 0x0000FF00) >> 8);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Config,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Config,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Config,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Config,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Config,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Config,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Config,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Config,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Config,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Config,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Config,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Config,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Config,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Config,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Config,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Config,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Config,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Config,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Config,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Config,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Config,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Config,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Config,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Config,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Config,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Config,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Config,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Config,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Config,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Config,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Config,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Config,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Config,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Config,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Config,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Config,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,GZipStream,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\GZipStream.cs,EmitHeader,The following statement contains a magic number: int bufferLength = 10 + cbLength + fnLength;
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,GZipStream,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\GZipStream.cs,EmitHeader,The following statement contains a magic number: header[i++] = 8;
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,GZipStream,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\GZipStream.cs,EmitHeader,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(timet)' 0' header' i' 4);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,GZipStream,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\GZipStream.cs,EmitHeader,The following statement contains a magic number: i += 4;
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,InflateBlocks,The following statement contains a magic number: hufts = new int[MANY * 3];
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Flush,The following statement contains a magic number: for (int pass=0; pass < 2; pass++)              {                  if (pass==0)                  {                      // compute number of bytes to copy as far as end of window                      nBytes = (int)((readAt <= writeAt ? writeAt : end) - readAt);                  }                  else                  {                      // compute bytes to copy                      nBytes = writeAt - readAt;                  }                    // workitem 8870                  if (nBytes == 0)                  {                      if (r == ZlibConstants.Z_BUF_ERROR)                          r = ZlibConstants.Z_OK;                      return r;                  }                    if (nBytes > _codec.AvailableBytesOut)                      nBytes = _codec.AvailableBytesOut;                    if (nBytes != 0 && r == ZlibConstants.Z_BUF_ERROR)                      r = ZlibConstants.Z_OK;                    // update counters                  _codec.AvailableBytesOut -= nBytes;                  _codec.TotalBytesOut += nBytes;                    // update check information                  if (checkfn != null)                      _codec._Adler32 = check = Adler.Adler32(check' window' readAt' nBytes);                    // copy as far as end of window                  Array.Copy(window' readAt' _codec.OutputBuffer' _codec.NextOut' nBytes);                  _codec.NextOut += nBytes;                  readAt += nBytes;                    // see if more to copy at beginning of window                  if (readAt == end && pass == 0)                  {                      // wrap pointers                      readAt = 0;                      if (writeAt == end)                          writeAt = 0;                  }                  else pass++;              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateCodes,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: k -= (c << 3);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Initialize,The following statement contains a magic number: if (w < 8 || w > 15)              {                  End();                  throw new ZlibException("Bad window size.");                    //return ZlibConstants.Z_STREAM_ERROR;              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Initialize,The following statement contains a magic number: if (w < 8 || w > 15)              {                  End();                  throw new ZlibException("Bad window size.");                    //return ZlibConstants.Z_STREAM_ERROR;              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Inflate,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Inflate,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Inflate,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Inflate,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Inflate,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Inflate,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Inflate,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Inflate,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Inflate,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Inflate,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Inflate,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Inflate,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Inflate,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Inflate,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Inflate,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Inflate,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Sync,The following statement contains a magic number: while (n != 0 && m < 4)              {                  if (_codec.InputBuffer[p] == mark[m])                  {                      m++;                  }                  else if (_codec.InputBuffer[p] != 0)                  {                      m = 0;                  }                  else                  {                      m = 4 - m;                  }                  p++; n--;              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Sync,The following statement contains a magic number: while (n != 0 && m < 4)              {                  if (_codec.InputBuffer[p] == mark[m])                  {                      m++;                  }                  else if (_codec.InputBuffer[p] != 0)                  {                      m = 0;                  }                  else                  {                      m = 4 - m;                  }                  p++; n--;              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Sync,The following statement contains a magic number: if (m != 4)              {                  return ZlibConstants.Z_DATA_ERROR;              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InfTree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\InfTree.cs,huft_build,The following statement contains a magic number: xp = 2;
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InfTree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)                          {                                  a = c[k];                                  while (a-- != 0)                                  {                                          // here i is the Huffman code of length k bits for value *p                                          // make tables up to required level                                          while (k > w + l)                                          {                                                  h++;                                                  w += l; // previous table always l bits                                                  // compute minimum size table less than or equal to l bits                                                  z = g - w;                                                  z = (z > l)?l:z; // table size upper limit                                                  if ((f = 1 << (j = k - w)) > a + 1)                                                  {                                                          // try a k-w bit table                                                          // too few codes for k-w bit table                                                          f -= (a + 1); // deduct codes from patterns left                                                          xp = k;                                                          if (j < z)                                                          {                                                                  while (++j < z)                                                                  {                                                                          // try smaller tables up to z bits                                                                          if ((f <<= 1) <= c[++xp])                                                                                  break; // enough codes to use up j bits                                                                          f -= c[xp]; // else deduct codes from patterns                                                                  }                                                          }                                                  }                                                  z = 1 << j; // table entries for j-bit table                                                                                                    // allocate new table                                                  if (hn[0] + z > MANY)                                                  {                                                          // (note: doesn't matter for fixed)                                                          return Z_DATA_ERROR; // overflow of MANY                                                  }                                                  u[h] = q = hn[0]; // DEBUG                                                  hn[0] += z;                                                                                                    // connect to last table' if there is one                                                  if (h != 0)                                                  {                                                          x[h] = i; // save pattern for backing up                                                          r[0] = (sbyte) j; // bits in this table                                                          r[1] = (sbyte) l; // bits to dump before this table                                                          j = SharedUtils.URShift(i' (w - l));                                                          r[2] = (int) (q - u[h - 1] - j); // offset to this table                                                          Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                                                  }                                                  else                                                  {                                                          t[0] = q; // first table is returned result                                                  }                                          }                                                                                    // set up table entry in r                                          r[1] = (sbyte) (k - w);                                          if (p >= n)                                          {                                                  r[0] = 128 + 64; // out of values--invalid code                                          }                                          else if (v[p] < s)                                          {                                                  r[0] = (sbyte) (v[p] < 256?0:32 + 64); // 256 is end-of-block                                                  r[2] = v[p++]; // simple code is just the value                                          }                                          else                                          {                                                  r[0] = (sbyte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists                                                  r[2] = d[v[p++] - s];                                          }                                                                                    // fill code-like entries with r                                          f = 1 << (k - w);                                          for (j = SharedUtils.URShift(i' w); j < z; j += f)                                          {                                                  Array.Copy(r' 0' hp' (q + j) * 3' 3);                                          }                                                                                    // backwards increment the k-bit code i                                          for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift(j' 1))                                          {                                                  i ^= j;                                          }                                          i ^= j;                                                                                    // backup over finished tables                                          mask = (1 << w) - 1; // needed on HP' cc -O bug                                          while ((i & mask) != x[h])                                          {                                                  h--; // don't need to update q                                                  w -= l;                                                  mask = (1 << w) - 1;                                          }                                  }                          }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InfTree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)                          {                                  a = c[k];                                  while (a-- != 0)                                  {                                          // here i is the Huffman code of length k bits for value *p                                          // make tables up to required level                                          while (k > w + l)                                          {                                                  h++;                                                  w += l; // previous table always l bits                                                  // compute minimum size table less than or equal to l bits                                                  z = g - w;                                                  z = (z > l)?l:z; // table size upper limit                                                  if ((f = 1 << (j = k - w)) > a + 1)                                                  {                                                          // try a k-w bit table                                                          // too few codes for k-w bit table                                                          f -= (a + 1); // deduct codes from patterns left                                                          xp = k;                                                          if (j < z)                                                          {                                                                  while (++j < z)                                                                  {                                                                          // try smaller tables up to z bits                                                                          if ((f <<= 1) <= c[++xp])                                                                                  break; // enough codes to use up j bits                                                                          f -= c[xp]; // else deduct codes from patterns                                                                  }                                                          }                                                  }                                                  z = 1 << j; // table entries for j-bit table                                                                                                    // allocate new table                                                  if (hn[0] + z > MANY)                                                  {                                                          // (note: doesn't matter for fixed)                                                          return Z_DATA_ERROR; // overflow of MANY                                                  }                                                  u[h] = q = hn[0]; // DEBUG                                                  hn[0] += z;                                                                                                    // connect to last table' if there is one                                                  if (h != 0)                                                  {                                                          x[h] = i; // save pattern for backing up                                                          r[0] = (sbyte) j; // bits in this table                                                          r[1] = (sbyte) l; // bits to dump before this table                                                          j = SharedUtils.URShift(i' (w - l));                                                          r[2] = (int) (q - u[h - 1] - j); // offset to this table                                                          Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                                                  }                                                  else                                                  {                                                          t[0] = q; // first table is returned result                                                  }                                          }                                                                                    // set up table entry in r                                          r[1] = (sbyte) (k - w);                                          if (p >= n)                                          {                                                  r[0] = 128 + 64; // out of values--invalid code                                          }                                          else if (v[p] < s)                                          {                                                  r[0] = (sbyte) (v[p] < 256?0:32 + 64); // 256 is end-of-block                                                  r[2] = v[p++]; // simple code is just the value                                          }                                          else                                          {                                                  r[0] = (sbyte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists                                                  r[2] = d[v[p++] - s];                                          }                                                                                    // fill code-like entries with r                                          f = 1 << (k - w);                                          for (j = SharedUtils.URShift(i' w); j < z; j += f)                                          {                                                  Array.Copy(r' 0' hp' (q + j) * 3' 3);                                          }                                                                                    // backwards increment the k-bit code i                                          for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift(j' 1))                                          {                                                  i ^= j;                                          }                                          i ^= j;                                                                                    // backup over finished tables                                          mask = (1 << w) - 1; // needed on HP' cc -O bug                                          while ((i & mask) != x[h])                                          {                                                  h--; // don't need to update q                                                  w -= l;                                                  mask = (1 << w) - 1;                                          }                                  }                          }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InfTree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)                          {                                  a = c[k];                                  while (a-- != 0)                                  {                                          // here i is the Huffman code of length k bits for value *p                                          // make tables up to required level                                          while (k > w + l)                                          {                                                  h++;                                                  w += l; // previous table always l bits                                                  // compute minimum size table less than or equal to l bits                                                  z = g - w;                                                  z = (z > l)?l:z; // table size upper limit                                                  if ((f = 1 << (j = k - w)) > a + 1)                                                  {                                                          // try a k-w bit table                                                          // too few codes for k-w bit table                                                          f -= (a + 1); // deduct codes from patterns left                                                          xp = k;                                                          if (j < z)                                                          {                                                                  while (++j < z)                                                                  {                                                                          // try smaller tables up to z bits                                                                          if ((f <<= 1) <= c[++xp])                                                                                  break; // enough codes to use up j bits                                                                          f -= c[xp]; // else deduct codes from patterns                                                                  }                                                          }                                                  }                                                  z = 1 << j; // table entries for j-bit table                                                                                                    // allocate new table                                                  if (hn[0] + z > MANY)                                                  {                                                          // (note: doesn't matter for fixed)                                                          return Z_DATA_ERROR; // overflow of MANY                                                  }                                                  u[h] = q = hn[0]; // DEBUG                                                  hn[0] += z;                                                                                                    // connect to last table' if there is one                                                  if (h != 0)                                                  {                                                          x[h] = i; // save pattern for backing up                                                          r[0] = (sbyte) j; // bits in this table                                                          r[1] = (sbyte) l; // bits to dump before this table                                                          j = SharedUtils.URShift(i' (w - l));                                                          r[2] = (int) (q - u[h - 1] - j); // offset to this table                                                          Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                                                  }                                                  else                                                  {                                                          t[0] = q; // first table is returned result                                                  }                                          }                                                                                    // set up table entry in r                                          r[1] = (sbyte) (k - w);                                          if (p >= n)                                          {                                                  r[0] = 128 + 64; // out of values--invalid code                                          }                                          else if (v[p] < s)                                          {                                                  r[0] = (sbyte) (v[p] < 256?0:32 + 64); // 256 is end-of-block                                                  r[2] = v[p++]; // simple code is just the value                                          }                                          else                                          {                                                  r[0] = (sbyte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists                                                  r[2] = d[v[p++] - s];                                          }                                                                                    // fill code-like entries with r                                          f = 1 << (k - w);                                          for (j = SharedUtils.URShift(i' w); j < z; j += f)                                          {                                                  Array.Copy(r' 0' hp' (q + j) * 3' 3);                                          }                                                                                    // backwards increment the k-bit code i                                          for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift(j' 1))                                          {                                                  i ^= j;                                          }                                          i ^= j;                                                                                    // backup over finished tables                                          mask = (1 << w) - 1; // needed on HP' cc -O bug                                          while ((i & mask) != x[h])                                          {                                                  h--; // don't need to update q                                                  w -= l;                                                  mask = (1 << w) - 1;                                          }                                  }                          }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InfTree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)                          {                                  a = c[k];                                  while (a-- != 0)                                  {                                          // here i is the Huffman code of length k bits for value *p                                          // make tables up to required level                                          while (k > w + l)                                          {                                                  h++;                                                  w += l; // previous table always l bits                                                  // compute minimum size table less than or equal to l bits                                                  z = g - w;                                                  z = (z > l)?l:z; // table size upper limit                                                  if ((f = 1 << (j = k - w)) > a + 1)                                                  {                                                          // try a k-w bit table                                                          // too few codes for k-w bit table                                                          f -= (a + 1); // deduct codes from patterns left                                                          xp = k;                                                          if (j < z)                                                          {                                                                  while (++j < z)                                                                  {                                                                          // try smaller tables up to z bits                                                                          if ((f <<= 1) <= c[++xp])                                                                                  break; // enough codes to use up j bits                                                                          f -= c[xp]; // else deduct codes from patterns                                                                  }                                                          }                                                  }                                                  z = 1 << j; // table entries for j-bit table                                                                                                    // allocate new table                                                  if (hn[0] + z > MANY)                                                  {                                                          // (note: doesn't matter for fixed)                                                          return Z_DATA_ERROR; // overflow of MANY                                                  }                                                  u[h] = q = hn[0]; // DEBUG                                                  hn[0] += z;                                                                                                    // connect to last table' if there is one                                                  if (h != 0)                                                  {                                                          x[h] = i; // save pattern for backing up                                                          r[0] = (sbyte) j; // bits in this table                                                          r[1] = (sbyte) l; // bits to dump before this table                                                          j = SharedUtils.URShift(i' (w - l));                                                          r[2] = (int) (q - u[h - 1] - j); // offset to this table                                                          Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                                                  }                                                  else                                                  {                                                          t[0] = q; // first table is returned result                                                  }                                          }                                                                                    // set up table entry in r                                          r[1] = (sbyte) (k - w);                                          if (p >= n)                                          {                                                  r[0] = 128 + 64; // out of values--invalid code                                          }                                          else if (v[p] < s)                                          {                                                  r[0] = (sbyte) (v[p] < 256?0:32 + 64); // 256 is end-of-block                                                  r[2] = v[p++]; // simple code is just the value                                          }                                          else                                          {                                                  r[0] = (sbyte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists                                                  r[2] = d[v[p++] - s];                                          }                                                                                    // fill code-like entries with r                                          f = 1 << (k - w);                                          for (j = SharedUtils.URShift(i' w); j < z; j += f)                                          {                                                  Array.Copy(r' 0' hp' (q + j) * 3' 3);                                          }                                                                                    // backwards increment the k-bit code i                                          for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift(j' 1))                                          {                                                  i ^= j;                                          }                                          i ^= j;                                                                                    // backup over finished tables                                          mask = (1 << w) - 1; // needed on HP' cc -O bug                                          while ((i & mask) != x[h])                                          {                                                  h--; // don't need to update q                                                  w -= l;                                                  mask = (1 << w) - 1;                                          }                                  }                          }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InfTree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)                          {                                  a = c[k];                                  while (a-- != 0)                                  {                                          // here i is the Huffman code of length k bits for value *p                                          // make tables up to required level                                          while (k > w + l)                                          {                                                  h++;                                                  w += l; // previous table always l bits                                                  // compute minimum size table less than or equal to l bits                                                  z = g - w;                                                  z = (z > l)?l:z; // table size upper limit                                                  if ((f = 1 << (j = k - w)) > a + 1)                                                  {                                                          // try a k-w bit table                                                          // too few codes for k-w bit table                                                          f -= (a + 1); // deduct codes from patterns left                                                          xp = k;                                                          if (j < z)                                                          {                                                                  while (++j < z)                                                                  {                                                                          // try smaller tables up to z bits                                                                          if ((f <<= 1) <= c[++xp])                                                                                  break; // enough codes to use up j bits                                                                          f -= c[xp]; // else deduct codes from patterns                                                                  }                                                          }                                                  }                                                  z = 1 << j; // table entries for j-bit table                                                                                                    // allocate new table                                                  if (hn[0] + z > MANY)                                                  {                                                          // (note: doesn't matter for fixed)                                                          return Z_DATA_ERROR; // overflow of MANY                                                  }                                                  u[h] = q = hn[0]; // DEBUG                                                  hn[0] += z;                                                                                                    // connect to last table' if there is one                                                  if (h != 0)                                                  {                                                          x[h] = i; // save pattern for backing up                                                          r[0] = (sbyte) j; // bits in this table                                                          r[1] = (sbyte) l; // bits to dump before this table                                                          j = SharedUtils.URShift(i' (w - l));                                                          r[2] = (int) (q - u[h - 1] - j); // offset to this table                                                          Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                                                  }                                                  else                                                  {                                                          t[0] = q; // first table is returned result                                                  }                                          }                                                                                    // set up table entry in r                                          r[1] = (sbyte) (k - w);                                          if (p >= n)                                          {                                                  r[0] = 128 + 64; // out of values--invalid code                                          }                                          else if (v[p] < s)                                          {                                                  r[0] = (sbyte) (v[p] < 256?0:32 + 64); // 256 is end-of-block                                                  r[2] = v[p++]; // simple code is just the value                                          }                                          else                                          {                                                  r[0] = (sbyte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists                                                  r[2] = d[v[p++] - s];                                          }                                                                                    // fill code-like entries with r                                          f = 1 << (k - w);                                          for (j = SharedUtils.URShift(i' w); j < z; j += f)                                          {                                                  Array.Copy(r' 0' hp' (q + j) * 3' 3);                                          }                                                                                    // backwards increment the k-bit code i                                          for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift(j' 1))                                          {                                                  i ^= j;                                          }                                          i ^= j;                                                                                    // backup over finished tables                                          mask = (1 << w) - 1; // needed on HP' cc -O bug                                          while ((i & mask) != x[h])                                          {                                                  h--; // don't need to update q                                                  w -= l;                                                  mask = (1 << w) - 1;                                          }                                  }                          }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InfTree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)                          {                                  a = c[k];                                  while (a-- != 0)                                  {                                          // here i is the Huffman code of length k bits for value *p                                          // make tables up to required level                                          while (k > w + l)                                          {                                                  h++;                                                  w += l; // previous table always l bits                                                  // compute minimum size table less than or equal to l bits                                                  z = g - w;                                                  z = (z > l)?l:z; // table size upper limit                                                  if ((f = 1 << (j = k - w)) > a + 1)                                                  {                                                          // try a k-w bit table                                                          // too few codes for k-w bit table                                                          f -= (a + 1); // deduct codes from patterns left                                                          xp = k;                                                          if (j < z)                                                          {                                                                  while (++j < z)                                                                  {                                                                          // try smaller tables up to z bits                                                                          if ((f <<= 1) <= c[++xp])                                                                                  break; // enough codes to use up j bits                                                                          f -= c[xp]; // else deduct codes from patterns                                                                  }                                                          }                                                  }                                                  z = 1 << j; // table entries for j-bit table                                                                                                    // allocate new table                                                  if (hn[0] + z > MANY)                                                  {                                                          // (note: doesn't matter for fixed)                                                          return Z_DATA_ERROR; // overflow of MANY                                                  }                                                  u[h] = q = hn[0]; // DEBUG                                                  hn[0] += z;                                                                                                    // connect to last table' if there is one                                                  if (h != 0)                                                  {                                                          x[h] = i; // save pattern for backing up                                                          r[0] = (sbyte) j; // bits in this table                                                          r[1] = (sbyte) l; // bits to dump before this table                                                          j = SharedUtils.URShift(i' (w - l));                                                          r[2] = (int) (q - u[h - 1] - j); // offset to this table                                                          Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                                                  }                                                  else                                                  {                                                          t[0] = q; // first table is returned result                                                  }                                          }                                                                                    // set up table entry in r                                          r[1] = (sbyte) (k - w);                                          if (p >= n)                                          {                                                  r[0] = 128 + 64; // out of values--invalid code                                          }                                          else if (v[p] < s)                                          {                                                  r[0] = (sbyte) (v[p] < 256?0:32 + 64); // 256 is end-of-block                                                  r[2] = v[p++]; // simple code is just the value                                          }                                          else                                          {                                                  r[0] = (sbyte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists                                                  r[2] = d[v[p++] - s];                                          }                                                                                    // fill code-like entries with r                                          f = 1 << (k - w);                                          for (j = SharedUtils.URShift(i' w); j < z; j += f)                                          {                                                  Array.Copy(r' 0' hp' (q + j) * 3' 3);                                          }                                                                                    // backwards increment the k-bit code i                                          for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift(j' 1))                                          {                                                  i ^= j;                                          }                                          i ^= j;                                                                                    // backup over finished tables                                          mask = (1 << w) - 1; // needed on HP' cc -O bug                                          while ((i & mask) != x[h])                                          {                                                  h--; // don't need to update q                                                  w -= l;                                                  mask = (1 << w) - 1;                                          }                                  }                          }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InfTree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)                          {                                  a = c[k];                                  while (a-- != 0)                                  {                                          // here i is the Huffman code of length k bits for value *p                                          // make tables up to required level                                          while (k > w + l)                                          {                                                  h++;                                                  w += l; // previous table always l bits                                                  // compute minimum size table less than or equal to l bits                                                  z = g - w;                                                  z = (z > l)?l:z; // table size upper limit                                                  if ((f = 1 << (j = k - w)) > a + 1)                                                  {                                                          // try a k-w bit table                                                          // too few codes for k-w bit table                                                          f -= (a + 1); // deduct codes from patterns left                                                          xp = k;                                                          if (j < z)                                                          {                                                                  while (++j < z)                                                                  {                                                                          // try smaller tables up to z bits                                                                          if ((f <<= 1) <= c[++xp])                                                                                  break; // enough codes to use up j bits                                                                          f -= c[xp]; // else deduct codes from patterns                                                                  }                                                          }                                                  }                                                  z = 1 << j; // table entries for j-bit table                                                                                                    // allocate new table                                                  if (hn[0] + z > MANY)                                                  {                                                          // (note: doesn't matter for fixed)                                                          return Z_DATA_ERROR; // overflow of MANY                                                  }                                                  u[h] = q = hn[0]; // DEBUG                                                  hn[0] += z;                                                                                                    // connect to last table' if there is one                                                  if (h != 0)                                                  {                                                          x[h] = i; // save pattern for backing up                                                          r[0] = (sbyte) j; // bits in this table                                                          r[1] = (sbyte) l; // bits to dump before this table                                                          j = SharedUtils.URShift(i' (w - l));                                                          r[2] = (int) (q - u[h - 1] - j); // offset to this table                                                          Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                                                  }                                                  else                                                  {                                                          t[0] = q; // first table is returned result                                                  }                                          }                                                                                    // set up table entry in r                                          r[1] = (sbyte) (k - w);                                          if (p >= n)                                          {                                                  r[0] = 128 + 64; // out of values--invalid code                                          }                                          else if (v[p] < s)                                          {                                                  r[0] = (sbyte) (v[p] < 256?0:32 + 64); // 256 is end-of-block                                                  r[2] = v[p++]; // simple code is just the value                                          }                                          else                                          {                                                  r[0] = (sbyte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists                                                  r[2] = d[v[p++] - s];                                          }                                                                                    // fill code-like entries with r                                          f = 1 << (k - w);                                          for (j = SharedUtils.URShift(i' w); j < z; j += f)                                          {                                                  Array.Copy(r' 0' hp' (q + j) * 3' 3);                                          }                                                                                    // backwards increment the k-bit code i                                          for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift(j' 1))                                          {                                                  i ^= j;                                          }                                          i ^= j;                                                                                    // backup over finished tables                                          mask = (1 << w) - 1; // needed on HP' cc -O bug                                          while ((i & mask) != x[h])                                          {                                                  h--; // don't need to update q                                                  w -= l;                                                  mask = (1 << w) - 1;                                          }                                  }                          }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InfTree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)                          {                                  a = c[k];                                  while (a-- != 0)                                  {                                          // here i is the Huffman code of length k bits for value *p                                          // make tables up to required level                                          while (k > w + l)                                          {                                                  h++;                                                  w += l; // previous table always l bits                                                  // compute minimum size table less than or equal to l bits                                                  z = g - w;                                                  z = (z > l)?l:z; // table size upper limit                                                  if ((f = 1 << (j = k - w)) > a + 1)                                                  {                                                          // try a k-w bit table                                                          // too few codes for k-w bit table                                                          f -= (a + 1); // deduct codes from patterns left                                                          xp = k;                                                          if (j < z)                                                          {                                                                  while (++j < z)                                                                  {                                                                          // try smaller tables up to z bits                                                                          if ((f <<= 1) <= c[++xp])                                                                                  break; // enough codes to use up j bits                                                                          f -= c[xp]; // else deduct codes from patterns                                                                  }                                                          }                                                  }                                                  z = 1 << j; // table entries for j-bit table                                                                                                    // allocate new table                                                  if (hn[0] + z > MANY)                                                  {                                                          // (note: doesn't matter for fixed)                                                          return Z_DATA_ERROR; // overflow of MANY                                                  }                                                  u[h] = q = hn[0]; // DEBUG                                                  hn[0] += z;                                                                                                    // connect to last table' if there is one                                                  if (h != 0)                                                  {                                                          x[h] = i; // save pattern for backing up                                                          r[0] = (sbyte) j; // bits in this table                                                          r[1] = (sbyte) l; // bits to dump before this table                                                          j = SharedUtils.URShift(i' (w - l));                                                          r[2] = (int) (q - u[h - 1] - j); // offset to this table                                                          Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                                                  }                                                  else                                                  {                                                          t[0] = q; // first table is returned result                                                  }                                          }                                                                                    // set up table entry in r                                          r[1] = (sbyte) (k - w);                                          if (p >= n)                                          {                                                  r[0] = 128 + 64; // out of values--invalid code                                          }                                          else if (v[p] < s)                                          {                                                  r[0] = (sbyte) (v[p] < 256?0:32 + 64); // 256 is end-of-block                                                  r[2] = v[p++]; // simple code is just the value                                          }                                          else                                          {                                                  r[0] = (sbyte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists                                                  r[2] = d[v[p++] - s];                                          }                                                                                    // fill code-like entries with r                                          f = 1 << (k - w);                                          for (j = SharedUtils.URShift(i' w); j < z; j += f)                                          {                                                  Array.Copy(r' 0' hp' (q + j) * 3' 3);                                          }                                                                                    // backwards increment the k-bit code i                                          for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift(j' 1))                                          {                                                  i ^= j;                                          }                                          i ^= j;                                                                                    // backup over finished tables                                          mask = (1 << w) - 1; // needed on HP' cc -O bug                                          while ((i & mask) != x[h])                                          {                                                  h--; // don't need to update q                                                  w -= l;                                                  mask = (1 << w) - 1;                                          }                                  }                          }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InfTree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)                          {                                  a = c[k];                                  while (a-- != 0)                                  {                                          // here i is the Huffman code of length k bits for value *p                                          // make tables up to required level                                          while (k > w + l)                                          {                                                  h++;                                                  w += l; // previous table always l bits                                                  // compute minimum size table less than or equal to l bits                                                  z = g - w;                                                  z = (z > l)?l:z; // table size upper limit                                                  if ((f = 1 << (j = k - w)) > a + 1)                                                  {                                                          // try a k-w bit table                                                          // too few codes for k-w bit table                                                          f -= (a + 1); // deduct codes from patterns left                                                          xp = k;                                                          if (j < z)                                                          {                                                                  while (++j < z)                                                                  {                                                                          // try smaller tables up to z bits                                                                          if ((f <<= 1) <= c[++xp])                                                                                  break; // enough codes to use up j bits                                                                          f -= c[xp]; // else deduct codes from patterns                                                                  }                                                          }                                                  }                                                  z = 1 << j; // table entries for j-bit table                                                                                                    // allocate new table                                                  if (hn[0] + z > MANY)                                                  {                                                          // (note: doesn't matter for fixed)                                                          return Z_DATA_ERROR; // overflow of MANY                                                  }                                                  u[h] = q = hn[0]; // DEBUG                                                  hn[0] += z;                                                                                                    // connect to last table' if there is one                                                  if (h != 0)                                                  {                                                          x[h] = i; // save pattern for backing up                                                          r[0] = (sbyte) j; // bits in this table                                                          r[1] = (sbyte) l; // bits to dump before this table                                                          j = SharedUtils.URShift(i' (w - l));                                                          r[2] = (int) (q - u[h - 1] - j); // offset to this table                                                          Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                                                  }                                                  else                                                  {                                                          t[0] = q; // first table is returned result                                                  }                                          }                                                                                    // set up table entry in r                                          r[1] = (sbyte) (k - w);                                          if (p >= n)                                          {                                                  r[0] = 128 + 64; // out of values--invalid code                                          }                                          else if (v[p] < s)                                          {                                                  r[0] = (sbyte) (v[p] < 256?0:32 + 64); // 256 is end-of-block                                                  r[2] = v[p++]; // simple code is just the value                                          }                                          else                                          {                                                  r[0] = (sbyte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists                                                  r[2] = d[v[p++] - s];                                          }                                                                                    // fill code-like entries with r                                          f = 1 << (k - w);                                          for (j = SharedUtils.URShift(i' w); j < z; j += f)                                          {                                                  Array.Copy(r' 0' hp' (q + j) * 3' 3);                                          }                                                                                    // backwards increment the k-bit code i                                          for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift(j' 1))                                          {                                                  i ^= j;                                          }                                          i ^= j;                                                                                    // backup over finished tables                                          mask = (1 << w) - 1; // needed on HP' cc -O bug                                          while ((i & mask) != x[h])                                          {                                                  h--; // don't need to update q                                                  w -= l;                                                  mask = (1 << w) - 1;                                          }                                  }                          }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InfTree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)                          {                                  a = c[k];                                  while (a-- != 0)                                  {                                          // here i is the Huffman code of length k bits for value *p                                          // make tables up to required level                                          while (k > w + l)                                          {                                                  h++;                                                  w += l; // previous table always l bits                                                  // compute minimum size table less than or equal to l bits                                                  z = g - w;                                                  z = (z > l)?l:z; // table size upper limit                                                  if ((f = 1 << (j = k - w)) > a + 1)                                                  {                                                          // try a k-w bit table                                                          // too few codes for k-w bit table                                                          f -= (a + 1); // deduct codes from patterns left                                                          xp = k;                                                          if (j < z)                                                          {                                                                  while (++j < z)                                                                  {                                                                          // try smaller tables up to z bits                                                                          if ((f <<= 1) <= c[++xp])                                                                                  break; // enough codes to use up j bits                                                                          f -= c[xp]; // else deduct codes from patterns                                                                  }                                                          }                                                  }                                                  z = 1 << j; // table entries for j-bit table                                                                                                    // allocate new table                                                  if (hn[0] + z > MANY)                                                  {                                                          // (note: doesn't matter for fixed)                                                          return Z_DATA_ERROR; // overflow of MANY                                                  }                                                  u[h] = q = hn[0]; // DEBUG                                                  hn[0] += z;                                                                                                    // connect to last table' if there is one                                                  if (h != 0)                                                  {                                                          x[h] = i; // save pattern for backing up                                                          r[0] = (sbyte) j; // bits in this table                                                          r[1] = (sbyte) l; // bits to dump before this table                                                          j = SharedUtils.URShift(i' (w - l));                                                          r[2] = (int) (q - u[h - 1] - j); // offset to this table                                                          Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                                                  }                                                  else                                                  {                                                          t[0] = q; // first table is returned result                                                  }                                          }                                                                                    // set up table entry in r                                          r[1] = (sbyte) (k - w);                                          if (p >= n)                                          {                                                  r[0] = 128 + 64; // out of values--invalid code                                          }                                          else if (v[p] < s)                                          {                                                  r[0] = (sbyte) (v[p] < 256?0:32 + 64); // 256 is end-of-block                                                  r[2] = v[p++]; // simple code is just the value                                          }                                          else                                          {                                                  r[0] = (sbyte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists                                                  r[2] = d[v[p++] - s];                                          }                                                                                    // fill code-like entries with r                                          f = 1 << (k - w);                                          for (j = SharedUtils.URShift(i' w); j < z; j += f)                                          {                                                  Array.Copy(r' 0' hp' (q + j) * 3' 3);                                          }                                                                                    // backwards increment the k-bit code i                                          for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift(j' 1))                                          {                                                  i ^= j;                                          }                                          i ^= j;                                                                                    // backup over finished tables                                          mask = (1 << w) - 1; // needed on HP' cc -O bug                                          while ((i & mask) != x[h])                                          {                                                  h--; // don't need to update q                                                  w -= l;                                                  mask = (1 << w) - 1;                                          }                                  }                          }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InfTree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)                          {                                  a = c[k];                                  while (a-- != 0)                                  {                                          // here i is the Huffman code of length k bits for value *p                                          // make tables up to required level                                          while (k > w + l)                                          {                                                  h++;                                                  w += l; // previous table always l bits                                                  // compute minimum size table less than or equal to l bits                                                  z = g - w;                                                  z = (z > l)?l:z; // table size upper limit                                                  if ((f = 1 << (j = k - w)) > a + 1)                                                  {                                                          // try a k-w bit table                                                          // too few codes for k-w bit table                                                          f -= (a + 1); // deduct codes from patterns left                                                          xp = k;                                                          if (j < z)                                                          {                                                                  while (++j < z)                                                                  {                                                                          // try smaller tables up to z bits                                                                          if ((f <<= 1) <= c[++xp])                                                                                  break; // enough codes to use up j bits                                                                          f -= c[xp]; // else deduct codes from patterns                                                                  }                                                          }                                                  }                                                  z = 1 << j; // table entries for j-bit table                                                                                                    // allocate new table                                                  if (hn[0] + z > MANY)                                                  {                                                          // (note: doesn't matter for fixed)                                                          return Z_DATA_ERROR; // overflow of MANY                                                  }                                                  u[h] = q = hn[0]; // DEBUG                                                  hn[0] += z;                                                                                                    // connect to last table' if there is one                                                  if (h != 0)                                                  {                                                          x[h] = i; // save pattern for backing up                                                          r[0] = (sbyte) j; // bits in this table                                                          r[1] = (sbyte) l; // bits to dump before this table                                                          j = SharedUtils.URShift(i' (w - l));                                                          r[2] = (int) (q - u[h - 1] - j); // offset to this table                                                          Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                                                  }                                                  else                                                  {                                                          t[0] = q; // first table is returned result                                                  }                                          }                                                                                    // set up table entry in r                                          r[1] = (sbyte) (k - w);                                          if (p >= n)                                          {                                                  r[0] = 128 + 64; // out of values--invalid code                                          }                                          else if (v[p] < s)                                          {                                                  r[0] = (sbyte) (v[p] < 256?0:32 + 64); // 256 is end-of-block                                                  r[2] = v[p++]; // simple code is just the value                                          }                                          else                                          {                                                  r[0] = (sbyte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists                                                  r[2] = d[v[p++] - s];                                          }                                                                                    // fill code-like entries with r                                          f = 1 << (k - w);                                          for (j = SharedUtils.URShift(i' w); j < z; j += f)                                          {                                                  Array.Copy(r' 0' hp' (q + j) * 3' 3);                                          }                                                                                    // backwards increment the k-bit code i                                          for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift(j' 1))                                          {                                                  i ^= j;                                          }                                          i ^= j;                                                                                    // backup over finished tables                                          mask = (1 << w) - 1; // needed on HP' cc -O bug                                          while ((i & mask) != x[h])                                          {                                                  h--; // don't need to update q                                                  w -= l;                                                  mask = (1 << w) - 1;                                          }                                  }                          }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InfTree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)                          {                                  a = c[k];                                  while (a-- != 0)                                  {                                          // here i is the Huffman code of length k bits for value *p                                          // make tables up to required level                                          while (k > w + l)                                          {                                                  h++;                                                  w += l; // previous table always l bits                                                  // compute minimum size table less than or equal to l bits                                                  z = g - w;                                                  z = (z > l)?l:z; // table size upper limit                                                  if ((f = 1 << (j = k - w)) > a + 1)                                                  {                                                          // try a k-w bit table                                                          // too few codes for k-w bit table                                                          f -= (a + 1); // deduct codes from patterns left                                                          xp = k;                                                          if (j < z)                                                          {                                                                  while (++j < z)                                                                  {                                                                          // try smaller tables up to z bits                                                                          if ((f <<= 1) <= c[++xp])                                                                                  break; // enough codes to use up j bits                                                                          f -= c[xp]; // else deduct codes from patterns                                                                  }                                                          }                                                  }                                                  z = 1 << j; // table entries for j-bit table                                                                                                    // allocate new table                                                  if (hn[0] + z > MANY)                                                  {                                                          // (note: doesn't matter for fixed)                                                          return Z_DATA_ERROR; // overflow of MANY                                                  }                                                  u[h] = q = hn[0]; // DEBUG                                                  hn[0] += z;                                                                                                    // connect to last table' if there is one                                                  if (h != 0)                                                  {                                                          x[h] = i; // save pattern for backing up                                                          r[0] = (sbyte) j; // bits in this table                                                          r[1] = (sbyte) l; // bits to dump before this table                                                          j = SharedUtils.URShift(i' (w - l));                                                          r[2] = (int) (q - u[h - 1] - j); // offset to this table                                                          Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                                                  }                                                  else                                                  {                                                          t[0] = q; // first table is returned result                                                  }                                          }                                                                                    // set up table entry in r                                          r[1] = (sbyte) (k - w);                                          if (p >= n)                                          {                                                  r[0] = 128 + 64; // out of values--invalid code                                          }                                          else if (v[p] < s)                                          {                                                  r[0] = (sbyte) (v[p] < 256?0:32 + 64); // 256 is end-of-block                                                  r[2] = v[p++]; // simple code is just the value                                          }                                          else                                          {                                                  r[0] = (sbyte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists                                                  r[2] = d[v[p++] - s];                                          }                                                                                    // fill code-like entries with r                                          f = 1 << (k - w);                                          for (j = SharedUtils.URShift(i' w); j < z; j += f)                                          {                                                  Array.Copy(r' 0' hp' (q + j) * 3' 3);                                          }                                                                                    // backwards increment the k-bit code i                                          for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift(j' 1))                                          {                                                  i ^= j;                                          }                                          i ^= j;                                                                                    // backup over finished tables                                          mask = (1 << w) - 1; // needed on HP' cc -O bug                                          while ((i & mask) != x[h])                                          {                                                  h--; // don't need to update q                                                  w -= l;                                                  mask = (1 << w) - 1;                                          }                                  }                          }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InfTree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)                          {                                  a = c[k];                                  while (a-- != 0)                                  {                                          // here i is the Huffman code of length k bits for value *p                                          // make tables up to required level                                          while (k > w + l)                                          {                                                  h++;                                                  w += l; // previous table always l bits                                                  // compute minimum size table less than or equal to l bits                                                  z = g - w;                                                  z = (z > l)?l:z; // table size upper limit                                                  if ((f = 1 << (j = k - w)) > a + 1)                                                  {                                                          // try a k-w bit table                                                          // too few codes for k-w bit table                                                          f -= (a + 1); // deduct codes from patterns left                                                          xp = k;                                                          if (j < z)                                                          {                                                                  while (++j < z)                                                                  {                                                                          // try smaller tables up to z bits                                                                          if ((f <<= 1) <= c[++xp])                                                                                  break; // enough codes to use up j bits                                                                          f -= c[xp]; // else deduct codes from patterns                                                                  }                                                          }                                                  }                                                  z = 1 << j; // table entries for j-bit table                                                                                                    // allocate new table                                                  if (hn[0] + z > MANY)                                                  {                                                          // (note: doesn't matter for fixed)                                                          return Z_DATA_ERROR; // overflow of MANY                                                  }                                                  u[h] = q = hn[0]; // DEBUG                                                  hn[0] += z;                                                                                                    // connect to last table' if there is one                                                  if (h != 0)                                                  {                                                          x[h] = i; // save pattern for backing up                                                          r[0] = (sbyte) j; // bits in this table                                                          r[1] = (sbyte) l; // bits to dump before this table                                                          j = SharedUtils.URShift(i' (w - l));                                                          r[2] = (int) (q - u[h - 1] - j); // offset to this table                                                          Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                                                  }                                                  else                                                  {                                                          t[0] = q; // first table is returned result                                                  }                                          }                                                                                    // set up table entry in r                                          r[1] = (sbyte) (k - w);                                          if (p >= n)                                          {                                                  r[0] = 128 + 64; // out of values--invalid code                                          }                                          else if (v[p] < s)                                          {                                                  r[0] = (sbyte) (v[p] < 256?0:32 + 64); // 256 is end-of-block                                                  r[2] = v[p++]; // simple code is just the value                                          }                                          else                                          {                                                  r[0] = (sbyte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists                                                  r[2] = d[v[p++] - s];                                          }                                                                                    // fill code-like entries with r                                          f = 1 << (k - w);                                          for (j = SharedUtils.URShift(i' w); j < z; j += f)                                          {                                                  Array.Copy(r' 0' hp' (q + j) * 3' 3);                                          }                                                                                    // backwards increment the k-bit code i                                          for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift(j' 1))                                          {                                                  i ^= j;                                          }                                          i ^= j;                                                                                    // backup over finished tables                                          mask = (1 << w) - 1; // needed on HP' cc -O bug                                          while ((i & mask) != x[h])                                          {                                                  h--; // don't need to update q                                                  w -= l;                                                  mask = (1 << w) - 1;                                          }                                  }                          }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InfTree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)                          {                                  a = c[k];                                  while (a-- != 0)                                  {                                          // here i is the Huffman code of length k bits for value *p                                          // make tables up to required level                                          while (k > w + l)                                          {                                                  h++;                                                  w += l; // previous table always l bits                                                  // compute minimum size table less than or equal to l bits                                                  z = g - w;                                                  z = (z > l)?l:z; // table size upper limit                                                  if ((f = 1 << (j = k - w)) > a + 1)                                                  {                                                          // try a k-w bit table                                                          // too few codes for k-w bit table                                                          f -= (a + 1); // deduct codes from patterns left                                                          xp = k;                                                          if (j < z)                                                          {                                                                  while (++j < z)                                                                  {                                                                          // try smaller tables up to z bits                                                                          if ((f <<= 1) <= c[++xp])                                                                                  break; // enough codes to use up j bits                                                                          f -= c[xp]; // else deduct codes from patterns                                                                  }                                                          }                                                  }                                                  z = 1 << j; // table entries for j-bit table                                                                                                    // allocate new table                                                  if (hn[0] + z > MANY)                                                  {                                                          // (note: doesn't matter for fixed)                                                          return Z_DATA_ERROR; // overflow of MANY                                                  }                                                  u[h] = q = hn[0]; // DEBUG                                                  hn[0] += z;                                                                                                    // connect to last table' if there is one                                                  if (h != 0)                                                  {                                                          x[h] = i; // save pattern for backing up                                                          r[0] = (sbyte) j; // bits in this table                                                          r[1] = (sbyte) l; // bits to dump before this table                                                          j = SharedUtils.URShift(i' (w - l));                                                          r[2] = (int) (q - u[h - 1] - j); // offset to this table                                                          Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                                                  }                                                  else                                                  {                                                          t[0] = q; // first table is returned result                                                  }                                          }                                                                                    // set up table entry in r                                          r[1] = (sbyte) (k - w);                                          if (p >= n)                                          {                                                  r[0] = 128 + 64; // out of values--invalid code                                          }                                          else if (v[p] < s)                                          {                                                  r[0] = (sbyte) (v[p] < 256?0:32 + 64); // 256 is end-of-block                                                  r[2] = v[p++]; // simple code is just the value                                          }                                          else                                          {                                                  r[0] = (sbyte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists                                                  r[2] = d[v[p++] - s];                                          }                                                                                    // fill code-like entries with r                                          f = 1 << (k - w);                                          for (j = SharedUtils.URShift(i' w); j < z; j += f)                                          {                                                  Array.Copy(r' 0' hp' (q + j) * 3' 3);                                          }                                                                                    // backwards increment the k-bit code i                                          for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift(j' 1))                                          {                                                  i ^= j;                                          }                                          i ^= j;                                                                                    // backup over finished tables                                          mask = (1 << w) - 1; // needed on HP' cc -O bug                                          while ((i & mask) != x[h])                                          {                                                  h--; // don't need to update q                                                  w -= l;                                                  mask = (1 << w) - 1;                                          }                                  }                          }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InfTree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: initWorkArea(19);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InfTree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: result = huft_build(c' 0' 19' 19' null' null' tb' bb' hp' hn' v);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InfTree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: result = huft_build(c' 0' 19' 19' null' null' tb' bb' hp' hn' v);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InfTree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: initWorkArea(288);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InfTree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: result = huft_build(c' 0' nl' 257' cplens' cplext' tl' bl' hp' hn' v);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InfTree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: initWorkArea(288);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InfTree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: if (result != Z_OK || (bd[0] == 0 && nl > 257))                          {                                  if (result == Z_DATA_ERROR)                                  {                                          z.Message = "oversubscribed distance tree";                                  }                                  else if (result == Z_BUF_ERROR)                                  {                                          z.Message = "incomplete distance tree";                                          result = Z_DATA_ERROR;                                  }                                  else if (result != Z_MEM_ERROR)                                  {                                          z.Message = "empty distance tree with lengths";                                          result = Z_DATA_ERROR;                                  }                                  return result;                          }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InfTree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\InfTree.cs,initWorkArea,The following statement contains a magic number: if (hn == null)                          {                                  hn = new int[1];                                  v = new int[vsize];                                  c = new int[BMAX + 1];                                  r = new int[3];                                  u = new int[BMAX];                                  x = new int[BMAX + 1];                          }                          else                          {                              if (v.Length < vsize)                              {                                  v = new int[vsize];                              }                              Array.Clear(v'0'vsize);                              Array.Clear(c'0'BMAX+1);                              r[0]=0; r[1]=0; r[2]=0;                              //  for(int i=0; i<BMAX; i++){u[i]=0;}                              //Array.Copy(c' 0' u' 0' BMAX);                              Array.Clear(u'0'BMAX);                              //  for(int i=0; i<BMAX+1; i++){x[i]=0;}                              //Array.Copy(c' 0' x' 0' BMAX + 1);                              Array.Clear(x'0'BMAX+1);                          }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,InfTree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\InfTree.cs,initWorkArea,The following statement contains a magic number: if (hn == null)                          {                                  hn = new int[1];                                  v = new int[vsize];                                  c = new int[BMAX + 1];                                  r = new int[3];                                  u = new int[BMAX];                                  x = new int[BMAX + 1];                          }                          else                          {                              if (v.Length < vsize)                              {                                  v = new int[vsize];                              }                              Array.Clear(v'0'vsize);                              Array.Clear(c'0'BMAX+1);                              r[0]=0; r[1]=0; r[2]=0;                              //  for(int i=0; i<BMAX; i++){u[i]=0;}                              //Array.Copy(c' 0' u' 0' BMAX);                              Array.Clear(u'0'BMAX);                              //  for(int i=0; i<BMAX+1; i++){x[i]=0;}                              //Array.Copy(c' 0' x' 0' BMAX + 1);                              Array.Clear(x'0'BMAX+1);                          }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Tree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Tree.cs,DistanceCode,The following statement contains a magic number: return (dist < 256)                  ? _dist_code[dist]                  : _dist_code[256 + SharedUtils.URShift(dist' 7)];
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Tree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Tree.cs,DistanceCode,The following statement contains a magic number: return (dist < 256)                  ? _dist_code[dist]                  : _dist_code[256 + SharedUtils.URShift(dist' 7)];
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Tree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Tree.cs,DistanceCode,The following statement contains a magic number: return (dist < 256)                  ? _dist_code[dist]                  : _dist_code[256 + SharedUtils.URShift(dist' 7)];
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Tree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Tree.cs,gen_bitlen,The following statement contains a magic number: tree[s.heap[s.heap_max] * 2 + 1] = 0;
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Tree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (h = s.heap_max + 1; h < HEAP_SIZE; h++)              {                  n = s.heap[h];                  bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;                  if (bits > max_length)                  {                      bits = max_length; overflow++;                  }                  tree[n * 2 + 1] = (short) bits;                  // We overwrite tree[n*2+1] which is no longer needed                                                    if (n > max_code)                      continue; // not a leaf node                                                    s.bl_count[bits]++;                  xbits = 0;                  if (n >= base_Renamed)                      xbits = extra[n - base_Renamed];                  f = tree[n * 2];                  s.opt_len += f * (bits + xbits);                  if (stree != null)                      s.static_len += f * (stree[n * 2 + 1] + xbits);              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Tree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (h = s.heap_max + 1; h < HEAP_SIZE; h++)              {                  n = s.heap[h];                  bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;                  if (bits > max_length)                  {                      bits = max_length; overflow++;                  }                  tree[n * 2 + 1] = (short) bits;                  // We overwrite tree[n*2+1] which is no longer needed                                                    if (n > max_code)                      continue; // not a leaf node                                                    s.bl_count[bits]++;                  xbits = 0;                  if (n >= base_Renamed)                      xbits = extra[n - base_Renamed];                  f = tree[n * 2];                  s.opt_len += f * (bits + xbits);                  if (stree != null)                      s.static_len += f * (stree[n * 2 + 1] + xbits);              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Tree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (h = s.heap_max + 1; h < HEAP_SIZE; h++)              {                  n = s.heap[h];                  bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;                  if (bits > max_length)                  {                      bits = max_length; overflow++;                  }                  tree[n * 2 + 1] = (short) bits;                  // We overwrite tree[n*2+1] which is no longer needed                                                    if (n > max_code)                      continue; // not a leaf node                                                    s.bl_count[bits]++;                  xbits = 0;                  if (n >= base_Renamed)                      xbits = extra[n - base_Renamed];                  f = tree[n * 2];                  s.opt_len += f * (bits + xbits);                  if (stree != null)                      s.static_len += f * (stree[n * 2 + 1] + xbits);              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Tree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (h = s.heap_max + 1; h < HEAP_SIZE; h++)              {                  n = s.heap[h];                  bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;                  if (bits > max_length)                  {                      bits = max_length; overflow++;                  }                  tree[n * 2 + 1] = (short) bits;                  // We overwrite tree[n*2+1] which is no longer needed                                                    if (n > max_code)                      continue; // not a leaf node                                                    s.bl_count[bits]++;                  xbits = 0;                  if (n >= base_Renamed)                      xbits = extra[n - base_Renamed];                  f = tree[n * 2];                  s.opt_len += f * (bits + xbits);                  if (stree != null)                      s.static_len += f * (stree[n * 2 + 1] + xbits);              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Tree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (h = s.heap_max + 1; h < HEAP_SIZE; h++)              {                  n = s.heap[h];                  bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;                  if (bits > max_length)                  {                      bits = max_length; overflow++;                  }                  tree[n * 2 + 1] = (short) bits;                  // We overwrite tree[n*2+1] which is no longer needed                                                    if (n > max_code)                      continue; // not a leaf node                                                    s.bl_count[bits]++;                  xbits = 0;                  if (n >= base_Renamed)                      xbits = extra[n - base_Renamed];                  f = tree[n * 2];                  s.opt_len += f * (bits + xbits);                  if (stree != null)                      s.static_len += f * (stree[n * 2 + 1] + xbits);              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Tree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Tree.cs,gen_bitlen,The following statement contains a magic number: do               {                  bits = max_length - 1;                  while (s.bl_count[bits] == 0)                      bits--;                  s.bl_count[bits]--; // move one leaf down the tree                  s.bl_count[bits + 1] = (short) (s.bl_count[bits + 1] + 2); // move one overflow item as its brother                  s.bl_count[max_length]--;                  // The brother of the overflow item also moves one step up'                  // but this does not affect bl_count[max_length]                  overflow -= 2;              }              while (overflow > 0);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Tree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Tree.cs,gen_bitlen,The following statement contains a magic number: do               {                  bits = max_length - 1;                  while (s.bl_count[bits] == 0)                      bits--;                  s.bl_count[bits]--; // move one leaf down the tree                  s.bl_count[bits + 1] = (short) (s.bl_count[bits + 1] + 2); // move one overflow item as its brother                  s.bl_count[max_length]--;                  // The brother of the overflow item also moves one step up'                  // but this does not affect bl_count[max_length]                  overflow -= 2;              }              while (overflow > 0);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Tree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (bits = max_length; bits != 0; bits--)              {                  n = s.bl_count[bits];                  while (n != 0)                  {                      m = s.heap[--h];                      if (m > max_code)                          continue;                      if (tree[m * 2 + 1] != bits)                      {                          s.opt_len = (int) (s.opt_len + ((long) bits - (long) tree[m * 2 + 1]) * (long) tree[m * 2]);                          tree[m * 2 + 1] = (short) bits;                      }                      n--;                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Tree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (bits = max_length; bits != 0; bits--)              {                  n = s.bl_count[bits];                  while (n != 0)                  {                      m = s.heap[--h];                      if (m > max_code)                          continue;                      if (tree[m * 2 + 1] != bits)                      {                          s.opt_len = (int) (s.opt_len + ((long) bits - (long) tree[m * 2 + 1]) * (long) tree[m * 2]);                          tree[m * 2 + 1] = (short) bits;                      }                      n--;                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Tree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (bits = max_length; bits != 0; bits--)              {                  n = s.bl_count[bits];                  while (n != 0)                  {                      m = s.heap[--h];                      if (m > max_code)                          continue;                      if (tree[m * 2 + 1] != bits)                      {                          s.opt_len = (int) (s.opt_len + ((long) bits - (long) tree[m * 2 + 1]) * (long) tree[m * 2]);                          tree[m * 2 + 1] = (short) bits;                      }                      n--;                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Tree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (bits = max_length; bits != 0; bits--)              {                  n = s.bl_count[bits];                  while (n != 0)                  {                      m = s.heap[--h];                      if (m > max_code)                          continue;                      if (tree[m * 2 + 1] != bits)                      {                          s.opt_len = (int) (s.opt_len + ((long) bits - (long) tree[m * 2 + 1]) * (long) tree[m * 2]);                          tree[m * 2 + 1] = (short) bits;                      }                      n--;                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Tree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Tree.cs,build_tree,The following statement contains a magic number: for (n = 0; n < elems; n++)              {                  if (tree[n * 2] != 0)                  {                      s.heap[++s.heap_len] = max_code = n;                      s.depth[n] = 0;                  }                  else                  {                      tree[n * 2 + 1] = 0;                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Tree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Tree.cs,build_tree,The following statement contains a magic number: for (n = 0; n < elems; n++)              {                  if (tree[n * 2] != 0)                  {                      s.heap[++s.heap_len] = max_code = n;                      s.depth[n] = 0;                  }                  else                  {                      tree[n * 2 + 1] = 0;                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Tree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Tree.cs,build_tree,The following statement contains a magic number: while (s.heap_len < 2)              {                  node = s.heap[++s.heap_len] = (max_code < 2?++max_code:0);                  tree[node * 2] = 1;                  s.depth[node] = 0;                  s.opt_len--;                  if (stree != null)                      s.static_len -= stree[node * 2 + 1];                  // node is 0 or 1 so it does not have extra bits              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Tree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Tree.cs,build_tree,The following statement contains a magic number: while (s.heap_len < 2)              {                  node = s.heap[++s.heap_len] = (max_code < 2?++max_code:0);                  tree[node * 2] = 1;                  s.depth[node] = 0;                  s.opt_len--;                  if (stree != null)                      s.static_len -= stree[node * 2 + 1];                  // node is 0 or 1 so it does not have extra bits              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Tree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Tree.cs,build_tree,The following statement contains a magic number: while (s.heap_len < 2)              {                  node = s.heap[++s.heap_len] = (max_code < 2?++max_code:0);                  tree[node * 2] = 1;                  s.depth[node] = 0;                  s.opt_len--;                  if (stree != null)                      s.static_len -= stree[node * 2 + 1];                  // node is 0 or 1 so it does not have extra bits              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Tree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Tree.cs,build_tree,The following statement contains a magic number: while (s.heap_len < 2)              {                  node = s.heap[++s.heap_len] = (max_code < 2?++max_code:0);                  tree[node * 2] = 1;                  s.depth[node] = 0;                  s.opt_len--;                  if (stree != null)                      s.static_len -= stree[node * 2 + 1];                  // node is 0 or 1 so it does not have extra bits              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Tree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Tree.cs,build_tree,The following statement contains a magic number: for (n = s.heap_len / 2; n >= 1; n--)                  s.pqdownheap(tree' n);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Tree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Tree.cs,build_tree,The following statement contains a magic number: do               {                  // n = node of least frequency                  n = s.heap[1];                  s.heap[1] = s.heap[s.heap_len--];                  s.pqdownheap(tree' 1);                  m = s.heap[1]; // m = node of next least frequency                                                    s.heap[--s.heap_max] = n; // keep the nodes sorted by frequency                  s.heap[--s.heap_max] = m;                                                    // Create a new node father of n and m                  tree[node * 2] = unchecked((short) (tree[n * 2] + tree[m * 2]));                  s.depth[node] = (sbyte) (System.Math.Max((byte) s.depth[n]' (byte) s.depth[m]) + 1);                  tree[n * 2 + 1] = tree[m * 2 + 1] = (short) node;                                                    // and insert the new node in the heap                  s.heap[1] = node++;                  s.pqdownheap(tree' 1);              }              while (s.heap_len >= 2);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Tree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Tree.cs,build_tree,The following statement contains a magic number: do               {                  // n = node of least frequency                  n = s.heap[1];                  s.heap[1] = s.heap[s.heap_len--];                  s.pqdownheap(tree' 1);                  m = s.heap[1]; // m = node of next least frequency                                                    s.heap[--s.heap_max] = n; // keep the nodes sorted by frequency                  s.heap[--s.heap_max] = m;                                                    // Create a new node father of n and m                  tree[node * 2] = unchecked((short) (tree[n * 2] + tree[m * 2]));                  s.depth[node] = (sbyte) (System.Math.Max((byte) s.depth[n]' (byte) s.depth[m]) + 1);                  tree[n * 2 + 1] = tree[m * 2 + 1] = (short) node;                                                    // and insert the new node in the heap                  s.heap[1] = node++;                  s.pqdownheap(tree' 1);              }              while (s.heap_len >= 2);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Tree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Tree.cs,build_tree,The following statement contains a magic number: do               {                  // n = node of least frequency                  n = s.heap[1];                  s.heap[1] = s.heap[s.heap_len--];                  s.pqdownheap(tree' 1);                  m = s.heap[1]; // m = node of next least frequency                                                    s.heap[--s.heap_max] = n; // keep the nodes sorted by frequency                  s.heap[--s.heap_max] = m;                                                    // Create a new node father of n and m                  tree[node * 2] = unchecked((short) (tree[n * 2] + tree[m * 2]));                  s.depth[node] = (sbyte) (System.Math.Max((byte) s.depth[n]' (byte) s.depth[m]) + 1);                  tree[n * 2 + 1] = tree[m * 2 + 1] = (short) node;                                                    // and insert the new node in the heap                  s.heap[1] = node++;                  s.pqdownheap(tree' 1);              }              while (s.heap_len >= 2);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Tree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Tree.cs,build_tree,The following statement contains a magic number: do               {                  // n = node of least frequency                  n = s.heap[1];                  s.heap[1] = s.heap[s.heap_len--];                  s.pqdownheap(tree' 1);                  m = s.heap[1]; // m = node of next least frequency                                                    s.heap[--s.heap_max] = n; // keep the nodes sorted by frequency                  s.heap[--s.heap_max] = m;                                                    // Create a new node father of n and m                  tree[node * 2] = unchecked((short) (tree[n * 2] + tree[m * 2]));                  s.depth[node] = (sbyte) (System.Math.Max((byte) s.depth[n]' (byte) s.depth[m]) + 1);                  tree[n * 2 + 1] = tree[m * 2 + 1] = (short) node;                                                    // and insert the new node in the heap                  s.heap[1] = node++;                  s.pqdownheap(tree' 1);              }              while (s.heap_len >= 2);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Tree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Tree.cs,build_tree,The following statement contains a magic number: do               {                  // n = node of least frequency                  n = s.heap[1];                  s.heap[1] = s.heap[s.heap_len--];                  s.pqdownheap(tree' 1);                  m = s.heap[1]; // m = node of next least frequency                                                    s.heap[--s.heap_max] = n; // keep the nodes sorted by frequency                  s.heap[--s.heap_max] = m;                                                    // Create a new node father of n and m                  tree[node * 2] = unchecked((short) (tree[n * 2] + tree[m * 2]));                  s.depth[node] = (sbyte) (System.Math.Max((byte) s.depth[n]' (byte) s.depth[m]) + 1);                  tree[n * 2 + 1] = tree[m * 2 + 1] = (short) node;                                                    // and insert the new node in the heap                  s.heap[1] = node++;                  s.pqdownheap(tree' 1);              }              while (s.heap_len >= 2);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Tree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Tree.cs,build_tree,The following statement contains a magic number: do               {                  // n = node of least frequency                  n = s.heap[1];                  s.heap[1] = s.heap[s.heap_len--];                  s.pqdownheap(tree' 1);                  m = s.heap[1]; // m = node of next least frequency                                                    s.heap[--s.heap_max] = n; // keep the nodes sorted by frequency                  s.heap[--s.heap_max] = m;                                                    // Create a new node father of n and m                  tree[node * 2] = unchecked((short) (tree[n * 2] + tree[m * 2]));                  s.depth[node] = (sbyte) (System.Math.Max((byte) s.depth[n]' (byte) s.depth[m]) + 1);                  tree[n * 2 + 1] = tree[m * 2 + 1] = (short) node;                                                    // and insert the new node in the heap                  s.heap[1] = node++;                  s.pqdownheap(tree' 1);              }              while (s.heap_len >= 2);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Tree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Tree.cs,gen_codes,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  int len = tree[n * 2 + 1];                  if (len == 0)                      continue;                  // Now reverse the bits                  tree[n * 2] =  unchecked((short) (bi_reverse(next_code[len]++' len)));              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Tree,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Tree.cs,gen_codes,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  int len = tree[n * 2 + 1];                  if (len == 0)                      continue;                  // Now reverse the bits                  tree[n * 2] =  unchecked((short) (bi_reverse(next_code[len]++' len)));              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Adler,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Zlib.cs,Adler32,The following statement contains a magic number: uint s2 = (uint) ((adler >> 16) & 0xffff);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Adler,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Zlib.cs,Adler32,The following statement contains a magic number: while (len > 0)              {                  int k = len < NMAX ? len : NMAX;                  len -= k;                  while (k >= 16)                  {                      //s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      k -= 16;                  }                  if (k != 0)                  {                      do                      {                          s1 += buf[index++];                          s2 += s1;                      }                      while (--k != 0);                  }                  s1 %= BASE;                  s2 %= BASE;              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Adler,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Zlib.cs,Adler32,The following statement contains a magic number: while (len > 0)              {                  int k = len < NMAX ? len : NMAX;                  len -= k;                  while (k >= 16)                  {                      //s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      k -= 16;                  }                  if (k != 0)                  {                      do                      {                          s1 += buf[index++];                          s2 += s1;                      }                      while (--k != 0);                  }                  s1 %= BASE;                  s2 %= BASE;              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,Adler,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Zlib.cs,Adler32,The following statement contains a magic number: return (uint)((s2 << 16) | s1);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,ZlibBaseStream,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\ZlibBaseStream.cs,Write,The following statement contains a magic number: do              {                  _z.OutputBuffer = workingBuffer;                  _z.NextOut = 0;                  _z.AvailableBytesOut = _workingBuffer.Length;                  int rc = (_wantCompress)                      ? _z.Deflate(_flushMode)                      : _z.Inflate(_flushMode);                  if (rc != ZlibConstants.Z_OK && rc != ZlibConstants.Z_STREAM_END)                      throw new ZlibException((_wantCompress ? "de" : "in") + "flating: " + _z.Message);                    //if (_workingBuffer.Length - _z.AvailableBytesOut > 0)                  _stream.Write(_workingBuffer' 0' _workingBuffer.Length - _z.AvailableBytesOut);                    done = _z.AvailableBytesIn == 0 && _z.AvailableBytesOut != 0;                    // If GZIP and de-compress' we're done when 8 bytes remain.                  if (_flavor == ZlibStreamFlavor.GZIP && !_wantCompress)                      done = (_z.AvailableBytesIn == 8 && _z.AvailableBytesOut != 0);                }              while (!done);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,ZlibBaseStream,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\ZlibBaseStream.cs,finish,The following statement contains a magic number: if (_streamMode == StreamMode.Writer)              {                  bool done = false;                  do                  {                      _z.OutputBuffer = workingBuffer;                      _z.NextOut = 0;                      _z.AvailableBytesOut = _workingBuffer.Length;                      int rc = (_wantCompress)                          ? _z.Deflate(FlushType.Finish)                          : _z.Inflate(FlushType.Finish);                        if (rc != ZlibConstants.Z_STREAM_END && rc != ZlibConstants.Z_OK)                      {                          string verb = (_wantCompress ? "de" : "in") + "flating";                          if (_z.Message == null)                              throw new ZlibException(String.Format("{0}: (rc = {1})"' verb' rc));                          else                              throw new ZlibException(verb + ": " + _z.Message);                      }                        if (_workingBuffer.Length - _z.AvailableBytesOut > 0)                      {                          _stream.Write(_workingBuffer' 0' _workingBuffer.Length - _z.AvailableBytesOut);                      }                        done = _z.AvailableBytesIn == 0 && _z.AvailableBytesOut != 0;                      // If GZIP and de-compress' we're done when 8 bytes remain.                      if (_flavor == ZlibStreamFlavor.GZIP && !_wantCompress)                          done = (_z.AvailableBytesIn == 8 && _z.AvailableBytesOut != 0);                    }                  while (!done);                    Flush();                    // workitem 7159                  if (_flavor == ZlibStreamFlavor.GZIP)                  {                      if (_wantCompress)                      {                          // Emit the GZIP trailer: CRC32 and  size mod 2^32                          int c1 = crc.Crc32Result;                          _stream.Write(BitConverter.GetBytes(c1)' 0' 4);                          int c2 = (Int32)(crc.TotalBytesRead & 0x00000000FFFFFFFF);                          _stream.Write(BitConverter.GetBytes(c2)' 0' 4);                      }                      else                      {                          throw new ZlibException("Writing with decompression is not supported.");                      }                  }              }              // workitem 7159              else if (_streamMode == StreamMode.Reader)              {                  if (_flavor == ZlibStreamFlavor.GZIP)                  {                      if (!_wantCompress)                      {                          // workitem 8501: handle edge case (decompress empty stream)                          if (_z.TotalBytesOut == 0L)                              return;                            // Read and potentially verify the GZIP trailer:                          // CRC32 and size mod 2^32                          byte[] trailer = new byte[8];                            // workitems 8679 & 12554                          if (_z.AvailableBytesIn < 8)                          {                              // Make sure we have read to the end of the stream                              Array.Copy(_z.InputBuffer' _z.NextIn' trailer' 0' _z.AvailableBytesIn);                              int bytesNeeded = 8 - _z.AvailableBytesIn;                              int bytesRead = _stream.Read(trailer'                                                           _z.AvailableBytesIn'                                                           bytesNeeded);                              if (bytesNeeded != bytesRead)                              {                                  throw new ZlibException(String.Format("Missing or incomplete GZIP trailer. Expected 8 bytes' got {0}."'                                                                        _z.AvailableBytesIn + bytesRead));                              }                          }                          else                          {                              Array.Copy(_z.InputBuffer' _z.NextIn' trailer' 0' trailer.Length);                          }                            Int32 crc32_expected = BitConverter.ToInt32(trailer' 0);                          Int32 crc32_actual = crc.Crc32Result;                          Int32 isize_expected = BitConverter.ToInt32(trailer' 4);                          Int32 isize_actual = (Int32)(_z.TotalBytesOut & 0x00000000FFFFFFFF);                            if (crc32_actual != crc32_expected)                              throw new ZlibException(String.Format("Bad CRC32 in GZIP trailer. (actual({0:X8})!=expected({1:X8}))"' crc32_actual' crc32_expected));                            if (isize_actual != isize_expected)                              throw new ZlibException(String.Format("Bad size in GZIP trailer. (actual({0})!=expected({1}))"' isize_actual' isize_expected));                        }                      else                      {                          throw new ZlibException("Reading with compression is not supported.");                      }                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,ZlibBaseStream,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\ZlibBaseStream.cs,finish,The following statement contains a magic number: if (_streamMode == StreamMode.Writer)              {                  bool done = false;                  do                  {                      _z.OutputBuffer = workingBuffer;                      _z.NextOut = 0;                      _z.AvailableBytesOut = _workingBuffer.Length;                      int rc = (_wantCompress)                          ? _z.Deflate(FlushType.Finish)                          : _z.Inflate(FlushType.Finish);                        if (rc != ZlibConstants.Z_STREAM_END && rc != ZlibConstants.Z_OK)                      {                          string verb = (_wantCompress ? "de" : "in") + "flating";                          if (_z.Message == null)                              throw new ZlibException(String.Format("{0}: (rc = {1})"' verb' rc));                          else                              throw new ZlibException(verb + ": " + _z.Message);                      }                        if (_workingBuffer.Length - _z.AvailableBytesOut > 0)                      {                          _stream.Write(_workingBuffer' 0' _workingBuffer.Length - _z.AvailableBytesOut);                      }                        done = _z.AvailableBytesIn == 0 && _z.AvailableBytesOut != 0;                      // If GZIP and de-compress' we're done when 8 bytes remain.                      if (_flavor == ZlibStreamFlavor.GZIP && !_wantCompress)                          done = (_z.AvailableBytesIn == 8 && _z.AvailableBytesOut != 0);                    }                  while (!done);                    Flush();                    // workitem 7159                  if (_flavor == ZlibStreamFlavor.GZIP)                  {                      if (_wantCompress)                      {                          // Emit the GZIP trailer: CRC32 and  size mod 2^32                          int c1 = crc.Crc32Result;                          _stream.Write(BitConverter.GetBytes(c1)' 0' 4);                          int c2 = (Int32)(crc.TotalBytesRead & 0x00000000FFFFFFFF);                          _stream.Write(BitConverter.GetBytes(c2)' 0' 4);                      }                      else                      {                          throw new ZlibException("Writing with decompression is not supported.");                      }                  }              }              // workitem 7159              else if (_streamMode == StreamMode.Reader)              {                  if (_flavor == ZlibStreamFlavor.GZIP)                  {                      if (!_wantCompress)                      {                          // workitem 8501: handle edge case (decompress empty stream)                          if (_z.TotalBytesOut == 0L)                              return;                            // Read and potentially verify the GZIP trailer:                          // CRC32 and size mod 2^32                          byte[] trailer = new byte[8];                            // workitems 8679 & 12554                          if (_z.AvailableBytesIn < 8)                          {                              // Make sure we have read to the end of the stream                              Array.Copy(_z.InputBuffer' _z.NextIn' trailer' 0' _z.AvailableBytesIn);                              int bytesNeeded = 8 - _z.AvailableBytesIn;                              int bytesRead = _stream.Read(trailer'                                                           _z.AvailableBytesIn'                                                           bytesNeeded);                              if (bytesNeeded != bytesRead)                              {                                  throw new ZlibException(String.Format("Missing or incomplete GZIP trailer. Expected 8 bytes' got {0}."'                                                                        _z.AvailableBytesIn + bytesRead));                              }                          }                          else                          {                              Array.Copy(_z.InputBuffer' _z.NextIn' trailer' 0' trailer.Length);                          }                            Int32 crc32_expected = BitConverter.ToInt32(trailer' 0);                          Int32 crc32_actual = crc.Crc32Result;                          Int32 isize_expected = BitConverter.ToInt32(trailer' 4);                          Int32 isize_actual = (Int32)(_z.TotalBytesOut & 0x00000000FFFFFFFF);                            if (crc32_actual != crc32_expected)                              throw new ZlibException(String.Format("Bad CRC32 in GZIP trailer. (actual({0:X8})!=expected({1:X8}))"' crc32_actual' crc32_expected));                            if (isize_actual != isize_expected)                              throw new ZlibException(String.Format("Bad size in GZIP trailer. (actual({0})!=expected({1}))"' isize_actual' isize_expected));                        }                      else                      {                          throw new ZlibException("Reading with compression is not supported.");                      }                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,ZlibBaseStream,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\ZlibBaseStream.cs,finish,The following statement contains a magic number: if (_streamMode == StreamMode.Writer)              {                  bool done = false;                  do                  {                      _z.OutputBuffer = workingBuffer;                      _z.NextOut = 0;                      _z.AvailableBytesOut = _workingBuffer.Length;                      int rc = (_wantCompress)                          ? _z.Deflate(FlushType.Finish)                          : _z.Inflate(FlushType.Finish);                        if (rc != ZlibConstants.Z_STREAM_END && rc != ZlibConstants.Z_OK)                      {                          string verb = (_wantCompress ? "de" : "in") + "flating";                          if (_z.Message == null)                              throw new ZlibException(String.Format("{0}: (rc = {1})"' verb' rc));                          else                              throw new ZlibException(verb + ": " + _z.Message);                      }                        if (_workingBuffer.Length - _z.AvailableBytesOut > 0)                      {                          _stream.Write(_workingBuffer' 0' _workingBuffer.Length - _z.AvailableBytesOut);                      }                        done = _z.AvailableBytesIn == 0 && _z.AvailableBytesOut != 0;                      // If GZIP and de-compress' we're done when 8 bytes remain.                      if (_flavor == ZlibStreamFlavor.GZIP && !_wantCompress)                          done = (_z.AvailableBytesIn == 8 && _z.AvailableBytesOut != 0);                    }                  while (!done);                    Flush();                    // workitem 7159                  if (_flavor == ZlibStreamFlavor.GZIP)                  {                      if (_wantCompress)                      {                          // Emit the GZIP trailer: CRC32 and  size mod 2^32                          int c1 = crc.Crc32Result;                          _stream.Write(BitConverter.GetBytes(c1)' 0' 4);                          int c2 = (Int32)(crc.TotalBytesRead & 0x00000000FFFFFFFF);                          _stream.Write(BitConverter.GetBytes(c2)' 0' 4);                      }                      else                      {                          throw new ZlibException("Writing with decompression is not supported.");                      }                  }              }              // workitem 7159              else if (_streamMode == StreamMode.Reader)              {                  if (_flavor == ZlibStreamFlavor.GZIP)                  {                      if (!_wantCompress)                      {                          // workitem 8501: handle edge case (decompress empty stream)                          if (_z.TotalBytesOut == 0L)                              return;                            // Read and potentially verify the GZIP trailer:                          // CRC32 and size mod 2^32                          byte[] trailer = new byte[8];                            // workitems 8679 & 12554                          if (_z.AvailableBytesIn < 8)                          {                              // Make sure we have read to the end of the stream                              Array.Copy(_z.InputBuffer' _z.NextIn' trailer' 0' _z.AvailableBytesIn);                              int bytesNeeded = 8 - _z.AvailableBytesIn;                              int bytesRead = _stream.Read(trailer'                                                           _z.AvailableBytesIn'                                                           bytesNeeded);                              if (bytesNeeded != bytesRead)                              {                                  throw new ZlibException(String.Format("Missing or incomplete GZIP trailer. Expected 8 bytes' got {0}."'                                                                        _z.AvailableBytesIn + bytesRead));                              }                          }                          else                          {                              Array.Copy(_z.InputBuffer' _z.NextIn' trailer' 0' trailer.Length);                          }                            Int32 crc32_expected = BitConverter.ToInt32(trailer' 0);                          Int32 crc32_actual = crc.Crc32Result;                          Int32 isize_expected = BitConverter.ToInt32(trailer' 4);                          Int32 isize_actual = (Int32)(_z.TotalBytesOut & 0x00000000FFFFFFFF);                            if (crc32_actual != crc32_expected)                              throw new ZlibException(String.Format("Bad CRC32 in GZIP trailer. (actual({0:X8})!=expected({1:X8}))"' crc32_actual' crc32_expected));                            if (isize_actual != isize_expected)                              throw new ZlibException(String.Format("Bad size in GZIP trailer. (actual({0})!=expected({1}))"' isize_actual' isize_expected));                        }                      else                      {                          throw new ZlibException("Reading with compression is not supported.");                      }                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,ZlibBaseStream,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\ZlibBaseStream.cs,finish,The following statement contains a magic number: if (_streamMode == StreamMode.Writer)              {                  bool done = false;                  do                  {                      _z.OutputBuffer = workingBuffer;                      _z.NextOut = 0;                      _z.AvailableBytesOut = _workingBuffer.Length;                      int rc = (_wantCompress)                          ? _z.Deflate(FlushType.Finish)                          : _z.Inflate(FlushType.Finish);                        if (rc != ZlibConstants.Z_STREAM_END && rc != ZlibConstants.Z_OK)                      {                          string verb = (_wantCompress ? "de" : "in") + "flating";                          if (_z.Message == null)                              throw new ZlibException(String.Format("{0}: (rc = {1})"' verb' rc));                          else                              throw new ZlibException(verb + ": " + _z.Message);                      }                        if (_workingBuffer.Length - _z.AvailableBytesOut > 0)                      {                          _stream.Write(_workingBuffer' 0' _workingBuffer.Length - _z.AvailableBytesOut);                      }                        done = _z.AvailableBytesIn == 0 && _z.AvailableBytesOut != 0;                      // If GZIP and de-compress' we're done when 8 bytes remain.                      if (_flavor == ZlibStreamFlavor.GZIP && !_wantCompress)                          done = (_z.AvailableBytesIn == 8 && _z.AvailableBytesOut != 0);                    }                  while (!done);                    Flush();                    // workitem 7159                  if (_flavor == ZlibStreamFlavor.GZIP)                  {                      if (_wantCompress)                      {                          // Emit the GZIP trailer: CRC32 and  size mod 2^32                          int c1 = crc.Crc32Result;                          _stream.Write(BitConverter.GetBytes(c1)' 0' 4);                          int c2 = (Int32)(crc.TotalBytesRead & 0x00000000FFFFFFFF);                          _stream.Write(BitConverter.GetBytes(c2)' 0' 4);                      }                      else                      {                          throw new ZlibException("Writing with decompression is not supported.");                      }                  }              }              // workitem 7159              else if (_streamMode == StreamMode.Reader)              {                  if (_flavor == ZlibStreamFlavor.GZIP)                  {                      if (!_wantCompress)                      {                          // workitem 8501: handle edge case (decompress empty stream)                          if (_z.TotalBytesOut == 0L)                              return;                            // Read and potentially verify the GZIP trailer:                          // CRC32 and size mod 2^32                          byte[] trailer = new byte[8];                            // workitems 8679 & 12554                          if (_z.AvailableBytesIn < 8)                          {                              // Make sure we have read to the end of the stream                              Array.Copy(_z.InputBuffer' _z.NextIn' trailer' 0' _z.AvailableBytesIn);                              int bytesNeeded = 8 - _z.AvailableBytesIn;                              int bytesRead = _stream.Read(trailer'                                                           _z.AvailableBytesIn'                                                           bytesNeeded);                              if (bytesNeeded != bytesRead)                              {                                  throw new ZlibException(String.Format("Missing or incomplete GZIP trailer. Expected 8 bytes' got {0}."'                                                                        _z.AvailableBytesIn + bytesRead));                              }                          }                          else                          {                              Array.Copy(_z.InputBuffer' _z.NextIn' trailer' 0' trailer.Length);                          }                            Int32 crc32_expected = BitConverter.ToInt32(trailer' 0);                          Int32 crc32_actual = crc.Crc32Result;                          Int32 isize_expected = BitConverter.ToInt32(trailer' 4);                          Int32 isize_actual = (Int32)(_z.TotalBytesOut & 0x00000000FFFFFFFF);                            if (crc32_actual != crc32_expected)                              throw new ZlibException(String.Format("Bad CRC32 in GZIP trailer. (actual({0:X8})!=expected({1:X8}))"' crc32_actual' crc32_expected));                            if (isize_actual != isize_expected)                              throw new ZlibException(String.Format("Bad size in GZIP trailer. (actual({0})!=expected({1}))"' isize_actual' isize_expected));                        }                      else                      {                          throw new ZlibException("Reading with compression is not supported.");                      }                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,ZlibBaseStream,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\ZlibBaseStream.cs,finish,The following statement contains a magic number: if (_streamMode == StreamMode.Writer)              {                  bool done = false;                  do                  {                      _z.OutputBuffer = workingBuffer;                      _z.NextOut = 0;                      _z.AvailableBytesOut = _workingBuffer.Length;                      int rc = (_wantCompress)                          ? _z.Deflate(FlushType.Finish)                          : _z.Inflate(FlushType.Finish);                        if (rc != ZlibConstants.Z_STREAM_END && rc != ZlibConstants.Z_OK)                      {                          string verb = (_wantCompress ? "de" : "in") + "flating";                          if (_z.Message == null)                              throw new ZlibException(String.Format("{0}: (rc = {1})"' verb' rc));                          else                              throw new ZlibException(verb + ": " + _z.Message);                      }                        if (_workingBuffer.Length - _z.AvailableBytesOut > 0)                      {                          _stream.Write(_workingBuffer' 0' _workingBuffer.Length - _z.AvailableBytesOut);                      }                        done = _z.AvailableBytesIn == 0 && _z.AvailableBytesOut != 0;                      // If GZIP and de-compress' we're done when 8 bytes remain.                      if (_flavor == ZlibStreamFlavor.GZIP && !_wantCompress)                          done = (_z.AvailableBytesIn == 8 && _z.AvailableBytesOut != 0);                    }                  while (!done);                    Flush();                    // workitem 7159                  if (_flavor == ZlibStreamFlavor.GZIP)                  {                      if (_wantCompress)                      {                          // Emit the GZIP trailer: CRC32 and  size mod 2^32                          int c1 = crc.Crc32Result;                          _stream.Write(BitConverter.GetBytes(c1)' 0' 4);                          int c2 = (Int32)(crc.TotalBytesRead & 0x00000000FFFFFFFF);                          _stream.Write(BitConverter.GetBytes(c2)' 0' 4);                      }                      else                      {                          throw new ZlibException("Writing with decompression is not supported.");                      }                  }              }              // workitem 7159              else if (_streamMode == StreamMode.Reader)              {                  if (_flavor == ZlibStreamFlavor.GZIP)                  {                      if (!_wantCompress)                      {                          // workitem 8501: handle edge case (decompress empty stream)                          if (_z.TotalBytesOut == 0L)                              return;                            // Read and potentially verify the GZIP trailer:                          // CRC32 and size mod 2^32                          byte[] trailer = new byte[8];                            // workitems 8679 & 12554                          if (_z.AvailableBytesIn < 8)                          {                              // Make sure we have read to the end of the stream                              Array.Copy(_z.InputBuffer' _z.NextIn' trailer' 0' _z.AvailableBytesIn);                              int bytesNeeded = 8 - _z.AvailableBytesIn;                              int bytesRead = _stream.Read(trailer'                                                           _z.AvailableBytesIn'                                                           bytesNeeded);                              if (bytesNeeded != bytesRead)                              {                                  throw new ZlibException(String.Format("Missing or incomplete GZIP trailer. Expected 8 bytes' got {0}."'                                                                        _z.AvailableBytesIn + bytesRead));                              }                          }                          else                          {                              Array.Copy(_z.InputBuffer' _z.NextIn' trailer' 0' trailer.Length);                          }                            Int32 crc32_expected = BitConverter.ToInt32(trailer' 0);                          Int32 crc32_actual = crc.Crc32Result;                          Int32 isize_expected = BitConverter.ToInt32(trailer' 4);                          Int32 isize_actual = (Int32)(_z.TotalBytesOut & 0x00000000FFFFFFFF);                            if (crc32_actual != crc32_expected)                              throw new ZlibException(String.Format("Bad CRC32 in GZIP trailer. (actual({0:X8})!=expected({1:X8}))"' crc32_actual' crc32_expected));                            if (isize_actual != isize_expected)                              throw new ZlibException(String.Format("Bad size in GZIP trailer. (actual({0})!=expected({1}))"' isize_actual' isize_expected));                        }                      else                      {                          throw new ZlibException("Reading with compression is not supported.");                      }                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,ZlibBaseStream,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\ZlibBaseStream.cs,finish,The following statement contains a magic number: if (_streamMode == StreamMode.Writer)              {                  bool done = false;                  do                  {                      _z.OutputBuffer = workingBuffer;                      _z.NextOut = 0;                      _z.AvailableBytesOut = _workingBuffer.Length;                      int rc = (_wantCompress)                          ? _z.Deflate(FlushType.Finish)                          : _z.Inflate(FlushType.Finish);                        if (rc != ZlibConstants.Z_STREAM_END && rc != ZlibConstants.Z_OK)                      {                          string verb = (_wantCompress ? "de" : "in") + "flating";                          if (_z.Message == null)                              throw new ZlibException(String.Format("{0}: (rc = {1})"' verb' rc));                          else                              throw new ZlibException(verb + ": " + _z.Message);                      }                        if (_workingBuffer.Length - _z.AvailableBytesOut > 0)                      {                          _stream.Write(_workingBuffer' 0' _workingBuffer.Length - _z.AvailableBytesOut);                      }                        done = _z.AvailableBytesIn == 0 && _z.AvailableBytesOut != 0;                      // If GZIP and de-compress' we're done when 8 bytes remain.                      if (_flavor == ZlibStreamFlavor.GZIP && !_wantCompress)                          done = (_z.AvailableBytesIn == 8 && _z.AvailableBytesOut != 0);                    }                  while (!done);                    Flush();                    // workitem 7159                  if (_flavor == ZlibStreamFlavor.GZIP)                  {                      if (_wantCompress)                      {                          // Emit the GZIP trailer: CRC32 and  size mod 2^32                          int c1 = crc.Crc32Result;                          _stream.Write(BitConverter.GetBytes(c1)' 0' 4);                          int c2 = (Int32)(crc.TotalBytesRead & 0x00000000FFFFFFFF);                          _stream.Write(BitConverter.GetBytes(c2)' 0' 4);                      }                      else                      {                          throw new ZlibException("Writing with decompression is not supported.");                      }                  }              }              // workitem 7159              else if (_streamMode == StreamMode.Reader)              {                  if (_flavor == ZlibStreamFlavor.GZIP)                  {                      if (!_wantCompress)                      {                          // workitem 8501: handle edge case (decompress empty stream)                          if (_z.TotalBytesOut == 0L)                              return;                            // Read and potentially verify the GZIP trailer:                          // CRC32 and size mod 2^32                          byte[] trailer = new byte[8];                            // workitems 8679 & 12554                          if (_z.AvailableBytesIn < 8)                          {                              // Make sure we have read to the end of the stream                              Array.Copy(_z.InputBuffer' _z.NextIn' trailer' 0' _z.AvailableBytesIn);                              int bytesNeeded = 8 - _z.AvailableBytesIn;                              int bytesRead = _stream.Read(trailer'                                                           _z.AvailableBytesIn'                                                           bytesNeeded);                              if (bytesNeeded != bytesRead)                              {                                  throw new ZlibException(String.Format("Missing or incomplete GZIP trailer. Expected 8 bytes' got {0}."'                                                                        _z.AvailableBytesIn + bytesRead));                              }                          }                          else                          {                              Array.Copy(_z.InputBuffer' _z.NextIn' trailer' 0' trailer.Length);                          }                            Int32 crc32_expected = BitConverter.ToInt32(trailer' 0);                          Int32 crc32_actual = crc.Crc32Result;                          Int32 isize_expected = BitConverter.ToInt32(trailer' 4);                          Int32 isize_actual = (Int32)(_z.TotalBytesOut & 0x00000000FFFFFFFF);                            if (crc32_actual != crc32_expected)                              throw new ZlibException(String.Format("Bad CRC32 in GZIP trailer. (actual({0:X8})!=expected({1:X8}))"' crc32_actual' crc32_expected));                            if (isize_actual != isize_expected)                              throw new ZlibException(String.Format("Bad size in GZIP trailer. (actual({0})!=expected({1}))"' isize_actual' isize_expected));                        }                      else                      {                          throw new ZlibException("Reading with compression is not supported.");                      }                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,ZlibBaseStream,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\ZlibBaseStream.cs,finish,The following statement contains a magic number: if (_streamMode == StreamMode.Writer)              {                  bool done = false;                  do                  {                      _z.OutputBuffer = workingBuffer;                      _z.NextOut = 0;                      _z.AvailableBytesOut = _workingBuffer.Length;                      int rc = (_wantCompress)                          ? _z.Deflate(FlushType.Finish)                          : _z.Inflate(FlushType.Finish);                        if (rc != ZlibConstants.Z_STREAM_END && rc != ZlibConstants.Z_OK)                      {                          string verb = (_wantCompress ? "de" : "in") + "flating";                          if (_z.Message == null)                              throw new ZlibException(String.Format("{0}: (rc = {1})"' verb' rc));                          else                              throw new ZlibException(verb + ": " + _z.Message);                      }                        if (_workingBuffer.Length - _z.AvailableBytesOut > 0)                      {                          _stream.Write(_workingBuffer' 0' _workingBuffer.Length - _z.AvailableBytesOut);                      }                        done = _z.AvailableBytesIn == 0 && _z.AvailableBytesOut != 0;                      // If GZIP and de-compress' we're done when 8 bytes remain.                      if (_flavor == ZlibStreamFlavor.GZIP && !_wantCompress)                          done = (_z.AvailableBytesIn == 8 && _z.AvailableBytesOut != 0);                    }                  while (!done);                    Flush();                    // workitem 7159                  if (_flavor == ZlibStreamFlavor.GZIP)                  {                      if (_wantCompress)                      {                          // Emit the GZIP trailer: CRC32 and  size mod 2^32                          int c1 = crc.Crc32Result;                          _stream.Write(BitConverter.GetBytes(c1)' 0' 4);                          int c2 = (Int32)(crc.TotalBytesRead & 0x00000000FFFFFFFF);                          _stream.Write(BitConverter.GetBytes(c2)' 0' 4);                      }                      else                      {                          throw new ZlibException("Writing with decompression is not supported.");                      }                  }              }              // workitem 7159              else if (_streamMode == StreamMode.Reader)              {                  if (_flavor == ZlibStreamFlavor.GZIP)                  {                      if (!_wantCompress)                      {                          // workitem 8501: handle edge case (decompress empty stream)                          if (_z.TotalBytesOut == 0L)                              return;                            // Read and potentially verify the GZIP trailer:                          // CRC32 and size mod 2^32                          byte[] trailer = new byte[8];                            // workitems 8679 & 12554                          if (_z.AvailableBytesIn < 8)                          {                              // Make sure we have read to the end of the stream                              Array.Copy(_z.InputBuffer' _z.NextIn' trailer' 0' _z.AvailableBytesIn);                              int bytesNeeded = 8 - _z.AvailableBytesIn;                              int bytesRead = _stream.Read(trailer'                                                           _z.AvailableBytesIn'                                                           bytesNeeded);                              if (bytesNeeded != bytesRead)                              {                                  throw new ZlibException(String.Format("Missing or incomplete GZIP trailer. Expected 8 bytes' got {0}."'                                                                        _z.AvailableBytesIn + bytesRead));                              }                          }                          else                          {                              Array.Copy(_z.InputBuffer' _z.NextIn' trailer' 0' trailer.Length);                          }                            Int32 crc32_expected = BitConverter.ToInt32(trailer' 0);                          Int32 crc32_actual = crc.Crc32Result;                          Int32 isize_expected = BitConverter.ToInt32(trailer' 4);                          Int32 isize_actual = (Int32)(_z.TotalBytesOut & 0x00000000FFFFFFFF);                            if (crc32_actual != crc32_expected)                              throw new ZlibException(String.Format("Bad CRC32 in GZIP trailer. (actual({0:X8})!=expected({1:X8}))"' crc32_actual' crc32_expected));                            if (isize_actual != isize_expected)                              throw new ZlibException(String.Format("Bad size in GZIP trailer. (actual({0})!=expected({1}))"' isize_actual' isize_expected));                        }                      else                      {                          throw new ZlibException("Reading with compression is not supported.");                      }                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,ZlibBaseStream,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: byte[] header = new byte[10];
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,ZlibBaseStream,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: if (n != 10)                  throw new ZlibException("Not a valid GZIP stream.");
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,ZlibBaseStream,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: if (header[0] != 0x1F || header[1] != 0x8B || header[2] != 8)                  throw new ZlibException("Bad GZIP header.");
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,ZlibBaseStream,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: if (header[0] != 0x1F || header[1] != 0x8B || header[2] != 8)                  throw new ZlibException("Bad GZIP header.");
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,ZlibBaseStream,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: Int32 timet = BitConverter.ToInt32(header' 4);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,ZlibBaseStream,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: if ((header[3] & 0x04) == 0x04)              {                  // read and discard extra field                  n = _stream.Read(header' 0' 2); // 2-byte length field                  totalBytesRead += n;                    Int16 extraLength = (Int16)(header[0] + header[1] * 256);                  byte[] extra = new byte[extraLength];                  n = _stream.Read(extra' 0' extra.Length);                  if (n != extraLength)                      throw new ZlibException("Unexpected end-of-file reading GZIP header.");                  totalBytesRead += n;              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,ZlibBaseStream,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: if ((header[3] & 0x04) == 0x04)              {                  // read and discard extra field                  n = _stream.Read(header' 0' 2); // 2-byte length field                  totalBytesRead += n;                    Int16 extraLength = (Int16)(header[0] + header[1] * 256);                  byte[] extra = new byte[extraLength];                  n = _stream.Read(extra' 0' extra.Length);                  if (n != extraLength)                      throw new ZlibException("Unexpected end-of-file reading GZIP header.");                  totalBytesRead += n;              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,ZlibBaseStream,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: if ((header[3] & 0x04) == 0x04)              {                  // read and discard extra field                  n = _stream.Read(header' 0' 2); // 2-byte length field                  totalBytesRead += n;                    Int16 extraLength = (Int16)(header[0] + header[1] * 256);                  byte[] extra = new byte[extraLength];                  n = _stream.Read(extra' 0' extra.Length);                  if (n != extraLength)                      throw new ZlibException("Unexpected end-of-file reading GZIP header.");                  totalBytesRead += n;              }
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,ZlibBaseStream,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: if ((header[3] & 0x08) == 0x08)                  _GzipFileName = ReadZeroTerminatedString();
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,ZlibBaseStream,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: if ((header[3] & 0x10) == 0x010)                  _GzipComment = ReadZeroTerminatedString();
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,ZlibBaseStream,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: if ((header[3] & 0x02) == 0x02)                  Read(_buf1' 0' 1);
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,ZlibBaseStream,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\ZlibBaseStream.cs,UncompressString,The following statement contains a magic number: byte[] working = new byte[1024];
Magic Number,ROMVault2.SupportedFiles.Zip.ZLib,ZlibBaseStream,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\ZlibBaseStream.cs,UncompressBuffer,The following statement contains a magic number: byte[] working = new byte[1024];
Magic Number,RomVaultX.SupportedFiles.Files,ThreadCRC,C:\repos\gjefferyes_RomVault\ROMVault2\ThreadReaders\ThreadCRC.cs,ThreadCRC,The following statement contains a magic number: _crc32Lookup = new uint[256];
Magic Number,RomVaultX.SupportedFiles.Files,ThreadCRC,C:\repos\gjefferyes_RomVault\ROMVault2\ThreadReaders\ThreadCRC.cs,ThreadCRC,The following statement contains a magic number: for (uint i = 0; i < 256; i++)              {                  uint entry = i;                  for (uint j = 0; j < 8; j++)                      if ((entry & 1) == 1)                          entry = (entry >> 1) ^ polynomial;                      else                          entry = entry >> 1;                  _crc32Lookup[i] = entry;              }
Magic Number,RomVaultX.SupportedFiles.Files,ThreadCRC,C:\repos\gjefferyes_RomVault\ROMVault2\ThreadReaders\ThreadCRC.cs,ThreadCRC,The following statement contains a magic number: for (uint i = 0; i < 256; i++)              {                  uint entry = i;                  for (uint j = 0; j < 8; j++)                      if ((entry & 1) == 1)                          entry = (entry >> 1) ^ polynomial;                      else                          entry = entry >> 1;                  _crc32Lookup[i] = entry;              }
Magic Number,RomVaultX.SupportedFiles.Files,ThreadCRC,C:\repos\gjefferyes_RomVault\ROMVault2\ThreadReaders\ThreadCRC.cs,MainLoop,The following statement contains a magic number: while (true)              {                  _waitEvent.WaitOne();                  if (_finished) break;                  for (int i = 0; i < _size; ++i)                      _crc = (_crc >> 8) ^ _crc32Lookup[(_crc & 0xff) ^ _buffer[i]];                    _outEvent.Set();              }
Magic Number,ROMVault2.Utils,VarFix,C:\repos\gjefferyes_RomVault\ROMVault2\Utils\VarFix.cs,ULong,The following statement contains a magic number: try              {                  if (n.Length >= 2 && n.Substring(0' 2).ToLower() == "0x")                  {                      return Convert.ToUInt64(n.Substring(2)' 16);                  }                    return Convert.ToUInt64(n);              }              catch              {                  return null;              }
Magic Number,ROMVault2.Utils,VarFix,C:\repos\gjefferyes_RomVault\ROMVault2\Utils\VarFix.cs,ULong,The following statement contains a magic number: try              {                  if (n.Length >= 2 && n.Substring(0' 2).ToLower() == "0x")                  {                      return Convert.ToUInt64(n.Substring(2)' 16);                  }                    return Convert.ToUInt64(n);              }              catch              {                  return null;              }
Magic Number,ROMVault2.Utils,VarFix,C:\repos\gjefferyes_RomVault\ROMVault2\Utils\VarFix.cs,ULong,The following statement contains a magic number: try              {                  if (n.Length >= 2 && n.Substring(0' 2).ToLower() == "0x")                  {                      return Convert.ToUInt64(n.Substring(2)' 16);                  }                    return Convert.ToUInt64(n);              }              catch              {                  return null;              }
Magic Number,ROMVault2.Utils,VarFix,C:\repos\gjefferyes_RomVault\ROMVault2\Utils\VarFix.cs,ULong,The following statement contains a magic number: try              {                  if (n.Length >= 2 && n.Substring(0' 2).ToLower() == "0x")                  {                      return Convert.ToUInt64(n.Substring(2)' 16);                  }                    return Convert.ToUInt64(n);              }              catch              {                  return null;              }
Magic Number,ROMVault2.Utils,VarFix,C:\repos\gjefferyes_RomVault\ROMVault2\Utils\VarFix.cs,CleanCheck,The following statement contains a magic number: if (retcrc.Length >= 2 && retcrc.Substring(0' 2).ToLower() == "0x")                  retcrc = retcrc.Substring(2);
Magic Number,ROMVault2.Utils,VarFix,C:\repos\gjefferyes_RomVault\ROMVault2\Utils\VarFix.cs,CleanCheck,The following statement contains a magic number: if (retcrc.Length >= 2 && retcrc.Substring(0' 2).ToLower() == "0x")                  retcrc = retcrc.Substring(2);
Magic Number,ROMVault2.Utils,VarFix,C:\repos\gjefferyes_RomVault\ROMVault2\Utils\VarFix.cs,CleanCheck,The following statement contains a magic number: if (retcrc.Length >= 2 && retcrc.Substring(0' 2).ToLower() == "0x")                  retcrc = retcrc.Substring(2);
Magic Number,ROMVault2.Utils,VarFix,C:\repos\gjefferyes_RomVault\ROMVault2\Utils\VarFix.cs,CleanMD5SHA1,The following statement contains a magic number: if (checksum.Length >= 2)                  if (checksum.Substring(0' 2) == "0x")                      checksum = checksum.Substring(2);
Magic Number,ROMVault2.Utils,VarFix,C:\repos\gjefferyes_RomVault\ROMVault2\Utils\VarFix.cs,CleanMD5SHA1,The following statement contains a magic number: if (checksum.Length >= 2)                  if (checksum.Substring(0' 2) == "0x")                      checksum = checksum.Substring(2);
Magic Number,ROMVault2.Utils,VarFix,C:\repos\gjefferyes_RomVault\ROMVault2\Utils\VarFix.cs,CleanMD5SHA1,The following statement contains a magic number: if (checksum.Length >= 2)                  if (checksum.Substring(0' 2) == "0x")                      checksum = checksum.Substring(2);
Magic Number,ROMVault2.Utils,VarFix,C:\repos\gjefferyes_RomVault\ROMVault2\Utils\VarFix.cs,CleanMD5SHA1,The following statement contains a magic number: int retL = checksum.Length / 2;
Magic Number,ROMVault2.Utils,VarFix,C:\repos\gjefferyes_RomVault\ROMVault2\Utils\VarFix.cs,CleanMD5SHA1,The following statement contains a magic number: for (int i = 0; i < retL; i++)                  retB[i] = Convert.ToByte(checksum.Substring(i * 2' 2)' 16);
Magic Number,ROMVault2.Utils,VarFix,C:\repos\gjefferyes_RomVault\ROMVault2\Utils\VarFix.cs,CleanMD5SHA1,The following statement contains a magic number: for (int i = 0; i < retL; i++)                  retB[i] = Convert.ToByte(checksum.Substring(i * 2' 2)' 16);
Magic Number,ROMVault2.Utils,VarFix,C:\repos\gjefferyes_RomVault\ROMVault2\Utils\VarFix.cs,CleanMD5SHA1,The following statement contains a magic number: for (int i = 0; i < retL; i++)                  retB[i] = Convert.ToByte(checksum.Substring(i * 2' 2)' 16);
Magic Number,ROMVault2.Utils,VarFix,C:\repos\gjefferyes_RomVault\ROMVault2\Utils\VarFix.cs,CleanFullFileName,The following statement contains a magic number: for (int i = 0; i < charName.Length; i++)              {                  int c = charName[i];                  if (c == ':' || c == '*' || c == '?' || c == '<' || c == '>' || c == '|' || c < 32)                      charName[i] = '-';                  else if (c == '\\')                      charName[i] = '/';              }
Magic Number,ROMVault2.Utils,VarFix,C:\repos\gjefferyes_RomVault\ROMVault2\Utils\VarFix.cs,CleanFileName,The following statement contains a magic number: for (int i = 0; i < charName.Length; i++)              {                  int c = charName[i];                  if (c == ':' || c == '*' || c == '?' || c == '<' || c == '>' || c == '|' || c == '\\' || c == '/' || c < 32)                      charName[i] = crep;              }
Magic Number,ROMVault2.IO,Path,C:\repos\gjefferyes_RomVault\ROMVault2\IO\RVIO.cs,IsPathRooted,The following statement contains a magic number: if (path != null)              {                  //CheckInvalidPathChars(path);                    int length = path.Length;                  if (                      (length >= 1 && (path[0] == DirectorySeparatorChar ||                      path[0] == AltDirectorySeparatorChar)) ||                      (length >= 2 && path[1] == VolumeSeparatorChar)                      ) return true;              }
Magic Number,ROMVault2.IO,Path,C:\repos\gjefferyes_RomVault\ROMVault2\IO\RVIO.cs,GetRootLength,The following statement contains a magic number: if (length >= 1 && (IsDirectorySeparator(path[0])))              {                  // handles UNC names and directories off current drive's root.                  i = 1;                  if (length >= 2 && (IsDirectorySeparator(path[1])))                  {                      i = 2;                      int n = 2;                      while (i < length && ((path[i] != DirectorySeparatorChar && path[i] != AltDirectorySeparatorChar) || --n > 0)) i++;                  }              }              else if (length >= 2 && path[1] == VolumeSeparatorChar)              {                  // handles A:\foo.                  i = 2;                  if (length >= 3 && (IsDirectorySeparator(path[2]))) i++;              }
Magic Number,ROMVault2.IO,Path,C:\repos\gjefferyes_RomVault\ROMVault2\IO\RVIO.cs,GetRootLength,The following statement contains a magic number: if (length >= 1 && (IsDirectorySeparator(path[0])))              {                  // handles UNC names and directories off current drive's root.                  i = 1;                  if (length >= 2 && (IsDirectorySeparator(path[1])))                  {                      i = 2;                      int n = 2;                      while (i < length && ((path[i] != DirectorySeparatorChar && path[i] != AltDirectorySeparatorChar) || --n > 0)) i++;                  }              }              else if (length >= 2 && path[1] == VolumeSeparatorChar)              {                  // handles A:\foo.                  i = 2;                  if (length >= 3 && (IsDirectorySeparator(path[2]))) i++;              }
Magic Number,ROMVault2.IO,Path,C:\repos\gjefferyes_RomVault\ROMVault2\IO\RVIO.cs,GetRootLength,The following statement contains a magic number: if (length >= 1 && (IsDirectorySeparator(path[0])))              {                  // handles UNC names and directories off current drive's root.                  i = 1;                  if (length >= 2 && (IsDirectorySeparator(path[1])))                  {                      i = 2;                      int n = 2;                      while (i < length && ((path[i] != DirectorySeparatorChar && path[i] != AltDirectorySeparatorChar) || --n > 0)) i++;                  }              }              else if (length >= 2 && path[1] == VolumeSeparatorChar)              {                  // handles A:\foo.                  i = 2;                  if (length >= 3 && (IsDirectorySeparator(path[2]))) i++;              }
Magic Number,ROMVault2.IO,Path,C:\repos\gjefferyes_RomVault\ROMVault2\IO\RVIO.cs,GetRootLength,The following statement contains a magic number: if (length >= 1 && (IsDirectorySeparator(path[0])))              {                  // handles UNC names and directories off current drive's root.                  i = 1;                  if (length >= 2 && (IsDirectorySeparator(path[1])))                  {                      i = 2;                      int n = 2;                      while (i < length && ((path[i] != DirectorySeparatorChar && path[i] != AltDirectorySeparatorChar) || --n > 0)) i++;                  }              }              else if (length >= 2 && path[1] == VolumeSeparatorChar)              {                  // handles A:\foo.                  i = 2;                  if (length >= 3 && (IsDirectorySeparator(path[2]))) i++;              }
Magic Number,ROMVault2.IO,Path,C:\repos\gjefferyes_RomVault\ROMVault2\IO\RVIO.cs,GetRootLength,The following statement contains a magic number: if (length >= 1 && (IsDirectorySeparator(path[0])))              {                  // handles UNC names and directories off current drive's root.                  i = 1;                  if (length >= 2 && (IsDirectorySeparator(path[1])))                  {                      i = 2;                      int n = 2;                      while (i < length && ((path[i] != DirectorySeparatorChar && path[i] != AltDirectorySeparatorChar) || --n > 0)) i++;                  }              }              else if (length >= 2 && path[1] == VolumeSeparatorChar)              {                  // handles A:\foo.                  i = 2;                  if (length >= 3 && (IsDirectorySeparator(path[2]))) i++;              }
Magic Number,ROMVault2.IO,Path,C:\repos\gjefferyes_RomVault\ROMVault2\IO\RVIO.cs,GetRootLength,The following statement contains a magic number: if (length >= 1 && (IsDirectorySeparator(path[0])))              {                  // handles UNC names and directories off current drive's root.                  i = 1;                  if (length >= 2 && (IsDirectorySeparator(path[1])))                  {                      i = 2;                      int n = 2;                      while (i < length && ((path[i] != DirectorySeparatorChar && path[i] != AltDirectorySeparatorChar) || --n > 0)) i++;                  }              }              else if (length >= 2 && path[1] == VolumeSeparatorChar)              {                  // handles A:\foo.                  i = 2;                  if (length >= 3 && (IsDirectorySeparator(path[2]))) i++;              }
Magic Number,ROMVault2.IO,Path,C:\repos\gjefferyes_RomVault\ROMVault2\IO\RVIO.cs,GetRootLength,The following statement contains a magic number: if (length >= 1 && (IsDirectorySeparator(path[0])))              {                  // handles UNC names and directories off current drive's root.                  i = 1;                  if (length >= 2 && (IsDirectorySeparator(path[1])))                  {                      i = 2;                      int n = 2;                      while (i < length && ((path[i] != DirectorySeparatorChar && path[i] != AltDirectorySeparatorChar) || --n > 0)) i++;                  }              }              else if (length >= 2 && path[1] == VolumeSeparatorChar)              {                  // handles A:\foo.                  i = 2;                  if (length >= 3 && (IsDirectorySeparator(path[2]))) i++;              }
Magic Number,ROMVault2.IO,NameFix,C:\repos\gjefferyes_RomVault\ROMVault2\IO\RVIO.cs,GetShortPath,The following statement contains a magic number: if (path.StartsWith(@"\\"))              {                  retPath = @"\\?\UNC\" + path.Substring(2);                  remove = 8;              }              else              {                  retPath = path;                  if (path.Substring(1' 1) != ":")                      retPath = Path.Combine(System.IO.Directory.GetCurrentDirectory()' retPath);                    retPath = cleandots(retPath);                  retPath = @"\\?\" + retPath;                  remove = 4;              }
Magic Number,ROMVault2.IO,NameFix,C:\repos\gjefferyes_RomVault\ROMVault2\IO\RVIO.cs,GetShortPath,The following statement contains a magic number: if (path.StartsWith(@"\\"))              {                  retPath = @"\\?\UNC\" + path.Substring(2);                  remove = 8;              }              else              {                  retPath = path;                  if (path.Substring(1' 1) != ":")                      retPath = Path.Combine(System.IO.Directory.GetCurrentDirectory()' retPath);                    retPath = cleandots(retPath);                  retPath = @"\\?\" + retPath;                  remove = 4;              }
Magic Number,ROMVault2.IO,NameFix,C:\repos\gjefferyes_RomVault\ROMVault2\IO\RVIO.cs,GetShortPath,The following statement contains a magic number: if (path.StartsWith(@"\\"))              {                  retPath = @"\\?\UNC\" + path.Substring(2);                  remove = 8;              }              else              {                  retPath = path;                  if (path.Substring(1' 1) != ":")                      retPath = Path.Combine(System.IO.Directory.GetCurrentDirectory()' retPath);                    retPath = cleandots(retPath);                  retPath = @"\\?\" + retPath;                  remove = 4;              }
Magic Number,ROMVault2.IO,NameFix,C:\repos\gjefferyes_RomVault\ROMVault2\IO\RVIO.cs,GetShortPath,The following statement contains a magic number: const int MAX_PATH = 300;
Magic Number,ROMVault2.IO,NameFix,C:\repos\gjefferyes_RomVault\ROMVault2\IO\RVIO.cs,GetShortPath,The following statement contains a magic number: if (remove == 8) retPath = "\\" + retPath;
Magic Number,ROMVault2.IO,NameFix,C:\repos\gjefferyes_RomVault\ROMVault2\IO\RVIO.cs,AddLongPathPrefix,The following statement contains a magic number: if (path.StartsWith(@"\\"))                  return @"\\?\UNC\" + path.Substring(2);
Magic Number,ROMVault2.IO,NameFix,C:\repos\gjefferyes_RomVault\ROMVault2\IO\RVIO.cs,cleandots,The following statement contains a magic number: while (retPath.Contains(@"\..\"))              {                  int index = retPath.IndexOf(@"\..\");                  string path1 = retPath.Substring(0' index);                  string path2 = retPath.Substring(index + 4);                    int path1Back = path1.LastIndexOf(@"\");                    retPath = path1.Substring(0' path1Back + 1) + path2;              }
Magic Number,ROMVault2.IO,Convert,C:\repos\gjefferyes_RomVault\ROMVault2\IO\Win32Native.cs,Length,The following statement contains a magic number: return ((long) high) << 32 | ((long) low & 0xFFFFFFFFL);
Magic Number,ROMVault2.IO,Convert,C:\repos\gjefferyes_RomVault\ROMVault2\IO\Win32Native.cs,Time,The following statement contains a magic number: return  ((long)high << 32) | low;
Magic Number,ROMVault2.SupportedFiles.Zip,ZipFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,LocalHeader,The following statement contains a magic number: return ((_localFiles[i]._generalPurposeBitFlag & 8) == 0) ? (ulong?)_localFiles[i].RelativeOffsetOfLocalHeader : null;
Magic Number,ROMVault2.SupportedFiles.Zip,ZipFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,FindEndOfCentralDirSignature,The following statement contains a magic number: byte[] buffer = new byte[buffSize + 4];
Magic Number,ROMVault2.SupportedFiles.Zip,ZipFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,FindEndOfCentralDirSignature,The following statement contains a magic number: long backPosition = 4;
Magic Number,ROMVault2.SupportedFiles.Zip,ZipFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,FindEndOfCentralDirSignature,The following statement contains a magic number: while (backPosition < maxBackSearch)              {                  backPosition += buffSize;                  if (backPosition > maxBackSearch) backPosition = maxBackSearch;                    long readSize = backPosition > (buffSize + 4) ? (buffSize + 4) : backPosition;                    _zipFs.Position = fileSize - backPosition;                    _zipFs.Read(buffer' 0' (int)readSize);                      for (long i = readSize - 4; i >= 0; i--)                  {                      if ((buffer[i] != 0x50) || (buffer[i + 1] != 0x4b) || (buffer[i + 2] != 0x05) || (buffer[i + 3] != 0x06)) continue;                        _zipFs.Position = (fileSize - backPosition) + i;                      return ZipReturn.ZipGood;                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip,ZipFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,FindEndOfCentralDirSignature,The following statement contains a magic number: while (backPosition < maxBackSearch)              {                  backPosition += buffSize;                  if (backPosition > maxBackSearch) backPosition = maxBackSearch;                    long readSize = backPosition > (buffSize + 4) ? (buffSize + 4) : backPosition;                    _zipFs.Position = fileSize - backPosition;                    _zipFs.Read(buffer' 0' (int)readSize);                      for (long i = readSize - 4; i >= 0; i--)                  {                      if ((buffer[i] != 0x50) || (buffer[i + 1] != 0x4b) || (buffer[i + 2] != 0x05) || (buffer[i + 3] != 0x06)) continue;                        _zipFs.Position = (fileSize - backPosition) + i;                      return ZipReturn.ZipGood;                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip,ZipFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,FindEndOfCentralDirSignature,The following statement contains a magic number: while (backPosition < maxBackSearch)              {                  backPosition += buffSize;                  if (backPosition > maxBackSearch) backPosition = maxBackSearch;                    long readSize = backPosition > (buffSize + 4) ? (buffSize + 4) : backPosition;                    _zipFs.Position = fileSize - backPosition;                    _zipFs.Read(buffer' 0' (int)readSize);                      for (long i = readSize - 4; i >= 0; i--)                  {                      if ((buffer[i] != 0x50) || (buffer[i + 1] != 0x4b) || (buffer[i + 2] != 0x05) || (buffer[i + 3] != 0x06)) continue;                        _zipFs.Position = (fileSize - backPosition) + i;                      return ZipReturn.ZipGood;                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip,ZipFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,FindEndOfCentralDirSignature,The following statement contains a magic number: while (backPosition < maxBackSearch)              {                  backPosition += buffSize;                  if (backPosition > maxBackSearch) backPosition = maxBackSearch;                    long readSize = backPosition > (buffSize + 4) ? (buffSize + 4) : backPosition;                    _zipFs.Position = fileSize - backPosition;                    _zipFs.Read(buffer' 0' (int)readSize);                      for (long i = readSize - 4; i >= 0; i--)                  {                      if ((buffer[i] != 0x50) || (buffer[i + 1] != 0x4b) || (buffer[i + 2] != 0x05) || (buffer[i + 3] != 0x06)) continue;                        _zipFs.Position = (fileSize - backPosition) + i;                      return ZipReturn.ZipGood;                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip,ZipFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,FindEndOfCentralDirSignature,The following statement contains a magic number: while (backPosition < maxBackSearch)              {                  backPosition += buffSize;                  if (backPosition > maxBackSearch) backPosition = maxBackSearch;                    long readSize = backPosition > (buffSize + 4) ? (buffSize + 4) : backPosition;                    _zipFs.Position = fileSize - backPosition;                    _zipFs.Read(buffer' 0' (int)readSize);                      for (long i = readSize - 4; i >= 0; i--)                  {                      if ((buffer[i] != 0x50) || (buffer[i + 1] != 0x4b) || (buffer[i + 2] != 0x05) || (buffer[i + 3] != 0x06)) continue;                        _zipFs.Position = (fileSize - backPosition) + i;                      return ZipReturn.ZipGood;                  }              }
Magic Number,ROMVault2.SupportedFiles.Zip,ZipFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,Zip64EndOfCentralDirRead,The following statement contains a magic number: if (tulong != 44) return ZipReturn.Zip64EndOfCentralDirError;
Magic Number,ROMVault2.SupportedFiles.Zip,ZipFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,Zip64EndOfCentralDirRead,The following statement contains a magic number: if (tushort != 45) return ZipReturn.Zip64EndOfCentralDirError;
Magic Number,ROMVault2.SupportedFiles.Zip,ZipFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,Zip64EndOfCentralDirWrite,The following statement contains a magic number: bw.Write((ulong)44);
Magic Number,ROMVault2.SupportedFiles.Zip,ZipFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,Zip64EndOfCentralDirWrite,The following statement contains a magic number: bw.Write((ushort)45);
Magic Number,ROMVault2.SupportedFiles.Zip,ZipFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,Zip64EndOfCentralDirWrite,The following statement contains a magic number: bw.Write((ushort)45);
Magic Number,ROMVault2.SupportedFiles.Zip,ZipFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,ZipFileOpen,The following statement contains a magic number: try              {                  if (!IO.File.Exists(newFilename))                  {                      ZipFileClose();                      return ZipReturn.ZipErrorFileNotFound;                  }                  _zipFileInfo = new IO.FileInfo(newFilename);                  if (_zipFileInfo.LastWriteTime != timestamp)                  {                      ZipFileClose();                      return ZipReturn.ZipErrorTimeStamp;                  }                  int errorCode = IO.FileStream.OpenFileRead(newFilename' out _zipFs);                  if (errorCode != 0)                  {                      ZipFileClose();                      if (errorCode == 32)                          return ZipReturn.ZipFileLocked;                      return ZipReturn.ZipErrorOpeningFile;                  }              }              catch (PathTooLongException)              {                  ZipFileClose();                  return ZipReturn.ZipFileNameToLong;              }              catch (IOException)              {                  ZipFileClose();                  return ZipReturn.ZipErrorOpeningFile;              }
Magic Number,ROMVault2.SupportedFiles.Zip,ZipFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,ZipFileOpen,The following statement contains a magic number: try              {                  ZipReturn zRet = FindEndOfCentralDirSignature();                  if (zRet != ZipReturn.ZipGood)                  {                      ZipFileClose();                      return zRet;                  }                    long endOfCentralDir = _zipFs.Position;                  zRet = EndOfCentralDirRead();                  if (zRet != ZipReturn.ZipGood)                  {                      ZipFileClose();                      return zRet;                  }                    // check if this is a ZIP64 zip and if it is read the Zip64 End Of Central Dir Info                  if (_centerDirStart == 0xffffffff || _centerDirSize == 0xffffffff || _localFilesCount == 0xffff)                  {                      _zip64 = true;                      _zipFs.Position = endOfCentralDir - 20;                      zRet = Zip64EndOfCentralDirectoryLocatorRead();                      if (zRet != ZipReturn.ZipGood)                      {                          ZipFileClose();                          return zRet;                      }                      _zipFs.Position = (long)_endOfCenterDir64;                      zRet = Zip64EndOfCentralDirRead();                      if (zRet != ZipReturn.ZipGood)                      {                          ZipFileClose();                          return zRet;                      }                  }                    bool trrntzip = false;                    // check if the ZIP has a valid TorrentZip file comment                  if (_fileComment.Length == 22)                  {                      if (GetString(_fileComment).Substring(0' 14) == "TORRENTZIPPED-")                      {                          CrcCalculatorStream crcCs = new CrcCalculatorStream(_zipFs' true);                          byte[] buffer = new byte[_centerDirSize];                          _zipFs.Position = (long)_centerDirStart;                          crcCs.Read(buffer' 0' (int)_centerDirSize);                          crcCs.Flush();                          crcCs.Close();                            uint r = (uint)crcCs.Crc;                          crcCs.Dispose();                            string tcrc = GetString(_fileComment).Substring(14' 8);                          string zcrc = r.ToString("X8");                          if (String.Compare(tcrc' zcrc' StringComparison.Ordinal) == 0)                              trrntzip = true;                        }                  }                      // now read the central directory                  _zipFs.Position = (long)_centerDirStart;                    _localFiles.Clear();                  _localFiles.Capacity = (int)_localFilesCount;                  for (int i = 0; i < _localFilesCount; i++)                  {                      LocalFile lc = new LocalFile(_zipFs);                      zRet = lc.CenteralDirectoryRead();                      if (zRet != ZipReturn.ZipGood)                      {                          ZipFileClose();                          return zRet;                      }                      _zip64 |= lc.Zip64;                      _localFiles.Add(lc);                  }                    for (int i = 0; i < _localFilesCount; i++)                  {                      zRet = _localFiles[i].LocalFileHeaderRead();                      if (zRet != ZipReturn.ZipGood)                      {                          ZipFileClose();                          return zRet;                      }                      trrntzip &= _localFiles[i].TrrntZip;                  }                    // check trrntzip file order                  if (trrntzip)                      for (int i = 0; i < _localFilesCount - 1; i++)                      {                          if (TrrntZipStringCompare(_localFiles[i].FileName' _localFiles[i + 1].FileName) < 0) continue;                          trrntzip = false;                          break;                      }                    // check trrntzip directories                  if (trrntzip)                      for (int i = 0; i < _localFilesCount - 1; i++)                      {                          // see if we found a directory                          string filename0 = _localFiles[i].FileName;                          if (filename0.Substring(filename0.Length - 1' 1) != "/") continue;                            // see if the next file is in that directory                          string filename1 = _localFiles[i + 1].FileName;                          if (filename1.Length <= filename0.Length) continue;                          if (TrrntZipStringCompare(filename0' filename1.Substring(0' filename0.Length)) != 0) continue;                            // if we found a file in the directory then we do not need the directory entry                          trrntzip = false;                          break;                      }                    if (trrntzip)                      _pZipStatus |= ZipStatus.TrrntZip;                    return ZipReturn.ZipGood;              }              catch              {                  ZipFileClose();                  return ZipReturn.ZipErrorReadingFile;              }
Magic Number,ROMVault2.SupportedFiles.Zip,ZipFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,ZipFileOpen,The following statement contains a magic number: try              {                  ZipReturn zRet = FindEndOfCentralDirSignature();                  if (zRet != ZipReturn.ZipGood)                  {                      ZipFileClose();                      return zRet;                  }                    long endOfCentralDir = _zipFs.Position;                  zRet = EndOfCentralDirRead();                  if (zRet != ZipReturn.ZipGood)                  {                      ZipFileClose();                      return zRet;                  }                    // check if this is a ZIP64 zip and if it is read the Zip64 End Of Central Dir Info                  if (_centerDirStart == 0xffffffff || _centerDirSize == 0xffffffff || _localFilesCount == 0xffff)                  {                      _zip64 = true;                      _zipFs.Position = endOfCentralDir - 20;                      zRet = Zip64EndOfCentralDirectoryLocatorRead();                      if (zRet != ZipReturn.ZipGood)                      {                          ZipFileClose();                          return zRet;                      }                      _zipFs.Position = (long)_endOfCenterDir64;                      zRet = Zip64EndOfCentralDirRead();                      if (zRet != ZipReturn.ZipGood)                      {                          ZipFileClose();                          return zRet;                      }                  }                    bool trrntzip = false;                    // check if the ZIP has a valid TorrentZip file comment                  if (_fileComment.Length == 22)                  {                      if (GetString(_fileComment).Substring(0' 14) == "TORRENTZIPPED-")                      {                          CrcCalculatorStream crcCs = new CrcCalculatorStream(_zipFs' true);                          byte[] buffer = new byte[_centerDirSize];                          _zipFs.Position = (long)_centerDirStart;                          crcCs.Read(buffer' 0' (int)_centerDirSize);                          crcCs.Flush();                          crcCs.Close();                            uint r = (uint)crcCs.Crc;                          crcCs.Dispose();                            string tcrc = GetString(_fileComment).Substring(14' 8);                          string zcrc = r.ToString("X8");                          if (String.Compare(tcrc' zcrc' StringComparison.Ordinal) == 0)                              trrntzip = true;                        }                  }                      // now read the central directory                  _zipFs.Position = (long)_centerDirStart;                    _localFiles.Clear();                  _localFiles.Capacity = (int)_localFilesCount;                  for (int i = 0; i < _localFilesCount; i++)                  {                      LocalFile lc = new LocalFile(_zipFs);                      zRet = lc.CenteralDirectoryRead();                      if (zRet != ZipReturn.ZipGood)                      {                          ZipFileClose();                          return zRet;                      }                      _zip64 |= lc.Zip64;                      _localFiles.Add(lc);                  }                    for (int i = 0; i < _localFilesCount; i++)                  {                      zRet = _localFiles[i].LocalFileHeaderRead();                      if (zRet != ZipReturn.ZipGood)                      {                          ZipFileClose();                          return zRet;                      }                      trrntzip &= _localFiles[i].TrrntZip;                  }                    // check trrntzip file order                  if (trrntzip)                      for (int i = 0; i < _localFilesCount - 1; i++)                      {                          if (TrrntZipStringCompare(_localFiles[i].FileName' _localFiles[i + 1].FileName) < 0) continue;                          trrntzip = false;                          break;                      }                    // check trrntzip directories                  if (trrntzip)                      for (int i = 0; i < _localFilesCount - 1; i++)                      {                          // see if we found a directory                          string filename0 = _localFiles[i].FileName;                          if (filename0.Substring(filename0.Length - 1' 1) != "/") continue;                            // see if the next file is in that directory                          string filename1 = _localFiles[i + 1].FileName;                          if (filename1.Length <= filename0.Length) continue;                          if (TrrntZipStringCompare(filename0' filename1.Substring(0' filename0.Length)) != 0) continue;                            // if we found a file in the directory then we do not need the directory entry                          trrntzip = false;                          break;                      }                    if (trrntzip)                      _pZipStatus |= ZipStatus.TrrntZip;                    return ZipReturn.ZipGood;              }              catch              {                  ZipFileClose();                  return ZipReturn.ZipErrorReadingFile;              }
Magic Number,ROMVault2.SupportedFiles.Zip,ZipFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,ZipFileOpen,The following statement contains a magic number: try              {                  ZipReturn zRet = FindEndOfCentralDirSignature();                  if (zRet != ZipReturn.ZipGood)                  {                      ZipFileClose();                      return zRet;                  }                    long endOfCentralDir = _zipFs.Position;                  zRet = EndOfCentralDirRead();                  if (zRet != ZipReturn.ZipGood)                  {                      ZipFileClose();                      return zRet;                  }                    // check if this is a ZIP64 zip and if it is read the Zip64 End Of Central Dir Info                  if (_centerDirStart == 0xffffffff || _centerDirSize == 0xffffffff || _localFilesCount == 0xffff)                  {                      _zip64 = true;                      _zipFs.Position = endOfCentralDir - 20;                      zRet = Zip64EndOfCentralDirectoryLocatorRead();                      if (zRet != ZipReturn.ZipGood)                      {                          ZipFileClose();                          return zRet;                      }                      _zipFs.Position = (long)_endOfCenterDir64;                      zRet = Zip64EndOfCentralDirRead();                      if (zRet != ZipReturn.ZipGood)                      {                          ZipFileClose();                          return zRet;                      }                  }                    bool trrntzip = false;                    // check if the ZIP has a valid TorrentZip file comment                  if (_fileComment.Length == 22)                  {                      if (GetString(_fileComment).Substring(0' 14) == "TORRENTZIPPED-")                      {                          CrcCalculatorStream crcCs = new CrcCalculatorStream(_zipFs' true);                          byte[] buffer = new byte[_centerDirSize];                          _zipFs.Position = (long)_centerDirStart;                          crcCs.Read(buffer' 0' (int)_centerDirSize);                          crcCs.Flush();                          crcCs.Close();                            uint r = (uint)crcCs.Crc;                          crcCs.Dispose();                            string tcrc = GetString(_fileComment).Substring(14' 8);                          string zcrc = r.ToString("X8");                          if (String.Compare(tcrc' zcrc' StringComparison.Ordinal) == 0)                              trrntzip = true;                        }                  }                      // now read the central directory                  _zipFs.Position = (long)_centerDirStart;                    _localFiles.Clear();                  _localFiles.Capacity = (int)_localFilesCount;                  for (int i = 0; i < _localFilesCount; i++)                  {                      LocalFile lc = new LocalFile(_zipFs);                      zRet = lc.CenteralDirectoryRead();                      if (zRet != ZipReturn.ZipGood)                      {                          ZipFileClose();                          return zRet;                      }                      _zip64 |= lc.Zip64;                      _localFiles.Add(lc);                  }                    for (int i = 0; i < _localFilesCount; i++)                  {                      zRet = _localFiles[i].LocalFileHeaderRead();                      if (zRet != ZipReturn.ZipGood)                      {                          ZipFileClose();                          return zRet;                      }                      trrntzip &= _localFiles[i].TrrntZip;                  }                    // check trrntzip file order                  if (trrntzip)                      for (int i = 0; i < _localFilesCount - 1; i++)                      {                          if (TrrntZipStringCompare(_localFiles[i].FileName' _localFiles[i + 1].FileName) < 0) continue;                          trrntzip = false;                          break;                      }                    // check trrntzip directories                  if (trrntzip)                      for (int i = 0; i < _localFilesCount - 1; i++)                      {                          // see if we found a directory                          string filename0 = _localFiles[i].FileName;                          if (filename0.Substring(filename0.Length - 1' 1) != "/") continue;                            // see if the next file is in that directory                          string filename1 = _localFiles[i + 1].FileName;                          if (filename1.Length <= filename0.Length) continue;                          if (TrrntZipStringCompare(filename0' filename1.Substring(0' filename0.Length)) != 0) continue;                            // if we found a file in the directory then we do not need the directory entry                          trrntzip = false;                          break;                      }                    if (trrntzip)                      _pZipStatus |= ZipStatus.TrrntZip;                    return ZipReturn.ZipGood;              }              catch              {                  ZipFileClose();                  return ZipReturn.ZipErrorReadingFile;              }
Magic Number,ROMVault2.SupportedFiles.Zip,ZipFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,ZipFileOpen,The following statement contains a magic number: try              {                  ZipReturn zRet = FindEndOfCentralDirSignature();                  if (zRet != ZipReturn.ZipGood)                  {                      ZipFileClose();                      return zRet;                  }                    long endOfCentralDir = _zipFs.Position;                  zRet = EndOfCentralDirRead();                  if (zRet != ZipReturn.ZipGood)                  {                      ZipFileClose();                      return zRet;                  }                    // check if this is a ZIP64 zip and if it is read the Zip64 End Of Central Dir Info                  if (_centerDirStart == 0xffffffff || _centerDirSize == 0xffffffff || _localFilesCount == 0xffff)                  {                      _zip64 = true;                      _zipFs.Position = endOfCentralDir - 20;                      zRet = Zip64EndOfCentralDirectoryLocatorRead();                      if (zRet != ZipReturn.ZipGood)                      {                          ZipFileClose();                          return zRet;                      }                      _zipFs.Position = (long)_endOfCenterDir64;                      zRet = Zip64EndOfCentralDirRead();                      if (zRet != ZipReturn.ZipGood)                      {                          ZipFileClose();                          return zRet;                      }                  }                    bool trrntzip = false;                    // check if the ZIP has a valid TorrentZip file comment                  if (_fileComment.Length == 22)                  {                      if (GetString(_fileComment).Substring(0' 14) == "TORRENTZIPPED-")                      {                          CrcCalculatorStream crcCs = new CrcCalculatorStream(_zipFs' true);                          byte[] buffer = new byte[_centerDirSize];                          _zipFs.Position = (long)_centerDirStart;                          crcCs.Read(buffer' 0' (int)_centerDirSize);                          crcCs.Flush();                          crcCs.Close();                            uint r = (uint)crcCs.Crc;                          crcCs.Dispose();                            string tcrc = GetString(_fileComment).Substring(14' 8);                          string zcrc = r.ToString("X8");                          if (String.Compare(tcrc' zcrc' StringComparison.Ordinal) == 0)                              trrntzip = true;                        }                  }                      // now read the central directory                  _zipFs.Position = (long)_centerDirStart;                    _localFiles.Clear();                  _localFiles.Capacity = (int)_localFilesCount;                  for (int i = 0; i < _localFilesCount; i++)                  {                      LocalFile lc = new LocalFile(_zipFs);                      zRet = lc.CenteralDirectoryRead();                      if (zRet != ZipReturn.ZipGood)                      {                          ZipFileClose();                          return zRet;                      }                      _zip64 |= lc.Zip64;                      _localFiles.Add(lc);                  }                    for (int i = 0; i < _localFilesCount; i++)                  {                      zRet = _localFiles[i].LocalFileHeaderRead();                      if (zRet != ZipReturn.ZipGood)                      {                          ZipFileClose();                          return zRet;                      }                      trrntzip &= _localFiles[i].TrrntZip;                  }                    // check trrntzip file order                  if (trrntzip)                      for (int i = 0; i < _localFilesCount - 1; i++)                      {                          if (TrrntZipStringCompare(_localFiles[i].FileName' _localFiles[i + 1].FileName) < 0) continue;                          trrntzip = false;                          break;                      }                    // check trrntzip directories                  if (trrntzip)                      for (int i = 0; i < _localFilesCount - 1; i++)                      {                          // see if we found a directory                          string filename0 = _localFiles[i].FileName;                          if (filename0.Substring(filename0.Length - 1' 1) != "/") continue;                            // see if the next file is in that directory                          string filename1 = _localFiles[i + 1].FileName;                          if (filename1.Length <= filename0.Length) continue;                          if (TrrntZipStringCompare(filename0' filename1.Substring(0' filename0.Length)) != 0) continue;                            // if we found a file in the directory then we do not need the directory entry                          trrntzip = false;                          break;                      }                    if (trrntzip)                      _pZipStatus |= ZipStatus.TrrntZip;                    return ZipReturn.ZipGood;              }              catch              {                  ZipFileClose();                  return ZipReturn.ZipErrorReadingFile;              }
Magic Number,ROMVault2.SupportedFiles.Zip,ZipFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,ZipFileOpen,The following statement contains a magic number: try              {                  ZipReturn zRet = FindEndOfCentralDirSignature();                  if (zRet != ZipReturn.ZipGood)                  {                      ZipFileClose();                      return zRet;                  }                    long endOfCentralDir = _zipFs.Position;                  zRet = EndOfCentralDirRead();                  if (zRet != ZipReturn.ZipGood)                  {                      ZipFileClose();                      return zRet;                  }                    // check if this is a ZIP64 zip and if it is read the Zip64 End Of Central Dir Info                  if (_centerDirStart == 0xffffffff || _centerDirSize == 0xffffffff || _localFilesCount == 0xffff)                  {                      _zip64 = true;                      _zipFs.Position = endOfCentralDir - 20;                      zRet = Zip64EndOfCentralDirectoryLocatorRead();                      if (zRet != ZipReturn.ZipGood)                      {                          ZipFileClose();                          return zRet;                      }                      _zipFs.Position = (long)_endOfCenterDir64;                      zRet = Zip64EndOfCentralDirRead();                      if (zRet != ZipReturn.ZipGood)                      {                          ZipFileClose();                          return zRet;                      }                  }                    bool trrntzip = false;                    // check if the ZIP has a valid TorrentZip file comment                  if (_fileComment.Length == 22)                  {                      if (GetString(_fileComment).Substring(0' 14) == "TORRENTZIPPED-")                      {                          CrcCalculatorStream crcCs = new CrcCalculatorStream(_zipFs' true);                          byte[] buffer = new byte[_centerDirSize];                          _zipFs.Position = (long)_centerDirStart;                          crcCs.Read(buffer' 0' (int)_centerDirSize);                          crcCs.Flush();                          crcCs.Close();                            uint r = (uint)crcCs.Crc;                          crcCs.Dispose();                            string tcrc = GetString(_fileComment).Substring(14' 8);                          string zcrc = r.ToString("X8");                          if (String.Compare(tcrc' zcrc' StringComparison.Ordinal) == 0)                              trrntzip = true;                        }                  }                      // now read the central directory                  _zipFs.Position = (long)_centerDirStart;                    _localFiles.Clear();                  _localFiles.Capacity = (int)_localFilesCount;                  for (int i = 0; i < _localFilesCount; i++)                  {                      LocalFile lc = new LocalFile(_zipFs);                      zRet = lc.CenteralDirectoryRead();                      if (zRet != ZipReturn.ZipGood)                      {                          ZipFileClose();                          return zRet;                      }                      _zip64 |= lc.Zip64;                      _localFiles.Add(lc);                  }                    for (int i = 0; i < _localFilesCount; i++)                  {                      zRet = _localFiles[i].LocalFileHeaderRead();                      if (zRet != ZipReturn.ZipGood)                      {                          ZipFileClose();                          return zRet;                      }                      trrntzip &= _localFiles[i].TrrntZip;                  }                    // check trrntzip file order                  if (trrntzip)                      for (int i = 0; i < _localFilesCount - 1; i++)                      {                          if (TrrntZipStringCompare(_localFiles[i].FileName' _localFiles[i + 1].FileName) < 0) continue;                          trrntzip = false;                          break;                      }                    // check trrntzip directories                  if (trrntzip)                      for (int i = 0; i < _localFilesCount - 1; i++)                      {                          // see if we found a directory                          string filename0 = _localFiles[i].FileName;                          if (filename0.Substring(filename0.Length - 1' 1) != "/") continue;                            // see if the next file is in that directory                          string filename1 = _localFiles[i + 1].FileName;                          if (filename1.Length <= filename0.Length) continue;                          if (TrrntZipStringCompare(filename0' filename1.Substring(0' filename0.Length)) != 0) continue;                            // if we found a file in the directory then we do not need the directory entry                          trrntzip = false;                          break;                      }                    if (trrntzip)                      _pZipStatus |= ZipStatus.TrrntZip;                    return ZipReturn.ZipGood;              }              catch              {                  ZipFileClose();                  return ZipReturn.ZipErrorReadingFile;              }
Magic Number,ROMVault2.SupportedFiles.Zip,ZipFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,GetBytes,The following statement contains a magic number: for (int i = 0; i < c.Length; i++)              {                  char t = c[i];                  b[i] = t > 255 ? (byte)'?' : (byte)c[i];              }
Magic Number,ROMVault2.SupportedFiles.Zip,ZipFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,IsUnicode,The following statement contains a magic number: for (int i = 0; i < c.Length; i++)                  if (c[i] > 255) return true;
Magic Number,ROMVault2.SupportedFiles.Zip,ZipFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,TrrntZipStringCompare,The following statement contains a magic number: for (;;)              {                  if (pos1 == bytes1.Length)                      return ((pos2 == bytes2.Length) ? 0 : -1);                  if (pos2 == bytes2.Length)                      return 1;                    int byte1 = bytes1[pos1++];                  int byte2 = bytes2[pos2++];                    if (byte1 >= 65 && byte1 <= 90) byte1 += 0x20;                  if (byte2 >= 65 && byte2 <= 90) byte2 += 0x20;                    if (byte1 < byte2)                      return -1;                  if (byte1 > byte2)                      return 1;              }
Magic Number,ROMVault2.SupportedFiles.Zip,ZipFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,TrrntZipStringCompare,The following statement contains a magic number: for (;;)              {                  if (pos1 == bytes1.Length)                      return ((pos2 == bytes2.Length) ? 0 : -1);                  if (pos2 == bytes2.Length)                      return 1;                    int byte1 = bytes1[pos1++];                  int byte2 = bytes2[pos2++];                    if (byte1 >= 65 && byte1 <= 90) byte1 += 0x20;                  if (byte2 >= 65 && byte2 <= 90) byte2 += 0x20;                    if (byte1 < byte2)                      return -1;                  if (byte1 > byte2)                      return 1;              }
Magic Number,ROMVault2.SupportedFiles.Zip,ZipFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,TrrntZipStringCompare,The following statement contains a magic number: for (;;)              {                  if (pos1 == bytes1.Length)                      return ((pos2 == bytes2.Length) ? 0 : -1);                  if (pos2 == bytes2.Length)                      return 1;                    int byte1 = bytes1[pos1++];                  int byte2 = bytes2[pos2++];                    if (byte1 >= 65 && byte1 <= 90) byte1 += 0x20;                  if (byte2 >= 65 && byte2 <= 90) byte2 += 0x20;                    if (byte1 < byte2)                      return -1;                  if (byte1 > byte2)                      return 1;              }
Magic Number,ROMVault2.SupportedFiles.Zip,ZipFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,TrrntZipStringCompare,The following statement contains a magic number: for (;;)              {                  if (pos1 == bytes1.Length)                      return ((pos2 == bytes2.Length) ? 0 : -1);                  if (pos2 == bytes2.Length)                      return 1;                    int byte1 = bytes1[pos1++];                  int byte2 = bytes2[pos2++];                    if (byte1 >= 65 && byte1 <= 90) byte1 += 0x20;                  if (byte2 >= 65 && byte2 <= 90) byte2 += 0x20;                    if (byte1 < byte2)                      return -1;                  if (byte1 > byte2)                      return 1;              }
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,LocalFile,The following statement contains a magic number: _generalPurposeBitFlag = 2;
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,LocalFile,The following statement contains a magic number: _compressionMethod = 8;
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,LocalFile,The following statement contains a magic number: _lastModFileTime = 48128;
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,LocalFile,The following statement contains a magic number: _lastModFileDate = 8600;
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,CenteralDirectoryRead,The following statement contains a magic number: try                  {                      BinaryReader br = new BinaryReader(_zipFs);                        uint thisSignature = br.ReadUInt32();                      if (thisSignature != CentralDirectoryHeaderSigniature)                          return ZipReturn.ZipCenteralDirError;                        br.ReadUInt16(); // Version Made By                        br.ReadUInt16(); // Version Needed To Extract                          _generalPurposeBitFlag = br.ReadUInt16();                      _compressionMethod = br.ReadUInt16();                      if (_compressionMethod != 8 && _compressionMethod != 0)                          return ZipReturn.ZipUnsupportedCompression;                        _lastModFileTime = br.ReadUInt16();                      _lastModFileDate = br.ReadUInt16();                      CRC = ReadCRC(br);                        _compressedSize = br.ReadUInt32();                      UncompressedSize = br.ReadUInt32();                        ushort fileNameLength = br.ReadUInt16();                      ushort extraFieldLength = br.ReadUInt16();                      ushort fileCommentLength = br.ReadUInt16();                        br.ReadUInt16(); // diskNumberStart                      br.ReadUInt16(); // internalFileAttributes                      br.ReadUInt32(); // externalFileAttributes                        RelativeOffsetOfLocalHeader = br.ReadUInt32();                        byte[] bFileName = br.ReadBytes(fileNameLength);                      FileName = (_generalPurposeBitFlag & (1 << 11)) == 0 ?                          GetString(bFileName) :                          Encoding.UTF8.GetString(bFileName' 0' fileNameLength);                        Byte[] extraField = br.ReadBytes(extraFieldLength);                      br.ReadBytes(fileCommentLength); // File Comments                        int pos = 0;                      while (extraFieldLength > pos)                      {                          ushort type = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          ushort blockLength = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          switch (type)                          {                              case 0x0001:                                  Zip64 = true;                                  if (UncompressedSize == 0xffffffff)                                  {                                      UncompressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  if (_compressedSize == 0xffffffff)                                  {                                      _compressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  if (RelativeOffsetOfLocalHeader == 0xffffffff)                                  {                                      RelativeOffsetOfLocalHeader = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  break;                              case 0x7075:                                  //byte version = extraField[pos];                                  pos += 1;                                  uint nameCRC32 = BitConverter.ToUInt32(extraField' pos);                                  pos += 4;                                    CRC32 crcTest = new CRC32();                                  crcTest.SlurpBlock(bFileName' 0' fileNameLength);                                  uint fCRC = crcTest.Crc32ResultU;                                    if (nameCRC32 != fCRC) return ZipReturn.ZipCenteralDirError;                                    int charLen = blockLength - 5;                                    FileName = Encoding.UTF8.GetString(extraField' pos' charLen);                                  pos += charLen;                                    break;                              default:                                  pos += blockLength;                                  break;                          }                      }                        return ZipReturn.ZipGood;                  }                  catch                  {                      return ZipReturn.ZipCenteralDirError;                  }
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,CenteralDirectoryRead,The following statement contains a magic number: try                  {                      BinaryReader br = new BinaryReader(_zipFs);                        uint thisSignature = br.ReadUInt32();                      if (thisSignature != CentralDirectoryHeaderSigniature)                          return ZipReturn.ZipCenteralDirError;                        br.ReadUInt16(); // Version Made By                        br.ReadUInt16(); // Version Needed To Extract                          _generalPurposeBitFlag = br.ReadUInt16();                      _compressionMethod = br.ReadUInt16();                      if (_compressionMethod != 8 && _compressionMethod != 0)                          return ZipReturn.ZipUnsupportedCompression;                        _lastModFileTime = br.ReadUInt16();                      _lastModFileDate = br.ReadUInt16();                      CRC = ReadCRC(br);                        _compressedSize = br.ReadUInt32();                      UncompressedSize = br.ReadUInt32();                        ushort fileNameLength = br.ReadUInt16();                      ushort extraFieldLength = br.ReadUInt16();                      ushort fileCommentLength = br.ReadUInt16();                        br.ReadUInt16(); // diskNumberStart                      br.ReadUInt16(); // internalFileAttributes                      br.ReadUInt32(); // externalFileAttributes                        RelativeOffsetOfLocalHeader = br.ReadUInt32();                        byte[] bFileName = br.ReadBytes(fileNameLength);                      FileName = (_generalPurposeBitFlag & (1 << 11)) == 0 ?                          GetString(bFileName) :                          Encoding.UTF8.GetString(bFileName' 0' fileNameLength);                        Byte[] extraField = br.ReadBytes(extraFieldLength);                      br.ReadBytes(fileCommentLength); // File Comments                        int pos = 0;                      while (extraFieldLength > pos)                      {                          ushort type = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          ushort blockLength = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          switch (type)                          {                              case 0x0001:                                  Zip64 = true;                                  if (UncompressedSize == 0xffffffff)                                  {                                      UncompressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  if (_compressedSize == 0xffffffff)                                  {                                      _compressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  if (RelativeOffsetOfLocalHeader == 0xffffffff)                                  {                                      RelativeOffsetOfLocalHeader = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  break;                              case 0x7075:                                  //byte version = extraField[pos];                                  pos += 1;                                  uint nameCRC32 = BitConverter.ToUInt32(extraField' pos);                                  pos += 4;                                    CRC32 crcTest = new CRC32();                                  crcTest.SlurpBlock(bFileName' 0' fileNameLength);                                  uint fCRC = crcTest.Crc32ResultU;                                    if (nameCRC32 != fCRC) return ZipReturn.ZipCenteralDirError;                                    int charLen = blockLength - 5;                                    FileName = Encoding.UTF8.GetString(extraField' pos' charLen);                                  pos += charLen;                                    break;                              default:                                  pos += blockLength;                                  break;                          }                      }                        return ZipReturn.ZipGood;                  }                  catch                  {                      return ZipReturn.ZipCenteralDirError;                  }
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,CenteralDirectoryRead,The following statement contains a magic number: try                  {                      BinaryReader br = new BinaryReader(_zipFs);                        uint thisSignature = br.ReadUInt32();                      if (thisSignature != CentralDirectoryHeaderSigniature)                          return ZipReturn.ZipCenteralDirError;                        br.ReadUInt16(); // Version Made By                        br.ReadUInt16(); // Version Needed To Extract                          _generalPurposeBitFlag = br.ReadUInt16();                      _compressionMethod = br.ReadUInt16();                      if (_compressionMethod != 8 && _compressionMethod != 0)                          return ZipReturn.ZipUnsupportedCompression;                        _lastModFileTime = br.ReadUInt16();                      _lastModFileDate = br.ReadUInt16();                      CRC = ReadCRC(br);                        _compressedSize = br.ReadUInt32();                      UncompressedSize = br.ReadUInt32();                        ushort fileNameLength = br.ReadUInt16();                      ushort extraFieldLength = br.ReadUInt16();                      ushort fileCommentLength = br.ReadUInt16();                        br.ReadUInt16(); // diskNumberStart                      br.ReadUInt16(); // internalFileAttributes                      br.ReadUInt32(); // externalFileAttributes                        RelativeOffsetOfLocalHeader = br.ReadUInt32();                        byte[] bFileName = br.ReadBytes(fileNameLength);                      FileName = (_generalPurposeBitFlag & (1 << 11)) == 0 ?                          GetString(bFileName) :                          Encoding.UTF8.GetString(bFileName' 0' fileNameLength);                        Byte[] extraField = br.ReadBytes(extraFieldLength);                      br.ReadBytes(fileCommentLength); // File Comments                        int pos = 0;                      while (extraFieldLength > pos)                      {                          ushort type = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          ushort blockLength = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          switch (type)                          {                              case 0x0001:                                  Zip64 = true;                                  if (UncompressedSize == 0xffffffff)                                  {                                      UncompressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  if (_compressedSize == 0xffffffff)                                  {                                      _compressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  if (RelativeOffsetOfLocalHeader == 0xffffffff)                                  {                                      RelativeOffsetOfLocalHeader = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  break;                              case 0x7075:                                  //byte version = extraField[pos];                                  pos += 1;                                  uint nameCRC32 = BitConverter.ToUInt32(extraField' pos);                                  pos += 4;                                    CRC32 crcTest = new CRC32();                                  crcTest.SlurpBlock(bFileName' 0' fileNameLength);                                  uint fCRC = crcTest.Crc32ResultU;                                    if (nameCRC32 != fCRC) return ZipReturn.ZipCenteralDirError;                                    int charLen = blockLength - 5;                                    FileName = Encoding.UTF8.GetString(extraField' pos' charLen);                                  pos += charLen;                                    break;                              default:                                  pos += blockLength;                                  break;                          }                      }                        return ZipReturn.ZipGood;                  }                  catch                  {                      return ZipReturn.ZipCenteralDirError;                  }
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,CenteralDirectoryRead,The following statement contains a magic number: try                  {                      BinaryReader br = new BinaryReader(_zipFs);                        uint thisSignature = br.ReadUInt32();                      if (thisSignature != CentralDirectoryHeaderSigniature)                          return ZipReturn.ZipCenteralDirError;                        br.ReadUInt16(); // Version Made By                        br.ReadUInt16(); // Version Needed To Extract                          _generalPurposeBitFlag = br.ReadUInt16();                      _compressionMethod = br.ReadUInt16();                      if (_compressionMethod != 8 && _compressionMethod != 0)                          return ZipReturn.ZipUnsupportedCompression;                        _lastModFileTime = br.ReadUInt16();                      _lastModFileDate = br.ReadUInt16();                      CRC = ReadCRC(br);                        _compressedSize = br.ReadUInt32();                      UncompressedSize = br.ReadUInt32();                        ushort fileNameLength = br.ReadUInt16();                      ushort extraFieldLength = br.ReadUInt16();                      ushort fileCommentLength = br.ReadUInt16();                        br.ReadUInt16(); // diskNumberStart                      br.ReadUInt16(); // internalFileAttributes                      br.ReadUInt32(); // externalFileAttributes                        RelativeOffsetOfLocalHeader = br.ReadUInt32();                        byte[] bFileName = br.ReadBytes(fileNameLength);                      FileName = (_generalPurposeBitFlag & (1 << 11)) == 0 ?                          GetString(bFileName) :                          Encoding.UTF8.GetString(bFileName' 0' fileNameLength);                        Byte[] extraField = br.ReadBytes(extraFieldLength);                      br.ReadBytes(fileCommentLength); // File Comments                        int pos = 0;                      while (extraFieldLength > pos)                      {                          ushort type = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          ushort blockLength = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          switch (type)                          {                              case 0x0001:                                  Zip64 = true;                                  if (UncompressedSize == 0xffffffff)                                  {                                      UncompressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  if (_compressedSize == 0xffffffff)                                  {                                      _compressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  if (RelativeOffsetOfLocalHeader == 0xffffffff)                                  {                                      RelativeOffsetOfLocalHeader = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  break;                              case 0x7075:                                  //byte version = extraField[pos];                                  pos += 1;                                  uint nameCRC32 = BitConverter.ToUInt32(extraField' pos);                                  pos += 4;                                    CRC32 crcTest = new CRC32();                                  crcTest.SlurpBlock(bFileName' 0' fileNameLength);                                  uint fCRC = crcTest.Crc32ResultU;                                    if (nameCRC32 != fCRC) return ZipReturn.ZipCenteralDirError;                                    int charLen = blockLength - 5;                                    FileName = Encoding.UTF8.GetString(extraField' pos' charLen);                                  pos += charLen;                                    break;                              default:                                  pos += blockLength;                                  break;                          }                      }                        return ZipReturn.ZipGood;                  }                  catch                  {                      return ZipReturn.ZipCenteralDirError;                  }
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,CenteralDirectoryRead,The following statement contains a magic number: try                  {                      BinaryReader br = new BinaryReader(_zipFs);                        uint thisSignature = br.ReadUInt32();                      if (thisSignature != CentralDirectoryHeaderSigniature)                          return ZipReturn.ZipCenteralDirError;                        br.ReadUInt16(); // Version Made By                        br.ReadUInt16(); // Version Needed To Extract                          _generalPurposeBitFlag = br.ReadUInt16();                      _compressionMethod = br.ReadUInt16();                      if (_compressionMethod != 8 && _compressionMethod != 0)                          return ZipReturn.ZipUnsupportedCompression;                        _lastModFileTime = br.ReadUInt16();                      _lastModFileDate = br.ReadUInt16();                      CRC = ReadCRC(br);                        _compressedSize = br.ReadUInt32();                      UncompressedSize = br.ReadUInt32();                        ushort fileNameLength = br.ReadUInt16();                      ushort extraFieldLength = br.ReadUInt16();                      ushort fileCommentLength = br.ReadUInt16();                        br.ReadUInt16(); // diskNumberStart                      br.ReadUInt16(); // internalFileAttributes                      br.ReadUInt32(); // externalFileAttributes                        RelativeOffsetOfLocalHeader = br.ReadUInt32();                        byte[] bFileName = br.ReadBytes(fileNameLength);                      FileName = (_generalPurposeBitFlag & (1 << 11)) == 0 ?                          GetString(bFileName) :                          Encoding.UTF8.GetString(bFileName' 0' fileNameLength);                        Byte[] extraField = br.ReadBytes(extraFieldLength);                      br.ReadBytes(fileCommentLength); // File Comments                        int pos = 0;                      while (extraFieldLength > pos)                      {                          ushort type = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          ushort blockLength = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          switch (type)                          {                              case 0x0001:                                  Zip64 = true;                                  if (UncompressedSize == 0xffffffff)                                  {                                      UncompressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  if (_compressedSize == 0xffffffff)                                  {                                      _compressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  if (RelativeOffsetOfLocalHeader == 0xffffffff)                                  {                                      RelativeOffsetOfLocalHeader = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  break;                              case 0x7075:                                  //byte version = extraField[pos];                                  pos += 1;                                  uint nameCRC32 = BitConverter.ToUInt32(extraField' pos);                                  pos += 4;                                    CRC32 crcTest = new CRC32();                                  crcTest.SlurpBlock(bFileName' 0' fileNameLength);                                  uint fCRC = crcTest.Crc32ResultU;                                    if (nameCRC32 != fCRC) return ZipReturn.ZipCenteralDirError;                                    int charLen = blockLength - 5;                                    FileName = Encoding.UTF8.GetString(extraField' pos' charLen);                                  pos += charLen;                                    break;                              default:                                  pos += blockLength;                                  break;                          }                      }                        return ZipReturn.ZipGood;                  }                  catch                  {                      return ZipReturn.ZipCenteralDirError;                  }
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,CenteralDirectoryRead,The following statement contains a magic number: try                  {                      BinaryReader br = new BinaryReader(_zipFs);                        uint thisSignature = br.ReadUInt32();                      if (thisSignature != CentralDirectoryHeaderSigniature)                          return ZipReturn.ZipCenteralDirError;                        br.ReadUInt16(); // Version Made By                        br.ReadUInt16(); // Version Needed To Extract                          _generalPurposeBitFlag = br.ReadUInt16();                      _compressionMethod = br.ReadUInt16();                      if (_compressionMethod != 8 && _compressionMethod != 0)                          return ZipReturn.ZipUnsupportedCompression;                        _lastModFileTime = br.ReadUInt16();                      _lastModFileDate = br.ReadUInt16();                      CRC = ReadCRC(br);                        _compressedSize = br.ReadUInt32();                      UncompressedSize = br.ReadUInt32();                        ushort fileNameLength = br.ReadUInt16();                      ushort extraFieldLength = br.ReadUInt16();                      ushort fileCommentLength = br.ReadUInt16();                        br.ReadUInt16(); // diskNumberStart                      br.ReadUInt16(); // internalFileAttributes                      br.ReadUInt32(); // externalFileAttributes                        RelativeOffsetOfLocalHeader = br.ReadUInt32();                        byte[] bFileName = br.ReadBytes(fileNameLength);                      FileName = (_generalPurposeBitFlag & (1 << 11)) == 0 ?                          GetString(bFileName) :                          Encoding.UTF8.GetString(bFileName' 0' fileNameLength);                        Byte[] extraField = br.ReadBytes(extraFieldLength);                      br.ReadBytes(fileCommentLength); // File Comments                        int pos = 0;                      while (extraFieldLength > pos)                      {                          ushort type = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          ushort blockLength = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          switch (type)                          {                              case 0x0001:                                  Zip64 = true;                                  if (UncompressedSize == 0xffffffff)                                  {                                      UncompressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  if (_compressedSize == 0xffffffff)                                  {                                      _compressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  if (RelativeOffsetOfLocalHeader == 0xffffffff)                                  {                                      RelativeOffsetOfLocalHeader = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  break;                              case 0x7075:                                  //byte version = extraField[pos];                                  pos += 1;                                  uint nameCRC32 = BitConverter.ToUInt32(extraField' pos);                                  pos += 4;                                    CRC32 crcTest = new CRC32();                                  crcTest.SlurpBlock(bFileName' 0' fileNameLength);                                  uint fCRC = crcTest.Crc32ResultU;                                    if (nameCRC32 != fCRC) return ZipReturn.ZipCenteralDirError;                                    int charLen = blockLength - 5;                                    FileName = Encoding.UTF8.GetString(extraField' pos' charLen);                                  pos += charLen;                                    break;                              default:                                  pos += blockLength;                                  break;                          }                      }                        return ZipReturn.ZipGood;                  }                  catch                  {                      return ZipReturn.ZipCenteralDirError;                  }
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,CenteralDirectoryRead,The following statement contains a magic number: try                  {                      BinaryReader br = new BinaryReader(_zipFs);                        uint thisSignature = br.ReadUInt32();                      if (thisSignature != CentralDirectoryHeaderSigniature)                          return ZipReturn.ZipCenteralDirError;                        br.ReadUInt16(); // Version Made By                        br.ReadUInt16(); // Version Needed To Extract                          _generalPurposeBitFlag = br.ReadUInt16();                      _compressionMethod = br.ReadUInt16();                      if (_compressionMethod != 8 && _compressionMethod != 0)                          return ZipReturn.ZipUnsupportedCompression;                        _lastModFileTime = br.ReadUInt16();                      _lastModFileDate = br.ReadUInt16();                      CRC = ReadCRC(br);                        _compressedSize = br.ReadUInt32();                      UncompressedSize = br.ReadUInt32();                        ushort fileNameLength = br.ReadUInt16();                      ushort extraFieldLength = br.ReadUInt16();                      ushort fileCommentLength = br.ReadUInt16();                        br.ReadUInt16(); // diskNumberStart                      br.ReadUInt16(); // internalFileAttributes                      br.ReadUInt32(); // externalFileAttributes                        RelativeOffsetOfLocalHeader = br.ReadUInt32();                        byte[] bFileName = br.ReadBytes(fileNameLength);                      FileName = (_generalPurposeBitFlag & (1 << 11)) == 0 ?                          GetString(bFileName) :                          Encoding.UTF8.GetString(bFileName' 0' fileNameLength);                        Byte[] extraField = br.ReadBytes(extraFieldLength);                      br.ReadBytes(fileCommentLength); // File Comments                        int pos = 0;                      while (extraFieldLength > pos)                      {                          ushort type = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          ushort blockLength = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          switch (type)                          {                              case 0x0001:                                  Zip64 = true;                                  if (UncompressedSize == 0xffffffff)                                  {                                      UncompressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  if (_compressedSize == 0xffffffff)                                  {                                      _compressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  if (RelativeOffsetOfLocalHeader == 0xffffffff)                                  {                                      RelativeOffsetOfLocalHeader = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  break;                              case 0x7075:                                  //byte version = extraField[pos];                                  pos += 1;                                  uint nameCRC32 = BitConverter.ToUInt32(extraField' pos);                                  pos += 4;                                    CRC32 crcTest = new CRC32();                                  crcTest.SlurpBlock(bFileName' 0' fileNameLength);                                  uint fCRC = crcTest.Crc32ResultU;                                    if (nameCRC32 != fCRC) return ZipReturn.ZipCenteralDirError;                                    int charLen = blockLength - 5;                                    FileName = Encoding.UTF8.GetString(extraField' pos' charLen);                                  pos += charLen;                                    break;                              default:                                  pos += blockLength;                                  break;                          }                      }                        return ZipReturn.ZipGood;                  }                  catch                  {                      return ZipReturn.ZipCenteralDirError;                  }
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,CenteralDirectoryRead,The following statement contains a magic number: try                  {                      BinaryReader br = new BinaryReader(_zipFs);                        uint thisSignature = br.ReadUInt32();                      if (thisSignature != CentralDirectoryHeaderSigniature)                          return ZipReturn.ZipCenteralDirError;                        br.ReadUInt16(); // Version Made By                        br.ReadUInt16(); // Version Needed To Extract                          _generalPurposeBitFlag = br.ReadUInt16();                      _compressionMethod = br.ReadUInt16();                      if (_compressionMethod != 8 && _compressionMethod != 0)                          return ZipReturn.ZipUnsupportedCompression;                        _lastModFileTime = br.ReadUInt16();                      _lastModFileDate = br.ReadUInt16();                      CRC = ReadCRC(br);                        _compressedSize = br.ReadUInt32();                      UncompressedSize = br.ReadUInt32();                        ushort fileNameLength = br.ReadUInt16();                      ushort extraFieldLength = br.ReadUInt16();                      ushort fileCommentLength = br.ReadUInt16();                        br.ReadUInt16(); // diskNumberStart                      br.ReadUInt16(); // internalFileAttributes                      br.ReadUInt32(); // externalFileAttributes                        RelativeOffsetOfLocalHeader = br.ReadUInt32();                        byte[] bFileName = br.ReadBytes(fileNameLength);                      FileName = (_generalPurposeBitFlag & (1 << 11)) == 0 ?                          GetString(bFileName) :                          Encoding.UTF8.GetString(bFileName' 0' fileNameLength);                        Byte[] extraField = br.ReadBytes(extraFieldLength);                      br.ReadBytes(fileCommentLength); // File Comments                        int pos = 0;                      while (extraFieldLength > pos)                      {                          ushort type = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          ushort blockLength = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          switch (type)                          {                              case 0x0001:                                  Zip64 = true;                                  if (UncompressedSize == 0xffffffff)                                  {                                      UncompressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  if (_compressedSize == 0xffffffff)                                  {                                      _compressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  if (RelativeOffsetOfLocalHeader == 0xffffffff)                                  {                                      RelativeOffsetOfLocalHeader = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  break;                              case 0x7075:                                  //byte version = extraField[pos];                                  pos += 1;                                  uint nameCRC32 = BitConverter.ToUInt32(extraField' pos);                                  pos += 4;                                    CRC32 crcTest = new CRC32();                                  crcTest.SlurpBlock(bFileName' 0' fileNameLength);                                  uint fCRC = crcTest.Crc32ResultU;                                    if (nameCRC32 != fCRC) return ZipReturn.ZipCenteralDirError;                                    int charLen = blockLength - 5;                                    FileName = Encoding.UTF8.GetString(extraField' pos' charLen);                                  pos += charLen;                                    break;                              default:                                  pos += blockLength;                                  break;                          }                      }                        return ZipReturn.ZipGood;                  }                  catch                  {                      return ZipReturn.ZipCenteralDirError;                  }
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,CenteralDirectoryRead,The following statement contains a magic number: try                  {                      BinaryReader br = new BinaryReader(_zipFs);                        uint thisSignature = br.ReadUInt32();                      if (thisSignature != CentralDirectoryHeaderSigniature)                          return ZipReturn.ZipCenteralDirError;                        br.ReadUInt16(); // Version Made By                        br.ReadUInt16(); // Version Needed To Extract                          _generalPurposeBitFlag = br.ReadUInt16();                      _compressionMethod = br.ReadUInt16();                      if (_compressionMethod != 8 && _compressionMethod != 0)                          return ZipReturn.ZipUnsupportedCompression;                        _lastModFileTime = br.ReadUInt16();                      _lastModFileDate = br.ReadUInt16();                      CRC = ReadCRC(br);                        _compressedSize = br.ReadUInt32();                      UncompressedSize = br.ReadUInt32();                        ushort fileNameLength = br.ReadUInt16();                      ushort extraFieldLength = br.ReadUInt16();                      ushort fileCommentLength = br.ReadUInt16();                        br.ReadUInt16(); // diskNumberStart                      br.ReadUInt16(); // internalFileAttributes                      br.ReadUInt32(); // externalFileAttributes                        RelativeOffsetOfLocalHeader = br.ReadUInt32();                        byte[] bFileName = br.ReadBytes(fileNameLength);                      FileName = (_generalPurposeBitFlag & (1 << 11)) == 0 ?                          GetString(bFileName) :                          Encoding.UTF8.GetString(bFileName' 0' fileNameLength);                        Byte[] extraField = br.ReadBytes(extraFieldLength);                      br.ReadBytes(fileCommentLength); // File Comments                        int pos = 0;                      while (extraFieldLength > pos)                      {                          ushort type = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          ushort blockLength = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          switch (type)                          {                              case 0x0001:                                  Zip64 = true;                                  if (UncompressedSize == 0xffffffff)                                  {                                      UncompressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  if (_compressedSize == 0xffffffff)                                  {                                      _compressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  if (RelativeOffsetOfLocalHeader == 0xffffffff)                                  {                                      RelativeOffsetOfLocalHeader = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  break;                              case 0x7075:                                  //byte version = extraField[pos];                                  pos += 1;                                  uint nameCRC32 = BitConverter.ToUInt32(extraField' pos);                                  pos += 4;                                    CRC32 crcTest = new CRC32();                                  crcTest.SlurpBlock(bFileName' 0' fileNameLength);                                  uint fCRC = crcTest.Crc32ResultU;                                    if (nameCRC32 != fCRC) return ZipReturn.ZipCenteralDirError;                                    int charLen = blockLength - 5;                                    FileName = Encoding.UTF8.GetString(extraField' pos' charLen);                                  pos += charLen;                                    break;                              default:                                  pos += blockLength;                                  break;                          }                      }                        return ZipReturn.ZipGood;                  }                  catch                  {                      return ZipReturn.ZipCenteralDirError;                  }
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,CenteralDirectoryWrite,The following statement contains a magic number: if (extraField.Count > 0)                  {                      ushort exfl = (ushort)extraField.Count;                      extraField.InsertRange(0' BitConverter.GetBytes((ushort)0x0001));                      extraField.InsertRange(2' BitConverter.GetBytes(exfl));                  }
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,CenteralDirectoryWrite,The following statement contains a magic number: if (IsUnicode(FileName))                  {                      _generalPurposeBitFlag |= 1 << 11;                      bFileName = Encoding.UTF8.GetBytes(FileName);                  }                  else                      bFileName = GetBytes(FileName);
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,CenteralDirectoryWrite,The following statement contains a magic number: ushort versionNeededToExtract = (ushort)(Zip64 ? 45 : 20);
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,CenteralDirectoryWrite,The following statement contains a magic number: ushort versionNeededToExtract = (ushort)(Zip64 ? 45 : 20);
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,CenteralDirectoryWrite,The following statement contains a magic number: bw.Write(CRC[3]);
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,CenteralDirectoryWrite,The following statement contains a magic number: bw.Write(CRC[2]);
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,LocalFileHeaderRead,The following statement contains a magic number: try                  {                      TrrntZip = true;                        BinaryReader br = new BinaryReader(_zipFs);                        _zipFs.Position = (long)RelativeOffsetOfLocalHeader;                      uint thisSignature = br.ReadUInt32();                      if (thisSignature != LocalFileHeaderSignature)                          return ZipReturn.ZipLocalFileHeaderError;                        br.ReadUInt16();  // version needed to extract                      ushort generalPurposeBitFlagLocal = br.ReadUInt16();                      if (generalPurposeBitFlagLocal != _generalPurposeBitFlag) TrrntZip = false;                        ushort tshort = br.ReadUInt16();                      if (tshort != _compressionMethod) return ZipReturn.ZipLocalFileHeaderError;                        tshort = br.ReadUInt16();                      if (tshort != _lastModFileTime) return ZipReturn.ZipLocalFileHeaderError;                        tshort = br.ReadUInt16();                      if (tshort != _lastModFileDate) return ZipReturn.ZipLocalFileHeaderError;                        byte[] tCRC = ReadCRC(br);                      if (((_generalPurposeBitFlag & 8) == 0) && !ByteArrCompare(tCRC' CRC)) return ZipReturn.ZipLocalFileHeaderError;                        uint tCompressedSize = br.ReadUInt32();                      if (Zip64 && tCompressedSize != 0xffffffff && tCompressedSize != _compressedSize)   // if Zip64 File then the compressedSize should be 0xffffffff                          return ZipReturn.ZipLocalFileHeaderError;                      if ((_generalPurposeBitFlag & 8) == 8 && tCompressedSize != 0)   // if bit 4 set then no compressedSize is set yet                          return ZipReturn.ZipLocalFileHeaderError;                      if (!Zip64 && (_generalPurposeBitFlag & 8) != 8 && tCompressedSize != _compressedSize) // check the compressedSize                          return ZipReturn.ZipLocalFileHeaderError;                            uint tUnCompressedSize = br.ReadUInt32();                      if (Zip64 && tUnCompressedSize != 0xffffffff && tUnCompressedSize != UncompressedSize)   // if Zip64 File then the unCompressedSize should be 0xffffffff                          return ZipReturn.ZipLocalFileHeaderError;                      if ((_generalPurposeBitFlag & 8) == 8 && tUnCompressedSize != 0)   // if bit 4 set then no unCompressedSize is set yet                          return ZipReturn.ZipLocalFileHeaderError;                      if (!Zip64 && (_generalPurposeBitFlag & 8) != 8 && tUnCompressedSize != UncompressedSize) // check the unCompressedSize                          return ZipReturn.ZipLocalFileHeaderError;                        ushort fileNameLength = br.ReadUInt16();                      ushort extraFieldLength = br.ReadUInt16();                          byte[] bFileName = br.ReadBytes(fileNameLength);                      string tFileName = (generalPurposeBitFlagLocal & (1 << 11)) == 0 ?                          GetString(bFileName) :                          Encoding.UTF8.GetString(bFileName' 0' fileNameLength);                        byte[] extraField = br.ReadBytes(extraFieldLength);                          Zip64 = false;                      int pos = 0;                      while (extraFieldLength > pos)                      {                          ushort type = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          ushort blockLength = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          switch (type)                          {                              case 0x0001:                                  Zip64 = true;                                  if (tUnCompressedSize == 0xffffffff)                                  {                                      ulong tLong = BitConverter.ToUInt64(extraField' pos);                                      if (tLong != UncompressedSize) return ZipReturn.ZipLocalFileHeaderError;                                      pos += 8;                                  }                                  if (tCompressedSize == 0xffffffff)                                  {                                      ulong tLong = BitConverter.ToUInt64(extraField' pos);                                      if (tLong != _compressedSize) return ZipReturn.ZipLocalFileHeaderError;                                      pos += 8;                                  }                                  break;                              case 0x7075:                                  //byte version = extraField[pos];                                  pos += 1;                                  uint nameCRC32 = BitConverter.ToUInt32(extraField' pos);                                  pos += 4;                                    CRC32 crcTest = new CRC32();                                  crcTest.SlurpBlock(bFileName' 0' fileNameLength);                                  uint fCRC = crcTest.Crc32ResultU;                                    if (nameCRC32 != fCRC) return ZipReturn.ZipLocalFileHeaderError;                                    int charLen = blockLength - 5;                                    tFileName = Encoding.UTF8.GetString(extraField' pos' charLen);                                  pos += charLen;                                    break;                              default:                                  pos += blockLength;                                  break;                          }                      }                        if (!CompareString(FileName' tFileName)) return ZipReturn.ZipLocalFileHeaderError;                        _dataLocation = (ulong)_zipFs.Position;                        if ((_generalPurposeBitFlag & 8) == 0) return ZipReturn.ZipGood;                        _zipFs.Position += (long)_compressedSize;                        tCRC = ReadCRC(br);                      if (!ByteArrCompare(tCRC' new byte[] { 0x50' 0x4b' 0x07' 0x08 }))                          tCRC = ReadCRC(br);                        if (!ByteArrCompare(tCRC' CRC)) return ZipReturn.ZipLocalFileHeaderError;                        uint tint = br.ReadUInt32();                      if (tint != _compressedSize) return ZipReturn.ZipLocalFileHeaderError;                        tint = br.ReadUInt32();                      if (tint != UncompressedSize) return ZipReturn.ZipLocalFileHeaderError;                        return ZipReturn.ZipGood;                  }                  catch                  {                      return ZipReturn.ZipLocalFileHeaderError;                  }
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,LocalFileHeaderRead,The following statement contains a magic number: try                  {                      TrrntZip = true;                        BinaryReader br = new BinaryReader(_zipFs);                        _zipFs.Position = (long)RelativeOffsetOfLocalHeader;                      uint thisSignature = br.ReadUInt32();                      if (thisSignature != LocalFileHeaderSignature)                          return ZipReturn.ZipLocalFileHeaderError;                        br.ReadUInt16();  // version needed to extract                      ushort generalPurposeBitFlagLocal = br.ReadUInt16();                      if (generalPurposeBitFlagLocal != _generalPurposeBitFlag) TrrntZip = false;                        ushort tshort = br.ReadUInt16();                      if (tshort != _compressionMethod) return ZipReturn.ZipLocalFileHeaderError;                        tshort = br.ReadUInt16();                      if (tshort != _lastModFileTime) return ZipReturn.ZipLocalFileHeaderError;                        tshort = br.ReadUInt16();                      if (tshort != _lastModFileDate) return ZipReturn.ZipLocalFileHeaderError;                        byte[] tCRC = ReadCRC(br);                      if (((_generalPurposeBitFlag & 8) == 0) && !ByteArrCompare(tCRC' CRC)) return ZipReturn.ZipLocalFileHeaderError;                        uint tCompressedSize = br.ReadUInt32();                      if (Zip64 && tCompressedSize != 0xffffffff && tCompressedSize != _compressedSize)   // if Zip64 File then the compressedSize should be 0xffffffff                          return ZipReturn.ZipLocalFileHeaderError;                      if ((_generalPurposeBitFlag & 8) == 8 && tCompressedSize != 0)   // if bit 4 set then no compressedSize is set yet                          return ZipReturn.ZipLocalFileHeaderError;                      if (!Zip64 && (_generalPurposeBitFlag & 8) != 8 && tCompressedSize != _compressedSize) // check the compressedSize                          return ZipReturn.ZipLocalFileHeaderError;                            uint tUnCompressedSize = br.ReadUInt32();                      if (Zip64 && tUnCompressedSize != 0xffffffff && tUnCompressedSize != UncompressedSize)   // if Zip64 File then the unCompressedSize should be 0xffffffff                          return ZipReturn.ZipLocalFileHeaderError;                      if ((_generalPurposeBitFlag & 8) == 8 && tUnCompressedSize != 0)   // if bit 4 set then no unCompressedSize is set yet                          return ZipReturn.ZipLocalFileHeaderError;                      if (!Zip64 && (_generalPurposeBitFlag & 8) != 8 && tUnCompressedSize != UncompressedSize) // check the unCompressedSize                          return ZipReturn.ZipLocalFileHeaderError;                        ushort fileNameLength = br.ReadUInt16();                      ushort extraFieldLength = br.ReadUInt16();                          byte[] bFileName = br.ReadBytes(fileNameLength);                      string tFileName = (generalPurposeBitFlagLocal & (1 << 11)) == 0 ?                          GetString(bFileName) :                          Encoding.UTF8.GetString(bFileName' 0' fileNameLength);                        byte[] extraField = br.ReadBytes(extraFieldLength);                          Zip64 = false;                      int pos = 0;                      while (extraFieldLength > pos)                      {                          ushort type = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          ushort blockLength = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          switch (type)                          {                              case 0x0001:                                  Zip64 = true;                                  if (tUnCompressedSize == 0xffffffff)                                  {                                      ulong tLong = BitConverter.ToUInt64(extraField' pos);                                      if (tLong != UncompressedSize) return ZipReturn.ZipLocalFileHeaderError;                                      pos += 8;                                  }                                  if (tCompressedSize == 0xffffffff)                                  {                                      ulong tLong = BitConverter.ToUInt64(extraField' pos);                                      if (tLong != _compressedSize) return ZipReturn.ZipLocalFileHeaderError;                                      pos += 8;                                  }                                  break;                              case 0x7075:                                  //byte version = extraField[pos];                                  pos += 1;                                  uint nameCRC32 = BitConverter.ToUInt32(extraField' pos);                                  pos += 4;                                    CRC32 crcTest = new CRC32();                                  crcTest.SlurpBlock(bFileName' 0' fileNameLength);                                  uint fCRC = crcTest.Crc32ResultU;                                    if (nameCRC32 != fCRC) return ZipReturn.ZipLocalFileHeaderError;                                    int charLen = blockLength - 5;                                    tFileName = Encoding.UTF8.GetString(extraField' pos' charLen);                                  pos += charLen;                                    break;                              default:                                  pos += blockLength;                                  break;                          }                      }                        if (!CompareString(FileName' tFileName)) return ZipReturn.ZipLocalFileHeaderError;                        _dataLocation = (ulong)_zipFs.Position;                        if ((_generalPurposeBitFlag & 8) == 0) return ZipReturn.ZipGood;                        _zipFs.Position += (long)_compressedSize;                        tCRC = ReadCRC(br);                      if (!ByteArrCompare(tCRC' new byte[] { 0x50' 0x4b' 0x07' 0x08 }))                          tCRC = ReadCRC(br);                        if (!ByteArrCompare(tCRC' CRC)) return ZipReturn.ZipLocalFileHeaderError;                        uint tint = br.ReadUInt32();                      if (tint != _compressedSize) return ZipReturn.ZipLocalFileHeaderError;                        tint = br.ReadUInt32();                      if (tint != UncompressedSize) return ZipReturn.ZipLocalFileHeaderError;                        return ZipReturn.ZipGood;                  }                  catch                  {                      return ZipReturn.ZipLocalFileHeaderError;                  }
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,LocalFileHeaderRead,The following statement contains a magic number: try                  {                      TrrntZip = true;                        BinaryReader br = new BinaryReader(_zipFs);                        _zipFs.Position = (long)RelativeOffsetOfLocalHeader;                      uint thisSignature = br.ReadUInt32();                      if (thisSignature != LocalFileHeaderSignature)                          return ZipReturn.ZipLocalFileHeaderError;                        br.ReadUInt16();  // version needed to extract                      ushort generalPurposeBitFlagLocal = br.ReadUInt16();                      if (generalPurposeBitFlagLocal != _generalPurposeBitFlag) TrrntZip = false;                        ushort tshort = br.ReadUInt16();                      if (tshort != _compressionMethod) return ZipReturn.ZipLocalFileHeaderError;                        tshort = br.ReadUInt16();                      if (tshort != _lastModFileTime) return ZipReturn.ZipLocalFileHeaderError;                        tshort = br.ReadUInt16();                      if (tshort != _lastModFileDate) return ZipReturn.ZipLocalFileHeaderError;                        byte[] tCRC = ReadCRC(br);                      if (((_generalPurposeBitFlag & 8) == 0) && !ByteArrCompare(tCRC' CRC)) return ZipReturn.ZipLocalFileHeaderError;                        uint tCompressedSize = br.ReadUInt32();                      if (Zip64 && tCompressedSize != 0xffffffff && tCompressedSize != _compressedSize)   // if Zip64 File then the compressedSize should be 0xffffffff                          return ZipReturn.ZipLocalFileHeaderError;                      if ((_generalPurposeBitFlag & 8) == 8 && tCompressedSize != 0)   // if bit 4 set then no compressedSize is set yet                          return ZipReturn.ZipLocalFileHeaderError;                      if (!Zip64 && (_generalPurposeBitFlag & 8) != 8 && tCompressedSize != _compressedSize) // check the compressedSize                          return ZipReturn.ZipLocalFileHeaderError;                            uint tUnCompressedSize = br.ReadUInt32();                      if (Zip64 && tUnCompressedSize != 0xffffffff && tUnCompressedSize != UncompressedSize)   // if Zip64 File then the unCompressedSize should be 0xffffffff                          return ZipReturn.ZipLocalFileHeaderError;                      if ((_generalPurposeBitFlag & 8) == 8 && tUnCompressedSize != 0)   // if bit 4 set then no unCompressedSize is set yet                          return ZipReturn.ZipLocalFileHeaderError;                      if (!Zip64 && (_generalPurposeBitFlag & 8) != 8 && tUnCompressedSize != UncompressedSize) // check the unCompressedSize                          return ZipReturn.ZipLocalFileHeaderError;                        ushort fileNameLength = br.ReadUInt16();                      ushort extraFieldLength = br.ReadUInt16();                          byte[] bFileName = br.ReadBytes(fileNameLength);                      string tFileName = (generalPurposeBitFlagLocal & (1 << 11)) == 0 ?                          GetString(bFileName) :                          Encoding.UTF8.GetString(bFileName' 0' fileNameLength);                        byte[] extraField = br.ReadBytes(extraFieldLength);                          Zip64 = false;                      int pos = 0;                      while (extraFieldLength > pos)                      {                          ushort type = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          ushort blockLength = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          switch (type)                          {                              case 0x0001:                                  Zip64 = true;                                  if (tUnCompressedSize == 0xffffffff)                                  {                                      ulong tLong = BitConverter.ToUInt64(extraField' pos);                                      if (tLong != UncompressedSize) return ZipReturn.ZipLocalFileHeaderError;                                      pos += 8;                                  }                                  if (tCompressedSize == 0xffffffff)                                  {                                      ulong tLong = BitConverter.ToUInt64(extraField' pos);                                      if (tLong != _compressedSize) return ZipReturn.ZipLocalFileHeaderError;                                      pos += 8;                                  }                                  break;                              case 0x7075:                                  //byte version = extraField[pos];                                  pos += 1;                                  uint nameCRC32 = BitConverter.ToUInt32(extraField' pos);                                  pos += 4;                                    CRC32 crcTest = new CRC32();                                  crcTest.SlurpBlock(bFileName' 0' fileNameLength);                                  uint fCRC = crcTest.Crc32ResultU;                                    if (nameCRC32 != fCRC) return ZipReturn.ZipLocalFileHeaderError;                                    int charLen = blockLength - 5;                                    tFileName = Encoding.UTF8.GetString(extraField' pos' charLen);                                  pos += charLen;                                    break;                              default:                                  pos += blockLength;                                  break;                          }                      }                        if (!CompareString(FileName' tFileName)) return ZipReturn.ZipLocalFileHeaderError;                        _dataLocation = (ulong)_zipFs.Position;                        if ((_generalPurposeBitFlag & 8) == 0) return ZipReturn.ZipGood;                        _zipFs.Position += (long)_compressedSize;                        tCRC = ReadCRC(br);                      if (!ByteArrCompare(tCRC' new byte[] { 0x50' 0x4b' 0x07' 0x08 }))                          tCRC = ReadCRC(br);                        if (!ByteArrCompare(tCRC' CRC)) return ZipReturn.ZipLocalFileHeaderError;                        uint tint = br.ReadUInt32();                      if (tint != _compressedSize) return ZipReturn.ZipLocalFileHeaderError;                        tint = br.ReadUInt32();                      if (tint != UncompressedSize) return ZipReturn.ZipLocalFileHeaderError;                        return ZipReturn.ZipGood;                  }                  catch                  {                      return ZipReturn.ZipLocalFileHeaderError;                  }
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,LocalFileHeaderRead,The following statement contains a magic number: try                  {                      TrrntZip = true;                        BinaryReader br = new BinaryReader(_zipFs);                        _zipFs.Position = (long)RelativeOffsetOfLocalHeader;                      uint thisSignature = br.ReadUInt32();                      if (thisSignature != LocalFileHeaderSignature)                          return ZipReturn.ZipLocalFileHeaderError;                        br.ReadUInt16();  // version needed to extract                      ushort generalPurposeBitFlagLocal = br.ReadUInt16();                      if (generalPurposeBitFlagLocal != _generalPurposeBitFlag) TrrntZip = false;                        ushort tshort = br.ReadUInt16();                      if (tshort != _compressionMethod) return ZipReturn.ZipLocalFileHeaderError;                        tshort = br.ReadUInt16();                      if (tshort != _lastModFileTime) return ZipReturn.ZipLocalFileHeaderError;                        tshort = br.ReadUInt16();                      if (tshort != _lastModFileDate) return ZipReturn.ZipLocalFileHeaderError;                        byte[] tCRC = ReadCRC(br);                      if (((_generalPurposeBitFlag & 8) == 0) && !ByteArrCompare(tCRC' CRC)) return ZipReturn.ZipLocalFileHeaderError;                        uint tCompressedSize = br.ReadUInt32();                      if (Zip64 && tCompressedSize != 0xffffffff && tCompressedSize != _compressedSize)   // if Zip64 File then the compressedSize should be 0xffffffff                          return ZipReturn.ZipLocalFileHeaderError;                      if ((_generalPurposeBitFlag & 8) == 8 && tCompressedSize != 0)   // if bit 4 set then no compressedSize is set yet                          return ZipReturn.ZipLocalFileHeaderError;                      if (!Zip64 && (_generalPurposeBitFlag & 8) != 8 && tCompressedSize != _compressedSize) // check the compressedSize                          return ZipReturn.ZipLocalFileHeaderError;                            uint tUnCompressedSize = br.ReadUInt32();                      if (Zip64 && tUnCompressedSize != 0xffffffff && tUnCompressedSize != UncompressedSize)   // if Zip64 File then the unCompressedSize should be 0xffffffff                          return ZipReturn.ZipLocalFileHeaderError;                      if ((_generalPurposeBitFlag & 8) == 8 && tUnCompressedSize != 0)   // if bit 4 set then no unCompressedSize is set yet                          return ZipReturn.ZipLocalFileHeaderError;                      if (!Zip64 && (_generalPurposeBitFlag & 8) != 8 && tUnCompressedSize != UncompressedSize) // check the unCompressedSize                          return ZipReturn.ZipLocalFileHeaderError;                        ushort fileNameLength = br.ReadUInt16();                      ushort extraFieldLength = br.ReadUInt16();                          byte[] bFileName = br.ReadBytes(fileNameLength);                      string tFileName = (generalPurposeBitFlagLocal & (1 << 11)) == 0 ?                          GetString(bFileName) :                          Encoding.UTF8.GetString(bFileName' 0' fileNameLength);                        byte[] extraField = br.ReadBytes(extraFieldLength);                          Zip64 = false;                      int pos = 0;                      while (extraFieldLength > pos)                      {                          ushort type = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          ushort blockLength = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          switch (type)                          {                              case 0x0001:                                  Zip64 = true;                                  if (tUnCompressedSize == 0xffffffff)                                  {                                      ulong tLong = BitConverter.ToUInt64(extraField' pos);                                      if (tLong != UncompressedSize) return ZipReturn.ZipLocalFileHeaderError;                                      pos += 8;                                  }                                  if (tCompressedSize == 0xffffffff)                                  {                                      ulong tLong = BitConverter.ToUInt64(extraField' pos);                                      if (tLong != _compressedSize) return ZipReturn.ZipLocalFileHeaderError;                                      pos += 8;                                  }                                  break;                              case 0x7075:                                  //byte version = extraField[pos];                                  pos += 1;                                  uint nameCRC32 = BitConverter.ToUInt32(extraField' pos);                                  pos += 4;                                    CRC32 crcTest = new CRC32();                                  crcTest.SlurpBlock(bFileName' 0' fileNameLength);                                  uint fCRC = crcTest.Crc32ResultU;                                    if (nameCRC32 != fCRC) return ZipReturn.ZipLocalFileHeaderError;                                    int charLen = blockLength - 5;                                    tFileName = Encoding.UTF8.GetString(extraField' pos' charLen);                                  pos += charLen;                                    break;                              default:                                  pos += blockLength;                                  break;                          }                      }                        if (!CompareString(FileName' tFileName)) return ZipReturn.ZipLocalFileHeaderError;                        _dataLocation = (ulong)_zipFs.Position;                        if ((_generalPurposeBitFlag & 8) == 0) return ZipReturn.ZipGood;                        _zipFs.Position += (long)_compressedSize;                        tCRC = ReadCRC(br);                      if (!ByteArrCompare(tCRC' new byte[] { 0x50' 0x4b' 0x07' 0x08 }))                          tCRC = ReadCRC(br);                        if (!ByteArrCompare(tCRC' CRC)) return ZipReturn.ZipLocalFileHeaderError;                        uint tint = br.ReadUInt32();                      if (tint != _compressedSize) return ZipReturn.ZipLocalFileHeaderError;                        tint = br.ReadUInt32();                      if (tint != UncompressedSize) return ZipReturn.ZipLocalFileHeaderError;                        return ZipReturn.ZipGood;                  }                  catch                  {                      return ZipReturn.ZipLocalFileHeaderError;                  }
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,LocalFileHeaderRead,The following statement contains a magic number: try                  {                      TrrntZip = true;                        BinaryReader br = new BinaryReader(_zipFs);                        _zipFs.Position = (long)RelativeOffsetOfLocalHeader;                      uint thisSignature = br.ReadUInt32();                      if (thisSignature != LocalFileHeaderSignature)                          return ZipReturn.ZipLocalFileHeaderError;                        br.ReadUInt16();  // version needed to extract                      ushort generalPurposeBitFlagLocal = br.ReadUInt16();                      if (generalPurposeBitFlagLocal != _generalPurposeBitFlag) TrrntZip = false;                        ushort tshort = br.ReadUInt16();                      if (tshort != _compressionMethod) return ZipReturn.ZipLocalFileHeaderError;                        tshort = br.ReadUInt16();                      if (tshort != _lastModFileTime) return ZipReturn.ZipLocalFileHeaderError;                        tshort = br.ReadUInt16();                      if (tshort != _lastModFileDate) return ZipReturn.ZipLocalFileHeaderError;                        byte[] tCRC = ReadCRC(br);                      if (((_generalPurposeBitFlag & 8) == 0) && !ByteArrCompare(tCRC' CRC)) return ZipReturn.ZipLocalFileHeaderError;                        uint tCompressedSize = br.ReadUInt32();                      if (Zip64 && tCompressedSize != 0xffffffff && tCompressedSize != _compressedSize)   // if Zip64 File then the compressedSize should be 0xffffffff                          return ZipReturn.ZipLocalFileHeaderError;                      if ((_generalPurposeBitFlag & 8) == 8 && tCompressedSize != 0)   // if bit 4 set then no compressedSize is set yet                          return ZipReturn.ZipLocalFileHeaderError;                      if (!Zip64 && (_generalPurposeBitFlag & 8) != 8 && tCompressedSize != _compressedSize) // check the compressedSize                          return ZipReturn.ZipLocalFileHeaderError;                            uint tUnCompressedSize = br.ReadUInt32();                      if (Zip64 && tUnCompressedSize != 0xffffffff && tUnCompressedSize != UncompressedSize)   // if Zip64 File then the unCompressedSize should be 0xffffffff                          return ZipReturn.ZipLocalFileHeaderError;                      if ((_generalPurposeBitFlag & 8) == 8 && tUnCompressedSize != 0)   // if bit 4 set then no unCompressedSize is set yet                          return ZipReturn.ZipLocalFileHeaderError;                      if (!Zip64 && (_generalPurposeBitFlag & 8) != 8 && tUnCompressedSize != UncompressedSize) // check the unCompressedSize                          return ZipReturn.ZipLocalFileHeaderError;                        ushort fileNameLength = br.ReadUInt16();                      ushort extraFieldLength = br.ReadUInt16();                          byte[] bFileName = br.ReadBytes(fileNameLength);                      string tFileName = (generalPurposeBitFlagLocal & (1 << 11)) == 0 ?                          GetString(bFileName) :                          Encoding.UTF8.GetString(bFileName' 0' fileNameLength);                        byte[] extraField = br.ReadBytes(extraFieldLength);                          Zip64 = false;                      int pos = 0;                      while (extraFieldLength > pos)                      {                          ushort type = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          ushort blockLength = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          switch (type)                          {                              case 0x0001:                                  Zip64 = true;                                  if (tUnCompressedSize == 0xffffffff)                                  {                                      ulong tLong = BitConverter.ToUInt64(extraField' pos);                                      if (tLong != UncompressedSize) return ZipReturn.ZipLocalFileHeaderError;                                      pos += 8;                                  }                                  if (tCompressedSize == 0xffffffff)                                  {                                      ulong tLong = BitConverter.ToUInt64(extraField' pos);                                      if (tLong != _compressedSize) return ZipReturn.ZipLocalFileHeaderError;                                      pos += 8;                                  }                                  break;                              case 0x7075:                                  //byte version = extraField[pos];                                  pos += 1;                                  uint nameCRC32 = BitConverter.ToUInt32(extraField' pos);                                  pos += 4;                                    CRC32 crcTest = new CRC32();                                  crcTest.SlurpBlock(bFileName' 0' fileNameLength);                                  uint fCRC = crcTest.Crc32ResultU;                                    if (nameCRC32 != fCRC) return ZipReturn.ZipLocalFileHeaderError;                                    int charLen = blockLength - 5;                                    tFileName = Encoding.UTF8.GetString(extraField' pos' charLen);                                  pos += charLen;                                    break;                              default:                                  pos += blockLength;                                  break;                          }                      }                        if (!CompareString(FileName' tFileName)) return ZipReturn.ZipLocalFileHeaderError;                        _dataLocation = (ulong)_zipFs.Position;                        if ((_generalPurposeBitFlag & 8) == 0) return ZipReturn.ZipGood;                        _zipFs.Position += (long)_compressedSize;                        tCRC = ReadCRC(br);                      if (!ByteArrCompare(tCRC' new byte[] { 0x50' 0x4b' 0x07' 0x08 }))                          tCRC = ReadCRC(br);                        if (!ByteArrCompare(tCRC' CRC)) return ZipReturn.ZipLocalFileHeaderError;                        uint tint = br.ReadUInt32();                      if (tint != _compressedSize) return ZipReturn.ZipLocalFileHeaderError;                        tint = br.ReadUInt32();                      if (tint != UncompressedSize) return ZipReturn.ZipLocalFileHeaderError;                        return ZipReturn.ZipGood;                  }                  catch                  {                      return ZipReturn.ZipLocalFileHeaderError;                  }
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,LocalFileHeaderRead,The following statement contains a magic number: try                  {                      TrrntZip = true;                        BinaryReader br = new BinaryReader(_zipFs);                        _zipFs.Position = (long)RelativeOffsetOfLocalHeader;                      uint thisSignature = br.ReadUInt32();                      if (thisSignature != LocalFileHeaderSignature)                          return ZipReturn.ZipLocalFileHeaderError;                        br.ReadUInt16();  // version needed to extract                      ushort generalPurposeBitFlagLocal = br.ReadUInt16();                      if (generalPurposeBitFlagLocal != _generalPurposeBitFlag) TrrntZip = false;                        ushort tshort = br.ReadUInt16();                      if (tshort != _compressionMethod) return ZipReturn.ZipLocalFileHeaderError;                        tshort = br.ReadUInt16();                      if (tshort != _lastModFileTime) return ZipReturn.ZipLocalFileHeaderError;                        tshort = br.ReadUInt16();                      if (tshort != _lastModFileDate) return ZipReturn.ZipLocalFileHeaderError;                        byte[] tCRC = ReadCRC(br);                      if (((_generalPurposeBitFlag & 8) == 0) && !ByteArrCompare(tCRC' CRC)) return ZipReturn.ZipLocalFileHeaderError;                        uint tCompressedSize = br.ReadUInt32();                      if (Zip64 && tCompressedSize != 0xffffffff && tCompressedSize != _compressedSize)   // if Zip64 File then the compressedSize should be 0xffffffff                          return ZipReturn.ZipLocalFileHeaderError;                      if ((_generalPurposeBitFlag & 8) == 8 && tCompressedSize != 0)   // if bit 4 set then no compressedSize is set yet                          return ZipReturn.ZipLocalFileHeaderError;                      if (!Zip64 && (_generalPurposeBitFlag & 8) != 8 && tCompressedSize != _compressedSize) // check the compressedSize                          return ZipReturn.ZipLocalFileHeaderError;                            uint tUnCompressedSize = br.ReadUInt32();                      if (Zip64 && tUnCompressedSize != 0xffffffff && tUnCompressedSize != UncompressedSize)   // if Zip64 File then the unCompressedSize should be 0xffffffff                          return ZipReturn.ZipLocalFileHeaderError;                      if ((_generalPurposeBitFlag & 8) == 8 && tUnCompressedSize != 0)   // if bit 4 set then no unCompressedSize is set yet                          return ZipReturn.ZipLocalFileHeaderError;                      if (!Zip64 && (_generalPurposeBitFlag & 8) != 8 && tUnCompressedSize != UncompressedSize) // check the unCompressedSize                          return ZipReturn.ZipLocalFileHeaderError;                        ushort fileNameLength = br.ReadUInt16();                      ushort extraFieldLength = br.ReadUInt16();                          byte[] bFileName = br.ReadBytes(fileNameLength);                      string tFileName = (generalPurposeBitFlagLocal & (1 << 11)) == 0 ?                          GetString(bFileName) :                          Encoding.UTF8.GetString(bFileName' 0' fileNameLength);                        byte[] extraField = br.ReadBytes(extraFieldLength);                          Zip64 = false;                      int pos = 0;                      while (extraFieldLength > pos)                      {                          ushort type = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          ushort blockLength = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          switch (type)                          {                              case 0x0001:                                  Zip64 = true;                                  if (tUnCompressedSize == 0xffffffff)                                  {                                      ulong tLong = BitConverter.ToUInt64(extraField' pos);                                      if (tLong != UncompressedSize) return ZipReturn.ZipLocalFileHeaderError;                                      pos += 8;                                  }                                  if (tCompressedSize == 0xffffffff)                                  {                                      ulong tLong = BitConverter.ToUInt64(extraField' pos);                                      if (tLong != _compressedSize) return ZipReturn.ZipLocalFileHeaderError;                                      pos += 8;                                  }                                  break;                              case 0x7075:                                  //byte version = extraField[pos];                                  pos += 1;                                  uint nameCRC32 = BitConverter.ToUInt32(extraField' pos);                                  pos += 4;                                    CRC32 crcTest = new CRC32();                                  crcTest.SlurpBlock(bFileName' 0' fileNameLength);                                  uint fCRC = crcTest.Crc32ResultU;                                    if (nameCRC32 != fCRC) return ZipReturn.ZipLocalFileHeaderError;                                    int charLen = blockLength - 5;                                    tFileName = Encoding.UTF8.GetString(extraField' pos' charLen);                                  pos += charLen;                                    break;                              default:                                  pos += blockLength;                                  break;                          }                      }                        if (!CompareString(FileName' tFileName)) return ZipReturn.ZipLocalFileHeaderError;                        _dataLocation = (ulong)_zipFs.Position;                        if ((_generalPurposeBitFlag & 8) == 0) return ZipReturn.ZipGood;                        _zipFs.Position += (long)_compressedSize;                        tCRC = ReadCRC(br);                      if (!ByteArrCompare(tCRC' new byte[] { 0x50' 0x4b' 0x07' 0x08 }))                          tCRC = ReadCRC(br);                        if (!ByteArrCompare(tCRC' CRC)) return ZipReturn.ZipLocalFileHeaderError;                        uint tint = br.ReadUInt32();                      if (tint != _compressedSize) return ZipReturn.ZipLocalFileHeaderError;                        tint = br.ReadUInt32();                      if (tint != UncompressedSize) return ZipReturn.ZipLocalFileHeaderError;                        return ZipReturn.ZipGood;                  }                  catch                  {                      return ZipReturn.ZipLocalFileHeaderError;                  }
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,LocalFileHeaderRead,The following statement contains a magic number: try                  {                      TrrntZip = true;                        BinaryReader br = new BinaryReader(_zipFs);                        _zipFs.Position = (long)RelativeOffsetOfLocalHeader;                      uint thisSignature = br.ReadUInt32();                      if (thisSignature != LocalFileHeaderSignature)                          return ZipReturn.ZipLocalFileHeaderError;                        br.ReadUInt16();  // version needed to extract                      ushort generalPurposeBitFlagLocal = br.ReadUInt16();                      if (generalPurposeBitFlagLocal != _generalPurposeBitFlag) TrrntZip = false;                        ushort tshort = br.ReadUInt16();                      if (tshort != _compressionMethod) return ZipReturn.ZipLocalFileHeaderError;                        tshort = br.ReadUInt16();                      if (tshort != _lastModFileTime) return ZipReturn.ZipLocalFileHeaderError;                        tshort = br.ReadUInt16();                      if (tshort != _lastModFileDate) return ZipReturn.ZipLocalFileHeaderError;                        byte[] tCRC = ReadCRC(br);                      if (((_generalPurposeBitFlag & 8) == 0) && !ByteArrCompare(tCRC' CRC)) return ZipReturn.ZipLocalFileHeaderError;                        uint tCompressedSize = br.ReadUInt32();                      if (Zip64 && tCompressedSize != 0xffffffff && tCompressedSize != _compressedSize)   // if Zip64 File then the compressedSize should be 0xffffffff                          return ZipReturn.ZipLocalFileHeaderError;                      if ((_generalPurposeBitFlag & 8) == 8 && tCompressedSize != 0)   // if bit 4 set then no compressedSize is set yet                          return ZipReturn.ZipLocalFileHeaderError;                      if (!Zip64 && (_generalPurposeBitFlag & 8) != 8 && tCompressedSize != _compressedSize) // check the compressedSize                          return ZipReturn.ZipLocalFileHeaderError;                            uint tUnCompressedSize = br.ReadUInt32();                      if (Zip64 && tUnCompressedSize != 0xffffffff && tUnCompressedSize != UncompressedSize)   // if Zip64 File then the unCompressedSize should be 0xffffffff                          return ZipReturn.ZipLocalFileHeaderError;                      if ((_generalPurposeBitFlag & 8) == 8 && tUnCompressedSize != 0)   // if bit 4 set then no unCompressedSize is set yet                          return ZipReturn.ZipLocalFileHeaderError;                      if (!Zip64 && (_generalPurposeBitFlag & 8) != 8 && tUnCompressedSize != UncompressedSize) // check the unCompressedSize                          return ZipReturn.ZipLocalFileHeaderError;                        ushort fileNameLength = br.ReadUInt16();                      ushort extraFieldLength = br.ReadUInt16();                          byte[] bFileName = br.ReadBytes(fileNameLength);                      string tFileName = (generalPurposeBitFlagLocal & (1 << 11)) == 0 ?                          GetString(bFileName) :                          Encoding.UTF8.GetString(bFileName' 0' fileNameLength);                        byte[] extraField = br.ReadBytes(extraFieldLength);                          Zip64 = false;                      int pos = 0;                      while (extraFieldLength > pos)                      {                          ushort type = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          ushort blockLength = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          switch (type)                          {                              case 0x0001:                                  Zip64 = true;                                  if (tUnCompressedSize == 0xffffffff)                                  {                                      ulong tLong = BitConverter.ToUInt64(extraField' pos);                                      if (tLong != UncompressedSize) return ZipReturn.ZipLocalFileHeaderError;                                      pos += 8;                                  }                                  if (tCompressedSize == 0xffffffff)                                  {                                      ulong tLong = BitConverter.ToUInt64(extraField' pos);                                      if (tLong != _compressedSize) return ZipReturn.ZipLocalFileHeaderError;                                      pos += 8;                                  }                                  break;                              case 0x7075:                                  //byte version = extraField[pos];                                  pos += 1;                                  uint nameCRC32 = BitConverter.ToUInt32(extraField' pos);                                  pos += 4;                                    CRC32 crcTest = new CRC32();                                  crcTest.SlurpBlock(bFileName' 0' fileNameLength);                                  uint fCRC = crcTest.Crc32ResultU;                                    if (nameCRC32 != fCRC) return ZipReturn.ZipLocalFileHeaderError;                                    int charLen = blockLength - 5;                                    tFileName = Encoding.UTF8.GetString(extraField' pos' charLen);                                  pos += charLen;                                    break;                              default:                                  pos += blockLength;                                  break;                          }                      }                        if (!CompareString(FileName' tFileName)) return ZipReturn.ZipLocalFileHeaderError;                        _dataLocation = (ulong)_zipFs.Position;                        if ((_generalPurposeBitFlag & 8) == 0) return ZipReturn.ZipGood;                        _zipFs.Position += (long)_compressedSize;                        tCRC = ReadCRC(br);                      if (!ByteArrCompare(tCRC' new byte[] { 0x50' 0x4b' 0x07' 0x08 }))                          tCRC = ReadCRC(br);                        if (!ByteArrCompare(tCRC' CRC)) return ZipReturn.ZipLocalFileHeaderError;                        uint tint = br.ReadUInt32();                      if (tint != _compressedSize) return ZipReturn.ZipLocalFileHeaderError;                        tint = br.ReadUInt32();                      if (tint != UncompressedSize) return ZipReturn.ZipLocalFileHeaderError;                        return ZipReturn.ZipGood;                  }                  catch                  {                      return ZipReturn.ZipLocalFileHeaderError;                  }
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,LocalFileHeaderRead,The following statement contains a magic number: try                  {                      TrrntZip = true;                        BinaryReader br = new BinaryReader(_zipFs);                        _zipFs.Position = (long)RelativeOffsetOfLocalHeader;                      uint thisSignature = br.ReadUInt32();                      if (thisSignature != LocalFileHeaderSignature)                          return ZipReturn.ZipLocalFileHeaderError;                        br.ReadUInt16();  // version needed to extract                      ushort generalPurposeBitFlagLocal = br.ReadUInt16();                      if (generalPurposeBitFlagLocal != _generalPurposeBitFlag) TrrntZip = false;                        ushort tshort = br.ReadUInt16();                      if (tshort != _compressionMethod) return ZipReturn.ZipLocalFileHeaderError;                        tshort = br.ReadUInt16();                      if (tshort != _lastModFileTime) return ZipReturn.ZipLocalFileHeaderError;                        tshort = br.ReadUInt16();                      if (tshort != _lastModFileDate) return ZipReturn.ZipLocalFileHeaderError;                        byte[] tCRC = ReadCRC(br);                      if (((_generalPurposeBitFlag & 8) == 0) && !ByteArrCompare(tCRC' CRC)) return ZipReturn.ZipLocalFileHeaderError;                        uint tCompressedSize = br.ReadUInt32();                      if (Zip64 && tCompressedSize != 0xffffffff && tCompressedSize != _compressedSize)   // if Zip64 File then the compressedSize should be 0xffffffff                          return ZipReturn.ZipLocalFileHeaderError;                      if ((_generalPurposeBitFlag & 8) == 8 && tCompressedSize != 0)   // if bit 4 set then no compressedSize is set yet                          return ZipReturn.ZipLocalFileHeaderError;                      if (!Zip64 && (_generalPurposeBitFlag & 8) != 8 && tCompressedSize != _compressedSize) // check the compressedSize                          return ZipReturn.ZipLocalFileHeaderError;                            uint tUnCompressedSize = br.ReadUInt32();                      if (Zip64 && tUnCompressedSize != 0xffffffff && tUnCompressedSize != UncompressedSize)   // if Zip64 File then the unCompressedSize should be 0xffffffff                          return ZipReturn.ZipLocalFileHeaderError;                      if ((_generalPurposeBitFlag & 8) == 8 && tUnCompressedSize != 0)   // if bit 4 set then no unCompressedSize is set yet                          return ZipReturn.ZipLocalFileHeaderError;                      if (!Zip64 && (_generalPurposeBitFlag & 8) != 8 && tUnCompressedSize != UncompressedSize) // check the unCompressedSize                          return ZipReturn.ZipLocalFileHeaderError;                        ushort fileNameLength = br.ReadUInt16();                      ushort extraFieldLength = br.ReadUInt16();                          byte[] bFileName = br.ReadBytes(fileNameLength);                      string tFileName = (generalPurposeBitFlagLocal & (1 << 11)) == 0 ?                          GetString(bFileName) :                          Encoding.UTF8.GetString(bFileName' 0' fileNameLength);                        byte[] extraField = br.ReadBytes(extraFieldLength);                          Zip64 = false;                      int pos = 0;                      while (extraFieldLength > pos)                      {                          ushort type = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          ushort blockLength = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          switch (type)                          {                              case 0x0001:                                  Zip64 = true;                                  if (tUnCompressedSize == 0xffffffff)                                  {                                      ulong tLong = BitConverter.ToUInt64(extraField' pos);                                      if (tLong != UncompressedSize) return ZipReturn.ZipLocalFileHeaderError;                                      pos += 8;                                  }                                  if (tCompressedSize == 0xffffffff)                                  {                                      ulong tLong = BitConverter.ToUInt64(extraField' pos);                                      if (tLong != _compressedSize) return ZipReturn.ZipLocalFileHeaderError;                                      pos += 8;                                  }                                  break;                              case 0x7075:                                  //byte version = extraField[pos];                                  pos += 1;                                  uint nameCRC32 = BitConverter.ToUInt32(extraField' pos);                                  pos += 4;                                    CRC32 crcTest = new CRC32();                                  crcTest.SlurpBlock(bFileName' 0' fileNameLength);                                  uint fCRC = crcTest.Crc32ResultU;                                    if (nameCRC32 != fCRC) return ZipReturn.ZipLocalFileHeaderError;                                    int charLen = blockLength - 5;                                    tFileName = Encoding.UTF8.GetString(extraField' pos' charLen);                                  pos += charLen;                                    break;                              default:                                  pos += blockLength;                                  break;                          }                      }                        if (!CompareString(FileName' tFileName)) return ZipReturn.ZipLocalFileHeaderError;                        _dataLocation = (ulong)_zipFs.Position;                        if ((_generalPurposeBitFlag & 8) == 0) return ZipReturn.ZipGood;                        _zipFs.Position += (long)_compressedSize;                        tCRC = ReadCRC(br);                      if (!ByteArrCompare(tCRC' new byte[] { 0x50' 0x4b' 0x07' 0x08 }))                          tCRC = ReadCRC(br);                        if (!ByteArrCompare(tCRC' CRC)) return ZipReturn.ZipLocalFileHeaderError;                        uint tint = br.ReadUInt32();                      if (tint != _compressedSize) return ZipReturn.ZipLocalFileHeaderError;                        tint = br.ReadUInt32();                      if (tint != UncompressedSize) return ZipReturn.ZipLocalFileHeaderError;                        return ZipReturn.ZipGood;                  }                  catch                  {                      return ZipReturn.ZipLocalFileHeaderError;                  }
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,LocalFileHeaderRead,The following statement contains a magic number: try                  {                      TrrntZip = true;                        BinaryReader br = new BinaryReader(_zipFs);                        _zipFs.Position = (long)RelativeOffsetOfLocalHeader;                      uint thisSignature = br.ReadUInt32();                      if (thisSignature != LocalFileHeaderSignature)                          return ZipReturn.ZipLocalFileHeaderError;                        br.ReadUInt16();  // version needed to extract                      ushort generalPurposeBitFlagLocal = br.ReadUInt16();                      if (generalPurposeBitFlagLocal != _generalPurposeBitFlag) TrrntZip = false;                        ushort tshort = br.ReadUInt16();                      if (tshort != _compressionMethod) return ZipReturn.ZipLocalFileHeaderError;                        tshort = br.ReadUInt16();                      if (tshort != _lastModFileTime) return ZipReturn.ZipLocalFileHeaderError;                        tshort = br.ReadUInt16();                      if (tshort != _lastModFileDate) return ZipReturn.ZipLocalFileHeaderError;                        byte[] tCRC = ReadCRC(br);                      if (((_generalPurposeBitFlag & 8) == 0) && !ByteArrCompare(tCRC' CRC)) return ZipReturn.ZipLocalFileHeaderError;                        uint tCompressedSize = br.ReadUInt32();                      if (Zip64 && tCompressedSize != 0xffffffff && tCompressedSize != _compressedSize)   // if Zip64 File then the compressedSize should be 0xffffffff                          return ZipReturn.ZipLocalFileHeaderError;                      if ((_generalPurposeBitFlag & 8) == 8 && tCompressedSize != 0)   // if bit 4 set then no compressedSize is set yet                          return ZipReturn.ZipLocalFileHeaderError;                      if (!Zip64 && (_generalPurposeBitFlag & 8) != 8 && tCompressedSize != _compressedSize) // check the compressedSize                          return ZipReturn.ZipLocalFileHeaderError;                            uint tUnCompressedSize = br.ReadUInt32();                      if (Zip64 && tUnCompressedSize != 0xffffffff && tUnCompressedSize != UncompressedSize)   // if Zip64 File then the unCompressedSize should be 0xffffffff                          return ZipReturn.ZipLocalFileHeaderError;                      if ((_generalPurposeBitFlag & 8) == 8 && tUnCompressedSize != 0)   // if bit 4 set then no unCompressedSize is set yet                          return ZipReturn.ZipLocalFileHeaderError;                      if (!Zip64 && (_generalPurposeBitFlag & 8) != 8 && tUnCompressedSize != UncompressedSize) // check the unCompressedSize                          return ZipReturn.ZipLocalFileHeaderError;                        ushort fileNameLength = br.ReadUInt16();                      ushort extraFieldLength = br.ReadUInt16();                          byte[] bFileName = br.ReadBytes(fileNameLength);                      string tFileName = (generalPurposeBitFlagLocal & (1 << 11)) == 0 ?                          GetString(bFileName) :                          Encoding.UTF8.GetString(bFileName' 0' fileNameLength);                        byte[] extraField = br.ReadBytes(extraFieldLength);                          Zip64 = false;                      int pos = 0;                      while (extraFieldLength > pos)                      {                          ushort type = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          ushort blockLength = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          switch (type)                          {                              case 0x0001:                                  Zip64 = true;                                  if (tUnCompressedSize == 0xffffffff)                                  {                                      ulong tLong = BitConverter.ToUInt64(extraField' pos);                                      if (tLong != UncompressedSize) return ZipReturn.ZipLocalFileHeaderError;                                      pos += 8;                                  }                                  if (tCompressedSize == 0xffffffff)                                  {                                      ulong tLong = BitConverter.ToUInt64(extraField' pos);                                      if (tLong != _compressedSize) return ZipReturn.ZipLocalFileHeaderError;                                      pos += 8;                                  }                                  break;                              case 0x7075:                                  //byte version = extraField[pos];                                  pos += 1;                                  uint nameCRC32 = BitConverter.ToUInt32(extraField' pos);                                  pos += 4;                                    CRC32 crcTest = new CRC32();                                  crcTest.SlurpBlock(bFileName' 0' fileNameLength);                                  uint fCRC = crcTest.Crc32ResultU;                                    if (nameCRC32 != fCRC) return ZipReturn.ZipLocalFileHeaderError;                                    int charLen = blockLength - 5;                                    tFileName = Encoding.UTF8.GetString(extraField' pos' charLen);                                  pos += charLen;                                    break;                              default:                                  pos += blockLength;                                  break;                          }                      }                        if (!CompareString(FileName' tFileName)) return ZipReturn.ZipLocalFileHeaderError;                        _dataLocation = (ulong)_zipFs.Position;                        if ((_generalPurposeBitFlag & 8) == 0) return ZipReturn.ZipGood;                        _zipFs.Position += (long)_compressedSize;                        tCRC = ReadCRC(br);                      if (!ByteArrCompare(tCRC' new byte[] { 0x50' 0x4b' 0x07' 0x08 }))                          tCRC = ReadCRC(br);                        if (!ByteArrCompare(tCRC' CRC)) return ZipReturn.ZipLocalFileHeaderError;                        uint tint = br.ReadUInt32();                      if (tint != _compressedSize) return ZipReturn.ZipLocalFileHeaderError;                        tint = br.ReadUInt32();                      if (tint != UncompressedSize) return ZipReturn.ZipLocalFileHeaderError;                        return ZipReturn.ZipGood;                  }                  catch                  {                      return ZipReturn.ZipLocalFileHeaderError;                  }
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,LocalFileHeaderRead,The following statement contains a magic number: try                  {                      TrrntZip = true;                        BinaryReader br = new BinaryReader(_zipFs);                        _zipFs.Position = (long)RelativeOffsetOfLocalHeader;                      uint thisSignature = br.ReadUInt32();                      if (thisSignature != LocalFileHeaderSignature)                          return ZipReturn.ZipLocalFileHeaderError;                        br.ReadUInt16();  // version needed to extract                      ushort generalPurposeBitFlagLocal = br.ReadUInt16();                      if (generalPurposeBitFlagLocal != _generalPurposeBitFlag) TrrntZip = false;                        ushort tshort = br.ReadUInt16();                      if (tshort != _compressionMethod) return ZipReturn.ZipLocalFileHeaderError;                        tshort = br.ReadUInt16();                      if (tshort != _lastModFileTime) return ZipReturn.ZipLocalFileHeaderError;                        tshort = br.ReadUInt16();                      if (tshort != _lastModFileDate) return ZipReturn.ZipLocalFileHeaderError;                        byte[] tCRC = ReadCRC(br);                      if (((_generalPurposeBitFlag & 8) == 0) && !ByteArrCompare(tCRC' CRC)) return ZipReturn.ZipLocalFileHeaderError;                        uint tCompressedSize = br.ReadUInt32();                      if (Zip64 && tCompressedSize != 0xffffffff && tCompressedSize != _compressedSize)   // if Zip64 File then the compressedSize should be 0xffffffff                          return ZipReturn.ZipLocalFileHeaderError;                      if ((_generalPurposeBitFlag & 8) == 8 && tCompressedSize != 0)   // if bit 4 set then no compressedSize is set yet                          return ZipReturn.ZipLocalFileHeaderError;                      if (!Zip64 && (_generalPurposeBitFlag & 8) != 8 && tCompressedSize != _compressedSize) // check the compressedSize                          return ZipReturn.ZipLocalFileHeaderError;                            uint tUnCompressedSize = br.ReadUInt32();                      if (Zip64 && tUnCompressedSize != 0xffffffff && tUnCompressedSize != UncompressedSize)   // if Zip64 File then the unCompressedSize should be 0xffffffff                          return ZipReturn.ZipLocalFileHeaderError;                      if ((_generalPurposeBitFlag & 8) == 8 && tUnCompressedSize != 0)   // if bit 4 set then no unCompressedSize is set yet                          return ZipReturn.ZipLocalFileHeaderError;                      if (!Zip64 && (_generalPurposeBitFlag & 8) != 8 && tUnCompressedSize != UncompressedSize) // check the unCompressedSize                          return ZipReturn.ZipLocalFileHeaderError;                        ushort fileNameLength = br.ReadUInt16();                      ushort extraFieldLength = br.ReadUInt16();                          byte[] bFileName = br.ReadBytes(fileNameLength);                      string tFileName = (generalPurposeBitFlagLocal & (1 << 11)) == 0 ?                          GetString(bFileName) :                          Encoding.UTF8.GetString(bFileName' 0' fileNameLength);                        byte[] extraField = br.ReadBytes(extraFieldLength);                          Zip64 = false;                      int pos = 0;                      while (extraFieldLength > pos)                      {                          ushort type = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          ushort blockLength = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          switch (type)                          {                              case 0x0001:                                  Zip64 = true;                                  if (tUnCompressedSize == 0xffffffff)                                  {                                      ulong tLong = BitConverter.ToUInt64(extraField' pos);                                      if (tLong != UncompressedSize) return ZipReturn.ZipLocalFileHeaderError;                                      pos += 8;                                  }                                  if (tCompressedSize == 0xffffffff)                                  {                                      ulong tLong = BitConverter.ToUInt64(extraField' pos);                                      if (tLong != _compressedSize) return ZipReturn.ZipLocalFileHeaderError;                                      pos += 8;                                  }                                  break;                              case 0x7075:                                  //byte version = extraField[pos];                                  pos += 1;                                  uint nameCRC32 = BitConverter.ToUInt32(extraField' pos);                                  pos += 4;                                    CRC32 crcTest = new CRC32();                                  crcTest.SlurpBlock(bFileName' 0' fileNameLength);                                  uint fCRC = crcTest.Crc32ResultU;                                    if (nameCRC32 != fCRC) return ZipReturn.ZipLocalFileHeaderError;                                    int charLen = blockLength - 5;                                    tFileName = Encoding.UTF8.GetString(extraField' pos' charLen);                                  pos += charLen;                                    break;                              default:                                  pos += blockLength;                                  break;                          }                      }                        if (!CompareString(FileName' tFileName)) return ZipReturn.ZipLocalFileHeaderError;                        _dataLocation = (ulong)_zipFs.Position;                        if ((_generalPurposeBitFlag & 8) == 0) return ZipReturn.ZipGood;                        _zipFs.Position += (long)_compressedSize;                        tCRC = ReadCRC(br);                      if (!ByteArrCompare(tCRC' new byte[] { 0x50' 0x4b' 0x07' 0x08 }))                          tCRC = ReadCRC(br);                        if (!ByteArrCompare(tCRC' CRC)) return ZipReturn.ZipLocalFileHeaderError;                        uint tint = br.ReadUInt32();                      if (tint != _compressedSize) return ZipReturn.ZipLocalFileHeaderError;                        tint = br.ReadUInt32();                      if (tint != UncompressedSize) return ZipReturn.ZipLocalFileHeaderError;                        return ZipReturn.ZipGood;                  }                  catch                  {                      return ZipReturn.ZipLocalFileHeaderError;                  }
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,LocalFileHeaderRead,The following statement contains a magic number: try                  {                      TrrntZip = true;                        BinaryReader br = new BinaryReader(_zipFs);                        _zipFs.Position = (long)RelativeOffsetOfLocalHeader;                      uint thisSignature = br.ReadUInt32();                      if (thisSignature != LocalFileHeaderSignature)                          return ZipReturn.ZipLocalFileHeaderError;                        br.ReadUInt16();  // version needed to extract                      ushort generalPurposeBitFlagLocal = br.ReadUInt16();                      if (generalPurposeBitFlagLocal != _generalPurposeBitFlag) TrrntZip = false;                        ushort tshort = br.ReadUInt16();                      if (tshort != _compressionMethod) return ZipReturn.ZipLocalFileHeaderError;                        tshort = br.ReadUInt16();                      if (tshort != _lastModFileTime) return ZipReturn.ZipLocalFileHeaderError;                        tshort = br.ReadUInt16();                      if (tshort != _lastModFileDate) return ZipReturn.ZipLocalFileHeaderError;                        byte[] tCRC = ReadCRC(br);                      if (((_generalPurposeBitFlag & 8) == 0) && !ByteArrCompare(tCRC' CRC)) return ZipReturn.ZipLocalFileHeaderError;                        uint tCompressedSize = br.ReadUInt32();                      if (Zip64 && tCompressedSize != 0xffffffff && tCompressedSize != _compressedSize)   // if Zip64 File then the compressedSize should be 0xffffffff                          return ZipReturn.ZipLocalFileHeaderError;                      if ((_generalPurposeBitFlag & 8) == 8 && tCompressedSize != 0)   // if bit 4 set then no compressedSize is set yet                          return ZipReturn.ZipLocalFileHeaderError;                      if (!Zip64 && (_generalPurposeBitFlag & 8) != 8 && tCompressedSize != _compressedSize) // check the compressedSize                          return ZipReturn.ZipLocalFileHeaderError;                            uint tUnCompressedSize = br.ReadUInt32();                      if (Zip64 && tUnCompressedSize != 0xffffffff && tUnCompressedSize != UncompressedSize)   // if Zip64 File then the unCompressedSize should be 0xffffffff                          return ZipReturn.ZipLocalFileHeaderError;                      if ((_generalPurposeBitFlag & 8) == 8 && tUnCompressedSize != 0)   // if bit 4 set then no unCompressedSize is set yet                          return ZipReturn.ZipLocalFileHeaderError;                      if (!Zip64 && (_generalPurposeBitFlag & 8) != 8 && tUnCompressedSize != UncompressedSize) // check the unCompressedSize                          return ZipReturn.ZipLocalFileHeaderError;                        ushort fileNameLength = br.ReadUInt16();                      ushort extraFieldLength = br.ReadUInt16();                          byte[] bFileName = br.ReadBytes(fileNameLength);                      string tFileName = (generalPurposeBitFlagLocal & (1 << 11)) == 0 ?                          GetString(bFileName) :                          Encoding.UTF8.GetString(bFileName' 0' fileNameLength);                        byte[] extraField = br.ReadBytes(extraFieldLength);                          Zip64 = false;                      int pos = 0;                      while (extraFieldLength > pos)                      {                          ushort type = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          ushort blockLength = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          switch (type)                          {                              case 0x0001:                                  Zip64 = true;                                  if (tUnCompressedSize == 0xffffffff)                                  {                                      ulong tLong = BitConverter.ToUInt64(extraField' pos);                                      if (tLong != UncompressedSize) return ZipReturn.ZipLocalFileHeaderError;                                      pos += 8;                                  }                                  if (tCompressedSize == 0xffffffff)                                  {                                      ulong tLong = BitConverter.ToUInt64(extraField' pos);                                      if (tLong != _compressedSize) return ZipReturn.ZipLocalFileHeaderError;                                      pos += 8;                                  }                                  break;                              case 0x7075:                                  //byte version = extraField[pos];                                  pos += 1;                                  uint nameCRC32 = BitConverter.ToUInt32(extraField' pos);                                  pos += 4;                                    CRC32 crcTest = new CRC32();                                  crcTest.SlurpBlock(bFileName' 0' fileNameLength);                                  uint fCRC = crcTest.Crc32ResultU;                                    if (nameCRC32 != fCRC) return ZipReturn.ZipLocalFileHeaderError;                                    int charLen = blockLength - 5;                                    tFileName = Encoding.UTF8.GetString(extraField' pos' charLen);                                  pos += charLen;                                    break;                              default:                                  pos += blockLength;                                  break;                          }                      }                        if (!CompareString(FileName' tFileName)) return ZipReturn.ZipLocalFileHeaderError;                        _dataLocation = (ulong)_zipFs.Position;                        if ((_generalPurposeBitFlag & 8) == 0) return ZipReturn.ZipGood;                        _zipFs.Position += (long)_compressedSize;                        tCRC = ReadCRC(br);                      if (!ByteArrCompare(tCRC' new byte[] { 0x50' 0x4b' 0x07' 0x08 }))                          tCRC = ReadCRC(br);                        if (!ByteArrCompare(tCRC' CRC)) return ZipReturn.ZipLocalFileHeaderError;                        uint tint = br.ReadUInt32();                      if (tint != _compressedSize) return ZipReturn.ZipLocalFileHeaderError;                        tint = br.ReadUInt32();                      if (tint != UncompressedSize) return ZipReturn.ZipLocalFileHeaderError;                        return ZipReturn.ZipGood;                  }                  catch                  {                      return ZipReturn.ZipLocalFileHeaderError;                  }
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,LocalFileHeaderRead,The following statement contains a magic number: try                  {                      TrrntZip = true;                        BinaryReader br = new BinaryReader(_zipFs);                        _zipFs.Position = (long)RelativeOffsetOfLocalHeader;                      uint thisSignature = br.ReadUInt32();                      if (thisSignature != LocalFileHeaderSignature)                          return ZipReturn.ZipLocalFileHeaderError;                        br.ReadUInt16();  // version needed to extract                      ushort generalPurposeBitFlagLocal = br.ReadUInt16();                      if (generalPurposeBitFlagLocal != _generalPurposeBitFlag) TrrntZip = false;                        ushort tshort = br.ReadUInt16();                      if (tshort != _compressionMethod) return ZipReturn.ZipLocalFileHeaderError;                        tshort = br.ReadUInt16();                      if (tshort != _lastModFileTime) return ZipReturn.ZipLocalFileHeaderError;                        tshort = br.ReadUInt16();                      if (tshort != _lastModFileDate) return ZipReturn.ZipLocalFileHeaderError;                        byte[] tCRC = ReadCRC(br);                      if (((_generalPurposeBitFlag & 8) == 0) && !ByteArrCompare(tCRC' CRC)) return ZipReturn.ZipLocalFileHeaderError;                        uint tCompressedSize = br.ReadUInt32();                      if (Zip64 && tCompressedSize != 0xffffffff && tCompressedSize != _compressedSize)   // if Zip64 File then the compressedSize should be 0xffffffff                          return ZipReturn.ZipLocalFileHeaderError;                      if ((_generalPurposeBitFlag & 8) == 8 && tCompressedSize != 0)   // if bit 4 set then no compressedSize is set yet                          return ZipReturn.ZipLocalFileHeaderError;                      if (!Zip64 && (_generalPurposeBitFlag & 8) != 8 && tCompressedSize != _compressedSize) // check the compressedSize                          return ZipReturn.ZipLocalFileHeaderError;                            uint tUnCompressedSize = br.ReadUInt32();                      if (Zip64 && tUnCompressedSize != 0xffffffff && tUnCompressedSize != UncompressedSize)   // if Zip64 File then the unCompressedSize should be 0xffffffff                          return ZipReturn.ZipLocalFileHeaderError;                      if ((_generalPurposeBitFlag & 8) == 8 && tUnCompressedSize != 0)   // if bit 4 set then no unCompressedSize is set yet                          return ZipReturn.ZipLocalFileHeaderError;                      if (!Zip64 && (_generalPurposeBitFlag & 8) != 8 && tUnCompressedSize != UncompressedSize) // check the unCompressedSize                          return ZipReturn.ZipLocalFileHeaderError;                        ushort fileNameLength = br.ReadUInt16();                      ushort extraFieldLength = br.ReadUInt16();                          byte[] bFileName = br.ReadBytes(fileNameLength);                      string tFileName = (generalPurposeBitFlagLocal & (1 << 11)) == 0 ?                          GetString(bFileName) :                          Encoding.UTF8.GetString(bFileName' 0' fileNameLength);                        byte[] extraField = br.ReadBytes(extraFieldLength);                          Zip64 = false;                      int pos = 0;                      while (extraFieldLength > pos)                      {                          ushort type = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          ushort blockLength = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          switch (type)                          {                              case 0x0001:                                  Zip64 = true;                                  if (tUnCompressedSize == 0xffffffff)                                  {                                      ulong tLong = BitConverter.ToUInt64(extraField' pos);                                      if (tLong != UncompressedSize) return ZipReturn.ZipLocalFileHeaderError;                                      pos += 8;                                  }                                  if (tCompressedSize == 0xffffffff)                                  {                                      ulong tLong = BitConverter.ToUInt64(extraField' pos);                                      if (tLong != _compressedSize) return ZipReturn.ZipLocalFileHeaderError;                                      pos += 8;                                  }                                  break;                              case 0x7075:                                  //byte version = extraField[pos];                                  pos += 1;                                  uint nameCRC32 = BitConverter.ToUInt32(extraField' pos);                                  pos += 4;                                    CRC32 crcTest = new CRC32();                                  crcTest.SlurpBlock(bFileName' 0' fileNameLength);                                  uint fCRC = crcTest.Crc32ResultU;                                    if (nameCRC32 != fCRC) return ZipReturn.ZipLocalFileHeaderError;                                    int charLen = blockLength - 5;                                    tFileName = Encoding.UTF8.GetString(extraField' pos' charLen);                                  pos += charLen;                                    break;                              default:                                  pos += blockLength;                                  break;                          }                      }                        if (!CompareString(FileName' tFileName)) return ZipReturn.ZipLocalFileHeaderError;                        _dataLocation = (ulong)_zipFs.Position;                        if ((_generalPurposeBitFlag & 8) == 0) return ZipReturn.ZipGood;                        _zipFs.Position += (long)_compressedSize;                        tCRC = ReadCRC(br);                      if (!ByteArrCompare(tCRC' new byte[] { 0x50' 0x4b' 0x07' 0x08 }))                          tCRC = ReadCRC(br);                        if (!ByteArrCompare(tCRC' CRC)) return ZipReturn.ZipLocalFileHeaderError;                        uint tint = br.ReadUInt32();                      if (tint != _compressedSize) return ZipReturn.ZipLocalFileHeaderError;                        tint = br.ReadUInt32();                      if (tint != UncompressedSize) return ZipReturn.ZipLocalFileHeaderError;                        return ZipReturn.ZipGood;                  }                  catch                  {                      return ZipReturn.ZipLocalFileHeaderError;                  }
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,LocalFileHeaderRead,The following statement contains a magic number: try                  {                      TrrntZip = true;                        BinaryReader br = new BinaryReader(_zipFs);                        _zipFs.Position = (long)RelativeOffsetOfLocalHeader;                      uint thisSignature = br.ReadUInt32();                      if (thisSignature != LocalFileHeaderSignature)                          return ZipReturn.ZipLocalFileHeaderError;                        br.ReadUInt16();  // version needed to extract                      ushort generalPurposeBitFlagLocal = br.ReadUInt16();                      if (generalPurposeBitFlagLocal != _generalPurposeBitFlag) TrrntZip = false;                        ushort tshort = br.ReadUInt16();                      if (tshort != _compressionMethod) return ZipReturn.ZipLocalFileHeaderError;                        tshort = br.ReadUInt16();                      if (tshort != _lastModFileTime) return ZipReturn.ZipLocalFileHeaderError;                        tshort = br.ReadUInt16();                      if (tshort != _lastModFileDate) return ZipReturn.ZipLocalFileHeaderError;                        byte[] tCRC = ReadCRC(br);                      if (((_generalPurposeBitFlag & 8) == 0) && !ByteArrCompare(tCRC' CRC)) return ZipReturn.ZipLocalFileHeaderError;                        uint tCompressedSize = br.ReadUInt32();                      if (Zip64 && tCompressedSize != 0xffffffff && tCompressedSize != _compressedSize)   // if Zip64 File then the compressedSize should be 0xffffffff                          return ZipReturn.ZipLocalFileHeaderError;                      if ((_generalPurposeBitFlag & 8) == 8 && tCompressedSize != 0)   // if bit 4 set then no compressedSize is set yet                          return ZipReturn.ZipLocalFileHeaderError;                      if (!Zip64 && (_generalPurposeBitFlag & 8) != 8 && tCompressedSize != _compressedSize) // check the compressedSize                          return ZipReturn.ZipLocalFileHeaderError;                            uint tUnCompressedSize = br.ReadUInt32();                      if (Zip64 && tUnCompressedSize != 0xffffffff && tUnCompressedSize != UncompressedSize)   // if Zip64 File then the unCompressedSize should be 0xffffffff                          return ZipReturn.ZipLocalFileHeaderError;                      if ((_generalPurposeBitFlag & 8) == 8 && tUnCompressedSize != 0)   // if bit 4 set then no unCompressedSize is set yet                          return ZipReturn.ZipLocalFileHeaderError;                      if (!Zip64 && (_generalPurposeBitFlag & 8) != 8 && tUnCompressedSize != UncompressedSize) // check the unCompressedSize                          return ZipReturn.ZipLocalFileHeaderError;                        ushort fileNameLength = br.ReadUInt16();                      ushort extraFieldLength = br.ReadUInt16();                          byte[] bFileName = br.ReadBytes(fileNameLength);                      string tFileName = (generalPurposeBitFlagLocal & (1 << 11)) == 0 ?                          GetString(bFileName) :                          Encoding.UTF8.GetString(bFileName' 0' fileNameLength);                        byte[] extraField = br.ReadBytes(extraFieldLength);                          Zip64 = false;                      int pos = 0;                      while (extraFieldLength > pos)                      {                          ushort type = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          ushort blockLength = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          switch (type)                          {                              case 0x0001:                                  Zip64 = true;                                  if (tUnCompressedSize == 0xffffffff)                                  {                                      ulong tLong = BitConverter.ToUInt64(extraField' pos);                                      if (tLong != UncompressedSize) return ZipReturn.ZipLocalFileHeaderError;                                      pos += 8;                                  }                                  if (tCompressedSize == 0xffffffff)                                  {                                      ulong tLong = BitConverter.ToUInt64(extraField' pos);                                      if (tLong != _compressedSize) return ZipReturn.ZipLocalFileHeaderError;                                      pos += 8;                                  }                                  break;                              case 0x7075:                                  //byte version = extraField[pos];                                  pos += 1;                                  uint nameCRC32 = BitConverter.ToUInt32(extraField' pos);                                  pos += 4;                                    CRC32 crcTest = new CRC32();                                  crcTest.SlurpBlock(bFileName' 0' fileNameLength);                                  uint fCRC = crcTest.Crc32ResultU;                                    if (nameCRC32 != fCRC) return ZipReturn.ZipLocalFileHeaderError;                                    int charLen = blockLength - 5;                                    tFileName = Encoding.UTF8.GetString(extraField' pos' charLen);                                  pos += charLen;                                    break;                              default:                                  pos += blockLength;                                  break;                          }                      }                        if (!CompareString(FileName' tFileName)) return ZipReturn.ZipLocalFileHeaderError;                        _dataLocation = (ulong)_zipFs.Position;                        if ((_generalPurposeBitFlag & 8) == 0) return ZipReturn.ZipGood;                        _zipFs.Position += (long)_compressedSize;                        tCRC = ReadCRC(br);                      if (!ByteArrCompare(tCRC' new byte[] { 0x50' 0x4b' 0x07' 0x08 }))                          tCRC = ReadCRC(br);                        if (!ByteArrCompare(tCRC' CRC)) return ZipReturn.ZipLocalFileHeaderError;                        uint tint = br.ReadUInt32();                      if (tint != _compressedSize) return ZipReturn.ZipLocalFileHeaderError;                        tint = br.ReadUInt32();                      if (tint != UncompressedSize) return ZipReturn.ZipLocalFileHeaderError;                        return ZipReturn.ZipGood;                  }                  catch                  {                      return ZipReturn.ZipLocalFileHeaderError;                  }
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,LocalFileHeaderRead,The following statement contains a magic number: try                  {                      TrrntZip = true;                        BinaryReader br = new BinaryReader(_zipFs);                        _zipFs.Position = (long)RelativeOffsetOfLocalHeader;                      uint thisSignature = br.ReadUInt32();                      if (thisSignature != LocalFileHeaderSignature)                          return ZipReturn.ZipLocalFileHeaderError;                        br.ReadUInt16();  // version needed to extract                      ushort generalPurposeBitFlagLocal = br.ReadUInt16();                      if (generalPurposeBitFlagLocal != _generalPurposeBitFlag) TrrntZip = false;                        ushort tshort = br.ReadUInt16();                      if (tshort != _compressionMethod) return ZipReturn.ZipLocalFileHeaderError;                        tshort = br.ReadUInt16();                      if (tshort != _lastModFileTime) return ZipReturn.ZipLocalFileHeaderError;                        tshort = br.ReadUInt16();                      if (tshort != _lastModFileDate) return ZipReturn.ZipLocalFileHeaderError;                        byte[] tCRC = ReadCRC(br);                      if (((_generalPurposeBitFlag & 8) == 0) && !ByteArrCompare(tCRC' CRC)) return ZipReturn.ZipLocalFileHeaderError;                        uint tCompressedSize = br.ReadUInt32();                      if (Zip64 && tCompressedSize != 0xffffffff && tCompressedSize != _compressedSize)   // if Zip64 File then the compressedSize should be 0xffffffff                          return ZipReturn.ZipLocalFileHeaderError;                      if ((_generalPurposeBitFlag & 8) == 8 && tCompressedSize != 0)   // if bit 4 set then no compressedSize is set yet                          return ZipReturn.ZipLocalFileHeaderError;                      if (!Zip64 && (_generalPurposeBitFlag & 8) != 8 && tCompressedSize != _compressedSize) // check the compressedSize                          return ZipReturn.ZipLocalFileHeaderError;                            uint tUnCompressedSize = br.ReadUInt32();                      if (Zip64 && tUnCompressedSize != 0xffffffff && tUnCompressedSize != UncompressedSize)   // if Zip64 File then the unCompressedSize should be 0xffffffff                          return ZipReturn.ZipLocalFileHeaderError;                      if ((_generalPurposeBitFlag & 8) == 8 && tUnCompressedSize != 0)   // if bit 4 set then no unCompressedSize is set yet                          return ZipReturn.ZipLocalFileHeaderError;                      if (!Zip64 && (_generalPurposeBitFlag & 8) != 8 && tUnCompressedSize != UncompressedSize) // check the unCompressedSize                          return ZipReturn.ZipLocalFileHeaderError;                        ushort fileNameLength = br.ReadUInt16();                      ushort extraFieldLength = br.ReadUInt16();                          byte[] bFileName = br.ReadBytes(fileNameLength);                      string tFileName = (generalPurposeBitFlagLocal & (1 << 11)) == 0 ?                          GetString(bFileName) :                          Encoding.UTF8.GetString(bFileName' 0' fileNameLength);                        byte[] extraField = br.ReadBytes(extraFieldLength);                          Zip64 = false;                      int pos = 0;                      while (extraFieldLength > pos)                      {                          ushort type = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          ushort blockLength = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          switch (type)                          {                              case 0x0001:                                  Zip64 = true;                                  if (tUnCompressedSize == 0xffffffff)                                  {                                      ulong tLong = BitConverter.ToUInt64(extraField' pos);                                      if (tLong != UncompressedSize) return ZipReturn.ZipLocalFileHeaderError;                                      pos += 8;                                  }                                  if (tCompressedSize == 0xffffffff)                                  {                                      ulong tLong = BitConverter.ToUInt64(extraField' pos);                                      if (tLong != _compressedSize) return ZipReturn.ZipLocalFileHeaderError;                                      pos += 8;                                  }                                  break;                              case 0x7075:                                  //byte version = extraField[pos];                                  pos += 1;                                  uint nameCRC32 = BitConverter.ToUInt32(extraField' pos);                                  pos += 4;                                    CRC32 crcTest = new CRC32();                                  crcTest.SlurpBlock(bFileName' 0' fileNameLength);                                  uint fCRC = crcTest.Crc32ResultU;                                    if (nameCRC32 != fCRC) return ZipReturn.ZipLocalFileHeaderError;                                    int charLen = blockLength - 5;                                    tFileName = Encoding.UTF8.GetString(extraField' pos' charLen);                                  pos += charLen;                                    break;                              default:                                  pos += blockLength;                                  break;                          }                      }                        if (!CompareString(FileName' tFileName)) return ZipReturn.ZipLocalFileHeaderError;                        _dataLocation = (ulong)_zipFs.Position;                        if ((_generalPurposeBitFlag & 8) == 0) return ZipReturn.ZipGood;                        _zipFs.Position += (long)_compressedSize;                        tCRC = ReadCRC(br);                      if (!ByteArrCompare(tCRC' new byte[] { 0x50' 0x4b' 0x07' 0x08 }))                          tCRC = ReadCRC(br);                        if (!ByteArrCompare(tCRC' CRC)) return ZipReturn.ZipLocalFileHeaderError;                        uint tint = br.ReadUInt32();                      if (tint != _compressedSize) return ZipReturn.ZipLocalFileHeaderError;                        tint = br.ReadUInt32();                      if (tint != UncompressedSize) return ZipReturn.ZipLocalFileHeaderError;                        return ZipReturn.ZipGood;                  }                  catch                  {                      return ZipReturn.ZipLocalFileHeaderError;                  }
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,LocalFileHeaderRead,The following statement contains a magic number: try                  {                      TrrntZip = true;                        BinaryReader br = new BinaryReader(_zipFs);                        _zipFs.Position = (long)RelativeOffsetOfLocalHeader;                      uint thisSignature = br.ReadUInt32();                      if (thisSignature != LocalFileHeaderSignature)                          return ZipReturn.ZipLocalFileHeaderError;                        br.ReadUInt16();  // version needed to extract                      ushort generalPurposeBitFlagLocal = br.ReadUInt16();                      if (generalPurposeBitFlagLocal != _generalPurposeBitFlag) TrrntZip = false;                        ushort tshort = br.ReadUInt16();                      if (tshort != _compressionMethod) return ZipReturn.ZipLocalFileHeaderError;                        tshort = br.ReadUInt16();                      if (tshort != _lastModFileTime) return ZipReturn.ZipLocalFileHeaderError;                        tshort = br.ReadUInt16();                      if (tshort != _lastModFileDate) return ZipReturn.ZipLocalFileHeaderError;                        byte[] tCRC = ReadCRC(br);                      if (((_generalPurposeBitFlag & 8) == 0) && !ByteArrCompare(tCRC' CRC)) return ZipReturn.ZipLocalFileHeaderError;                        uint tCompressedSize = br.ReadUInt32();                      if (Zip64 && tCompressedSize != 0xffffffff && tCompressedSize != _compressedSize)   // if Zip64 File then the compressedSize should be 0xffffffff                          return ZipReturn.ZipLocalFileHeaderError;                      if ((_generalPurposeBitFlag & 8) == 8 && tCompressedSize != 0)   // if bit 4 set then no compressedSize is set yet                          return ZipReturn.ZipLocalFileHeaderError;                      if (!Zip64 && (_generalPurposeBitFlag & 8) != 8 && tCompressedSize != _compressedSize) // check the compressedSize                          return ZipReturn.ZipLocalFileHeaderError;                            uint tUnCompressedSize = br.ReadUInt32();                      if (Zip64 && tUnCompressedSize != 0xffffffff && tUnCompressedSize != UncompressedSize)   // if Zip64 File then the unCompressedSize should be 0xffffffff                          return ZipReturn.ZipLocalFileHeaderError;                      if ((_generalPurposeBitFlag & 8) == 8 && tUnCompressedSize != 0)   // if bit 4 set then no unCompressedSize is set yet                          return ZipReturn.ZipLocalFileHeaderError;                      if (!Zip64 && (_generalPurposeBitFlag & 8) != 8 && tUnCompressedSize != UncompressedSize) // check the unCompressedSize                          return ZipReturn.ZipLocalFileHeaderError;                        ushort fileNameLength = br.ReadUInt16();                      ushort extraFieldLength = br.ReadUInt16();                          byte[] bFileName = br.ReadBytes(fileNameLength);                      string tFileName = (generalPurposeBitFlagLocal & (1 << 11)) == 0 ?                          GetString(bFileName) :                          Encoding.UTF8.GetString(bFileName' 0' fileNameLength);                        byte[] extraField = br.ReadBytes(extraFieldLength);                          Zip64 = false;                      int pos = 0;                      while (extraFieldLength > pos)                      {                          ushort type = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          ushort blockLength = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          switch (type)                          {                              case 0x0001:                                  Zip64 = true;                                  if (tUnCompressedSize == 0xffffffff)                                  {                                      ulong tLong = BitConverter.ToUInt64(extraField' pos);                                      if (tLong != UncompressedSize) return ZipReturn.ZipLocalFileHeaderError;                                      pos += 8;                                  }                                  if (tCompressedSize == 0xffffffff)                                  {                                      ulong tLong = BitConverter.ToUInt64(extraField' pos);                                      if (tLong != _compressedSize) return ZipReturn.ZipLocalFileHeaderError;                                      pos += 8;                                  }                                  break;                              case 0x7075:                                  //byte version = extraField[pos];                                  pos += 1;                                  uint nameCRC32 = BitConverter.ToUInt32(extraField' pos);                                  pos += 4;                                    CRC32 crcTest = new CRC32();                                  crcTest.SlurpBlock(bFileName' 0' fileNameLength);                                  uint fCRC = crcTest.Crc32ResultU;                                    if (nameCRC32 != fCRC) return ZipReturn.ZipLocalFileHeaderError;                                    int charLen = blockLength - 5;                                    tFileName = Encoding.UTF8.GetString(extraField' pos' charLen);                                  pos += charLen;                                    break;                              default:                                  pos += blockLength;                                  break;                          }                      }                        if (!CompareString(FileName' tFileName)) return ZipReturn.ZipLocalFileHeaderError;                        _dataLocation = (ulong)_zipFs.Position;                        if ((_generalPurposeBitFlag & 8) == 0) return ZipReturn.ZipGood;                        _zipFs.Position += (long)_compressedSize;                        tCRC = ReadCRC(br);                      if (!ByteArrCompare(tCRC' new byte[] { 0x50' 0x4b' 0x07' 0x08 }))                          tCRC = ReadCRC(br);                        if (!ByteArrCompare(tCRC' CRC)) return ZipReturn.ZipLocalFileHeaderError;                        uint tint = br.ReadUInt32();                      if (tint != _compressedSize) return ZipReturn.ZipLocalFileHeaderError;                        tint = br.ReadUInt32();                      if (tint != UncompressedSize) return ZipReturn.ZipLocalFileHeaderError;                        return ZipReturn.ZipGood;                  }                  catch                  {                      return ZipReturn.ZipLocalFileHeaderError;                  }
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,LocalFileHeaderRead,The following statement contains a magic number: try                  {                      TrrntZip = true;                        BinaryReader br = new BinaryReader(_zipFs);                        _zipFs.Position = (long)RelativeOffsetOfLocalHeader;                      uint thisSignature = br.ReadUInt32();                      if (thisSignature != LocalFileHeaderSignature)                          return ZipReturn.ZipLocalFileHeaderError;                        br.ReadUInt16();  // version needed to extract                      ushort generalPurposeBitFlagLocal = br.ReadUInt16();                      if (generalPurposeBitFlagLocal != _generalPurposeBitFlag) TrrntZip = false;                        ushort tshort = br.ReadUInt16();                      if (tshort != _compressionMethod) return ZipReturn.ZipLocalFileHeaderError;                        tshort = br.ReadUInt16();                      if (tshort != _lastModFileTime) return ZipReturn.ZipLocalFileHeaderError;                        tshort = br.ReadUInt16();                      if (tshort != _lastModFileDate) return ZipReturn.ZipLocalFileHeaderError;                        byte[] tCRC = ReadCRC(br);                      if (((_generalPurposeBitFlag & 8) == 0) && !ByteArrCompare(tCRC' CRC)) return ZipReturn.ZipLocalFileHeaderError;                        uint tCompressedSize = br.ReadUInt32();                      if (Zip64 && tCompressedSize != 0xffffffff && tCompressedSize != _compressedSize)   // if Zip64 File then the compressedSize should be 0xffffffff                          return ZipReturn.ZipLocalFileHeaderError;                      if ((_generalPurposeBitFlag & 8) == 8 && tCompressedSize != 0)   // if bit 4 set then no compressedSize is set yet                          return ZipReturn.ZipLocalFileHeaderError;                      if (!Zip64 && (_generalPurposeBitFlag & 8) != 8 && tCompressedSize != _compressedSize) // check the compressedSize                          return ZipReturn.ZipLocalFileHeaderError;                            uint tUnCompressedSize = br.ReadUInt32();                      if (Zip64 && tUnCompressedSize != 0xffffffff && tUnCompressedSize != UncompressedSize)   // if Zip64 File then the unCompressedSize should be 0xffffffff                          return ZipReturn.ZipLocalFileHeaderError;                      if ((_generalPurposeBitFlag & 8) == 8 && tUnCompressedSize != 0)   // if bit 4 set then no unCompressedSize is set yet                          return ZipReturn.ZipLocalFileHeaderError;                      if (!Zip64 && (_generalPurposeBitFlag & 8) != 8 && tUnCompressedSize != UncompressedSize) // check the unCompressedSize                          return ZipReturn.ZipLocalFileHeaderError;                        ushort fileNameLength = br.ReadUInt16();                      ushort extraFieldLength = br.ReadUInt16();                          byte[] bFileName = br.ReadBytes(fileNameLength);                      string tFileName = (generalPurposeBitFlagLocal & (1 << 11)) == 0 ?                          GetString(bFileName) :                          Encoding.UTF8.GetString(bFileName' 0' fileNameLength);                        byte[] extraField = br.ReadBytes(extraFieldLength);                          Zip64 = false;                      int pos = 0;                      while (extraFieldLength > pos)                      {                          ushort type = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          ushort blockLength = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          switch (type)                          {                              case 0x0001:                                  Zip64 = true;                                  if (tUnCompressedSize == 0xffffffff)                                  {                                      ulong tLong = BitConverter.ToUInt64(extraField' pos);                                      if (tLong != UncompressedSize) return ZipReturn.ZipLocalFileHeaderError;                                      pos += 8;                                  }                                  if (tCompressedSize == 0xffffffff)                                  {                                      ulong tLong = BitConverter.ToUInt64(extraField' pos);                                      if (tLong != _compressedSize) return ZipReturn.ZipLocalFileHeaderError;                                      pos += 8;                                  }                                  break;                              case 0x7075:                                  //byte version = extraField[pos];                                  pos += 1;                                  uint nameCRC32 = BitConverter.ToUInt32(extraField' pos);                                  pos += 4;                                    CRC32 crcTest = new CRC32();                                  crcTest.SlurpBlock(bFileName' 0' fileNameLength);                                  uint fCRC = crcTest.Crc32ResultU;                                    if (nameCRC32 != fCRC) return ZipReturn.ZipLocalFileHeaderError;                                    int charLen = blockLength - 5;                                    tFileName = Encoding.UTF8.GetString(extraField' pos' charLen);                                  pos += charLen;                                    break;                              default:                                  pos += blockLength;                                  break;                          }                      }                        if (!CompareString(FileName' tFileName)) return ZipReturn.ZipLocalFileHeaderError;                        _dataLocation = (ulong)_zipFs.Position;                        if ((_generalPurposeBitFlag & 8) == 0) return ZipReturn.ZipGood;                        _zipFs.Position += (long)_compressedSize;                        tCRC = ReadCRC(br);                      if (!ByteArrCompare(tCRC' new byte[] { 0x50' 0x4b' 0x07' 0x08 }))                          tCRC = ReadCRC(br);                        if (!ByteArrCompare(tCRC' CRC)) return ZipReturn.ZipLocalFileHeaderError;                        uint tint = br.ReadUInt32();                      if (tint != _compressedSize) return ZipReturn.ZipLocalFileHeaderError;                        tint = br.ReadUInt32();                      if (tint != UncompressedSize) return ZipReturn.ZipLocalFileHeaderError;                        return ZipReturn.ZipGood;                  }                  catch                  {                      return ZipReturn.ZipLocalFileHeaderError;                  }
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,LocalFileHeaderRead,The following statement contains a magic number: try                  {                      TrrntZip = true;                        BinaryReader br = new BinaryReader(_zipFs);                        _zipFs.Position = (long)RelativeOffsetOfLocalHeader;                      uint thisSignature = br.ReadUInt32();                      if (thisSignature != LocalFileHeaderSignature)                          return ZipReturn.ZipLocalFileHeaderError;                        br.ReadUInt16();  // version needed to extract                      ushort generalPurposeBitFlagLocal = br.ReadUInt16();                      if (generalPurposeBitFlagLocal != _generalPurposeBitFlag) TrrntZip = false;                        ushort tshort = br.ReadUInt16();                      if (tshort != _compressionMethod) return ZipReturn.ZipLocalFileHeaderError;                        tshort = br.ReadUInt16();                      if (tshort != _lastModFileTime) return ZipReturn.ZipLocalFileHeaderError;                        tshort = br.ReadUInt16();                      if (tshort != _lastModFileDate) return ZipReturn.ZipLocalFileHeaderError;                        byte[] tCRC = ReadCRC(br);                      if (((_generalPurposeBitFlag & 8) == 0) && !ByteArrCompare(tCRC' CRC)) return ZipReturn.ZipLocalFileHeaderError;                        uint tCompressedSize = br.ReadUInt32();                      if (Zip64 && tCompressedSize != 0xffffffff && tCompressedSize != _compressedSize)   // if Zip64 File then the compressedSize should be 0xffffffff                          return ZipReturn.ZipLocalFileHeaderError;                      if ((_generalPurposeBitFlag & 8) == 8 && tCompressedSize != 0)   // if bit 4 set then no compressedSize is set yet                          return ZipReturn.ZipLocalFileHeaderError;                      if (!Zip64 && (_generalPurposeBitFlag & 8) != 8 && tCompressedSize != _compressedSize) // check the compressedSize                          return ZipReturn.ZipLocalFileHeaderError;                            uint tUnCompressedSize = br.ReadUInt32();                      if (Zip64 && tUnCompressedSize != 0xffffffff && tUnCompressedSize != UncompressedSize)   // if Zip64 File then the unCompressedSize should be 0xffffffff                          return ZipReturn.ZipLocalFileHeaderError;                      if ((_generalPurposeBitFlag & 8) == 8 && tUnCompressedSize != 0)   // if bit 4 set then no unCompressedSize is set yet                          return ZipReturn.ZipLocalFileHeaderError;                      if (!Zip64 && (_generalPurposeBitFlag & 8) != 8 && tUnCompressedSize != UncompressedSize) // check the unCompressedSize                          return ZipReturn.ZipLocalFileHeaderError;                        ushort fileNameLength = br.ReadUInt16();                      ushort extraFieldLength = br.ReadUInt16();                          byte[] bFileName = br.ReadBytes(fileNameLength);                      string tFileName = (generalPurposeBitFlagLocal & (1 << 11)) == 0 ?                          GetString(bFileName) :                          Encoding.UTF8.GetString(bFileName' 0' fileNameLength);                        byte[] extraField = br.ReadBytes(extraFieldLength);                          Zip64 = false;                      int pos = 0;                      while (extraFieldLength > pos)                      {                          ushort type = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          ushort blockLength = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          switch (type)                          {                              case 0x0001:                                  Zip64 = true;                                  if (tUnCompressedSize == 0xffffffff)                                  {                                      ulong tLong = BitConverter.ToUInt64(extraField' pos);                                      if (tLong != UncompressedSize) return ZipReturn.ZipLocalFileHeaderError;                                      pos += 8;                                  }                                  if (tCompressedSize == 0xffffffff)                                  {                                      ulong tLong = BitConverter.ToUInt64(extraField' pos);                                      if (tLong != _compressedSize) return ZipReturn.ZipLocalFileHeaderError;                                      pos += 8;                                  }                                  break;                              case 0x7075:                                  //byte version = extraField[pos];                                  pos += 1;                                  uint nameCRC32 = BitConverter.ToUInt32(extraField' pos);                                  pos += 4;                                    CRC32 crcTest = new CRC32();                                  crcTest.SlurpBlock(bFileName' 0' fileNameLength);                                  uint fCRC = crcTest.Crc32ResultU;                                    if (nameCRC32 != fCRC) return ZipReturn.ZipLocalFileHeaderError;                                    int charLen = blockLength - 5;                                    tFileName = Encoding.UTF8.GetString(extraField' pos' charLen);                                  pos += charLen;                                    break;                              default:                                  pos += blockLength;                                  break;                          }                      }                        if (!CompareString(FileName' tFileName)) return ZipReturn.ZipLocalFileHeaderError;                        _dataLocation = (ulong)_zipFs.Position;                        if ((_generalPurposeBitFlag & 8) == 0) return ZipReturn.ZipGood;                        _zipFs.Position += (long)_compressedSize;                        tCRC = ReadCRC(br);                      if (!ByteArrCompare(tCRC' new byte[] { 0x50' 0x4b' 0x07' 0x08 }))                          tCRC = ReadCRC(br);                        if (!ByteArrCompare(tCRC' CRC)) return ZipReturn.ZipLocalFileHeaderError;                        uint tint = br.ReadUInt32();                      if (tint != _compressedSize) return ZipReturn.ZipLocalFileHeaderError;                        tint = br.ReadUInt32();                      if (tint != UncompressedSize) return ZipReturn.ZipLocalFileHeaderError;                        return ZipReturn.ZipGood;                  }                  catch                  {                      return ZipReturn.ZipLocalFileHeaderError;                  }
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,LocalFileHeaderReadQuick,The following statement contains a magic number: try                  {                      TrrntZip = true;                        BinaryReader br = new BinaryReader(_zipFs);                        _zipFs.Position = (long)RelativeOffsetOfLocalHeader;                      uint thisSignature = br.ReadUInt32();                      if (thisSignature != LocalFileHeaderSignature)                          return ZipReturn.ZipLocalFileHeaderError;                        br.ReadUInt16();  // version needed to extract                      _generalPurposeBitFlag = br.ReadUInt16();                      if ((_generalPurposeBitFlag & 8) == 8)                          return ZipReturn.ZipCannotFastOpen;                        _compressionMethod = br.ReadUInt16();                      _lastModFileTime = br.ReadUInt16();                      _lastModFileDate = br.ReadUInt16();                      CRC = ReadCRC(br);                      _compressedSize = br.ReadUInt32();                      UncompressedSize = br.ReadUInt32();                        ushort fileNameLength = br.ReadUInt16();                      ushort extraFieldLength = br.ReadUInt16();                        byte[] bFileName = br.ReadBytes(fileNameLength);                        FileName = (_generalPurposeBitFlag & (1 << 11)) == 0 ?                          GetString(bFileName) :                          Encoding.UTF8.GetString(bFileName' 0' fileNameLength);                        byte[] extraField = br.ReadBytes(extraFieldLength);                        Zip64 = false;                      int pos = 0;                      while (extraFieldLength > pos)                      {                          ushort type = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          ushort blockLength = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          switch (type)                          {                              case 0x0001:                                  Zip64 = true;                                  if (UncompressedSize == 0xffffffff)                                  {                                      UncompressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  if (_compressedSize == 0xffffffff)                                  {                                      _compressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  break;                              case 0x7075:                                  pos += 1;                                  uint nameCRC32 = BitConverter.ToUInt32(extraField' pos);                                  pos += 4;                                    CRC32 crcTest = new CRC32();                                  crcTest.SlurpBlock(bFileName' 0' fileNameLength);                                  uint fCRC = crcTest.Crc32ResultU;                                    if (nameCRC32 != fCRC) return ZipReturn.ZipLocalFileHeaderError;                                    int charLen = blockLength - 5;                                    FileName = Encoding.UTF8.GetString(extraField' pos' charLen);                                    pos += charLen;                                    break;                              default:                                  pos += blockLength;                                  break;                          }                      }                        _dataLocation = (ulong)_zipFs.Position;                      return ZipReturn.ZipGood;                    }                  catch                  {                      return ZipReturn.ZipLocalFileHeaderError;                  }
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,LocalFileHeaderReadQuick,The following statement contains a magic number: try                  {                      TrrntZip = true;                        BinaryReader br = new BinaryReader(_zipFs);                        _zipFs.Position = (long)RelativeOffsetOfLocalHeader;                      uint thisSignature = br.ReadUInt32();                      if (thisSignature != LocalFileHeaderSignature)                          return ZipReturn.ZipLocalFileHeaderError;                        br.ReadUInt16();  // version needed to extract                      _generalPurposeBitFlag = br.ReadUInt16();                      if ((_generalPurposeBitFlag & 8) == 8)                          return ZipReturn.ZipCannotFastOpen;                        _compressionMethod = br.ReadUInt16();                      _lastModFileTime = br.ReadUInt16();                      _lastModFileDate = br.ReadUInt16();                      CRC = ReadCRC(br);                      _compressedSize = br.ReadUInt32();                      UncompressedSize = br.ReadUInt32();                        ushort fileNameLength = br.ReadUInt16();                      ushort extraFieldLength = br.ReadUInt16();                        byte[] bFileName = br.ReadBytes(fileNameLength);                        FileName = (_generalPurposeBitFlag & (1 << 11)) == 0 ?                          GetString(bFileName) :                          Encoding.UTF8.GetString(bFileName' 0' fileNameLength);                        byte[] extraField = br.ReadBytes(extraFieldLength);                        Zip64 = false;                      int pos = 0;                      while (extraFieldLength > pos)                      {                          ushort type = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          ushort blockLength = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          switch (type)                          {                              case 0x0001:                                  Zip64 = true;                                  if (UncompressedSize == 0xffffffff)                                  {                                      UncompressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  if (_compressedSize == 0xffffffff)                                  {                                      _compressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  break;                              case 0x7075:                                  pos += 1;                                  uint nameCRC32 = BitConverter.ToUInt32(extraField' pos);                                  pos += 4;                                    CRC32 crcTest = new CRC32();                                  crcTest.SlurpBlock(bFileName' 0' fileNameLength);                                  uint fCRC = crcTest.Crc32ResultU;                                    if (nameCRC32 != fCRC) return ZipReturn.ZipLocalFileHeaderError;                                    int charLen = blockLength - 5;                                    FileName = Encoding.UTF8.GetString(extraField' pos' charLen);                                    pos += charLen;                                    break;                              default:                                  pos += blockLength;                                  break;                          }                      }                        _dataLocation = (ulong)_zipFs.Position;                      return ZipReturn.ZipGood;                    }                  catch                  {                      return ZipReturn.ZipLocalFileHeaderError;                  }
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,LocalFileHeaderReadQuick,The following statement contains a magic number: try                  {                      TrrntZip = true;                        BinaryReader br = new BinaryReader(_zipFs);                        _zipFs.Position = (long)RelativeOffsetOfLocalHeader;                      uint thisSignature = br.ReadUInt32();                      if (thisSignature != LocalFileHeaderSignature)                          return ZipReturn.ZipLocalFileHeaderError;                        br.ReadUInt16();  // version needed to extract                      _generalPurposeBitFlag = br.ReadUInt16();                      if ((_generalPurposeBitFlag & 8) == 8)                          return ZipReturn.ZipCannotFastOpen;                        _compressionMethod = br.ReadUInt16();                      _lastModFileTime = br.ReadUInt16();                      _lastModFileDate = br.ReadUInt16();                      CRC = ReadCRC(br);                      _compressedSize = br.ReadUInt32();                      UncompressedSize = br.ReadUInt32();                        ushort fileNameLength = br.ReadUInt16();                      ushort extraFieldLength = br.ReadUInt16();                        byte[] bFileName = br.ReadBytes(fileNameLength);                        FileName = (_generalPurposeBitFlag & (1 << 11)) == 0 ?                          GetString(bFileName) :                          Encoding.UTF8.GetString(bFileName' 0' fileNameLength);                        byte[] extraField = br.ReadBytes(extraFieldLength);                        Zip64 = false;                      int pos = 0;                      while (extraFieldLength > pos)                      {                          ushort type = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          ushort blockLength = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          switch (type)                          {                              case 0x0001:                                  Zip64 = true;                                  if (UncompressedSize == 0xffffffff)                                  {                                      UncompressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  if (_compressedSize == 0xffffffff)                                  {                                      _compressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  break;                              case 0x7075:                                  pos += 1;                                  uint nameCRC32 = BitConverter.ToUInt32(extraField' pos);                                  pos += 4;                                    CRC32 crcTest = new CRC32();                                  crcTest.SlurpBlock(bFileName' 0' fileNameLength);                                  uint fCRC = crcTest.Crc32ResultU;                                    if (nameCRC32 != fCRC) return ZipReturn.ZipLocalFileHeaderError;                                    int charLen = blockLength - 5;                                    FileName = Encoding.UTF8.GetString(extraField' pos' charLen);                                    pos += charLen;                                    break;                              default:                                  pos += blockLength;                                  break;                          }                      }                        _dataLocation = (ulong)_zipFs.Position;                      return ZipReturn.ZipGood;                    }                  catch                  {                      return ZipReturn.ZipLocalFileHeaderError;                  }
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,LocalFileHeaderReadQuick,The following statement contains a magic number: try                  {                      TrrntZip = true;                        BinaryReader br = new BinaryReader(_zipFs);                        _zipFs.Position = (long)RelativeOffsetOfLocalHeader;                      uint thisSignature = br.ReadUInt32();                      if (thisSignature != LocalFileHeaderSignature)                          return ZipReturn.ZipLocalFileHeaderError;                        br.ReadUInt16();  // version needed to extract                      _generalPurposeBitFlag = br.ReadUInt16();                      if ((_generalPurposeBitFlag & 8) == 8)                          return ZipReturn.ZipCannotFastOpen;                        _compressionMethod = br.ReadUInt16();                      _lastModFileTime = br.ReadUInt16();                      _lastModFileDate = br.ReadUInt16();                      CRC = ReadCRC(br);                      _compressedSize = br.ReadUInt32();                      UncompressedSize = br.ReadUInt32();                        ushort fileNameLength = br.ReadUInt16();                      ushort extraFieldLength = br.ReadUInt16();                        byte[] bFileName = br.ReadBytes(fileNameLength);                        FileName = (_generalPurposeBitFlag & (1 << 11)) == 0 ?                          GetString(bFileName) :                          Encoding.UTF8.GetString(bFileName' 0' fileNameLength);                        byte[] extraField = br.ReadBytes(extraFieldLength);                        Zip64 = false;                      int pos = 0;                      while (extraFieldLength > pos)                      {                          ushort type = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          ushort blockLength = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          switch (type)                          {                              case 0x0001:                                  Zip64 = true;                                  if (UncompressedSize == 0xffffffff)                                  {                                      UncompressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  if (_compressedSize == 0xffffffff)                                  {                                      _compressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  break;                              case 0x7075:                                  pos += 1;                                  uint nameCRC32 = BitConverter.ToUInt32(extraField' pos);                                  pos += 4;                                    CRC32 crcTest = new CRC32();                                  crcTest.SlurpBlock(bFileName' 0' fileNameLength);                                  uint fCRC = crcTest.Crc32ResultU;                                    if (nameCRC32 != fCRC) return ZipReturn.ZipLocalFileHeaderError;                                    int charLen = blockLength - 5;                                    FileName = Encoding.UTF8.GetString(extraField' pos' charLen);                                    pos += charLen;                                    break;                              default:                                  pos += blockLength;                                  break;                          }                      }                        _dataLocation = (ulong)_zipFs.Position;                      return ZipReturn.ZipGood;                    }                  catch                  {                      return ZipReturn.ZipLocalFileHeaderError;                  }
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,LocalFileHeaderReadQuick,The following statement contains a magic number: try                  {                      TrrntZip = true;                        BinaryReader br = new BinaryReader(_zipFs);                        _zipFs.Position = (long)RelativeOffsetOfLocalHeader;                      uint thisSignature = br.ReadUInt32();                      if (thisSignature != LocalFileHeaderSignature)                          return ZipReturn.ZipLocalFileHeaderError;                        br.ReadUInt16();  // version needed to extract                      _generalPurposeBitFlag = br.ReadUInt16();                      if ((_generalPurposeBitFlag & 8) == 8)                          return ZipReturn.ZipCannotFastOpen;                        _compressionMethod = br.ReadUInt16();                      _lastModFileTime = br.ReadUInt16();                      _lastModFileDate = br.ReadUInt16();                      CRC = ReadCRC(br);                      _compressedSize = br.ReadUInt32();                      UncompressedSize = br.ReadUInt32();                        ushort fileNameLength = br.ReadUInt16();                      ushort extraFieldLength = br.ReadUInt16();                        byte[] bFileName = br.ReadBytes(fileNameLength);                        FileName = (_generalPurposeBitFlag & (1 << 11)) == 0 ?                          GetString(bFileName) :                          Encoding.UTF8.GetString(bFileName' 0' fileNameLength);                        byte[] extraField = br.ReadBytes(extraFieldLength);                        Zip64 = false;                      int pos = 0;                      while (extraFieldLength > pos)                      {                          ushort type = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          ushort blockLength = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          switch (type)                          {                              case 0x0001:                                  Zip64 = true;                                  if (UncompressedSize == 0xffffffff)                                  {                                      UncompressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  if (_compressedSize == 0xffffffff)                                  {                                      _compressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  break;                              case 0x7075:                                  pos += 1;                                  uint nameCRC32 = BitConverter.ToUInt32(extraField' pos);                                  pos += 4;                                    CRC32 crcTest = new CRC32();                                  crcTest.SlurpBlock(bFileName' 0' fileNameLength);                                  uint fCRC = crcTest.Crc32ResultU;                                    if (nameCRC32 != fCRC) return ZipReturn.ZipLocalFileHeaderError;                                    int charLen = blockLength - 5;                                    FileName = Encoding.UTF8.GetString(extraField' pos' charLen);                                    pos += charLen;                                    break;                              default:                                  pos += blockLength;                                  break;                          }                      }                        _dataLocation = (ulong)_zipFs.Position;                      return ZipReturn.ZipGood;                    }                  catch                  {                      return ZipReturn.ZipLocalFileHeaderError;                  }
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,LocalFileHeaderReadQuick,The following statement contains a magic number: try                  {                      TrrntZip = true;                        BinaryReader br = new BinaryReader(_zipFs);                        _zipFs.Position = (long)RelativeOffsetOfLocalHeader;                      uint thisSignature = br.ReadUInt32();                      if (thisSignature != LocalFileHeaderSignature)                          return ZipReturn.ZipLocalFileHeaderError;                        br.ReadUInt16();  // version needed to extract                      _generalPurposeBitFlag = br.ReadUInt16();                      if ((_generalPurposeBitFlag & 8) == 8)                          return ZipReturn.ZipCannotFastOpen;                        _compressionMethod = br.ReadUInt16();                      _lastModFileTime = br.ReadUInt16();                      _lastModFileDate = br.ReadUInt16();                      CRC = ReadCRC(br);                      _compressedSize = br.ReadUInt32();                      UncompressedSize = br.ReadUInt32();                        ushort fileNameLength = br.ReadUInt16();                      ushort extraFieldLength = br.ReadUInt16();                        byte[] bFileName = br.ReadBytes(fileNameLength);                        FileName = (_generalPurposeBitFlag & (1 << 11)) == 0 ?                          GetString(bFileName) :                          Encoding.UTF8.GetString(bFileName' 0' fileNameLength);                        byte[] extraField = br.ReadBytes(extraFieldLength);                        Zip64 = false;                      int pos = 0;                      while (extraFieldLength > pos)                      {                          ushort type = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          ushort blockLength = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          switch (type)                          {                              case 0x0001:                                  Zip64 = true;                                  if (UncompressedSize == 0xffffffff)                                  {                                      UncompressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  if (_compressedSize == 0xffffffff)                                  {                                      _compressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  break;                              case 0x7075:                                  pos += 1;                                  uint nameCRC32 = BitConverter.ToUInt32(extraField' pos);                                  pos += 4;                                    CRC32 crcTest = new CRC32();                                  crcTest.SlurpBlock(bFileName' 0' fileNameLength);                                  uint fCRC = crcTest.Crc32ResultU;                                    if (nameCRC32 != fCRC) return ZipReturn.ZipLocalFileHeaderError;                                    int charLen = blockLength - 5;                                    FileName = Encoding.UTF8.GetString(extraField' pos' charLen);                                    pos += charLen;                                    break;                              default:                                  pos += blockLength;                                  break;                          }                      }                        _dataLocation = (ulong)_zipFs.Position;                      return ZipReturn.ZipGood;                    }                  catch                  {                      return ZipReturn.ZipLocalFileHeaderError;                  }
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,LocalFileHeaderReadQuick,The following statement contains a magic number: try                  {                      TrrntZip = true;                        BinaryReader br = new BinaryReader(_zipFs);                        _zipFs.Position = (long)RelativeOffsetOfLocalHeader;                      uint thisSignature = br.ReadUInt32();                      if (thisSignature != LocalFileHeaderSignature)                          return ZipReturn.ZipLocalFileHeaderError;                        br.ReadUInt16();  // version needed to extract                      _generalPurposeBitFlag = br.ReadUInt16();                      if ((_generalPurposeBitFlag & 8) == 8)                          return ZipReturn.ZipCannotFastOpen;                        _compressionMethod = br.ReadUInt16();                      _lastModFileTime = br.ReadUInt16();                      _lastModFileDate = br.ReadUInt16();                      CRC = ReadCRC(br);                      _compressedSize = br.ReadUInt32();                      UncompressedSize = br.ReadUInt32();                        ushort fileNameLength = br.ReadUInt16();                      ushort extraFieldLength = br.ReadUInt16();                        byte[] bFileName = br.ReadBytes(fileNameLength);                        FileName = (_generalPurposeBitFlag & (1 << 11)) == 0 ?                          GetString(bFileName) :                          Encoding.UTF8.GetString(bFileName' 0' fileNameLength);                        byte[] extraField = br.ReadBytes(extraFieldLength);                        Zip64 = false;                      int pos = 0;                      while (extraFieldLength > pos)                      {                          ushort type = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          ushort blockLength = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          switch (type)                          {                              case 0x0001:                                  Zip64 = true;                                  if (UncompressedSize == 0xffffffff)                                  {                                      UncompressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  if (_compressedSize == 0xffffffff)                                  {                                      _compressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  break;                              case 0x7075:                                  pos += 1;                                  uint nameCRC32 = BitConverter.ToUInt32(extraField' pos);                                  pos += 4;                                    CRC32 crcTest = new CRC32();                                  crcTest.SlurpBlock(bFileName' 0' fileNameLength);                                  uint fCRC = crcTest.Crc32ResultU;                                    if (nameCRC32 != fCRC) return ZipReturn.ZipLocalFileHeaderError;                                    int charLen = blockLength - 5;                                    FileName = Encoding.UTF8.GetString(extraField' pos' charLen);                                    pos += charLen;                                    break;                              default:                                  pos += blockLength;                                  break;                          }                      }                        _dataLocation = (ulong)_zipFs.Position;                      return ZipReturn.ZipGood;                    }                  catch                  {                      return ZipReturn.ZipLocalFileHeaderError;                  }
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,LocalFileHeaderReadQuick,The following statement contains a magic number: try                  {                      TrrntZip = true;                        BinaryReader br = new BinaryReader(_zipFs);                        _zipFs.Position = (long)RelativeOffsetOfLocalHeader;                      uint thisSignature = br.ReadUInt32();                      if (thisSignature != LocalFileHeaderSignature)                          return ZipReturn.ZipLocalFileHeaderError;                        br.ReadUInt16();  // version needed to extract                      _generalPurposeBitFlag = br.ReadUInt16();                      if ((_generalPurposeBitFlag & 8) == 8)                          return ZipReturn.ZipCannotFastOpen;                        _compressionMethod = br.ReadUInt16();                      _lastModFileTime = br.ReadUInt16();                      _lastModFileDate = br.ReadUInt16();                      CRC = ReadCRC(br);                      _compressedSize = br.ReadUInt32();                      UncompressedSize = br.ReadUInt32();                        ushort fileNameLength = br.ReadUInt16();                      ushort extraFieldLength = br.ReadUInt16();                        byte[] bFileName = br.ReadBytes(fileNameLength);                        FileName = (_generalPurposeBitFlag & (1 << 11)) == 0 ?                          GetString(bFileName) :                          Encoding.UTF8.GetString(bFileName' 0' fileNameLength);                        byte[] extraField = br.ReadBytes(extraFieldLength);                        Zip64 = false;                      int pos = 0;                      while (extraFieldLength > pos)                      {                          ushort type = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          ushort blockLength = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          switch (type)                          {                              case 0x0001:                                  Zip64 = true;                                  if (UncompressedSize == 0xffffffff)                                  {                                      UncompressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  if (_compressedSize == 0xffffffff)                                  {                                      _compressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  break;                              case 0x7075:                                  pos += 1;                                  uint nameCRC32 = BitConverter.ToUInt32(extraField' pos);                                  pos += 4;                                    CRC32 crcTest = new CRC32();                                  crcTest.SlurpBlock(bFileName' 0' fileNameLength);                                  uint fCRC = crcTest.Crc32ResultU;                                    if (nameCRC32 != fCRC) return ZipReturn.ZipLocalFileHeaderError;                                    int charLen = blockLength - 5;                                    FileName = Encoding.UTF8.GetString(extraField' pos' charLen);                                    pos += charLen;                                    break;                              default:                                  pos += blockLength;                                  break;                          }                      }                        _dataLocation = (ulong)_zipFs.Position;                      return ZipReturn.ZipGood;                    }                  catch                  {                      return ZipReturn.ZipLocalFileHeaderError;                  }
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,LocalFileHeaderReadQuick,The following statement contains a magic number: try                  {                      TrrntZip = true;                        BinaryReader br = new BinaryReader(_zipFs);                        _zipFs.Position = (long)RelativeOffsetOfLocalHeader;                      uint thisSignature = br.ReadUInt32();                      if (thisSignature != LocalFileHeaderSignature)                          return ZipReturn.ZipLocalFileHeaderError;                        br.ReadUInt16();  // version needed to extract                      _generalPurposeBitFlag = br.ReadUInt16();                      if ((_generalPurposeBitFlag & 8) == 8)                          return ZipReturn.ZipCannotFastOpen;                        _compressionMethod = br.ReadUInt16();                      _lastModFileTime = br.ReadUInt16();                      _lastModFileDate = br.ReadUInt16();                      CRC = ReadCRC(br);                      _compressedSize = br.ReadUInt32();                      UncompressedSize = br.ReadUInt32();                        ushort fileNameLength = br.ReadUInt16();                      ushort extraFieldLength = br.ReadUInt16();                        byte[] bFileName = br.ReadBytes(fileNameLength);                        FileName = (_generalPurposeBitFlag & (1 << 11)) == 0 ?                          GetString(bFileName) :                          Encoding.UTF8.GetString(bFileName' 0' fileNameLength);                        byte[] extraField = br.ReadBytes(extraFieldLength);                        Zip64 = false;                      int pos = 0;                      while (extraFieldLength > pos)                      {                          ushort type = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          ushort blockLength = BitConverter.ToUInt16(extraField' pos);                          pos += 2;                          switch (type)                          {                              case 0x0001:                                  Zip64 = true;                                  if (UncompressedSize == 0xffffffff)                                  {                                      UncompressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  if (_compressedSize == 0xffffffff)                                  {                                      _compressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  break;                              case 0x7075:                                  pos += 1;                                  uint nameCRC32 = BitConverter.ToUInt32(extraField' pos);                                  pos += 4;                                    CRC32 crcTest = new CRC32();                                  crcTest.SlurpBlock(bFileName' 0' fileNameLength);                                  uint fCRC = crcTest.Crc32ResultU;                                    if (nameCRC32 != fCRC) return ZipReturn.ZipLocalFileHeaderError;                                    int charLen = blockLength - 5;                                    FileName = Encoding.UTF8.GetString(extraField' pos' charLen);                                    pos += charLen;                                    break;                              default:                                  pos += blockLength;                                  break;                          }                      }                        _dataLocation = (ulong)_zipFs.Position;                      return ZipReturn.ZipGood;                    }                  catch                  {                      return ZipReturn.ZipLocalFileHeaderError;                  }
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,LocalFileHeaderWrite,The following statement contains a magic number: if (IsUnicode(FileName))                  {                      _generalPurposeBitFlag |= 1 << 11;                      bFileName = Encoding.UTF8.GetBytes(FileName);                  }                  else                      bFileName = GetBytes(FileName);
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,LocalFileHeaderWrite,The following statement contains a magic number: ushort versionNeededToExtract = (ushort)(Zip64 ? 45 : 20);
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,LocalFileHeaderWrite,The following statement contains a magic number: ushort versionNeededToExtract = (ushort)(Zip64 ? 45 : 20);
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,LocalFileHeaderWrite,The following statement contains a magic number: if (Zip64)                  {                      for (int i = 0; i < 20; i++)                          extraField.Add(0);                  }
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,LocalFileOpenReadStream,The following statement contains a magic number: switch (_compressionMethod)                  {                      case 8:                          if (raw)                          {                              _readStream = _zipFs;                              streamSize = _compressedSize;                          }                          else                          {                              _readStream = new DeflateStream(_zipFs' CompressionMode.Decompress' true);                              streamSize = UncompressedSize;                            }                          break;                      case 0:                          _readStream = _zipFs;                          streamSize = _compressedSize;  // same as UncompressedSize                          break;                  }
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,WriteCompressedSize,The following statement contains a magic number: bw.Write(CRC[3]);
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,WriteCompressedSize,The following statement contains a magic number: bw.Write(CRC[2]);
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,WriteCompressedSize,The following statement contains a magic number: if (Zip64)                  {                      _zipFs.Seek((long)_extraLocation' SeekOrigin.Begin);                      bw.Write((ushort)0x0001); // id                      bw.Write((ushort)16); // data length                      bw.Write(UncompressedSize);                      bw.Write(_compressedSize);                  }
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,LocalFileCheck,The following statement contains a magic number: try                  {                      Stream sInput = null;                      _zipFs.Seek((long)_dataLocation' SeekOrigin.Begin);                        switch (_compressionMethod)                      {                          case 8:                              sInput = new DeflateStream(_zipFs' CompressionMode.Decompress' true);                              break;                          case 0:                              sInput = _zipFs;                              break;                      }                        if (sInput == null)                      {                          FileStatus = ZipReturn.ZipErrorGettingDataStream;                          return;                      }                          if (_buffer0 == null)                      {                          _buffer0 = new byte[Buffersize];                          _buffer1 = new byte[Buffersize];                      }                        ulong sizetogo = UncompressedSize;                        ThreadLoadBuffer lbuffer = new ThreadLoadBuffer(sInput);                      ThreadCRC tcrc32 = new ThreadCRC();                      ThreadMD5 tmd5 = new ThreadMD5();                      ThreadSHA1 tsha1 = new ThreadSHA1();                        // Pre load the first buffer0                      int sizeNext = sizetogo > Buffersize ? Buffersize : (int)sizetogo;                      sInput.Read(_buffer0' 0' sizeNext);                      int sizebuffer = sizeNext;                      sizetogo -= (ulong)sizeNext;                      bool whichBuffer = true;                        while (sizebuffer > 0 && !lbuffer.errorState)                      {                          sizeNext = sizetogo > Buffersize ? Buffersize : (int)sizetogo;                            if (sizeNext > 0)                              lbuffer.Trigger(whichBuffer ? _buffer1 : _buffer0' sizeNext);                            byte[] buffer = whichBuffer ? _buffer0 : _buffer1;                          tcrc32.Trigger(buffer' sizebuffer);                          tmd5.Trigger(buffer' sizebuffer);                          tsha1.Trigger(buffer' sizebuffer);                            if (sizeNext > 0)                              lbuffer.Wait();                          tcrc32.Wait();                          tmd5.Wait();                          tsha1.Wait();                            sizebuffer = sizeNext;                          sizetogo -= (ulong)sizeNext;                          whichBuffer = !whichBuffer;                      }                        if (lbuffer.errorState)                      {                          if (_compressionMethod == 8)                          {                              sInput.Close();                              sInput.Dispose();                          }                            lbuffer.Dispose();                          tcrc32.Dispose();                          tmd5.Dispose();                          tsha1.Dispose();                          FileStatus = ZipReturn.ZipDecodeError;                          return;                      }                        lbuffer.Finish();                      tcrc32.Finish();                      tmd5.Finish();                      tsha1.Finish();                        byte[] testcrc = tcrc32.Hash;                      md5 = tmd5.Hash;                      sha1 = tsha1.Hash;                        lbuffer.Dispose();                      tcrc32.Dispose();                      tmd5.Dispose();                      tsha1.Dispose();                        if (_compressionMethod == 8)                      {                          sInput.Close();                          sInput.Dispose();                      }                        FileStatus = ByteArrCompare(CRC' testcrc) ? ZipReturn.ZipGood : ZipReturn.ZipCRCDecodeError;                  }                  catch                  {                      FileStatus = ZipReturn.ZipDecodeError;                  }
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,LocalFileCheck,The following statement contains a magic number: try                  {                      Stream sInput = null;                      _zipFs.Seek((long)_dataLocation' SeekOrigin.Begin);                        switch (_compressionMethod)                      {                          case 8:                              sInput = new DeflateStream(_zipFs' CompressionMode.Decompress' true);                              break;                          case 0:                              sInput = _zipFs;                              break;                      }                        if (sInput == null)                      {                          FileStatus = ZipReturn.ZipErrorGettingDataStream;                          return;                      }                          if (_buffer0 == null)                      {                          _buffer0 = new byte[Buffersize];                          _buffer1 = new byte[Buffersize];                      }                        ulong sizetogo = UncompressedSize;                        ThreadLoadBuffer lbuffer = new ThreadLoadBuffer(sInput);                      ThreadCRC tcrc32 = new ThreadCRC();                      ThreadMD5 tmd5 = new ThreadMD5();                      ThreadSHA1 tsha1 = new ThreadSHA1();                        // Pre load the first buffer0                      int sizeNext = sizetogo > Buffersize ? Buffersize : (int)sizetogo;                      sInput.Read(_buffer0' 0' sizeNext);                      int sizebuffer = sizeNext;                      sizetogo -= (ulong)sizeNext;                      bool whichBuffer = true;                        while (sizebuffer > 0 && !lbuffer.errorState)                      {                          sizeNext = sizetogo > Buffersize ? Buffersize : (int)sizetogo;                            if (sizeNext > 0)                              lbuffer.Trigger(whichBuffer ? _buffer1 : _buffer0' sizeNext);                            byte[] buffer = whichBuffer ? _buffer0 : _buffer1;                          tcrc32.Trigger(buffer' sizebuffer);                          tmd5.Trigger(buffer' sizebuffer);                          tsha1.Trigger(buffer' sizebuffer);                            if (sizeNext > 0)                              lbuffer.Wait();                          tcrc32.Wait();                          tmd5.Wait();                          tsha1.Wait();                            sizebuffer = sizeNext;                          sizetogo -= (ulong)sizeNext;                          whichBuffer = !whichBuffer;                      }                        if (lbuffer.errorState)                      {                          if (_compressionMethod == 8)                          {                              sInput.Close();                              sInput.Dispose();                          }                            lbuffer.Dispose();                          tcrc32.Dispose();                          tmd5.Dispose();                          tsha1.Dispose();                          FileStatus = ZipReturn.ZipDecodeError;                          return;                      }                        lbuffer.Finish();                      tcrc32.Finish();                      tmd5.Finish();                      tsha1.Finish();                        byte[] testcrc = tcrc32.Hash;                      md5 = tmd5.Hash;                      sha1 = tsha1.Hash;                        lbuffer.Dispose();                      tcrc32.Dispose();                      tmd5.Dispose();                      tsha1.Dispose();                        if (_compressionMethod == 8)                      {                          sInput.Close();                          sInput.Dispose();                      }                        FileStatus = ByteArrCompare(CRC' testcrc) ? ZipReturn.ZipGood : ZipReturn.ZipCRCDecodeError;                  }                  catch                  {                      FileStatus = ZipReturn.ZipDecodeError;                  }
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,LocalFileCheck,The following statement contains a magic number: try                  {                      Stream sInput = null;                      _zipFs.Seek((long)_dataLocation' SeekOrigin.Begin);                        switch (_compressionMethod)                      {                          case 8:                              sInput = new DeflateStream(_zipFs' CompressionMode.Decompress' true);                              break;                          case 0:                              sInput = _zipFs;                              break;                      }                        if (sInput == null)                      {                          FileStatus = ZipReturn.ZipErrorGettingDataStream;                          return;                      }                          if (_buffer0 == null)                      {                          _buffer0 = new byte[Buffersize];                          _buffer1 = new byte[Buffersize];                      }                        ulong sizetogo = UncompressedSize;                        ThreadLoadBuffer lbuffer = new ThreadLoadBuffer(sInput);                      ThreadCRC tcrc32 = new ThreadCRC();                      ThreadMD5 tmd5 = new ThreadMD5();                      ThreadSHA1 tsha1 = new ThreadSHA1();                        // Pre load the first buffer0                      int sizeNext = sizetogo > Buffersize ? Buffersize : (int)sizetogo;                      sInput.Read(_buffer0' 0' sizeNext);                      int sizebuffer = sizeNext;                      sizetogo -= (ulong)sizeNext;                      bool whichBuffer = true;                        while (sizebuffer > 0 && !lbuffer.errorState)                      {                          sizeNext = sizetogo > Buffersize ? Buffersize : (int)sizetogo;                            if (sizeNext > 0)                              lbuffer.Trigger(whichBuffer ? _buffer1 : _buffer0' sizeNext);                            byte[] buffer = whichBuffer ? _buffer0 : _buffer1;                          tcrc32.Trigger(buffer' sizebuffer);                          tmd5.Trigger(buffer' sizebuffer);                          tsha1.Trigger(buffer' sizebuffer);                            if (sizeNext > 0)                              lbuffer.Wait();                          tcrc32.Wait();                          tmd5.Wait();                          tsha1.Wait();                            sizebuffer = sizeNext;                          sizetogo -= (ulong)sizeNext;                          whichBuffer = !whichBuffer;                      }                        if (lbuffer.errorState)                      {                          if (_compressionMethod == 8)                          {                              sInput.Close();                              sInput.Dispose();                          }                            lbuffer.Dispose();                          tcrc32.Dispose();                          tmd5.Dispose();                          tsha1.Dispose();                          FileStatus = ZipReturn.ZipDecodeError;                          return;                      }                        lbuffer.Finish();                      tcrc32.Finish();                      tmd5.Finish();                      tsha1.Finish();                        byte[] testcrc = tcrc32.Hash;                      md5 = tmd5.Hash;                      sha1 = tsha1.Hash;                        lbuffer.Dispose();                      tcrc32.Dispose();                      tmd5.Dispose();                      tsha1.Dispose();                        if (_compressionMethod == 8)                      {                          sInput.Close();                          sInput.Dispose();                      }                        FileStatus = ByteArrCompare(CRC' testcrc) ? ZipReturn.ZipGood : ZipReturn.ZipCRCDecodeError;                  }                  catch                  {                      FileStatus = ZipReturn.ZipDecodeError;                  }
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,LocalFileAddDirectory,The following statement contains a magic number: ds.WriteByte(03);
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,ReadCRC,The following statement contains a magic number: byte[] tCRC = new byte[4];
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,ReadCRC,The following statement contains a magic number: tCRC[3] = br.ReadByte();
Magic Number,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,ReadCRC,The following statement contains a magic number: tCRC[2] = br.ReadByte();
Duplicate Code,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,FixZip,The method contains a code clone-set at the following line numbers (starting from the method definition): ((291' 310)' (334' 353))
Duplicate Code,ROMVault2,FrmMain,C:\repos\gjefferyes_RomVault\ROMVault2\FrmMain.cs,UpdateRomGrid,The method contains a code clone-set at the following line numbers (starting from the method definition): ((24' 62)' (169' 207))
Duplicate Code,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The method contains a code clone-set at the following line numbers (starting from the method definition): ((28' 47)' (245' 264)' (186' 205)' (246' 265))
Duplicate Code,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The method contains a code clone-set at the following line numbers (starting from the method definition): ((186' 205)' (313' 332)' (348' 367)' (246' 265))
Missing Default,ROMVault2,Report,C:\repos\gjefferyes_RomVault\ROMVault2\Report.cs,FindAllDats,The following switch statement is missing a default case: switch (rt)                      {                          case ReportType.Complete:                              if (correct > 0 && missing == 0 && fixesNeeded == 0)                                  _ts.WriteLine(RemoveBase(dat.GetData(RvDat.DatData.DatFullName)));                              break;                          case ReportType.CompletelyMissing:                              if (correct == 0 && missing > 0 && fixesNeeded == 0)                                  _ts.WriteLine(RemoveBase(dat.GetData(RvDat.DatData.DatFullName)));                              break;                          case ReportType.PartialMissing:                              if ((correct > 0 && missing > 0) || fixesNeeded > 0)                              {                                  _ts.WriteLine(RemoveBase(dat.GetData(RvDat.DatData.DatFullName)));                                  _fileNameLength = 0;                                  _fileSizeLength = 0;                                  _repStatusLength = 0;                                  ReportMissingFindSizes(d' dat' rt);                                  ReportDrawBars();                                  ReportMissing(d' dat' rt);                                  ReportDrawBars();                                  _ts.WriteLine();                              }                              break;                          case ReportType.Fixing:                              if (fixesNeeded > 0)                              {                                  _ts.WriteLine(RemoveBase(dat.GetData(RvDat.DatData.DatFullName)));                                  _fileNameLength = 0;                                  _fileSizeLength = 0;                                  _repStatusLength = 0;                                  ReportMissingFindSizes(d' dat' rt);                                  ReportDrawBars();                                  ReportMissing(d' dat' rt);                                  ReportDrawBars();                                  _ts.WriteLine();                              }                              break;                      }
Missing Default,ROMVault2,FixFileCopy,C:\repos\gjefferyes_RomVault\ROMVault2\FixFileCopy.cs,RawCopy,The following switch statement is missing a default case: switch (Program.rvSettings.FixLevel)              {                  case eFixLevel.TrrntZipLevel1:                      return trrntzipped;                  case eFixLevel.TrrntZipLevel2:                      return trrntzipped && deepchecked;                  case eFixLevel.TrrntZipLevel3:                      return false;                    case eFixLevel.Level1:                      return true;                  case eFixLevel.Level2:                      return deepchecked;                  case eFixLevel.Level3:                      return false;              }
Missing Default,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,CountFixDir,The following switch statement is missing a default case: switch (child.FileType)                  {                      case FileType.Zip:                          if (!thisSelected)                              continue;                          RvDir tZip = (RvDir)child;                          count += tZip.DirStatus.CountCanBeFixed();                            break;                        case FileType.Dir:                            count += CountFixDir((RvDir)child' thisSelected);                          break;                        case FileType.File:                          if (!thisSelected)                              continue;                          if (child.RepStatus == RepStatus.CanBeFixed)                              count++;                          break;                  }
Missing Default,ROMVault2,FixFiles,C:\repos\gjefferyes_RomVault\ROMVault2\FixFiles.cs,FixBase,The following switch statement is missing a default case: switch (child.FileType)              {                  case FileType.Zip:                      if (!thisSelected)                          return ReturnCode.Good;                        if (!String.IsNullOrEmpty(child.FileName))                      {                          string strDir = child.Parent.FullName;                          File.Move(Path.Combine(strDir' child.FileName + ".zip")' Path.Combine(strDir' child.Name + ".zip"));                          child.FileName = null;                      }                        do                      {                          returnCode = FixZip((RvDir)child);                      } while (returnCode == ReturnCode.StartOver);                      break;                    case FileType.Dir:                      if (thisSelected)                      {                          if (!String.IsNullOrEmpty(child.FileName))                          {                              string strDir = child.Parent.FullName;                              System.IO.Directory.Move(Path.Combine(strDir' child.FileName)' Path.Combine(strDir' "__RomVault.tmpDir"));                              Directory.Move(Path.Combine(strDir' "__RomVault.tmpDir")' Path.Combine(strDir' child.Name));                              child.FileName = null;                          }                      }                        returnCode = FixDir((RvDir)child' thisSelected);                      return returnCode;                    case FileType.File:                      if (!thisSelected)                          return ReturnCode.Good;                        do                      {                          returnCode = FixFile((RvFile)child);                      } while (returnCode == ReturnCode.StartOver);                      break;              }
Missing Default,ROMVault2,FrmProgressWindowFix,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindowFix.cs,FrmProgressWindowFixResize,The following switch statement is missing a default case: switch (WindowState)              {                  case FormWindowState.Minimized:                      if (_parentForm.Visible) _parentForm.Hide();                      return;                  case FormWindowState.Maximized:                      if (!_parentForm.Visible) _parentForm.Show();                      return;                  case FormWindowState.Normal:                      if (!_parentForm.Visible) _parentForm.Show();                      return;              }
Missing Default,ROMVault2,DatUpdate,C:\repos\gjefferyes_RomVault\ROMVault2\DatUpdate.cs,RemoveOldDats,The following switch statement is missing a default case: switch (res)                  {                      case 0:                          dbDat.Status = DatUpdateStatus.Correct;                          dbIndex++;                          scanIndex++;                          break;                        case 1:                          // this is a new dat that we will add next time around                          scanIndex++;                          break;                      case -1:                          dbDat.Status = DatUpdateStatus.Delete;                          lDir.DirDatRemove(dbIndex);                          break;                  }
Missing Default,ROMVault2,DatUpdate,C:\repos\gjefferyes_RomVault\ROMVault2\DatUpdate.cs,RemoveOldDats,The following switch statement is missing a default case: switch (res)                  {                      case 0:                          // found a matching directory in DatRoot So recurse back into it                          RemoveOldDats(dbChild' (RvDir)fileChild);                          dbIndex++;                          scanIndex++;                          break;                        case 1:                          // found a new directory will be added later                          scanIndex++;                          break;                      case -1:                          if (dbChild.FileType == FileType.Dir && dbChild.Dat == null)                              RemoveOldDats(dbChild' new RvDir(FileType.Dir));                          dbIndex++;                          break;                  }
Missing Default,ROMVault2,DatUpdate,C:\repos\gjefferyes_RomVault\ROMVault2\DatUpdate.cs,AddNewDats,The following switch statement is missing a default case: switch (res)                  {                      case 0:                          _datsProcessed++;                          _bgw.ReportProgress(_datsProcessed);                          _bgw.ReportProgress(0' new bgwText("Dat : " + Path.GetFileNameWithoutExtension(fileDat.GetData(RvDat.DatData.DatFullName))));                              Debug.WriteLine("Correct");                          // Should already be set as correct above                          dbDat.Status = DatUpdateStatus.Correct;                          dbIndex++;                          scanIndex++;                          break;                        case 1:                          _datsProcessed++;                          _bgw.ReportProgress(_datsProcessed);                          _bgw.ReportProgress(0' new bgwText("Scanning New Dat : " + Path.GetFileNameWithoutExtension(fileDat.GetData(RvDat.DatData.DatFullName))));                              Debug.WriteLine("Adding new DAT");                          if (UpdateDatFile(fileDat' autoAddDirectory' dbDir))                              dbIndex++;                          scanIndex++;                          break;                        case -1:                          // This should not happen as deleted dat have been removed above                          //dbIndex++;                          ReportError.SendAndShow(Resources.DatUpdate_UpdateDatList_ERROR_Deleting_a_DAT_that_should_already_be_deleted);                          break;                  }
Missing Default,ROMVault2,DatUpdate,C:\repos\gjefferyes_RomVault\ROMVault2\DatUpdate.cs,UpdateDirs,The following switch statement is missing a default case: switch (res)                  {                      case 0:                          // found a matching directory in DatRoot So recurse back into it                                                    if (dbChild.GotStatus == GotStatus.Got)                          {                              if (dbChild.Name != fileChild.Name) // check if the case of the Item in the DB is different from the Dat Root Actual filename                              {                                  if (!string.IsNullOrEmpty(dbChild.FileName)) // if we do not already have a different case name stored                                  {                                      dbChild.FileName = dbChild.Name; // copy the DB filename to the FileName                                  }                                  else // We already have a different case filename found in RomRoot                                  {                                      if (dbChild.FileName == fileChild.Name) // check if the Datroot name does now match the name in the DB Filename                                      {                                          dbChild.FileName = null; // if it does undo the BadCase Flag                                      }                                  }                                  dbChild.Name = fileChild.Name; // Set the db Name to match the Datroot Name.                              }                          }                          else                              dbChild.Name = fileChild.Name;                            UpdateDatList((RvDir)dbChild'(RvDir)fileChild);                          dbIndex++;                          scanIndex++;                          break;                        case 1:                          // found a new directory in Dat                          RvDir tDir = new RvDir(FileType.Dir)                          {                              Name = fileChild.Name'                              Tree = new RvTreeRow()'                              DatStatus = DatStatus.InDatCollect'                          };                          dbDir.ChildAdd(tDir' dbIndex);                          Debug.WriteLine("Adding new Dir and Calling back in to check this DIR " + tDir.Name);                          UpdateDatList(tDir'(RvDir)fileChild);                            dbIndex++;                          scanIndex++;                          break;                      case -1:                          // all files                           dbIndex++;                          break;                  }
Missing Default,ROMVault2,FileScanning,C:\repos\gjefferyes_RomVault\ROMVault2\FileScanning.cs,Compare,The following switch statement is missing a default case: switch (res)                  {                      case 0:                            if (dbChild == null || fileChild == null)                          {                              ReportError.SendAndShow(Resources.FileScanning_CheckADir_Error_in_File_Scanning_Code);                              break;                          }                            //Complete MultiName Compare                          List<RvBase> dbs = new List<RvBase>();                          List<RvBase> files = new List<RvBase>();                          int dbsCount = 1;                          int filesCount = 1;                              dbs.Add(dbChild);                          files.Add(fileChild);                            while (dbIndex + dbsCount < dbDir.ChildCount && DBHelper.CompareName(dbChild' dbDir.Child(dbIndex + dbsCount)) == 0)                          {                              dbs.Add(dbDir.Child(dbIndex + dbsCount));                              dbsCount += 1;                          }                          while (fileIndex + filesCount < fileDir.ChildCount && DBHelper.CompareName(fileChild' fileDir.Child(fileIndex + filesCount)) == 0)                          {                              files.Add(fileDir.Child(fileIndex + filesCount));                              filesCount += 1;                          }                            for (int indexfile = 0; indexfile < filesCount; indexfile++)                          {                              if (files[indexfile].SearchFound) continue;                                for (int indexdb = 0; indexdb < dbsCount; indexdb++)                              {                                  if (dbs[indexdb].SearchFound) continue;                                    bool matched = FullCompare(dbs[indexdb]' files[indexfile]' false' fullDir' EScanLevel);                                  if (!matched) continue;                                    MatchFound(dbs[indexdb]' files[indexfile]);                                  dbs[indexdb].SearchFound = true;                                  files[indexfile].SearchFound = true;                              }                                if (files[indexfile].SearchFound) continue;                                for (int indexdb = 0; indexdb < dbsCount; indexdb++)                              {                                  if (dbs[indexdb].SearchFound) continue;                                    bool matched = FullCompare(dbs[indexdb]' files[indexfile]' true' fullDir' EScanLevel);                                  if (!matched) continue;                                    MatchFound(dbs[indexdb]' files[indexfile]);                                  dbs[indexdb].SearchFound = true;                                  files[indexfile].SearchFound = true;                              }                          }                              for (int indexdb = 0; indexdb < dbsCount; indexdb++)                          {                              if (dbs[indexdb].SearchFound)                              {                                  dbIndex++;                                  continue;                              }                              DBFileNotFound(dbs[indexdb]' dbDir' ref dbIndex);                          }                            for (int indexfile = 0; indexfile < filesCount; indexfile++)                          {                              if (files[indexfile].SearchFound)                                  continue;                              NewFileFound(files[indexfile]' dbDir' dbIndex);                              dbIndex++;                          }                            fileIndex += filesCount;                          break;                      case 1:                          NewFileFound(fileChild' dbDir' dbIndex);                          dbIndex++;                          fileIndex++;                          break;                      case -1:                          DBFileNotFound(dbChild' dbDir' ref dbIndex);                          break;                  }
Missing Default,ROMVault2,FileScanning,C:\repos\gjefferyes_RomVault\ROMVault2\FileScanning.cs,DBFileNotFound,The following switch statement is missing a default case: switch (dbChild.FileType)                  {                      case FileType.Zip:                          MarkAsMissing((RvDir)dbChild);                          break;                      case FileType.Dir:                          RvDir tDir = (RvDir)dbChild;                          if (tDir.Tree == null)                              MarkAsMissing(tDir);                          break;                  }
Missing Default,ROMVault2,FileScanning,C:\repos\gjefferyes_RomVault\ROMVault2\FileScanning.cs,MarkAsMissing,The following switch statement is missing a default case: switch (dbChild.FileType)                      {                          case FileType.Zip:                              MarkAsMissing((RvDir)dbChild);                              break;                          case FileType.Dir:                              RvDir tDir = (RvDir)dbChild;                              if (tDir.Tree == null)                                  MarkAsMissing(tDir);                              break;                      }
Missing Default,ROMVault2,FrmProgressWindow,C:\repos\gjefferyes_RomVault\ROMVault2\FrmProgressWindow.cs,FrmProgressWindow_Resize,The following switch statement is missing a default case: switch (WindowState)              {                  case FormWindowState.Minimized:                      if (_parentForm.Visible) _parentForm.Hide();                      return;                  case FormWindowState.Maximized:                      if (!_parentForm.Visible) _parentForm.Show();                      return;                  case FormWindowState.Normal:                      if (!_parentForm.Visible) _parentForm.Show();                      return;              }
Missing Default,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,PaintTree,The following switch statement is missing a default case: switch (cTree)                      {                          case "│":                              g.DrawLine(p' x + 9' y' x + 9' y + 16);                              break;                            case "├":                          case "└":                              g.DrawLine(p' x + 9' y' x + 9' y + 16);                              g.DrawLine(p' x + 9' y + 16' x + 27' y + 16);                              break;                      }
Missing Default,ROMVault2,RvTree,C:\repos\gjefferyes_RomVault\ROMVault2\rvTree.cs,PaintTree,The following switch statement is missing a default case: switch (pTree.Tree.Checked)                  {                      case RvTreeRow.TreeSelect.Disabled:                          g.DrawImage(rvImages.TickBoxDisabled' RSub(pTree.Tree.RChecked' _hScroll' _vScroll));                          break;                      case RvTreeRow.TreeSelect.UnSelected:                          g.DrawImage(rvImages.TickBoxUnTicked' RSub(pTree.Tree.RChecked' _hScroll' _vScroll));                          break;                      case RvTreeRow.TreeSelect.Selected:                          g.DrawImage(rvImages.TickBoxTicked' RSub(pTree.Tree.RChecked' _hScroll' _vScroll));                          break;                  }
Missing Default,ROMVault2.SupportedFiles.CHD,CHD,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\CHD\CHD.cs,CheckFile,The following switch statement is missing a default case: switch (version)              {                  case 1:                      if (length != 76) return;                        //    V1 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // 512-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] (V1 header length)                        return;                    case 2:                      if (length != 80) return;                        //    V2 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                        //    [ 24] UINT32 hunksize;      // seclen-byte sectors per hunk                      //    [ 28] UINT32 totalhunks;    // total # of hunks represented                      //    [ 32] UINT32 cylinders;     // number of cylinders on hard disk                      //    [ 36] UINT32 heads;         // number of heads on hard disk                      //    [ 40] UINT32 sectors;       // number of sectors on hard disk                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 seclen;        // number of bytes per sector                      //    [ 80] (V2 header length)                      return;                    case 3:                      if (length != 120) return;                        //    V3 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT8  md5[16];       // MD5 checksum of raw data                      MD5CHD = ReadBytes(buff' 44' 16);                      //    [ 60] UINT8  parentmd5[16]; // MD5 checksum of parent file                      //    [ 76] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 80] UINT8  sha1[20];      // SHA1 checksum of raw data                      SHA1CHD = ReadBytes(buff' 80' 20);                      //    [100] UINT8  parentsha1[20];// SHA1 checksum of parent file                      //    [120] (V3 header length)                      return;                    case 4:                      if (length != 108) return;                        //    V4 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 flags;         // flags (see below)                      //    [ 20] UINT32 compression;   // compression type                      compression = ReadUInt32(buff' 20);                      if (compression == 0) return;                      //    [ 24] UINT32 totalhunks;    // total # of hunks represented                      //    [ 28] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 36] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 44] UINT32 hunkbytes;     // number of bytes per hunk                      //    [ 48] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 48' 20);                      //    [ 68] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [ 88] UINT8  rawsha1[20];   // raw data SHA1                      //    [108] (V4 header length)                      return;                    case 5:                      if (length != 124) return;                        //    V5 header:                      //    [  0] char   tag[8];        // 'MComprHD'                      //    [  8] UINT32 length;        // length of header (including tag and length fields)                      //    [ 12] UINT32 version;       // drive format version                      //    [ 16] UINT32 compressors[4];// which custom compressors are used?                      UInt32 compression0 = ReadUInt32(buff' 16);                      UInt32 compression1 = ReadUInt32(buff' 20);                      UInt32 compression2 = ReadUInt32(buff' 24);                      UInt32 compression3 = ReadUInt32(buff' 28);                      if (compression0 == 0 && compression1 == 0 && compression2 == 0 && compression3 == 0) return;                      //    [ 32] UINT64 logicalbytes;  // logical size of the data (in bytes)                      //    [ 40] UINT64 mapoffset;     // offset to the map                      //    [ 48] UINT64 metaoffset;    // offset to the first blob of metadata                      //    [ 56] UINT32 hunkbytes;     // number of bytes per hunk (512k maximum)                      //    [ 60] UINT32 unitbytes;     // number of bytes per unit within each hunk                      //    [ 64] UINT8  rawsha1[20];   // raw data SHA1                      //    [ 84] UINT8  sha1[20];      // combined raw+meta SHA1                      SHA1CHD = ReadBytes(buff' 84' 20);                      //    [104] UINT8  parentsha1[20];// combined raw+meta SHA1 of parent                      //    [124] (V5 header length)                      return;              }
Missing Default,ROMVault2.DatReaders,DatCmpReader,C:\repos\gjefferyes_RomVault\ROMVault2\DatReaders\DatCmpReader.cs,LoadEmulator,The following switch statement is missing a default case: switch (DatFileLoader.Next.ToLower())                  {                      case "name": DatFileLoader.GnRest(); DatFileLoader.Gn(); break;                      case "version": DatFileLoader.GnRest(); DatFileLoader.Gn(); break;                  }
Missing Default,ROMVault2.SupportedFiles.Zip.ZLib,DeflateManager,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Deflate.cs,SetDeflater,The following switch statement is missing a default case: switch (config.Flavor)              {                  case DeflateFlavor.Store:                      DeflateFunction = DeflateNone;                      break;                  case DeflateFlavor.Fast:                      DeflateFunction = DeflateFast;                      break;                  case DeflateFlavor.Slow:                      DeflateFunction = DeflateSlow;                      break;              }
Missing Default,ROMVault2.SupportedFiles.Zip.ZLib,InflateBlocks,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\ZLib\Inflate.cs,Process,The following switch statement is missing a default case: switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }
Missing Default,ROMVault2.Utils,DBTypeGet,C:\repos\gjefferyes_RomVault\ROMVault2\Utils\DBTypeGet.cs,DirFromFile,The following switch statement is missing a default case: switch (ft)              {                  case FileType.File:                      return FileType.Dir;                  case FileType.ZipFile:                      return FileType.Zip;              }
Missing Default,ROMVault2.Utils,DBTypeGet,C:\repos\gjefferyes_RomVault\ROMVault2\Utils\DBTypeGet.cs,FileFromDir,The following switch statement is missing a default case: switch (ft)              {                  case FileType.Dir:                      return FileType.File;                  case FileType.Zip:                      return FileType.ZipFile;              }
Missing Default,ROMVault2.SupportedFiles.Zip,ZipFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,ZipErrorMessageText,The following switch statement is missing a default case: switch (zS)              {                  case ZipReturn.ZipGood:                      ret = "";                      break;                  case ZipReturn.ZipFileCountError:                      ret = "The number of file in the Zip does not mach the number of files in the Zips Centeral Directory";                      break;                  case ZipReturn.ZipSignatureError:                      ret = "An unknown Signature Block was found in the Zip";                      break;                  case ZipReturn.ZipExtraDataOnEndOfZip:                      ret = "Extra Data was found on the end of the Zip";                      break;                  case ZipReturn.ZipUnsupportedCompression:                      ret = "An unsupported Compression method was found in the Zip' if you recompress this zip it will be usable";                      break;                  case ZipReturn.ZipLocalFileHeaderError:                      ret = "Error reading a zipped file header information";                      break;                  case ZipReturn.ZipCenteralDirError:                      ret = "There is an error in the Zip Centeral Directory";                      break;                  case ZipReturn.ZipReadingFromOutputFile:                      ret = "Trying to write to a Zip file open for output only";                      break;                  case ZipReturn.ZipWritingToInputFile:                      ret = "Tring to read from a Zip file open for input only";                      break;                  case ZipReturn.ZipErrorGettingDataStream:                      ret = "Error creating Data Stream";                      break;                  case ZipReturn.ZipCRCDecodeError:                      ret = "CRC error";                      break;                  case ZipReturn.ZipDecodeError:                      ret = "Error unzipping a file";                      break;              }
Missing Default,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,LocalFileOpenReadStream,The following switch statement is missing a default case: switch (_compressionMethod)                  {                      case 8:                          if (raw)                          {                              _readStream = _zipFs;                              streamSize = _compressedSize;                          }                          else                          {                              _readStream = new DeflateStream(_zipFs' CompressionMode.Decompress' true);                              streamSize = UncompressedSize;                            }                          break;                      case 0:                          _readStream = _zipFs;                          streamSize = _compressedSize;  // same as UncompressedSize                          break;                  }
Missing Default,ROMVault2.SupportedFiles.Zip,LocalFile,C:\repos\gjefferyes_RomVault\ROMVault2\SupportedFiles\Zip\zipFile.cs,LocalFileCheck,The following switch statement is missing a default case: switch (_compressionMethod)                      {                          case 8:                              sInput = new DeflateStream(_zipFs' CompressionMode.Decompress' true);                              break;                          case 0:                              sInput = _zipFs;                              break;                      }
