Implementation smell,Namespace,Class,File,Method,Description
Long Method,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,RecvDecodingTables,The method has 110 lines of code.
Long Method,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,GetAndMoveToFrontDecode,The method has 224 lines of code.
Long Method,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,HbMakeCodeLengths,The method has 155 lines of code.
Long Method,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,SendMTFValues,The method has 353 lines of code.
Long Method,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,QSort3,The method has 123 lines of code.
Long Method,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,MainSort,The method has 202 lines of code.
Long Method,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,FullGtU,The method has 126 lines of code.
Long Method,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,GenerateMTFValues,The method has 102 lines of code.
Long Method,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The method has 449 lines of code.
Long Method,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,The method has 183 lines of code.
Long Method,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,SetCoderProperties,The method has 103 lines of code.
Long Method,Compress.SevenZip.Compress.LZ,BinTree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZ\LzBinTree.cs,GetMatches,The method has 122 lines of code.
Long Method,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,createSuccessors,The method has 107 lines of code.
Long Method,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,updateModel,The method has 167 lines of code.
Long Method,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,decodeChar,The method has 132 lines of code.
Long Method,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,UpdateModel,The method has 131 lines of code.
Long Method,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,CreateSuccessors,The method has 100 lines of code.
Long Method,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,ZipFileOpenReadStream,The method has 146 lines of code.
Long Method,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Create7ZStructure,The method has 149 lines of code.
Long Method,Compress.ZipFile,ZipFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,ZipFileReadHeaders,The method has 135 lines of code.
Long Method,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,LocalFileHeaderRead,The method has 124 lines of code.
Long Method,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,DeflateFast,The method has 101 lines of code.
Long Method,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,DeflateSlow,The method has 127 lines of code.
Long Method,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Deflate,The method has 149 lines of code.
Long Method,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The method has 448 lines of code.
Long Method,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The method has 307 lines of code.
Long Method,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,InflateFast,The method has 206 lines of code.
Long Method,Compress.ZipFile.ZLib,InflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Inflate,The method has 159 lines of code.
Long Method,Compress.ZipFile.ZLib,InfTree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\InfTree.cs,huft_build,The method has 212 lines of code.
Complex Method,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,ReadByte,Cyclomatic complexity of the method is 9
Complex Method,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,HbCreateDecodeTables,Cyclomatic complexity of the method is 10
Complex Method,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,RecvDecodingTables,Cyclomatic complexity of the method is 21
Complex Method,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,GetAndMoveToFrontDecode,Cyclomatic complexity of the method is 18
Complex Method,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,HbMakeCodeLengths,Cyclomatic complexity of the method is 22
Complex Method,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,SendMTFValues,Cyclomatic complexity of the method is 60
Complex Method,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,SimpleSort,Cyclomatic complexity of the method is 15
Complex Method,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,QSort3,Cyclomatic complexity of the method is 17
Complex Method,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,MainSort,Cyclomatic complexity of the method is 25
Complex Method,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,GenerateMTFValues,Cyclomatic complexity of the method is 14
Complex Method,Compress.SevenZip.Compress.LZMA,Decoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaDecoder.cs,Code,Cyclomatic complexity of the method is 13
Complex Method,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,Cyclomatic complexity of the method is 64
Complex Method,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,Cyclomatic complexity of the method is 31
Complex Method,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,SetCoderProperties,Cyclomatic complexity of the method is 26
Complex Method,Compress.SevenZip.Compress.LZMA,LzmaStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaStream.cs,Read,Cyclomatic complexity of the method is 15
Complex Method,Compress.SevenZip.Compress.LZMA,LzmaStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaStream.cs,decodeChunkHeader,Cyclomatic complexity of the method is 9
Complex Method,Compress.SevenZip.Compress.LZ,BinTree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZ\LzBinTree.cs,GetMatches,Cyclomatic complexity of the method is 22
Complex Method,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,startModelRare,Cyclomatic complexity of the method is 8
Complex Method,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,decodeChar,Cyclomatic complexity of the method is 9
Complex Method,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,createSuccessors,Cyclomatic complexity of the method is 9
Complex Method,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,updateModel,Cyclomatic complexity of the method is 22
Complex Method,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,decodeChar,Cyclomatic complexity of the method is 11
Complex Method,Compress.SevenZip.Compress.PPmd.H,SubAllocator,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\SubAllocator.cs,glueFreeBlocks,Cyclomatic complexity of the method is 9
Complex Method,Compress.SevenZip.Compress.PPmd.I1,Allocator,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Allocator.cs,GlueFreeBlocks,Cyclomatic complexity of the method is 10
Complex Method,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,Model,Cyclomatic complexity of the method is 8
Complex Method,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,StartModel,Cyclomatic complexity of the method is 12
Complex Method,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,UpdateModel,Cyclomatic complexity of the method is 20
Complex Method,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,ReduceOrder,Cyclomatic complexity of the method is 11
Complex Method,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,RestoreModel,Cyclomatic complexity of the method is 11
Complex Method,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,CutOff,Cyclomatic complexity of the method is 11
Complex Method,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,DeepScan,Cyclomatic complexity of the method is 10
Complex Method,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,Cyclomatic complexity of the method is 8
Complex Method,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,ZipFileOpenReadStream,Cyclomatic complexity of the method is 27
Complex Method,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Create7ZStructure,Cyclomatic complexity of the method is 18
Complex Method,Compress.SevenZip.Filters,BCJ2Filter,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Filters\BCJ2Filter.cs,Read,Cyclomatic complexity of the method is 11
Complex Method,Compress.SevenZip.Filters,BCJFilter,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Filters\BCJFilter.cs,Transform,Cyclomatic complexity of the method is 11
Complex Method,Compress.SevenZip.Filters,Filter,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Filters\Filter.cs,Read,Cyclomatic complexity of the method is 12
Complex Method,Compress.SevenZip.Structure,Coder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Structure\Coder.cs,Read,Cyclomatic complexity of the method is 13
Complex Method,Compress.SevenZip.Structure,FileInfo,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Structure\FileInfo.cs,Read,Cyclomatic complexity of the method is 13
Complex Method,Compress.SevenZip.Structure,Folder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Structure\Folder.cs,ReadFolder,Cyclomatic complexity of the method is 9
Complex Method,Compress.SevenZip.Structure,Folder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Structure\Folder.cs,ReadUnPackInfo,Cyclomatic complexity of the method is 10
Complex Method,Compress.SevenZip.Structure,Folder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Structure\Folder.cs,ReadSubStreamsInfo,Cyclomatic complexity of the method is 17
Complex Method,Compress.SevenZip.Structure,PackedStreamInfo,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Structure\PackedStreamInfo.cs,Read,Cyclomatic complexity of the method is 8
Complex Method,Compress.ZipFile,ZipFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,ZipFileReadHeaders,Cyclomatic complexity of the method is 22
Complex Method,Compress.ZipFile,ZipFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,ZipErrorMessageText,Cyclomatic complexity of the method is 12
Complex Method,Compress.ZipFile,ZipFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,TrrntZipStringCompare,Cyclomatic complexity of the method is 8
Complex Method,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,CenteralDirectoryRead,Cyclomatic complexity of the method is 10
Complex Method,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,LocalFileHeaderRead,Cyclomatic complexity of the method is 18
Complex Method,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,LocalFileHeaderReadQuick,Cyclomatic complexity of the method is 9
Complex Method,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,LocalFileCheck,Cyclomatic complexity of the method is 11
Complex Method,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,scan_tree,Cyclomatic complexity of the method is 10
Complex Method,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,send_tree,Cyclomatic complexity of the method is 10
Complex Method,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,DeflateNone,Cyclomatic complexity of the method is 11
Complex Method,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,DeflateFast,Cyclomatic complexity of the method is 14
Complex Method,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,DeflateSlow,Cyclomatic complexity of the method is 18
Complex Method,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Deflate,Cyclomatic complexity of the method is 22
Complex Method,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,Cyclomatic complexity of the method is 52
Complex Method,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Flush,Cyclomatic complexity of the method is 10
Complex Method,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,Cyclomatic complexity of the method is 43
Complex Method,Compress.ZipFile.ZLib,InflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Inflate,Cyclomatic complexity of the method is 35
Complex Method,Compress.ZipFile.ZLib,InfTree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\InfTree.cs,huft_build,Cyclomatic complexity of the method is 26
Complex Method,Compress.ZipFile.ZLib,InfTree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\InfTree.cs,inflate_trees_dynamic,Cyclomatic complexity of the method is 8
Complex Method,Compress.ZipFile.ZLib,Tree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Tree.cs,gen_bitlen,Cyclomatic complexity of the method is 12
Complex Method,Compress.ZipFile.ZLib,ZlibBaseStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\ZlibBaseStream.cs,finish,Cyclomatic complexity of the method is 13
Complex Method,Compress.ZipFile.ZLib,ZlibBaseStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,Cyclomatic complexity of the method is 9
Complex Method,Compress.ZipFile.ZLib,ZlibBaseStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\ZlibBaseStream.cs,Read,Cyclomatic complexity of the method is 18
Long Parameter List,Compress,ICompress,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ICompress.cs,ZipFileOpenWriteStream,The method has 6 parameters. Parameters: raw' trrntzip' filename' uncompressedSize' compressionMethod' stream
Long Parameter List,Compress.SevenZip.Common,ICoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Common\ICoder.cs,Code,The method has 5 parameters. Parameters: inStream' outStream' inSize' outSize' progress
Long Parameter List,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,HbCreateDecodeTables,The method has 7 parameters. Parameters: limit' basev' perm' length' minLen' maxLen' alphaSize
Long Parameter List,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,HbAssignCodes,The method has 5 parameters. Parameters: code' length' minLen' maxLen' alphaSize
Long Parameter List,Compress.SevenZip.Compress.LZMA,Decoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaDecoder.cs,Code,The method has 5 parameters. Parameters: inStream' outStream' inSize' outSize' progress
Long Parameter List,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,Code,The method has 5 parameters. Parameters: inStream' outStream' inSize' outSize' progress
Long Parameter List,Compress.SevenZip.Compress.LZMA,LzmaStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaStream.cs,LzmaStream,The method has 6 parameters. Parameters: properties' inputStream' inputSize' outputSize' presetDictionary' isLZMA2
Long Parameter List,Compress.SevenZip.Compress.RangeCoder,BitTreeEncoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\RangeCoder\RangeCoderBitTree.cs,ReverseEncode,The method has 5 parameters. Parameters: Models' startIndex' rangeEncoder' NumBitLevels' symbol
Long Parameter List,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,ZipFileOpenWriteStream,The method has 6 parameters. Parameters: raw' trrntzip' filename' uncompressedSize' compressionMethod' stream
Long Parameter List,Compress.SevenZip,Util,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Util.cs,memcpyr,The method has 5 parameters. Parameters: destBuffer' destPoint' sourceBuffer' sourcePoint' len
Long Parameter List,Compress.ZipFile,ZipFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,ZipFileOpenWriteStream,The method has 6 parameters. Parameters: raw' trrntzip' filename' uncompressedSize' compressionMethod' stream
Long Parameter List,Compress.ZipFile,ZipFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,ZipFileOpenReadStream,The method has 5 parameters. Parameters: index' raw' stream' streamSize' compressionMethod
Long Parameter List,Compress.ZipFile,ZipFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,ZipFileOpenReadStreamQuick,The method has 5 parameters. Parameters: pos' raw' stream' streamSize' compressionMethod
Long Parameter List,Compress.ZipFile,ZipFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,ZipFileAddFake,The method has 6 parameters. Parameters: filename' fileOffset' uncompressedSize' compressedSize' crc32' localHeader
Long Parameter List,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,LocalFileHeaderFake,The method has 5 parameters. Parameters: filePosition' uncompressedSize' compressedSize' crc32' ms
Long Parameter List,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,LocalFileOpenWriteStream,The method has 5 parameters. Parameters: raw' trrntZip' uncompressedSize' compressionMethod' stream
Long Parameter List,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Initialize,The method has 5 parameters. Parameters: codec' level' windowBits' memLevel' strategy
Long Parameter List,Compress.ZipFile.ZLib,Config,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Config,The method has 5 parameters. Parameters: goodLength' maxLazy' niceLength' maxChainLength' flavor
Long Parameter List,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Init,The method has 6 parameters. Parameters: bl' bd' tl' tl_index' td' td_index
Long Parameter List,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,InflateFast,The method has 8 parameters. Parameters: bl' bd' tl' tl_index' td' td_index' s' z
Long Parameter List,Compress.ZipFile.ZLib,InfTree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\InfTree.cs,huft_build,The method has 11 parameters. Parameters: b' bindex' n' s' d' e' t' m' hp' hn' v
Long Parameter List,Compress.ZipFile.ZLib,InfTree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\InfTree.cs,inflate_trees_bits,The method has 5 parameters. Parameters: c' bb' tb' hp' z
Long Parameter List,Compress.ZipFile.ZLib,InfTree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\InfTree.cs,inflate_trees_dynamic,The method has 9 parameters. Parameters: nl' nd' c' bl' bd' tl' td' hp' z
Long Parameter List,Compress.ZipFile.ZLib,InfTree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\InfTree.cs,inflate_trees_fixed,The method has 5 parameters. Parameters: bl' bd' tl' td' z
Long Parameter List,Compress.ZipFile.ZLib,StaticTree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Zlib.cs,StaticTree,The method has 5 parameters. Parameters: treeCodes' extraBits' extraBase' elems' maxLength
Long Parameter List,Compress.ZipFile.ZLib,ZlibBaseStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\ZlibBaseStream.cs,ZlibBaseStream,The method has 5 parameters. Parameters: stream' compressionMode' level' flavor' leaveOpen
Long Identifier,Compress.SevenZip.Compress.LZMA,Base,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaBase.cs,,The length of the parameter kNumLitPosStatesBitsEncodingMax is 31.
Long Identifier,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,,The length of the parameter numberStatisticsToBinarySummaryIndex is 36.
Long Identifier,Compress.ZipFile,ZipFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,,The length of the parameter CentralDirectoryHeaderSigniature is 32.
Long Identifier,Compress.ZipFile,ZipFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,,The length of the parameter Zip64EndOfCentralDirectoryLocator is 33.
Long Statement,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The length of the statement  "                            UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1(); " is 126.
Long Statement,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The length of the statement  "                                    UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1(); " is 126.
Long Statement,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,FillDistancesPrices,The length of the statement  "                    _posSlotPrices[st + posSlot] += ((((posSlot >> 1) - 1) - Base.kNumAlignBits) << RangeCoder.BitEncoder.kNumBitPriceShiftBits); " is 125.
Long Statement,Compress.SevenZip.Compress.PPmd.H,SubAllocator,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\SubAllocator.cs,startSubAllocator,The length of the statement  "            //UPGRADE_ISSUE: The following fragment of code could not be parsed and was not converted. "ms-help://MS.VSCC.v80/dv_commoner/local/redirect.htm?index='!DefaultContextWindowIndex'&keyword='jlca1156'" " is 199.
Long Statement,Compress.SevenZip.Compress.PPmd.I1,Coder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Coder.cs,RangeEncoderNormalize,The length of the statement  "            while ((low ^ (low + range)) < RangeTop || range < RangeBottom && ((range = (uint) -low & (RangeBottom - 1)) != 0 || true)) " is 123.
Long Statement,Compress.SevenZip.Compress.PPmd.I1,Coder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Coder.cs,RangeDecoderNormalize,The length of the statement  "            while ((low ^ (low + range)) < RangeTop || range < RangeBottom && ((range = (uint) -low & (RangeBottom - 1)) != 0 || true)) " is 123.
Long Statement,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,StartModel,The length of the statement  "            maximumContext.Statistics = Allocator.AllocateUnits(256 / 2);  // allocates enough space for 256 PPM states (each is 6 bytes) " is 125.
Long Statement,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,RestoreModel,The length of the statement  "                    currentContext.Flags = (byte)((currentContext.Flags & 0x10) + ((currentContext.Statistics.Symbol >= 0x40) ? 0x08 : 0x00)); " is 122.
Long Statement,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,EncodeBinarySymbol,The length of the statement  "            int index2 = numberStatisticsToBinarySummaryIndex[context.Suffix.NumberStatistics] + previousSuccess + context.Flags + ((runLength >> 26) & 0x20); " is 146.
Long Statement,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,DecodeBinarySymbol,The length of the statement  "            int index2 = numberStatisticsToBinarySummaryIndex[context.Suffix.NumberStatistics] + previousSuccess + context.Flags + ((runLength >> 26) & 0x20); " is 146.
Long Statement,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,DecodeSymbol2,The length of the statement  "                decodeStates[stateIndex++] = state;  // note that decodeStates is a static array that is re-used on each call to this method (for performance reasons) " is 150.
Long Statement,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,MakeEscapeFrequency,The length of the statement  "                int index2 = ((context.SummaryFrequency > 11 * (context.NumberStatistics + 1)) ? 1 : 0) + ((2 * context.NumberStatistics < numberStatistics + numberMasked) ? 2 : 0) + context.Flags; " is 181.
Long Statement,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,Rescale,The length of the statement  "                context.Statistics = Allocator.ShrinkUnits(context.Statistics' oldUnitCount' (uint)((context.NumberStatistics + 2) >> 1)); " is 122.
Long Statement,Compress.ThreadReaders,ThreadCRC,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ThreadReaders\ThreadCRC.cs,MainLoop,The length of the statement  "                        crc ^= (uint) (_buffer[offset] + (_buffer[offset + 1] << 8) + (_buffer[offset + 2] << 16) + (_buffer[offset + 3] << 24)); " is 121.
Long Statement,Compress.ThreadReaders,ThreadCRC,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ThreadReaders\ThreadCRC.cs,MainLoop,The length of the statement  "                        uint high = (uint) (_buffer[offset + 4] + (_buffer[offset + 5] << 8) + (_buffer[offset + 6] << 16) + (_buffer[offset + 7] << 24)); " is 130.
Long Statement,Compress.ZipFile,ZipFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,EndOfCentralDirWrite,The length of the statement  "            bw.Write((ushort) (_localFiles.Count >= 0xffff ? 0xffff : _localFiles.Count)); // TotalNumber of enteries in the central directory  " is 130.
Long Statement,Compress.ZipFile.ZLib,ZlibBaseStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\ZlibBaseStream.cs,finish,The length of the statement  "                            throw new ZlibException(String.Format("Bad CRC32 in GZIP trailer. (actual({0:X8})!=expected({1:X8}))"' crc32_actual' crc32_expected)); " is 134.
Long Statement,Compress.ZipFile.ZLib,ZlibBaseStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\ZlibBaseStream.cs,finish,The length of the statement  "                            throw new ZlibException(String.Format("Bad size in GZIP trailer. (actual({0})!=expected({1}))"' isize_actual' isize_expected)); " is 127.
Complex Conditional,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,InitBlock,The conditional expression  "magic1 != 0x17 || magic2 != 0x72 || magic3 != 0x45                       || magic4 != 0x38 || magic5 != 0x50 || magic6 != 0x90"  is complex.
Complex Conditional,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,InitBlock,The conditional expression  "magic1 != 0x31 || magic2 != 0x41 || magic3 != 0x59                  || magic4 != 0x26 || magic5 != 0x53 || magic6 != 0x59"  is complex.
Complex Conditional,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,SetDecompressStructureSizes,The conditional expression  "!(0 <= newSize100k && newSize100k <= 9 && 0 <= blockSize100k                  && blockSize100k <= 9)"  is complex.
Complex Conditional,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,SendMTFValues,The conditional expression  "ge > gs && nPart != nGroups && nPart != 1                          && ((nGroups - nPart) % 2 == 1)"  is complex.
Complex Conditional,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,AllocateCompressStructures,The conditional expression  "block == null || quadrant == null || zptr == null                  || ftab == null"  is complex.
Complex Conditional,Compress.SevenZip.Compress.PPmd.I1,Coder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Coder.cs,RangeEncoderNormalize,The conditional expression  "(low ^ (low + range)) < RangeTop || range < RangeBottom && ((range = (uint) -low & (RangeBottom - 1)) != 0 || true)"  is complex.
Complex Conditional,Compress.SevenZip.Compress.PPmd.I1,Coder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Coder.cs,RangeDecoderNormalize,The conditional expression  "(low ^ (low + range)) < RangeTop || range < RangeBottom && ((range = (uint) -low & (RangeBottom - 1)) != 0 || true)"  is complex.
Complex Conditional,Compress.SevenZip.Structure,Coder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Structure\Coder.cs,Read,The conditional expression  "(Method.Length == 3) && (Method[0] == 3) && (Method[1] == 1) && (Method[2] == 1)"  is complex.
Complex Conditional,Compress.SevenZip.Structure,Coder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Structure\Coder.cs,Read,The conditional expression  "(Method.Length == 4) && (Method[0] == 3) && (Method[1] == 3) && (Method[2] == 1) && (Method[3] == 3)"  is complex.
Complex Conditional,Compress.SevenZip.Structure,Coder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Structure\Coder.cs,Read,The conditional expression  "(Method.Length == 4) && (Method[0] == 3) && (Method[1] == 3) && (Method[2] == 1) && (Method[3] == 27)"  is complex.
Complex Conditional,Compress.SevenZip.Structure,Coder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Structure\Coder.cs,Read,The conditional expression  "(Method.Length == 3) && (Method[0] == 3) && (Method[1] == 4) && (Method[2] == 1)"  is complex.
Complex Conditional,Compress.SevenZip.Structure,Coder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Structure\Coder.cs,Read,The conditional expression  "(Method.Length == 3) && (Method[0] == 4) && (Method[1] == 2) && (Method[2] == 2)"  is complex.
Complex Conditional,Compress.SevenZip.Structure,Header,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Structure\Header.cs,ReadHeaderOrPackedHeader,The conditional expression  "!((method.Length == 3) && (method[0] == 3) && (method[1] == 1) && (method[2] == 1))"  is complex.
Complex Conditional,Compress.ZipFile,ZipFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,FindEndOfCentralDirSignature,The conditional expression  "(buffer[i] != 0x50) || (buffer[i + 1] != 0x4b) || (buffer[i + 2] != 0x05) || (buffer[i + 3] != 0x06)"  is complex.
Complex Conditional,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,DeflateSlow,The conditional expression  "match_length <= 5 && (compressionStrategy == CompressionStrategy.Filtered ||                                                (match_length == MIN_MATCH && strstart - match_start > 4096))"  is complex.
Complex Conditional,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,longest_match,The conditional expression  "window[match + best_len] != scan_end ||                      window[match + best_len - 1] != scan_end1 ||                      window[match] != window[scan] ||                      window[++match] != window[scan + 1]"  is complex.
Complex Conditional,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Deflate,The conditional expression  "_codec.OutputBuffer == null ||                  (_codec.InputBuffer == null && _codec.AvailableBytesIn != 0) ||                  (status == FINISH_STATE && flush != FlushType.Finish)"  is complex.
Complex Conditional,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Deflate,The conditional expression  "_codec.AvailableBytesIn != 0 || lookahead != 0 || (flush != FlushType.None && status != FINISH_STATE)"  is complex.
Complex Conditional,Compress.ZipFile.ZLib,ZlibCodec,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\ZlibCodec.cs,flush_pending,The conditional expression  "dstate.pending.Length <= dstate.nextPending ||                  OutputBuffer.Length <= NextOut ||                  dstate.pending.Length < (dstate.nextPending + len) ||                  OutputBuffer.Length < (NextOut + len)"  is complex.
Virtual Method Call from Constructor,Compress.SevenZip.Compress.PPmd.H,SubAllocator,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\SubAllocator.cs,SubAllocator,The constructor "SubAllocator" calls a virtual method "clean".
Empty Catch Block,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,BsFinishedWithStream,The method has an empty catch block.
Magic Number,Compress.SevenZip.Common,CRC,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Common\CRC.cs,CRC,The following statement contains a magic number: Table = new uint[256];
Magic Number,Compress.SevenZip.Common,CRC,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Common\CRC.cs,CRC,The following statement contains a magic number: j < 8
Magic Number,Compress.SevenZip.Common,CRC,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Common\CRC.cs,CRC,The following statement contains a magic number: i < 256
Magic Number,Compress.SevenZip.Common,CRC,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Common\CRC.cs,UpdateByte,The following statement contains a magic number: _value = Table[(((byte)(_value)) ^ b)] ^ (_value >> 8);
Magic Number,Compress.SevenZip.Common,CRC,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Common\CRC.cs,Update,The following statement contains a magic number: _value = Table[(((byte)(_value)) ^ data[offset + i])] ^ (_value >> 8);
Magic Number,Compress.SevenZip.Compress.BZip2,BZip2Stream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\BZip2Stream.cs,IsBZip2,The following statement contains a magic number: byte[] chars = br.ReadBytes(2);
Magic Number,Compress.SevenZip.Compress.BZip2,BZip2Stream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\BZip2Stream.cs,IsBZip2,The following statement contains a magic number: chars.Length < 2 || chars[0] != 'B' || chars[1] != 'Z'
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,MakeMaps,The following statement contains a magic number: i < 256
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,EndBlock,The following statement contains a magic number: computedCombinedCRC = (computedCombinedCRC << 1)                  | (int)(((uint)computedCombinedCRC) >> 31);
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,BsR,The following statement contains a magic number: bsBuff = (bsBuff << 8) | (zzi & 0xff);
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,BsR,The following statement contains a magic number: bsLive += 8;
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,BsGetUChar,The following statement contains a magic number: return (char)BsR(8);
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,BsGetint,The following statement contains a magic number: u = (u << 8) | BsR(8);
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,BsGetint,The following statement contains a magic number: u = (u << 8) | BsR(8);
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,BsGetint,The following statement contains a magic number: u = (u << 8) | BsR(8);
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,BsGetint,The following statement contains a magic number: u = (u << 8) | BsR(8);
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,BsGetint,The following statement contains a magic number: u = (u << 8) | BsR(8);
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,BsGetint,The following statement contains a magic number: u = (u << 8) | BsR(8);
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,BsGetint,The following statement contains a magic number: u = (u << 8) | BsR(8);
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,BsGetint,The following statement contains a magic number: u = (u << 8) | BsR(8);
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: bool[] inUse16 = new bool[16];
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: i < 16
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: i < 256
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: inUse[i * 16 + j] = true;
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: j < 16
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: i < 16
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: alphaSize = nInUse + 2;
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: nGroups = BsR(3);
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: nSelectors = BsR(15);
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: int curr = BsR(5);
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: minLen = 32;
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,GetAndMoveToFrontDecode,The following statement contains a magic number: char[] yy = new char[256];
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,GetAndMoveToFrontDecode,The following statement contains a magic number: origPtr = BsGetIntVS(24);
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,GetAndMoveToFrontDecode,The following statement contains a magic number: i <= 255
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,GetAndMoveToFrontDecode,The following statement contains a magic number: i <= 255
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,GetAndMoveToFrontDecode,The following statement contains a magic number: bsBuff = (bsBuff << 8) | (zzi & 0xff);
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,GetAndMoveToFrontDecode,The following statement contains a magic number: bsLive += 8;
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,GetAndMoveToFrontDecode,The following statement contains a magic number: N = N * 2;
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,GetAndMoveToFrontDecode,The following statement contains a magic number: bsBuff = (bsBuff << 8) | (zzi & 0xff);
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,GetAndMoveToFrontDecode,The following statement contains a magic number: bsLive += 8;
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,SetupBlock,The following statement contains a magic number: int[] cftab = new int[257];
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,SetupBlock,The following statement contains a magic number: i <= 256
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,SetupBlock,The following statement contains a magic number: i <= 256
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,SetupBlock,The following statement contains a magic number: ch2 = 256;
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,SetupRandPartA,The following statement contains a magic number: rTPos == 512
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,SetDecompressStructureSizes,The following statement contains a magic number: !(0 <= newSize100k && newSize100k <= 9 && 0 <= blockSize100k                  && blockSize100k <= 9)
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,SetDecompressStructureSizes,The following statement contains a magic number: !(0 <= newSize100k && newSize100k <= 9 && 0 <= blockSize100k                  && blockSize100k <= 9)
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,MakeMaps,The following statement contains a magic number: i < 256
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,HbMakeCodeLengths,The following statement contains a magic number: int[] heap = new int[BZip2Constants.MAX_ALPHA_SIZE + 2];
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,HbMakeCodeLengths,The following statement contains a magic number: int[] weight = new int[BZip2Constants.MAX_ALPHA_SIZE * 2];
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,HbMakeCodeLengths,The following statement contains a magic number: int[] parent = new int[BZip2Constants.MAX_ALPHA_SIZE * 2];
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,HbMakeCodeLengths,The following statement contains a magic number: weight[i + 1] = (freq[i] == 0 ? 1 : freq[i]) << 8;
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,HbMakeCodeLengths,The following statement contains a magic number: parent[0] = -2;
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,HbMakeCodeLengths,The following statement contains a magic number: !(nHeap < (BZip2Constants.MAX_ALPHA_SIZE + 2))
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,HbMakeCodeLengths,The following statement contains a magic number: !(nNodes < (BZip2Constants.MAX_ALPHA_SIZE * 2))
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,HbMakeCodeLengths,The following statement contains a magic number: j = weight[i] >> 8;
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,HbMakeCodeLengths,The following statement contains a magic number: j = 1 + (j / 2);
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,HbMakeCodeLengths,The following statement contains a magic number: weight[i] = j << 8;
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,CBZip2OutputStream,The following statement contains a magic number: workFactor = 50;
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,CBZip2OutputStream,The following statement contains a magic number: inBlockSize = 9;
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,CBZip2OutputStream,The following statement contains a magic number: inBlockSize > 9
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,WriteByte,The following statement contains a magic number: int b = (256 + bv) % 256;
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,WriteByte,The following statement contains a magic number: int b = (256 + bv) % 256;
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,WriteByte,The following statement contains a magic number: runLength > 254
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,WriteRun,The following statement contains a magic number: switch (runLength)                  {                      case 1:                          last++;                          block[last + 1] = (char)currentChar;                          break;                      case 2:                          last++;                          block[last + 1] = (char)currentChar;                          last++;                          block[last + 1] = (char)currentChar;                          break;                      case 3:                          last++;                          block[last + 1] = (char)currentChar;                          last++;                          block[last + 1] = (char)currentChar;                          last++;                          block[last + 1] = (char)currentChar;                          break;                      default:                          inUse[runLength - 4] = true;                          last++;                          block[last + 1] = (char)currentChar;                          last++;                          block[last + 1] = (char)currentChar;                          last++;                          block[last + 1] = (char)currentChar;                          last++;                          block[last + 1] = (char)currentChar;                          last++;                          block[last + 1] = (char)(runLength - 4);                          break;                  }
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,WriteRun,The following statement contains a magic number: switch (runLength)                  {                      case 1:                          last++;                          block[last + 1] = (char)currentChar;                          break;                      case 2:                          last++;                          block[last + 1] = (char)currentChar;                          last++;                          block[last + 1] = (char)currentChar;                          break;                      case 3:                          last++;                          block[last + 1] = (char)currentChar;                          last++;                          block[last + 1] = (char)currentChar;                          last++;                          block[last + 1] = (char)currentChar;                          break;                      default:                          inUse[runLength - 4] = true;                          last++;                          block[last + 1] = (char)currentChar;                          last++;                          block[last + 1] = (char)currentChar;                          last++;                          block[last + 1] = (char)currentChar;                          last++;                          block[last + 1] = (char)currentChar;                          last++;                          block[last + 1] = (char)(runLength - 4);                          break;                  }
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,WriteRun,The following statement contains a magic number: switch (runLength)                  {                      case 1:                          last++;                          block[last + 1] = (char)currentChar;                          break;                      case 2:                          last++;                          block[last + 1] = (char)currentChar;                          last++;                          block[last + 1] = (char)currentChar;                          break;                      case 3:                          last++;                          block[last + 1] = (char)currentChar;                          last++;                          block[last + 1] = (char)currentChar;                          last++;                          block[last + 1] = (char)currentChar;                          break;                      default:                          inUse[runLength - 4] = true;                          last++;                          block[last + 1] = (char)currentChar;                          last++;                          block[last + 1] = (char)currentChar;                          last++;                          block[last + 1] = (char)currentChar;                          last++;                          block[last + 1] = (char)currentChar;                          last++;                          block[last + 1] = (char)(runLength - 4);                          break;                  }
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,WriteRun,The following statement contains a magic number: switch (runLength)                  {                      case 1:                          last++;                          block[last + 1] = (char)currentChar;                          break;                      case 2:                          last++;                          block[last + 1] = (char)currentChar;                          last++;                          block[last + 1] = (char)currentChar;                          break;                      case 3:                          last++;                          block[last + 1] = (char)currentChar;                          last++;                          block[last + 1] = (char)currentChar;                          last++;                          block[last + 1] = (char)currentChar;                          break;                      default:                          inUse[runLength - 4] = true;                          last++;                          block[last + 1] = (char)currentChar;                          last++;                          block[last + 1] = (char)currentChar;                          last++;                          block[last + 1] = (char)currentChar;                          last++;                          block[last + 1] = (char)currentChar;                          last++;                          block[last + 1] = (char)(runLength - 4);                          break;                  }
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,InitBlock,The following statement contains a magic number: i < 256
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,InitBlock,The following statement contains a magic number: allowableBlockSize = BZip2Constants.baseBlockSize * blockSize100k - 20;
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,EndBlock,The following statement contains a magic number: combinedCRC = (combinedCRC << 1) | (int)(((uint)combinedCRC) >> 31);
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,BsFinishedWithStream,The following statement contains a magic number: int ch = (bsBuff >> 24);
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,BsFinishedWithStream,The following statement contains a magic number: bsBuff <<= 8;
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,BsFinishedWithStream,The following statement contains a magic number: bsLive -= 8;
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,BsW,The following statement contains a magic number: int ch = (bsBuff >> 24);
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,BsW,The following statement contains a magic number: bsBuff <<= 8;
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,BsW,The following statement contains a magic number: bsLive -= 8;
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,BsW,The following statement contains a magic number: bsLive >= 8
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,BsW,The following statement contains a magic number: bsBuff |= (v << (32 - bsLive - n));
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,BsPutUChar,The following statement contains a magic number: BsW(8' c);
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,BsPutint,The following statement contains a magic number: BsW(8' (u >> 24) & 0xff);
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,BsPutint,The following statement contains a magic number: BsW(8' (u >> 24) & 0xff);
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,BsPutint,The following statement contains a magic number: BsW(8' (u >> 16) & 0xff);
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,BsPutint,The following statement contains a magic number: BsW(8' (u >> 16) & 0xff);
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,BsPutint,The following statement contains a magic number: BsW(8' (u >> 8) & 0xff);
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,BsPutint,The following statement contains a magic number: BsW(8' (u >> 8) & 0xff);
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,BsPutint,The following statement contains a magic number: BsW(8' u & 0xff);
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: alphaSize = nInUse + 2;
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: nGroups = 2;
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: nMTF < 200
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: cost2 += (short)len[2][icv];
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: cost3 += (short)len[3][icv];
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: cost4 += (short)len[4][icv];
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: cost5 += (short)len[5][icv];
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: cost[2] = cost2;
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: cost[3] = cost3;
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: cost[4] = cost4;
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: cost[5] = cost5;
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: nGroups == 6
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: bc = 999999999;
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: HbMakeCodeLengths(len[t]' rfreq[t]' alphaSize' 20);
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: !(nGroups < 8)
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: !(nSelectors < 32768 && nSelectors <= (2 + (900000 / BZip2Constants.G_SIZE)))
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: !(nSelectors < 32768 && nSelectors <= (2 + (900000 / BZip2Constants.G_SIZE)))
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: !(nSelectors < 32768 && nSelectors <= (2 + (900000 / BZip2Constants.G_SIZE)))
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: minLen = 32;
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: maxLen > 20
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: bool[] inUse16 = new bool[16];
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: BsW(3' nGroups);
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: BsW(15' nSelectors);
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: BsW(5' curr);
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: BsW(2' 2);
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: BsW(2' 2);
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: BsW(2' 3);
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: BsW(2' 3);
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,MoveToFrontCodeAndSend,The following statement contains a magic number: BsPutIntVS(24' origPtr);
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,SimpleSort,The following statement contains a magic number: bigN < 2
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,MainSort,The following statement contains a magic number: int[] runningOrder = new int[256];
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,MainSort,The following statement contains a magic number: int[] copy = new int[256];
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,MainSort,The following statement contains a magic number: bool[] bigDone = new bool[256];
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,MainSort,The following statement contains a magic number: block[last + i + 2] = block[(i % (last + 1)) + 1];
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,MainSort,The following statement contains a magic number: last < 4000
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,RandomiseBlock,The following statement contains a magic number: i < 256
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,RandomiseBlock,The following statement contains a magic number: rTPos == 512
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,FullGtU,The following statement contains a magic number: k -= 4;
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,AllocateCompressStructures,The following statement contains a magic number: ftab = new int[65537];
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,AllocateCompressStructures,The following statement contains a magic number: szptr = new short[2 * n];
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: char[] yy = new char[256];
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: switch (zPend % 2)                      {                          case 0:                              szptr[wr] = (short)BZip2Constants.RUNA;                              wr++;                              mtfFreq[BZip2Constants.RUNA]++;                              break;                          case 1:                              szptr[wr] = (short)BZip2Constants.RUNB;                              wr++;                              mtfFreq[BZip2Constants.RUNB]++;                              break;                      }
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: zPend < 2
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: zPend = (zPend - 2) / 2;
Magic Number,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: zPend = (zPend - 2) / 2;
Magic Number,Compress.SevenZip.Compress.BZip2,CRC,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CRC.cs,UpdateCRC,The following statement contains a magic number: int temp = (globalCrc >> 24) ^ inCh;
Magic Number,Compress.SevenZip.Compress.BZip2,CRC,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CRC.cs,UpdateCRC,The following statement contains a magic number: temp = 256 + temp;
Magic Number,Compress.SevenZip.Compress.BZip2,CRC,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CRC.cs,UpdateCRC,The following statement contains a magic number: globalCrc = (globalCrc << 8) ^ CRC.crc32Table[temp];
Magic Number,Compress.SevenZip.Compress.LZMA,State,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaBase.cs,UpdateChar,The following statement contains a magic number: Index < 4
Magic Number,Compress.SevenZip.Compress.LZMA,State,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaBase.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,Compress.SevenZip.Compress.LZMA,State,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaBase.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,Compress.SevenZip.Compress.LZMA,State,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaBase.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,Compress.SevenZip.Compress.LZMA,State,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaBase.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,Compress.SevenZip.Compress.LZMA,State,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaBase.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,Compress.SevenZip.Compress.LZMA,State,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaBase.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,Compress.SevenZip.Compress.LZMA,State,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaBase.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,Compress.SevenZip.Compress.LZMA,State,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaBase.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,Compress.SevenZip.Compress.LZMA,State,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaBase.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,Compress.SevenZip.Compress.LZMA,State,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaBase.cs,IsCharState,The following statement contains a magic number: return Index < 7;
Magic Number,Compress.SevenZip.Compress.LZMA,Decoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaDecoder.cs,CreateDictionary,The following statement contains a magic number: int blockSize = Math.Max(m_DictionarySize' (1 << 12));
Magic Number,Compress.SevenZip.Compress.LZMA,Decoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaDecoder.cs,SetLiteralProperties,The following statement contains a magic number: lp > 8
Magic Number,Compress.SevenZip.Compress.LZMA,Decoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaDecoder.cs,SetLiteralProperties,The following statement contains a magic number: lc > 8
Magic Number,Compress.SevenZip.Compress.LZMA,Decoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: int lc = properties[0] % 9;
Magic Number,Compress.SevenZip.Compress.LZMA,Decoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: int remainder = properties[0] / 9;
Magic Number,Compress.SevenZip.Compress.LZMA,Decoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: int lp = remainder % 5;
Magic Number,Compress.SevenZip.Compress.LZMA,Decoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: int pb = remainder / 5;
Magic Number,Compress.SevenZip.Compress.LZMA,Decoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: m_DictionarySize += properties[1 + i] << (i * 8);
Magic Number,Compress.SevenZip.Compress.LZMA,Decoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: i < 4
Magic Number,Compress.SevenZip.Compress.LZMA,Decoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: properties.Length >= 5
Magic Number,Compress.SevenZip.Compress.LZMA,LiteralDecoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaDecoder.cs,GetState,The following statement contains a magic number: return ((pos & m_PosMask) << m_NumPrevBits) + (uint)(prevByte >> (8 - m_NumPrevBits));
Magic Number,Compress.SevenZip.Compress.LZMA,Decoder2,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaDecoder.cs,DecodeWithMatchByte,The following statement contains a magic number: uint matchBit = (uint)(matchByte >> 7) & 1;
Magic Number,Compress.SevenZip.Compress.LZMA,Decoder2,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaDecoder.cs,DecodeWithMatchByte,The following statement contains a magic number: uint bit = m_Decoders[((1 + matchBit) << 8) + symbol].Decode(rangeDecoder);
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,Encoder,The following statement contains a magic number: const Byte kFastSlots = 22;
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,Encoder,The following statement contains a magic number: int c = 2;
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: pos < (1 << 11)
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 10] + 20);
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 10] + 20);
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: pos < (1 << 21)
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 20] + 40);
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 20] + 40);
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 6] + 12);
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 6] + 12);
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: pos < (1 << 17)
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 16] + 32);
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 16] + 32);
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: pos < (1 << 27)
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 26] + 52);
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 26] + 52);
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,Create,The following statement contains a magic number: int numHashBytes = 4;
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,Create,The following statement contains a magic number: numHashBytes = 2;
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,ReadMatchDistances,The following statement contains a magic number: lenRes = _matchDistances[numDistancePairs - 2];
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: numAvailableBytes < 2
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: lenMain < 2 && currentByte != matchByte && repLens[repMaxIndex] < 2
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: lenMain < 2 && currentByte != matchByte && repLens[repMaxIndex] < 2
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: lenEnd < 2
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: _optimum[0].Backs2 = reps[2];
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: _optimum[0].Backs3 = reps[3];
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: repLen < 2
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice(repLen - 2' posState);
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: len = ((repLens[0] >= 2) ? repLens[0] + 1 : 2);
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: len = ((repLens[0] >= 2) ? repLens[0] + 1 : 2);
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: offs += 2;
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: offs += 2;
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: _optimum[cur].Backs2 = reps[2];
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: _optimum[cur].Backs3 = reps[3];
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: numAvailableBytes < 2
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: lenTest2 >= 2
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: UInt32 startLen = 2;
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: lenTest < 2
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: lenTest2 >= 2
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: numDistancePairs += 2;
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: offs += 2;
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: lenTest2 >= 2
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: offs += 2;
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,ChangePair,The following statement contains a magic number: const int kDif = 7;
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,ChangePair,The following statement contains a magic number: return (smallDist < ((UInt32)(1) << (32 - kDif)) && bigDist >= (smallDist << kDif));
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,WriteEndMarker,The following statement contains a magic number: int footerBits = 30;
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: _matchPriceCount >= (1 << 7)
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: nowPos64 - progressPosValuePrev >= (1 << 12)
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: properties[0] = (Byte)((_posStateBits * 5 + _numLiteralPosStateBits) * 9 + _numLiteralContextBits);
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: properties[0] = (Byte)((_posStateBits * 5 + _numLiteralPosStateBits) * 9 + _numLiteralContextBits);
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: properties[1 + i] = (Byte)((_dictionarySize >> (8 * i)) & 0xFF);
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: i < 4
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,FillDistancesPrices,The following statement contains a magic number: UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: switch (propIDs[i])                  {                      case CoderPropID.NumFastBytes:                          {                              if (!(prop is Int32))                                  throw new InvalidParamException();                              Int32 numFastBytes = (Int32)prop;                              if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)                                  throw new InvalidParamException();                              _numFastBytes = (UInt32)numFastBytes;                              break;                          }                      case CoderPropID.Algorithm:                          {                              /*                              if (!(prop is Int32))                                  throw new InvalidParamException();                              Int32 maximize = (Int32)prop;                              _fastMode = (maximize == 0);                              _maxMode = (maximize >= 2);                              */                              break;                          }                      case CoderPropID.MatchFinder:                          {                              if (!(prop is String))                                  throw new InvalidParamException();                              EMatchFinderType matchFinderIndexPrev = _matchFinderType;                              int m = FindMatchFinder(((string)prop).ToUpper());                              if (m < 0)                                  throw new InvalidParamException();                              _matchFinderType = (EMatchFinderType)m;                              if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType)                              {                                  _dictionarySizePrev = 0xFFFFFFFF;                                  _matchFinder = null;                              }                              break;                          }                      case CoderPropID.DictionarySize:                          {                              const int kDicLogSizeMaxCompress = 30;                              if (!(prop is Int32))                                  throw new InvalidParamException(); ;                              Int32 dictionarySize = (Int32)prop;                              if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) ||                                  dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))                                  throw new InvalidParamException();                              _dictionarySize = (UInt32)dictionarySize;                              int dicLogSize;                              for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)                                  if (dictionarySize <= ((UInt32)(1) << dicLogSize))                                      break;                              _distTableSize = (UInt32)dicLogSize * 2;                              break;                          }                      case CoderPropID.PosStateBits:                          {                              if (!(prop is Int32))                                  throw new InvalidParamException();                              Int32 v = (Int32)prop;                              if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)                                  throw new InvalidParamException();                              _posStateBits = (int)v;                              _posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;                              break;                          }                      case CoderPropID.LitPosBits:                          {                              if (!(prop is Int32))                                  throw new InvalidParamException();                              Int32 v = (Int32)prop;                              if (v < 0 || v > (UInt32)Base.kNumLitPosStatesBitsEncodingMax)                                  throw new InvalidParamException();                              _numLiteralPosStateBits = (int)v;                              break;                          }                      case CoderPropID.LitContextBits:                          {                              if (!(prop is Int32))                                  throw new InvalidParamException();                              Int32 v = (Int32)prop;                              if (v < 0 || v > (UInt32)Base.kNumLitContextBitsMax)                                  throw new InvalidParamException(); ;                              _numLiteralContextBits = (int)v;                              break;                          }                      case CoderPropID.EndMarker:                          {                              if (!(prop is Boolean))                                  throw new InvalidParamException();                              SetWriteEndMarkerMode((Boolean)prop);                              break;                          }                      default:                          throw new InvalidParamException();                  }
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: switch (propIDs[i])                  {                      case CoderPropID.NumFastBytes:                          {                              if (!(prop is Int32))                                  throw new InvalidParamException();                              Int32 numFastBytes = (Int32)prop;                              if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)                                  throw new InvalidParamException();                              _numFastBytes = (UInt32)numFastBytes;                              break;                          }                      case CoderPropID.Algorithm:                          {                              /*                              if (!(prop is Int32))                                  throw new InvalidParamException();                              Int32 maximize = (Int32)prop;                              _fastMode = (maximize == 0);                              _maxMode = (maximize >= 2);                              */                              break;                          }                      case CoderPropID.MatchFinder:                          {                              if (!(prop is String))                                  throw new InvalidParamException();                              EMatchFinderType matchFinderIndexPrev = _matchFinderType;                              int m = FindMatchFinder(((string)prop).ToUpper());                              if (m < 0)                                  throw new InvalidParamException();                              _matchFinderType = (EMatchFinderType)m;                              if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType)                              {                                  _dictionarySizePrev = 0xFFFFFFFF;                                  _matchFinder = null;                              }                              break;                          }                      case CoderPropID.DictionarySize:                          {                              const int kDicLogSizeMaxCompress = 30;                              if (!(prop is Int32))                                  throw new InvalidParamException(); ;                              Int32 dictionarySize = (Int32)prop;                              if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) ||                                  dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))                                  throw new InvalidParamException();                              _dictionarySize = (UInt32)dictionarySize;                              int dicLogSize;                              for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)                                  if (dictionarySize <= ((UInt32)(1) << dicLogSize))                                      break;                              _distTableSize = (UInt32)dicLogSize * 2;                              break;                          }                      case CoderPropID.PosStateBits:                          {                              if (!(prop is Int32))                                  throw new InvalidParamException();                              Int32 v = (Int32)prop;                              if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)                                  throw new InvalidParamException();                              _posStateBits = (int)v;                              _posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;                              break;                          }                      case CoderPropID.LitPosBits:                          {                              if (!(prop is Int32))                                  throw new InvalidParamException();                              Int32 v = (Int32)prop;                              if (v < 0 || v > (UInt32)Base.kNumLitPosStatesBitsEncodingMax)                                  throw new InvalidParamException();                              _numLiteralPosStateBits = (int)v;                              break;                          }                      case CoderPropID.LitContextBits:                          {                              if (!(prop is Int32))                                  throw new InvalidParamException();                              Int32 v = (Int32)prop;                              if (v < 0 || v > (UInt32)Base.kNumLitContextBitsMax)                                  throw new InvalidParamException(); ;                              _numLiteralContextBits = (int)v;                              break;                          }                      case CoderPropID.EndMarker:                          {                              if (!(prop is Boolean))                                  throw new InvalidParamException();                              SetWriteEndMarkerMode((Boolean)prop);                              break;                          }                      default:                          throw new InvalidParamException();                  }
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: switch (propIDs[i])                  {                      case CoderPropID.NumFastBytes:                          {                              if (!(prop is Int32))                                  throw new InvalidParamException();                              Int32 numFastBytes = (Int32)prop;                              if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)                                  throw new InvalidParamException();                              _numFastBytes = (UInt32)numFastBytes;                              break;                          }                      case CoderPropID.Algorithm:                          {                              /*                              if (!(prop is Int32))                                  throw new InvalidParamException();                              Int32 maximize = (Int32)prop;                              _fastMode = (maximize == 0);                              _maxMode = (maximize >= 2);                              */                              break;                          }                      case CoderPropID.MatchFinder:                          {                              if (!(prop is String))                                  throw new InvalidParamException();                              EMatchFinderType matchFinderIndexPrev = _matchFinderType;                              int m = FindMatchFinder(((string)prop).ToUpper());                              if (m < 0)                                  throw new InvalidParamException();                              _matchFinderType = (EMatchFinderType)m;                              if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType)                              {                                  _dictionarySizePrev = 0xFFFFFFFF;                                  _matchFinder = null;                              }                              break;                          }                      case CoderPropID.DictionarySize:                          {                              const int kDicLogSizeMaxCompress = 30;                              if (!(prop is Int32))                                  throw new InvalidParamException(); ;                              Int32 dictionarySize = (Int32)prop;                              if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) ||                                  dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))                                  throw new InvalidParamException();                              _dictionarySize = (UInt32)dictionarySize;                              int dicLogSize;                              for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)                                  if (dictionarySize <= ((UInt32)(1) << dicLogSize))                                      break;                              _distTableSize = (UInt32)dicLogSize * 2;                              break;                          }                      case CoderPropID.PosStateBits:                          {                              if (!(prop is Int32))                                  throw new InvalidParamException();                              Int32 v = (Int32)prop;                              if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)                                  throw new InvalidParamException();                              _posStateBits = (int)v;                              _posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;                              break;                          }                      case CoderPropID.LitPosBits:                          {                              if (!(prop is Int32))                                  throw new InvalidParamException();                              Int32 v = (Int32)prop;                              if (v < 0 || v > (UInt32)Base.kNumLitPosStatesBitsEncodingMax)                                  throw new InvalidParamException();                              _numLiteralPosStateBits = (int)v;                              break;                          }                      case CoderPropID.LitContextBits:                          {                              if (!(prop is Int32))                                  throw new InvalidParamException();                              Int32 v = (Int32)prop;                              if (v < 0 || v > (UInt32)Base.kNumLitContextBitsMax)                                  throw new InvalidParamException(); ;                              _numLiteralContextBits = (int)v;                              break;                          }                      case CoderPropID.EndMarker:                          {                              if (!(prop is Boolean))                                  throw new InvalidParamException();                              SetWriteEndMarkerMode((Boolean)prop);                              break;                          }                      default:                          throw new InvalidParamException();                  }
Magic Number,Compress.SevenZip.Compress.LZMA,LiteralEncoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,GetSubCoder,The following statement contains a magic number: return m_Coders[((pos & m_PosMask) << m_NumPrevBits) + (uint)(prevByte >> (8 - m_NumPrevBits))];
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder2,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,EncodeMatched,The following statement contains a magic number: state += ((1 + matchBit) << 8);
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder2,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,GetPrice,The following statement contains a magic number: int i = 7;
Magic Number,Compress.SevenZip.Compress.LZMA,Encoder2,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoder.cs,GetPrice,The following statement contains a magic number: price += m_Encoders[((1 + matchBit) << 8) + context].GetPrice(bit);
Magic Number,Compress.SevenZip.Compress.LZMA,LzmaEncoderProperties,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoderProperties.cs,LzmaEncoderProperties,The following statement contains a magic number: int posStateBits = 2;
Magic Number,Compress.SevenZip.Compress.LZMA,LzmaEncoderProperties,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoderProperties.cs,LzmaEncoderProperties,The following statement contains a magic number: int litContextBits = 4;
Magic Number,Compress.SevenZip.Compress.LZMA,LzmaEncoderProperties,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaEncoderProperties.cs,LzmaEncoderProperties,The following statement contains a magic number: int algorithm = 2;
Magic Number,Compress.SevenZip.Compress.LZMA,LzmaStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaStream.cs,LzmaStream,The following statement contains a magic number: MemoryStream propStream = new MemoryStream(5);
Magic Number,Compress.SevenZip.Compress.LZMA,LzmaStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaStream.cs,decodeChunkHeader,The following statement contains a magic number: availableBytes = (control & 0x1F) << 16;
Magic Number,Compress.SevenZip.Compress.LZMA,LzmaStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaStream.cs,decodeChunkHeader,The following statement contains a magic number: availableBytes += (inputStream.ReadByte() << 8) + inputStream.ReadByte() + 1;
Magic Number,Compress.SevenZip.Compress.LZMA,LzmaStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaStream.cs,decodeChunkHeader,The following statement contains a magic number: inputPosition += 2;
Magic Number,Compress.SevenZip.Compress.LZMA,LzmaStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaStream.cs,decodeChunkHeader,The following statement contains a magic number: rangeDecoderLimit = (inputStream.ReadByte() << 8) + inputStream.ReadByte() + 1;
Magic Number,Compress.SevenZip.Compress.LZMA,LzmaStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaStream.cs,decodeChunkHeader,The following statement contains a magic number: inputPosition += 2;
Magic Number,Compress.SevenZip.Compress.LZMA,LzmaStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaStream.cs,Seek,The following statement contains a magic number: byte[] tmpBuff=new byte[1024];
Magic Number,Compress.SevenZip.Compress.LZMA,LzmaStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaStream.cs,Seek,The following statement contains a magic number: int sizenow = sizeToGo > 1024 ? 1024 : (int)sizeToGo;
Magic Number,Compress.SevenZip.Compress.LZMA,LzmaStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZMA\LzmaStream.cs,Seek,The following statement contains a magic number: int sizenow = sizeToGo > 1024 ? 1024 : (int)sizeToGo;
Magic Number,Compress.SevenZip.Compress.LZ,BinTree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZ\LzBinTree.cs,SetType,The following statement contains a magic number: HASH_ARRAY = (numHashBytes > 2);
Magic Number,Compress.SevenZip.Compress.LZ,BinTree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZ\LzBinTree.cs,SetType,The following statement contains a magic number: kMinMatchCheck = 4;
Magic Number,Compress.SevenZip.Compress.LZ,BinTree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: historySize > kMaxValForNormalize - 256
Magic Number,Compress.SevenZip.Compress.LZ,BinTree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: _cutValue = 16 + (matchMaxLen >> 1);
Magic Number,Compress.SevenZip.Compress.LZ,BinTree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: UInt32 windowReservSize = (historySize + keepAddBufferBefore +                      matchMaxLen + keepAddBufferAfter) / 2 + 256;
Magic Number,Compress.SevenZip.Compress.LZ,BinTree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: UInt32 windowReservSize = (historySize + keepAddBufferBefore +                      matchMaxLen + keepAddBufferAfter) / 2 + 256;
Magic Number,Compress.SevenZip.Compress.LZ,BinTree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: _son = new UInt32[(_cyclicBufferSize = cyclicBufferSize) * 2];
Magic Number,Compress.SevenZip.Compress.LZ,BinTree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: hs |= (hs >> 2);
Magic Number,Compress.SevenZip.Compress.LZ,BinTree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: hs |= (hs >> 4);
Magic Number,Compress.SevenZip.Compress.LZ,BinTree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: hs |= (hs >> 8);
Magic Number,Compress.SevenZip.Compress.LZ,BinTree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: hs > (1 << 24)
Magic Number,Compress.SevenZip.Compress.LZ,BinTree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);
Magic Number,Compress.SevenZip.Compress.LZ,BinTree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);
Magic Number,Compress.SevenZip.Compress.LZ,BinTree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;
Magic Number,Compress.SevenZip.Compress.LZ,BinTree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;
Magic Number,Compress.SevenZip.Compress.LZ,BinTree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: distances[offset++] = maxLen = 2;
Magic Number,Compress.SevenZip.Compress.LZ,BinTree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: offset -= 2;
Magic Number,Compress.SevenZip.Compress.LZ,BinTree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: distances[offset++] = maxLen = 3;
Magic Number,Compress.SevenZip.Compress.LZ,BinTree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: offset -= 2;
Magic Number,Compress.SevenZip.Compress.LZ,BinTree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);
Magic Number,Compress.SevenZip.Compress.LZ,BinTree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);
Magic Number,Compress.SevenZip.Compress.LZ,BinTree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;
Magic Number,Compress.SevenZip.Compress.LZ,BinTree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;
Magic Number,Compress.SevenZip.Compress.LZ,BinTree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\LZ\LzBinTree.cs,Normalize,The following statement contains a magic number: NormalizeLinks(_son' _cyclicBufferSize * 2' subValue);
Magic Number,Compress.SevenZip.Compress.PPmd.H,FreqData,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\FreqData.cs,GetStats,The following statement contains a magic number: return Utility.readIntLittleEndian(Memory' Address + 2);
Magic Number,Compress.SevenZip.Compress.PPmd.H,FreqData,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\FreqData.cs,SetStats,The following statement contains a magic number: Utility.WriteLittleEndian(Memory' Address + 2' state);
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,InitBlock,The following statement contains a magic number: SEE2Cont[i] = new SEE2Context[16];
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,InitBlock,The following statement contains a magic number: i < 25
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,InitBlock,The following statement contains a magic number: binSumm[i2] = new int[64];
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,InitBlock,The following statement contains a magic number: i2 < 128
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,restartModelRare,The following statement contains a magic number: initRL = -(maxOrder < 12 ? maxOrder : 12) - 1;
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,restartModelRare,The following statement contains a magic number: initRL = -(maxOrder < 12 ? maxOrder : 12) - 1;
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,restartModelRare,The following statement contains a magic number: minContext.NumStats = 256;
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,restartModelRare,The following statement contains a magic number: addr = subAlloc.allocUnits(256 / 2);
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,restartModelRare,The following statement contains a magic number: addr = subAlloc.allocUnits(256 / 2);
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,restartModelRare,The following statement contains a magic number: i < 256
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,restartModelRare,The following statement contains a magic number: binSumm[i][k + m] = BIN_SCALE - InitBinEsc[k] / (i + 2);
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,restartModelRare,The following statement contains a magic number: m < 64
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,restartModelRare,The following statement contains a magic number: k < 8
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,restartModelRare,The following statement contains a magic number: i < 128
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,restartModelRare,The following statement contains a magic number: SEE2Cont[i][k].Initialize(5 * i + 10);
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,restartModelRare,The following statement contains a magic number: SEE2Cont[i][k].Initialize(5 * i + 10);
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,restartModelRare,The following statement contains a magic number: k < 16
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,restartModelRare,The following statement contains a magic number: i < 25
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,startModelRare,The following statement contains a magic number: NS2BSIndx[1] = 2;
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,startModelRare,The following statement contains a magic number: NS2BSIndx[2 + j] = 4;
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,startModelRare,The following statement contains a magic number: NS2BSIndx[2 + j] = 4;
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,startModelRare,The following statement contains a magic number: j < 9
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,startModelRare,The following statement contains a magic number: NS2BSIndx[11 + j] = 6;
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,startModelRare,The following statement contains a magic number: NS2BSIndx[11 + j] = 6;
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,startModelRare,The following statement contains a magic number: j < 256 - 11
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,startModelRare,The following statement contains a magic number: j < 256 - 11
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,startModelRare,The following statement contains a magic number: i < 3
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,startModelRare,The following statement contains a magic number: i < 256
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,createSuccessors,The following statement contains a magic number: upState.Freq = 1 + ((2 * cf <= s0) ? (5 * cf > s0 ? 1 : 0) : ((2 * cf + 3 * s0 - 1) / (2 * s0)));
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,createSuccessors,The following statement contains a magic number: upState.Freq = 1 + ((2 * cf <= s0) ? (5 * cf > s0 ? 1 : 0) : ((2 * cf + 3 * s0 - 1) / (2 * s0)));
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,createSuccessors,The following statement contains a magic number: upState.Freq = 1 + ((2 * cf <= s0) ? (5 * cf > s0 ? 1 : 0) : ((2 * cf + 3 * s0 - 1) / (2 * s0)));
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,createSuccessors,The following statement contains a magic number: upState.Freq = 1 + ((2 * cf <= s0) ? (5 * cf > s0 ? 1 : 0) : ((2 * cf + 3 * s0 - 1) / (2 * s0)));
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,createSuccessors,The following statement contains a magic number: upState.Freq = 1 + ((2 * cf <= s0) ? (5 * cf > s0 ? 1 : 0) : ((2 * cf + 3 * s0 - 1) / (2 * s0)));
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,updateModel,The following statement contains a magic number: p.IncrementFreq(2);
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,updateModel,The following statement contains a magic number: pc.FreqData.IncrementSummFreq(2);
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,updateModel,The following statement contains a magic number: p.Freq < MAX_FREQ - 9
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,updateModel,The following statement contains a magic number: fs.Freq < MAX_FREQ / 4 && pc.Address != 0
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,updateModel,The following statement contains a magic number: int sum = ((2 * ns1 < ns) ? 1 : 0) + 2 * (((4 * ns1 <= ns) ? 1 : 0) & ((pc.FreqData.SummFreq <= 8 * ns1) ? 1 : 0));
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,updateModel,The following statement contains a magic number: int sum = ((2 * ns1 < ns) ? 1 : 0) + 2 * (((4 * ns1 <= ns) ? 1 : 0) & ((pc.FreqData.SummFreq <= 8 * ns1) ? 1 : 0));
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,updateModel,The following statement contains a magic number: int sum = ((2 * ns1 < ns) ? 1 : 0) + 2 * (((4 * ns1 <= ns) ? 1 : 0) & ((pc.FreqData.SummFreq <= 8 * ns1) ? 1 : 0));
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,updateModel,The following statement contains a magic number: int sum = ((2 * ns1 < ns) ? 1 : 0) + 2 * (((4 * ns1 <= ns) ? 1 : 0) & ((pc.FreqData.SummFreq <= 8 * ns1) ? 1 : 0));
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,updateModel,The following statement contains a magic number: cf = 2 * fs.Freq * (pc.FreqData.SummFreq + 6);
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,updateModel,The following statement contains a magic number: cf = 2 * fs.Freq * (pc.FreqData.SummFreq + 6);
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,updateModel,The following statement contains a magic number: cf = 1 + (cf > sf ? 1 : 0) + (cf >= 4 * sf ? 1 : 0);
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,updateModel,The following statement contains a magic number: pc.FreqData.IncrementSummFreq(3);
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,updateModel,The following statement contains a magic number: cf < 6 * sf
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,decodeInit,The following statement contains a magic number: j < 16
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,decodeInit,The following statement contains a magic number: i < 25
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,decodeChar,The following statement contains a magic number: return -2;
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,decodeChar,The following statement contains a magic number: i < 256
Magic Number,Compress.SevenZip.Compress.PPmd.H,ModelPPM,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\ModelPPM.cs,decodeChar,The following statement contains a magic number: return -2;
Magic Number,Compress.SevenZip.Compress.PPmd.H,PPMContext,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\PPMContext.cs,getSuffix,The following statement contains a magic number: suffix = Utility.readIntLittleEndian(Memory' Address + 8);
Magic Number,Compress.SevenZip.Compress.PPmd.H,PPMContext,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\PPMContext.cs,setSuffix,The following statement contains a magic number: Utility.WriteLittleEndian(Memory' Address + 8' suffix);
Magic Number,Compress.SevenZip.Compress.PPmd.H,PPMContext,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\PPMContext.cs,rescale,The following statement contains a magic number: temp.IncrementFreq(4);
Magic Number,Compress.SevenZip.Compress.PPmd.H,PPMContext,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\PPMContext.cs,rescale,The following statement contains a magic number: freqData.IncrementSummFreq(4);
Magic Number,Compress.SevenZip.Compress.PPmd.H,PPMContext,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\PPMContext.cs,getArrayIndex,The following statement contains a magic number: ret += Model.HiBitsFlag + 2 * Model.getHB2Flag()[rs.Symbol];
Magic Number,Compress.SevenZip.Compress.PPmd.H,PPMContext,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\PPMContext.cs,getArrayIndex,The following statement contains a magic number: ret += ((Utility.URShift(Model.RunLength' 26)) & 0x20);
Magic Number,Compress.SevenZip.Compress.PPmd.H,PPMContext,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\PPMContext.cs,decodeBinSymbol,The following statement contains a magic number: rs.IncrementFreq((rs.Freq < 128) ? 1 : 0);
Magic Number,Compress.SevenZip.Compress.PPmd.H,PPMContext,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\PPMContext.cs,decodeBinSymbol,The following statement contains a magic number: bs = ((bs + ModelPPM.INTERVAL - getMean(bs' ModelPPM.PERIOD_BITS' 2)) & 0xffff);
Magic Number,Compress.SevenZip.Compress.PPmd.H,PPMContext,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\PPMContext.cs,update1,The following statement contains a magic number: model.FoundState.IncrementFreq(4);
Magic Number,Compress.SevenZip.Compress.PPmd.H,PPMContext,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\PPMContext.cs,update1,The following statement contains a magic number: freqData.IncrementSummFreq(4);
Magic Number,Compress.SevenZip.Compress.PPmd.H,PPMContext,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\PPMContext.cs,update1_0,The following statement contains a magic number: model.PrevSuccess = 2 * model.FoundState.Freq > freqData.SummFreq ? 1 : 0;
Magic Number,Compress.SevenZip.Compress.PPmd.H,PPMContext,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\PPMContext.cs,update1_0,The following statement contains a magic number: freqData.IncrementSummFreq(4);
Magic Number,Compress.SevenZip.Compress.PPmd.H,PPMContext,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\PPMContext.cs,update1_0,The following statement contains a magic number: model.FoundState.IncrementFreq(4);
Magic Number,Compress.SevenZip.Compress.PPmd.H,PPMContext,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\PPMContext.cs,update2,The following statement contains a magic number: model.FoundState.IncrementFreq(4);
Magic Number,Compress.SevenZip.Compress.PPmd.H,PPMContext,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\PPMContext.cs,update2,The following statement contains a magic number: freqData.IncrementSummFreq(4);
Magic Number,Compress.SevenZip.Compress.PPmd.H,PPMContext,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\PPMContext.cs,makeEscFreq2,The following statement contains a magic number: idx2 += 2 * ((freqData.SummFreq < 11 * numStats) ? 1 : 0);
Magic Number,Compress.SevenZip.Compress.PPmd.H,PPMContext,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\PPMContext.cs,makeEscFreq2,The following statement contains a magic number: idx2 += 2 * ((freqData.SummFreq < 11 * numStats) ? 1 : 0);
Magic Number,Compress.SevenZip.Compress.PPmd.H,PPMContext,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\PPMContext.cs,makeEscFreq2,The following statement contains a magic number: idx2 += 4 * ((model.NumMasked > Diff) ? 1 : 0);
Magic Number,Compress.SevenZip.Compress.PPmd.H,PPMContext,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\PPMContext.cs,makeEscFreq2,The following statement contains a magic number: numStats != 256
Magic Number,Compress.SevenZip.Compress.PPmd.H,PPMContext,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\PPMContext.cs,makeEscFreq,The following statement contains a magic number: idx2 += 2 * ((freqData.SummFreq < 11 * numStats) ? 1 : 0);
Magic Number,Compress.SevenZip.Compress.PPmd.H,PPMContext,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\PPMContext.cs,makeEscFreq,The following statement contains a magic number: idx2 += 2 * ((freqData.SummFreq < 11 * numStats) ? 1 : 0);
Magic Number,Compress.SevenZip.Compress.PPmd.H,PPMContext,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\PPMContext.cs,makeEscFreq,The following statement contains a magic number: idx2 += 4 * ((numMasked > nonMasked) ? 1 : 0);
Magic Number,Compress.SevenZip.Compress.PPmd.H,PPMContext,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\PPMContext.cs,makeEscFreq,The following statement contains a magic number: numStats != 256
Magic Number,Compress.SevenZip.Compress.PPmd.H,PPMContext,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\PPMContext.cs,decodeSymbol1,The following statement contains a magic number: model.PrevSuccess = (2 * HiCnt > coder.SubRange.Scale) ? 1 : 0;
Magic Number,Compress.SevenZip.Compress.PPmd.H,PPMContext,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\PPMContext.cs,decodeSymbol1,The following statement contains a magic number: HiCnt += 4;
Magic Number,Compress.SevenZip.Compress.PPmd.H,PPMContext,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\PPMContext.cs,decodeSymbol1,The following statement contains a magic number: freqData.IncrementSummFreq(4);
Magic Number,Compress.SevenZip.Compress.PPmd.H,RangeCoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\RangeCoder.cs,Init,The following statement contains a magic number: code = ((code << 8) | Char) & UintMask;
Magic Number,Compress.SevenZip.Compress.PPmd.H,RangeCoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\RangeCoder.cs,Init,The following statement contains a magic number: i < 4
Magic Number,Compress.SevenZip.Compress.PPmd.H,RangeCoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\RangeCoder.cs,AriDecNormalize,The following statement contains a magic number: code = ((code << 8) | Char) & UintMask;
Magic Number,Compress.SevenZip.Compress.PPmd.H,RangeCoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\RangeCoder.cs,AriDecNormalize,The following statement contains a magic number: range = (range << 8) & UintMask;
Magic Number,Compress.SevenZip.Compress.PPmd.H,RangeCoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\RangeCoder.cs,AriDecNormalize,The following statement contains a magic number: low = (low << 8) & UintMask;
Magic Number,Compress.SevenZip.Compress.PPmd.H,RarMemBlock,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\RarMemBlock.cs,GetNext,The following statement contains a magic number: next = Utility.readIntLittleEndian(Memory' Address + 4);
Magic Number,Compress.SevenZip.Compress.PPmd.H,RarMemBlock,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\RarMemBlock.cs,SetNext,The following statement contains a magic number: Utility.WriteLittleEndian(Memory' Address + 4' next);
Magic Number,Compress.SevenZip.Compress.PPmd.H,RarMemBlock,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\RarMemBlock.cs,GetNU,The following statement contains a magic number: NU = Utility.readShortLittleEndian(Memory' Address + 2) & 0xffff;
Magic Number,Compress.SevenZip.Compress.PPmd.H,RarMemBlock,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\RarMemBlock.cs,SetNU,The following statement contains a magic number: Utility.WriteLittleEndian(Memory' Address + 2' (short)nu);
Magic Number,Compress.SevenZip.Compress.PPmd.H,RarMemBlock,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\RarMemBlock.cs,GetPrev,The following statement contains a magic number: prev = Utility.readIntLittleEndian(Memory' Address + 8);
Magic Number,Compress.SevenZip.Compress.PPmd.H,RarMemBlock,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\RarMemBlock.cs,SetPrev,The following statement contains a magic number: Utility.WriteLittleEndian(Memory' Address + 8' prev);
Magic Number,Compress.SevenZip.Compress.PPmd.H,SEE2Context,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\SEE2Context.cs,Initialize,The following statement contains a magic number: shift = (ModelPPM.PERIOD_BITS - 4) & 0xff;
Magic Number,Compress.SevenZip.Compress.PPmd.H,SEE2Context,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\SEE2Context.cs,Initialize,The following statement contains a magic number: count = 4;
Magic Number,Compress.SevenZip.Compress.PPmd.H,SEE2Context,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\SEE2Context.cs,update,The following statement contains a magic number: count = (3 << shift++);
Magic Number,Compress.SevenZip.Compress.PPmd.H,State,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\State.cs,GetSuccessor,The following statement contains a magic number: return Utility.readIntLittleEndian(Memory' Address + 2);
Magic Number,Compress.SevenZip.Compress.PPmd.H,State,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\State.cs,SetSuccessor,The following statement contains a magic number: Utility.WriteLittleEndian(Memory' Address + 2' successor);
Magic Number,Compress.SevenZip.Compress.PPmd.H,SubAllocator,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\SubAllocator.cs,startSubAllocator,The following statement contains a magic number: int realAllocSize = 1 + allocSize + 4 * N_INDEXES;
Magic Number,Compress.SevenZip.Compress.PPmd.H,SubAllocator,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\SubAllocator.cs,glueFreeBlocks,The following statement contains a magic number: sz > 128
Magic Number,Compress.SevenZip.Compress.PPmd.H,SubAllocator,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\SubAllocator.cs,allocUnitsRare,The following statement contains a magic number: glueCount = 255;
Magic Number,Compress.SevenZip.Compress.PPmd.H,SubAllocator,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\SubAllocator.cs,initSubAllocator,The following statement contains a magic number: int size2 = FIXED_UNIT_SIZE * (subAllocatorSize / 8 / FIXED_UNIT_SIZE * 7);
Magic Number,Compress.SevenZip.Compress.PPmd.H,SubAllocator,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\SubAllocator.cs,initSubAllocator,The following statement contains a magic number: int size2 = FIXED_UNIT_SIZE * (subAllocatorSize / 8 / FIXED_UNIT_SIZE * 7);
Magic Number,Compress.SevenZip.Compress.PPmd.H,SubAllocator,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\H\SubAllocator.cs,initSubAllocator,The following statement contains a magic number: k < 128
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Allocator,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Allocator.cs,Allocator,The following statement contains a magic number: unitsToIndex = new byte[128];
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Allocator,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Allocator.cs,Allocator,The following statement contains a magic number: unitCount < 128
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Allocator,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Allocator.cs,Initialize,The following statement contains a magic number: uint difference = UnitSize * (AllocatorSize / 8 / UnitSize * 7);
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Allocator,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Allocator.cs,Initialize,The following statement contains a magic number: uint difference = UnitSize * (AllocatorSize / 8 / UnitSize * 7);
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Allocator,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Allocator.cs,MoveUnitsUp,The following statement contains a magic number: oldPointer > BaseUnit + 16 * 1024 || oldPointer > MemoryNodes[index].Next
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Allocator,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Allocator.cs,MoveUnitsUp,The following statement contains a magic number: oldPointer > BaseUnit + 16 * 1024 || oldPointer > MemoryNodes[index].Next
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Allocator,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Allocator.cs,GlueFreeBlocks,The following statement contains a magic number: MemoryNodes[IndexCount - 1].Insert(memoryNode0' 128);
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Allocator,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Allocator.cs,GlueFreeBlocks,The following statement contains a magic number: unitCount > 128
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Allocator,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Allocator.cs,GlueFreeBlocks,The following statement contains a magic number: GlueCount = 1 << 13;
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Allocator,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Allocator.cs,CopyUnits,The following statement contains a magic number: target[2] = source[2];
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Allocator,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Allocator.cs,CopyUnits,The following statement contains a magic number: target[2] = source[2];
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Allocator,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Allocator.cs,CopyUnits,The following statement contains a magic number: target[3] = source[3];
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Allocator,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Allocator.cs,CopyUnits,The following statement contains a magic number: target[3] = source[3];
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Allocator,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Allocator.cs,CopyUnits,The following statement contains a magic number: target[4] = source[4];
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Allocator,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Allocator.cs,CopyUnits,The following statement contains a magic number: target[4] = source[4];
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Allocator,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Allocator.cs,CopyUnits,The following statement contains a magic number: target[5] = source[5];
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Allocator,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Allocator.cs,CopyUnits,The following statement contains a magic number: target[5] = source[5];
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Allocator,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Allocator.cs,CopyUnits,The following statement contains a magic number: target[6] = source[6];
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Allocator,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Allocator.cs,CopyUnits,The following statement contains a magic number: target[6] = source[6];
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Allocator,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Allocator.cs,CopyUnits,The following statement contains a magic number: target[7] = source[7];
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Allocator,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Allocator.cs,CopyUnits,The following statement contains a magic number: target[7] = source[7];
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Allocator,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Allocator.cs,CopyUnits,The following statement contains a magic number: target[8] = source[8];
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Allocator,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Allocator.cs,CopyUnits,The following statement contains a magic number: target[8] = source[8];
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Allocator,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Allocator.cs,CopyUnits,The following statement contains a magic number: target[9] = source[9];
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Allocator,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Allocator.cs,CopyUnits,The following statement contains a magic number: target[9] = source[9];
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Allocator,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Allocator.cs,CopyUnits,The following statement contains a magic number: target[10] = source[10];
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Allocator,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Allocator.cs,CopyUnits,The following statement contains a magic number: target[10] = source[10];
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Allocator,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Allocator.cs,CopyUnits,The following statement contains a magic number: target[11] = source[11];
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Allocator,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Allocator.cs,CopyUnits,The following statement contains a magic number: target[11] = source[11];
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Coder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Coder.cs,RangeEncoderNormalize,The following statement contains a magic number: stream.WriteByte((byte) (low >> 24));
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Coder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Coder.cs,RangeEncoderNormalize,The following statement contains a magic number: range <<= 8;
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Coder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Coder.cs,RangeEncoderNormalize,The following statement contains a magic number: low <<= 8;
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Coder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Coder.cs,RangeEncoderFlush,The following statement contains a magic number: stream.WriteByte((byte) (low >> 24));
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Coder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Coder.cs,RangeEncoderFlush,The following statement contains a magic number: low <<= 8;
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Coder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Coder.cs,RangeEncoderFlush,The following statement contains a magic number: index < 4
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Coder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Coder.cs,RangeDecoderInitialize,The following statement contains a magic number: code = (code << 8) | (byte) stream.ReadByte();
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Coder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Coder.cs,RangeDecoderInitialize,The following statement contains a magic number: index < 4
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Coder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Coder.cs,RangeDecoderNormalize,The following statement contains a magic number: code = (code << 8) | (byte) stream.ReadByte();
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Coder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Coder.cs,RangeDecoderNormalize,The following statement contains a magic number: range <<= 8;
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Coder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Coder.cs,RangeDecoderNormalize,The following statement contains a magic number: low <<= 8;
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,Model,The following statement contains a magic number: numberStatisticsToBinarySummaryIndex[0] = 2 * 0;
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,Model,The following statement contains a magic number: numberStatisticsToBinarySummaryIndex[1] = 2 * 1;
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,Model,The following statement contains a magic number: numberStatisticsToBinarySummaryIndex[index] = 2 * 2;
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,Model,The following statement contains a magic number: numberStatisticsToBinarySummaryIndex[index] = 2 * 2;
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,Model,The following statement contains a magic number: index < 11
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,Model,The following statement contains a magic number: numberStatisticsToBinarySummaryIndex[index] = 2 * 3;
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,Model,The following statement contains a magic number: numberStatisticsToBinarySummaryIndex[index] = 2 * 3;
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,Model,The following statement contains a magic number: index < 256
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,Model,The following statement contains a magic number: index < 260
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,Model,The following statement contains a magic number: see2Contexts = new See2Context[24' 32];
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,Model,The following statement contains a magic number: see2Contexts = new See2Context[24' 32];
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,Model,The following statement contains a magic number: index1 < 24
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,Model,The following statement contains a magic number: emptySee2Context.Shift = (byte)((Signature >> 16) & 0x000000ff);
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,Model,The following statement contains a magic number: emptySee2Context.Count = (byte)(Signature >> 24);
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,Decode,The following statement contains a magic number: byte[] buffer = new byte[65536];
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,StartModel,The following statement contains a magic number: modelOrder < 2
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,StartModel,The following statement contains a magic number: initialRunLength = -((modelOrder < 12) ? modelOrder : 12) - 1;
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,StartModel,The following statement contains a magic number: initialRunLength = -((modelOrder < 12) ? modelOrder : 12) - 1;
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,StartModel,The following statement contains a magic number: maximumContext.NumberStatistics = 255;
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,StartModel,The following statement contains a magic number: maximumContext.SummaryFrequency = (ushort)(maximumContext.NumberStatistics + 2);
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,StartModel,The following statement contains a magic number: maximumContext.Statistics = Allocator.AllocateUnits(256 / 2);
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,StartModel,The following statement contains a magic number: maximumContext.Statistics = Allocator.AllocateUnits(256 / 2);
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,StartModel,The following statement contains a magic number: index < 256
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,StartModel,The following statement contains a magic number: index2 < 8
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,StartModel,The following statement contains a magic number: index2 < 64
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,StartModel,The following statement contains a magic number: probability < 25
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,StartModel,The following statement contains a magic number: probabilities[index1 + 3] == probability + 3
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,StartModel,The following statement contains a magic number: probabilities[index1 + 3] == probability + 3
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,StartModel,The following statement contains a magic number: see2Contexts[probability' index2].Initialize(2 * index1 + 5);
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,StartModel,The following statement contains a magic number: see2Contexts[probability' index2].Initialize(2 * index1 + 5);
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,StartModel,The following statement contains a magic number: index2 < 32
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,StartModel,The following statement contains a magic number: probability < 24
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,UpdateModel,The following statement contains a magic number: cf = (uint)((state.Frequency < MaximumFrequency - 9) ? 2 : 0);
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,UpdateModel,The following statement contains a magic number: cf = (uint)((state.Frequency < MaximumFrequency - 9) ? 2 : 0);
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,UpdateModel,The following statement contains a magic number: (foundStateFrequency < MaximumFrequency / 4) && (context != PpmContext.Zero)
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,UpdateModel,The following statement contains a magic number: currentContext.SummaryFrequency += (ushort)((3 * ns1 + 1 < numberStatistics) ? 1 : 0);
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,UpdateModel,The following statement contains a magic number: cf = (uint)(2 * foundStateFrequency * (currentContext.SummaryFrequency + 6));
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,UpdateModel,The following statement contains a magic number: cf = (uint)(2 * foundStateFrequency * (currentContext.SummaryFrequency + 6));
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,UpdateModel,The following statement contains a magic number: cf = (uint)(1 + ((cf > sf) ? 1 : 0) + ((cf >= 4 * sf) ? 1 : 0));
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,UpdateModel,The following statement contains a magic number: currentContext.SummaryFrequency += 4;
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,UpdateModel,The following statement contains a magic number: cf < 6 * sf
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,CreateSuccessors,The following statement contains a magic number: temporary = (byte)((state.Frequency < MaximumFrequency - 9) ? 1 : 0);
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,CreateSuccessors,The following statement contains a magic number: localFrequency = (byte)(1 + ((2 * cf <= s0) ? (uint)((5 * cf > s0) ? 1 : 0) : ((cf + 2 * s0 - 3) / s0)));
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,CreateSuccessors,The following statement contains a magic number: localFrequency = (byte)(1 + ((2 * cf <= s0) ? (uint)((5 * cf > s0) ? 1 : 0) : ((cf + 2 * s0 - 3) / s0)));
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,CreateSuccessors,The following statement contains a magic number: localFrequency = (byte)(1 + ((2 * cf <= s0) ? (uint)((5 * cf > s0) ? 1 : 0) : ((cf + 2 * s0 - 3) / s0)));
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,CreateSuccessors,The following statement contains a magic number: localFrequency = (byte)(1 + ((2 * cf <= s0) ? (uint)((5 * cf > s0) ? 1 : 0) : ((cf + 2 * s0 - 3) / s0)));
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,ReduceOrder,The following statement contains a magic number: temporary = (byte)((state.Frequency < MaximumFrequency - 9) ? 2 : 0);
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,ReduceOrder,The following statement contains a magic number: temporary = (byte)((state.Frequency < MaximumFrequency - 9) ? 2 : 0);
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,RestoreModel,The following statement contains a magic number: currentContext.FirstStateFrequency = (byte)((currentContext.FirstStateFrequency + 11) >> 3);
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,RestoreModel,The following statement contains a magic number: currentContext.FirstStateFrequency = (byte)((currentContext.FirstStateFrequency + 11) >> 3);
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,EncodeBinarySymbol,The following statement contains a magic number: int index2 = numberStatisticsToBinarySummaryIndex[context.Suffix.NumberStatistics] + previousSuccess + context.Flags + ((runLength >> 26) & 0x20);
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,EncodeBinarySymbol,The following statement contains a magic number: state.Frequency += (byte)((state.Frequency < 196) ? 1 : 0);
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,EncodeBinarySymbol,The following statement contains a magic number: binarySummary[index1' index2] += (ushort)(Interval - Mean(binarySummary[index1' index2]' PeriodBitCount' 2));
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,EncodeSymbol1,The following statement contains a magic number: previousSuccess = (byte)((2 * Coder.HighCount >= Coder.Scale) ? 1 : 0);
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,EncodeSymbol1,The following statement contains a magic number: foundState.Frequency += 4;
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,EncodeSymbol1,The following statement contains a magic number: context.SummaryFrequency += 4;
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,DecodeBinarySymbol,The following statement contains a magic number: int index2 = numberStatisticsToBinarySummaryIndex[context.Suffix.NumberStatistics] + previousSuccess + context.Flags + ((runLength >> 26) & 0x20);
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,DecodeBinarySymbol,The following statement contains a magic number: state.Frequency += (byte)((state.Frequency < 196) ? 1 : 0);
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,DecodeBinarySymbol,The following statement contains a magic number: binarySummary[index1' index2] += (ushort)(Interval - Mean(binarySummary[index1' index2]' PeriodBitCount' 2));
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,DecodeSymbol1,The following statement contains a magic number: previousSuccess = (byte)((2 * Coder.HighCount >= Coder.Scale) ? 1 : 0);
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,DecodeSymbol1,The following statement contains a magic number: highCount += 4;
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,DecodeSymbol1,The following statement contains a magic number: context.SummaryFrequency += 4;
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,Update1,The following statement contains a magic number: foundState.Frequency += 4;
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,Update1,The following statement contains a magic number: context.SummaryFrequency += 4;
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,Update2,The following statement contains a magic number: foundState.Frequency += 4;
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,Update2,The following statement contains a magic number: context.SummaryFrequency += 4;
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,MakeEscapeFrequency,The following statement contains a magic number: uint numberStatistics = (uint)2 * context.NumberStatistics;
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,MakeEscapeFrequency,The following statement contains a magic number: int index1 = probabilities[context.NumberStatistics + 2] - 3;
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,MakeEscapeFrequency,The following statement contains a magic number: int index1 = probabilities[context.NumberStatistics + 2] - 3;
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,MakeEscapeFrequency,The following statement contains a magic number: int index2 = ((context.SummaryFrequency > 11 * (context.NumberStatistics + 1)) ? 1 : 0) + ((2 * context.NumberStatistics < numberStatistics + numberMasked) ? 2 : 0) + context.Flags;
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,MakeEscapeFrequency,The following statement contains a magic number: int index2 = ((context.SummaryFrequency > 11 * (context.NumberStatistics + 1)) ? 1 : 0) + ((2 * context.NumberStatistics < numberStatistics + numberMasked) ? 2 : 0) + context.Flags;
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,MakeEscapeFrequency,The following statement contains a magic number: int index2 = ((context.SummaryFrequency > 11 * (context.NumberStatistics + 1)) ? 1 : 0) + ((2 * context.NumberStatistics < numberStatistics + numberMasked) ? 2 : 0) + context.Flags;
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,Rescale,The following statement contains a magic number: state.Frequency += 4;
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,Rescale,The following statement contains a magic number: context.SummaryFrequency += 4;
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,Rescale,The following statement contains a magic number: oldUnitCount = (uint)((context.NumberStatistics + 2) >> 1);
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,Rescale,The following statement contains a magic number: localFrequency = (byte)((2 * localFrequency + escapeFrequency - 1) / escapeFrequency);
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,Rescale,The following statement contains a magic number: localFrequency = (byte)(MaximumFrequency / 3);
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,Rescale,The following statement contains a magic number: localFrequency > MaximumFrequency / 3
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,Rescale,The following statement contains a magic number: context.Statistics = Allocator.ShrinkUnits(context.Statistics' oldUnitCount' (uint)((context.NumberStatistics + 2) >> 1));
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,Refresh,The following statement contains a magic number: context.Statistics = Allocator.ShrinkUnits(context.Statistics' oldUnitCount' (uint)((index + 2) >> 1));
Magic Number,Compress.SevenZip.Compress.PPmd.I1,Model,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\Model.cs,CutOff,The following statement contains a magic number: uint unitCount = (uint)((context.NumberStatistics + 2) >> 1);
Magic Number,Compress.SevenZip.Compress.PPmd.I1,See2Context,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\See2Context.cs,Initialize,The following statement contains a magic number: Shift = PeriodBitCount - 4;
Magic Number,Compress.SevenZip.Compress.PPmd.I1,See2Context,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\See2Context.cs,Initialize,The following statement contains a magic number: Count = 7;
Magic Number,Compress.SevenZip.Compress.PPmd.I1,See2Context,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\I1\See2Context.cs,Update,The following statement contains a magic number: Count = (byte) (3 << Shift++);
Magic Number,Compress.SevenZip.Compress.PPmd,PpmdProperties,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\PpmdProperties.cs,PpmdProperties,The following statement contains a magic number: AllocatorSize = (((props >> 4) & 0xff) + 1) << 20;
Magic Number,Compress.SevenZip.Compress.PPmd,PpmdProperties,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\PpmdProperties.cs,PpmdProperties,The following statement contains a magic number: AllocatorSize = (((props >> 4) & 0xff) + 1) << 20;
Magic Number,Compress.SevenZip.Compress.PPmd,PpmdProperties,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\PpmdProperties.cs,PpmdProperties,The following statement contains a magic number: ModelRestorationMethod = (I1.ModelRestorationMethod)(props >> 12);
Magic Number,Compress.SevenZip.Compress.PPmd,PpmdProperties,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\PpmdProperties.cs,PpmdProperties,The following statement contains a magic number: properties.Length == 2
Magic Number,Compress.SevenZip.Compress.PPmd,PpmdStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\PpmdStream.cs,Seek,The following statement contains a magic number: byte[] tmpBuff = new byte[1024];
Magic Number,Compress.SevenZip.Compress.PPmd,PpmdStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\PpmdStream.cs,Seek,The following statement contains a magic number: int sizenow = sizeToGo > 1024 ? 1024 : (int)sizeToGo;
Magic Number,Compress.SevenZip.Compress.PPmd,PpmdStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\PpmdStream.cs,Seek,The following statement contains a magic number: int sizenow = sizeToGo > 1024 ? 1024 : (int)sizeToGo;
Magic Number,Compress.SevenZip.Compress.PPmd,Utility,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\Utility.cs,readIntBigEndian,The following statement contains a magic number: temp <<= 8;
Magic Number,Compress.SevenZip.Compress.PPmd,Utility,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\Utility.cs,readIntBigEndian,The following statement contains a magic number: temp <<= 8;
Magic Number,Compress.SevenZip.Compress.PPmd,Utility,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\Utility.cs,readIntBigEndian,The following statement contains a magic number: temp |= array[pos + 2] & 0xff;
Magic Number,Compress.SevenZip.Compress.PPmd,Utility,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\Utility.cs,readIntBigEndian,The following statement contains a magic number: temp <<= 8;
Magic Number,Compress.SevenZip.Compress.PPmd,Utility,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\Utility.cs,readIntBigEndian,The following statement contains a magic number: temp |= array[pos + 3] & 0xff;
Magic Number,Compress.SevenZip.Compress.PPmd,Utility,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\Utility.cs,writeIntBigEndian,The following statement contains a magic number: array[pos] = (byte)((Utility.URShift(value' 24)) & 0xff);
Magic Number,Compress.SevenZip.Compress.PPmd,Utility,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\Utility.cs,writeIntBigEndian,The following statement contains a magic number: array[pos + 1] = (byte)((Utility.URShift(value' 16)) & 0xff);
Magic Number,Compress.SevenZip.Compress.PPmd,Utility,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\Utility.cs,writeIntBigEndian,The following statement contains a magic number: array[pos + 2] = (byte)((Utility.URShift(value' 8)) & 0xff);
Magic Number,Compress.SevenZip.Compress.PPmd,Utility,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\Utility.cs,writeIntBigEndian,The following statement contains a magic number: array[pos + 2] = (byte)((Utility.URShift(value' 8)) & 0xff);
Magic Number,Compress.SevenZip.Compress.PPmd,Utility,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\Utility.cs,writeIntBigEndian,The following statement contains a magic number: array[pos + 3] = (byte)((value) & 0xff);
Magic Number,Compress.SevenZip.Compress.PPmd,Utility,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\Utility.cs,Skip,The following statement contains a magic number: byte[] buffer = new byte[32 * 1024];
Magic Number,Compress.SevenZip.Compress.PPmd,Utility,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\Utility.cs,Skip,The following statement contains a magic number: byte[] buffer = new byte[32 * 1024];
Magic Number,Compress.SevenZip.Compress.PPmd,Utility,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\Utility.cs,SkipAll,The following statement contains a magic number: byte[] buffer = new byte[32 * 1024];
Magic Number,Compress.SevenZip.Compress.PPmd,Utility,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\Utility.cs,SkipAll,The following statement contains a magic number: byte[] buffer = new byte[32 * 1024];
Magic Number,Compress.SevenZip.Compress.PPmd,Utility,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\Utility.cs,UInt32ToBigEndianBytes,The following statement contains a magic number: return new byte[] {                  (byte)((x >> 24) & 0xff)'                  (byte)((x >> 16) & 0xff)'                  (byte)((x >> 8) & 0xff)'                  (byte)(x & 0xff) };
Magic Number,Compress.SevenZip.Compress.PPmd,Utility,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\Utility.cs,UInt32ToBigEndianBytes,The following statement contains a magic number: return new byte[] {                  (byte)((x >> 24) & 0xff)'                  (byte)((x >> 16) & 0xff)'                  (byte)((x >> 8) & 0xff)'                  (byte)(x & 0xff) };
Magic Number,Compress.SevenZip.Compress.PPmd,Utility,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\Utility.cs,UInt32ToBigEndianBytes,The following statement contains a magic number: return new byte[] {                  (byte)((x >> 24) & 0xff)'                  (byte)((x >> 16) & 0xff)'                  (byte)((x >> 8) & 0xff)'                  (byte)(x & 0xff) };
Magic Number,Compress.SevenZip.Compress.PPmd,Utility,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\Utility.cs,DosDateToDateTime,The following statement contains a magic number: int year = iDate / 512 + 1980;
Magic Number,Compress.SevenZip.Compress.PPmd,Utility,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\Utility.cs,DosDateToDateTime,The following statement contains a magic number: int year = iDate / 512 + 1980;
Magic Number,Compress.SevenZip.Compress.PPmd,Utility,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\Utility.cs,DosDateToDateTime,The following statement contains a magic number: int month = iDate % 512 / 32;
Magic Number,Compress.SevenZip.Compress.PPmd,Utility,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\Utility.cs,DosDateToDateTime,The following statement contains a magic number: int month = iDate % 512 / 32;
Magic Number,Compress.SevenZip.Compress.PPmd,Utility,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\Utility.cs,DosDateToDateTime,The following statement contains a magic number: int day = iDate % 512 % 32;
Magic Number,Compress.SevenZip.Compress.PPmd,Utility,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\Utility.cs,DosDateToDateTime,The following statement contains a magic number: int day = iDate % 512 % 32;
Magic Number,Compress.SevenZip.Compress.PPmd,Utility,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\Utility.cs,DosDateToDateTime,The following statement contains a magic number: int hour = iTime / 2048;
Magic Number,Compress.SevenZip.Compress.PPmd,Utility,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\Utility.cs,DosDateToDateTime,The following statement contains a magic number: int minute = iTime % 2048 / 32;
Magic Number,Compress.SevenZip.Compress.PPmd,Utility,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\Utility.cs,DosDateToDateTime,The following statement contains a magic number: int minute = iTime % 2048 / 32;
Magic Number,Compress.SevenZip.Compress.PPmd,Utility,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\Utility.cs,DosDateToDateTime,The following statement contains a magic number: int second = iTime % 2048 % 32 * 2;
Magic Number,Compress.SevenZip.Compress.PPmd,Utility,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\Utility.cs,DosDateToDateTime,The following statement contains a magic number: int second = iTime % 2048 % 32 * 2;
Magic Number,Compress.SevenZip.Compress.PPmd,Utility,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\Utility.cs,DosDateToDateTime,The following statement contains a magic number: int second = iTime % 2048 % 32 * 2;
Magic Number,Compress.SevenZip.Compress.PPmd,Utility,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\Utility.cs,DosDateToDateTime,The following statement contains a magic number: year = 1980;
Magic Number,Compress.SevenZip.Compress.PPmd,Utility,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\Utility.cs,DateTimeToDosTime,The following statement contains a magic number: return (uint)(                  (dateTime.Value.Second / 2) | (dateTime.Value.Minute << 5) | (dateTime.Value.Hour << 11) |                  (dateTime.Value.Day << 16) | (dateTime.Value.Month << 21) | ((dateTime.Value.Year - 1980) << 25));
Magic Number,Compress.SevenZip.Compress.PPmd,Utility,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\Utility.cs,DateTimeToDosTime,The following statement contains a magic number: return (uint)(                  (dateTime.Value.Second / 2) | (dateTime.Value.Minute << 5) | (dateTime.Value.Hour << 11) |                  (dateTime.Value.Day << 16) | (dateTime.Value.Month << 21) | ((dateTime.Value.Year - 1980) << 25));
Magic Number,Compress.SevenZip.Compress.PPmd,Utility,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\Utility.cs,DateTimeToDosTime,The following statement contains a magic number: return (uint)(                  (dateTime.Value.Second / 2) | (dateTime.Value.Minute << 5) | (dateTime.Value.Hour << 11) |                  (dateTime.Value.Day << 16) | (dateTime.Value.Month << 21) | ((dateTime.Value.Year - 1980) << 25));
Magic Number,Compress.SevenZip.Compress.PPmd,Utility,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\Utility.cs,DateTimeToDosTime,The following statement contains a magic number: return (uint)(                  (dateTime.Value.Second / 2) | (dateTime.Value.Minute << 5) | (dateTime.Value.Hour << 11) |                  (dateTime.Value.Day << 16) | (dateTime.Value.Month << 21) | ((dateTime.Value.Year - 1980) << 25));
Magic Number,Compress.SevenZip.Compress.PPmd,Utility,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\Utility.cs,DateTimeToDosTime,The following statement contains a magic number: return (uint)(                  (dateTime.Value.Second / 2) | (dateTime.Value.Minute << 5) | (dateTime.Value.Hour << 11) |                  (dateTime.Value.Day << 16) | (dateTime.Value.Month << 21) | ((dateTime.Value.Year - 1980) << 25));
Magic Number,Compress.SevenZip.Compress.PPmd,Utility,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\Utility.cs,DateTimeToDosTime,The following statement contains a magic number: return (uint)(                  (dateTime.Value.Second / 2) | (dateTime.Value.Minute << 5) | (dateTime.Value.Hour << 11) |                  (dateTime.Value.Day << 16) | (dateTime.Value.Month << 21) | ((dateTime.Value.Year - 1980) << 25));
Magic Number,Compress.SevenZip.Compress.PPmd,Utility,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\Utility.cs,DateTimeToDosTime,The following statement contains a magic number: return (uint)(                  (dateTime.Value.Second / 2) | (dateTime.Value.Minute << 5) | (dateTime.Value.Hour << 11) |                  (dateTime.Value.Day << 16) | (dateTime.Value.Month << 21) | ((dateTime.Value.Year - 1980) << 25));
Magic Number,Compress.SevenZip.Compress.PPmd,Utility,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\Utility.cs,DosDateToDateTime,The following statement contains a magic number: return DosDateToDateTime((UInt16)(iTime / 65536)'                                       (UInt16)(iTime % 65536));
Magic Number,Compress.SevenZip.Compress.PPmd,Utility,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\Utility.cs,DosDateToDateTime,The following statement contains a magic number: return DosDateToDateTime((UInt16)(iTime / 65536)'                                       (UInt16)(iTime % 65536));
Magic Number,Compress.SevenZip.Compress.PPmd,Utility,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\PPmd\Utility.cs,TransferTo,The following statement contains a magic number: byte[] array = new byte[4096];
Magic Number,Compress.SevenZip.Compress.RangeCoder,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\RangeCoder\RangeCoder.cs,FlushData,The following statement contains a magic number: i < 5
Magic Number,Compress.SevenZip.Compress.RangeCoder,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\RangeCoder\RangeCoder.cs,Encode,The following statement contains a magic number: Range <<= 8;
Magic Number,Compress.SevenZip.Compress.RangeCoder,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: Stream.WriteByte((byte)(temp + (Low >> 32)));
Magic Number,Compress.SevenZip.Compress.RangeCoder,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: _cache = (byte)(((uint)Low) >> 24);
Magic Number,Compress.SevenZip.Compress.RangeCoder,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: (uint)Low < (uint)0xFF000000 || (uint)(Low >> 32) == 1
Magic Number,Compress.SevenZip.Compress.RangeCoder,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: Low = ((uint)Low) << 8;
Magic Number,Compress.SevenZip.Compress.RangeCoder,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\RangeCoder\RangeCoder.cs,EncodeDirectBits,The following statement contains a magic number: Range <<= 8;
Magic Number,Compress.SevenZip.Compress.RangeCoder,Encoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\RangeCoder\RangeCoder.cs,EncodeBit,The following statement contains a magic number: Range <<= 8;
Magic Number,Compress.SevenZip.Compress.RangeCoder,Decoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\RangeCoder\RangeCoder.cs,Init,The following statement contains a magic number: Code = (Code << 8) | (byte)Stream.ReadByte();
Magic Number,Compress.SevenZip.Compress.RangeCoder,Decoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\RangeCoder\RangeCoder.cs,Init,The following statement contains a magic number: i < 5
Magic Number,Compress.SevenZip.Compress.RangeCoder,Decoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\RangeCoder\RangeCoder.cs,Init,The following statement contains a magic number: Total = 5;
Magic Number,Compress.SevenZip.Compress.RangeCoder,Decoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\RangeCoder\RangeCoder.cs,Normalize,The following statement contains a magic number: Code = (Code << 8) | (byte)Stream.ReadByte();
Magic Number,Compress.SevenZip.Compress.RangeCoder,Decoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\RangeCoder\RangeCoder.cs,Normalize,The following statement contains a magic number: Range <<= 8;
Magic Number,Compress.SevenZip.Compress.RangeCoder,Decoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\RangeCoder\RangeCoder.cs,Normalize2,The following statement contains a magic number: Code = (Code << 8) | (byte)Stream.ReadByte();
Magic Number,Compress.SevenZip.Compress.RangeCoder,Decoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\RangeCoder\RangeCoder.cs,Normalize2,The following statement contains a magic number: Range <<= 8;
Magic Number,Compress.SevenZip.Compress.RangeCoder,Decoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: uint t = (code - range) >> 31;
Magic Number,Compress.SevenZip.Compress.RangeCoder,Decoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: code = (code << 8) | (byte)Stream.ReadByte();
Magic Number,Compress.SevenZip.Compress.RangeCoder,Decoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: range <<= 8;
Magic Number,Compress.SevenZip.Compress.RangeCoder,BitEncoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\RangeCoder\RangeCoderBit.cs,Encode,The following statement contains a magic number: encoder.Range <<= 8;
Magic Number,Compress.SevenZip.Compress.RangeCoder,BitDecoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();
Magic Number,Compress.SevenZip.Compress.RangeCoder,BitDecoder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: rangeDecoder.Range <<= 8;
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,IsRomVault7Z,The following statement contains a magic number: length < 32
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,IsRomVault7Z,The following statement contains a magic number: _zipFs.Seek(length - 32' SeekOrigin.Begin);
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,IsRomVault7Z,The following statement contains a magic number: byte[] header = new byte[12];
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,IsRomVault7Z,The following statement contains a magic number: _zipFs.Read(header' 0' 12);
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,IsRomVault7Z,The following statement contains a magic number: i < 12
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: const int crcsz = 128;
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: const int t7ZsigSize = 16 + 1 + 9 + 4 + 4;
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: const int t7ZsigSize = 16 + 1 + 9 + 4 + 4;
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: const int t7ZsigSize = 16 + 1 + 9 + 4 + 4;
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: const int t7ZsigSize = 16 + 1 + 9 + 4 + 4;
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: const int tmpbufsize = 256 + t7ZsigSize + 8 + 4;
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: const int tmpbufsize = 256 + t7ZsigSize + 8 + 4;
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: const int tmpbufsize = 256 + t7ZsigSize + 8 + 4;
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: int endReadLength = crcsz + t7ZsigSize + 4;
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: ar -= t7ZsigSize + 4;
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: ar >= t7ZsigSize + 4
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: Util.memcpyr(buffer' crcsz * 2 + 8' buffer' bufferPos + ar' t7ZsigSize + 4);
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: Util.memcpyr(buffer' crcsz * 2 + 8' buffer' bufferPos + ar' t7ZsigSize + 4);
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: Util.memcpyr(buffer' crcsz * 2 + 8' buffer' bufferPos + ar' t7ZsigSize + 4);
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: foffs -= t7ZsigSize + 4;
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: buffer[crcsz * 2 + 0] = (byte)((foffs >> 0) & 0xff);
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: buffer[crcsz * 2 + 1] = (byte)((foffs >> 8) & 0xff);
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: buffer[crcsz * 2 + 1] = (byte)((foffs >> 8) & 0xff);
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: buffer[crcsz * 2 + 2] = (byte)((foffs >> 16) & 0xff);
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: buffer[crcsz * 2 + 2] = (byte)((foffs >> 16) & 0xff);
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: buffer[crcsz * 2 + 2] = (byte)((foffs >> 16) & 0xff);
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: buffer[crcsz * 2 + 3] = (byte)((foffs >> 24) & 0xff);
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: buffer[crcsz * 2 + 3] = (byte)((foffs >> 24) & 0xff);
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: buffer[crcsz * 2 + 3] = (byte)((foffs >> 24) & 0xff);
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: buffer[crcsz * 2 + 4] = 0;
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: buffer[crcsz * 2 + 4] = 0;
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: buffer[crcsz * 2 + 5] = 0;
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: buffer[crcsz * 2 + 5] = 0;
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: buffer[crcsz * 2 + 6] = 0;
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: buffer[crcsz * 2 + 6] = 0;
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: buffer[crcsz * 2 + 7] = 0;
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: buffer[crcsz * 2 + 7] = 0;
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: t7Zid[16] = buffer[crcsz * 2 + 4 + 8 + 16];
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: t7Zid[16] = buffer[crcsz * 2 + 4 + 8 + 16];
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: t7Zid[16] = buffer[crcsz * 2 + 4 + 8 + 16];
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: t7Zid[16] = buffer[crcsz * 2 + 4 + 8 + 16];
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: t7Zid[16] = buffer[crcsz * 2 + 4 + 8 + 16];
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: uint inCrc32 = (uint)(buffer[crcsz * 2 + 8 + 0] +                                             (buffer[crcsz * 2 + 8 + 1] << 8) +                                             (buffer[crcsz * 2 + 8 + 2] << 16) +                                             (buffer[crcsz * 2 + 8 + 3] << 24));
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: uint inCrc32 = (uint)(buffer[crcsz * 2 + 8 + 0] +                                             (buffer[crcsz * 2 + 8 + 1] << 8) +                                             (buffer[crcsz * 2 + 8 + 2] << 16) +                                             (buffer[crcsz * 2 + 8 + 3] << 24));
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: uint inCrc32 = (uint)(buffer[crcsz * 2 + 8 + 0] +                                             (buffer[crcsz * 2 + 8 + 1] << 8) +                                             (buffer[crcsz * 2 + 8 + 2] << 16) +                                             (buffer[crcsz * 2 + 8 + 3] << 24));
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: uint inCrc32 = (uint)(buffer[crcsz * 2 + 8 + 0] +                                             (buffer[crcsz * 2 + 8 + 1] << 8) +                                             (buffer[crcsz * 2 + 8 + 2] << 16) +                                             (buffer[crcsz * 2 + 8 + 3] << 24));
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: uint inCrc32 = (uint)(buffer[crcsz * 2 + 8 + 0] +                                             (buffer[crcsz * 2 + 8 + 1] << 8) +                                             (buffer[crcsz * 2 + 8 + 2] << 16) +                                             (buffer[crcsz * 2 + 8 + 3] << 24));
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: uint inCrc32 = (uint)(buffer[crcsz * 2 + 8 + 0] +                                             (buffer[crcsz * 2 + 8 + 1] << 8) +                                             (buffer[crcsz * 2 + 8 + 2] << 16) +                                             (buffer[crcsz * 2 + 8 + 3] << 24));
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: uint inCrc32 = (uint)(buffer[crcsz * 2 + 8 + 0] +                                             (buffer[crcsz * 2 + 8 + 1] << 8) +                                             (buffer[crcsz * 2 + 8 + 2] << 16) +                                             (buffer[crcsz * 2 + 8 + 3] << 24));
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: uint inCrc32 = (uint)(buffer[crcsz * 2 + 8 + 0] +                                             (buffer[crcsz * 2 + 8 + 1] << 8) +                                             (buffer[crcsz * 2 + 8 + 2] << 16) +                                             (buffer[crcsz * 2 + 8 + 3] << 24));
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: uint inCrc32 = (uint)(buffer[crcsz * 2 + 8 + 0] +                                             (buffer[crcsz * 2 + 8 + 1] << 8) +                                             (buffer[crcsz * 2 + 8 + 2] << 16) +                                             (buffer[crcsz * 2 + 8 + 3] << 24));
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: uint inCrc32 = (uint)(buffer[crcsz * 2 + 8 + 0] +                                             (buffer[crcsz * 2 + 8 + 1] << 8) +                                             (buffer[crcsz * 2 + 8 + 2] << 16) +                                             (buffer[crcsz * 2 + 8 + 3] << 24));
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: uint inCrc32 = (uint)(buffer[crcsz * 2 + 8 + 0] +                                             (buffer[crcsz * 2 + 8 + 1] << 8) +                                             (buffer[crcsz * 2 + 8 + 2] << 16) +                                             (buffer[crcsz * 2 + 8 + 3] << 24));
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: uint inCrc32 = (uint)(buffer[crcsz * 2 + 8 + 0] +                                             (buffer[crcsz * 2 + 8 + 1] << 8) +                                             (buffer[crcsz * 2 + 8 + 2] << 16) +                                             (buffer[crcsz * 2 + 8 + 3] << 24));
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: uint inCrc32 = (uint)(buffer[crcsz * 2 + 8 + 0] +                                             (buffer[crcsz * 2 + 8 + 1] << 8) +                                             (buffer[crcsz * 2 + 8 + 2] << 16) +                                             (buffer[crcsz * 2 + 8 + 3] << 24));
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: buffer[crcsz * 2 + 8 + 0] = 0xff;
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: buffer[crcsz * 2 + 8 + 0] = 0xff;
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: buffer[crcsz * 2 + 8 + 1] = 0xff;
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: buffer[crcsz * 2 + 8 + 1] = 0xff;
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: buffer[crcsz * 2 + 8 + 2] = 0xff;
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: buffer[crcsz * 2 + 8 + 2] = 0xff;
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: buffer[crcsz * 2 + 8 + 2] = 0xff;
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: buffer[crcsz * 2 + 8 + 3] = 0xff;
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: buffer[crcsz * 2 + 8 + 3] = 0xff;
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: buffer[crcsz * 2 + 8 + 3] = 0xff;
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: uint calcCrc32 = CRC.CalculateDigest(buffer' 0' crcsz * 2 + 8 + t7ZsigSize + 4);
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: uint calcCrc32 = CRC.CalculateDigest(buffer' 0' crcsz * 2 + 8 + t7ZsigSize + 4);
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: uint calcCrc32 = CRC.CalculateDigest(buffer' 0' crcsz * 2 + 8 + t7ZsigSize + 4);
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: Util.memcmp(buffer' crcsz * 2 + 4 + 8' t7Zid' t7ZidSize)
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: Util.memcmp(buffer' crcsz * 2 + 4 + 8' t7Zid' t7ZidSize)
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Istorrent7Z,The following statement contains a magic number: Util.memcmp(buffer' crcsz * 2 + 4 + 8' t7Zid' t7ZidSize)
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,ZipFileOpenReadStream,The following statement contains a magic number: switch (coder.DecoderType)                          {                              case DecompressType.Stored:                                  coder.decoderStream = inputCoders[0];                                  break;                              case DecompressType.Delta:                                  coder.decoderStream=new Delta(folder.Coders[i].Properties'inputCoders[0]);                                  break;                              case DecompressType.LZMA:                                  coder.decoderStream = new LzmaStream(folder.Coders[i].Properties' inputCoders[0]);                                  break;                              case DecompressType.LZMA2:                                  coder.decoderStream = new LzmaStream(folder.Coders[i].Properties' inputCoders[0]);                                  break;                              case DecompressType.PPMd:                                  coder.decoderStream = new PpmdStream(new PpmdProperties(folder.Coders[i].Properties)' inputCoders[0]' false);                                  break;                              case DecompressType.BZip2:                                  coder.decoderStream = new BZip2Stream(inputCoders[0]' CompressionMode.Decompress' true);                                  break;                              case DecompressType.BCJ:                                  coder.decoderStream = new BCJFilter(false' inputCoders[0]);                                  break;                              case DecompressType.BCJ2:                                  coder.decoderStream = new BCJ2Filter(inputCoders[0]' inputCoders[1]' inputCoders[2]' inputCoders[3]);                                  break;                              default:                                  return ZipReturn.ZipDecodeError;                          }
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,ZipFileOpenReadStream,The following statement contains a magic number: switch (coder.DecoderType)                          {                              case DecompressType.Stored:                                  coder.decoderStream = inputCoders[0];                                  break;                              case DecompressType.Delta:                                  coder.decoderStream=new Delta(folder.Coders[i].Properties'inputCoders[0]);                                  break;                              case DecompressType.LZMA:                                  coder.decoderStream = new LzmaStream(folder.Coders[i].Properties' inputCoders[0]);                                  break;                              case DecompressType.LZMA2:                                  coder.decoderStream = new LzmaStream(folder.Coders[i].Properties' inputCoders[0]);                                  break;                              case DecompressType.PPMd:                                  coder.decoderStream = new PpmdStream(new PpmdProperties(folder.Coders[i].Properties)' inputCoders[0]' false);                                  break;                              case DecompressType.BZip2:                                  coder.decoderStream = new BZip2Stream(inputCoders[0]' CompressionMode.Decompress' true);                                  break;                              case DecompressType.BCJ:                                  coder.decoderStream = new BCJFilter(false' inputCoders[0]);                                  break;                              case DecompressType.BCJ2:                                  coder.decoderStream = new BCJ2Filter(inputCoders[0]' inputCoders[1]' inputCoders[2]' inputCoders[3]);                                  break;                              default:                                  return ZipReturn.ZipDecodeError;                          }
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,ZipFileCreate,The following statement contains a magic number: LzmaEncoderProperties ep = new LzmaEncoderProperties(true' 1 << 24' 64);
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,ZipFileCreate,The following statement contains a magic number: LzmaEncoderProperties ep = new LzmaEncoderProperties(true' 1 << 24' 64);
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,ZipFileCloseWriteStream,The following statement contains a magic number: _localFiles[_localFiles.Count - 1].crc = new[] { crc32[3]' crc32[2]' crc32[1]' crc32[0] };
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,ZipFileCloseWriteStream,The following statement contains a magic number: _localFiles[_localFiles.Count - 1].crc = new[] { crc32[3]' crc32[2]' crc32[1]' crc32[0] };
Magic Number,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,Create7ZStructure,The following statement contains a magic number: folder.Coders[0] = new Coder                  {                      Method = new byte[] { 3' 1' 1 }'                      NumInStreams = 1'                      NumOutStreams = 1'                      Properties = _codeMSbytes                  };
Magic Number,Compress.SevenZip,Util,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Util.cs,ReadEncodedUInt64,The following statement contains a magic number: value += highPart << (8*i);
Magic Number,Compress.SevenZip,Util,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Util.cs,ReadEncodedUInt64,The following statement contains a magic number: value |= (ulong) b << (8*i);
Magic Number,Compress.SevenZip,Util,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Util.cs,ReadEncodedUInt64,The following statement contains a magic number: i < 8
Magic Number,Compress.SevenZip,Util,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Util.cs,WriteEncodedUInt64,The following statement contains a magic number: firstByte |= (byte) (value >> (8*i));
Magic Number,Compress.SevenZip,Util,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Util.cs,WriteEncodedUInt64,The following statement contains a magic number: value < (ulong) 1 << (7*(i + 1))
Magic Number,Compress.SevenZip,Util,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Util.cs,WriteEncodedUInt64,The following statement contains a magic number: i < 8
Magic Number,Compress.SevenZip,Util,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Util.cs,WriteEncodedUInt64,The following statement contains a magic number: value >>= 8;
Magic Number,Compress.SevenZip,Util,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Util.cs,WriteUint32Def,The following statement contains a magic number: br.WriteEncodedUInt64((ulong) (values.Length*4 + 2));
Magic Number,Compress.SevenZip,Util,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Util.cs,WriteUint32Def,The following statement contains a magic number: br.WriteEncodedUInt64((ulong) (values.Length*4 + 2));
Magic Number,Compress.SevenZip,Util,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Util.cs,WriteBoolFlags,The following statement contains a magic number: bw.WriteEncodedUInt64((ulong) ((bArray.Length + 7)/8));
Magic Number,Compress.SevenZip,Util,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Util.cs,WriteBoolFlags,The following statement contains a magic number: bw.WriteEncodedUInt64((ulong) ((bArray.Length + 7)/8));
Magic Number,Compress.SevenZip,Util,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Util.cs,uinttobytes,The following statement contains a magic number: byte[] b = new byte[4];
Magic Number,Compress.SevenZip,Util,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Util.cs,uinttobytes,The following statement contains a magic number: b[0] = (byte) ((c >> 24) & 0xff);
Magic Number,Compress.SevenZip,Util,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Util.cs,uinttobytes,The following statement contains a magic number: b[1] = (byte) ((c >> 16) & 0xff);
Magic Number,Compress.SevenZip,Util,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Util.cs,uinttobytes,The following statement contains a magic number: b[2] = (byte) ((c >> 8) & 0xff);
Magic Number,Compress.SevenZip,Util,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Util.cs,uinttobytes,The following statement contains a magic number: b[2] = (byte) ((c >> 8) & 0xff);
Magic Number,Compress.SevenZip,Util,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Util.cs,uinttobytes,The following statement contains a magic number: b[3] = (byte) ((c >> 0) & 0xff);
Magic Number,Compress.SevenZip,Util,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Util.cs,bytestouint,The following statement contains a magic number: return (uint?) ((crc[0] << 24) | (crc[1] << 16) | (crc[2] << 8) | (crc[3] << 0));
Magic Number,Compress.SevenZip,Util,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Util.cs,bytestouint,The following statement contains a magic number: return (uint?) ((crc[0] << 24) | (crc[1] << 16) | (crc[2] << 8) | (crc[3] << 0));
Magic Number,Compress.SevenZip,Util,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Util.cs,bytestouint,The following statement contains a magic number: return (uint?) ((crc[0] << 24) | (crc[1] << 16) | (crc[2] << 8) | (crc[3] << 0));
Magic Number,Compress.SevenZip,Util,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Util.cs,bytestouint,The following statement contains a magic number: return (uint?) ((crc[0] << 24) | (crc[1] << 16) | (crc[2] << 8) | (crc[3] << 0));
Magic Number,Compress.SevenZip,Util,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Util.cs,bytestouint,The following statement contains a magic number: return (uint?) ((crc[0] << 24) | (crc[1] << 16) | (crc[2] << 8) | (crc[3] << 0));
Magic Number,Compress.SevenZip.Filters,BCJ2Filter,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Filters\BCJ2Filter.cs,BCJ2Filter,The following statement contains a magic number: byte[] controlbuf=new byte[5];
Magic Number,Compress.SevenZip.Filters,BCJ2Filter,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Filters\BCJ2Filter.cs,BCJ2Filter,The following statement contains a magic number: control.Read(controlbuf' 0' 5);
Magic Number,Compress.SevenZip.Filters,BCJ2Filter,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Filters\BCJ2Filter.cs,BCJ2Filter,The following statement contains a magic number: code = (code << 8) | controlbuf[i];
Magic Number,Compress.SevenZip.Filters,BCJ2Filter,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Filters\BCJ2Filter.cs,BCJ2Filter,The following statement contains a magic number: i < 5
Magic Number,Compress.SevenZip.Filters,BCJ2Filter,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Filters\BCJ2Filter.cs,Seek,The following statement contains a magic number: const int bufferSize = 10240;
Magic Number,Compress.SevenZip.Filters,BCJFilter,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Filters\BCJFilter.cs,BCJFilter,The following statement contains a magic number: pos = 5;
Magic Number,Compress.SevenZip.Filters,BCJFilter,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Filters\BCJFilter.cs,Transform,The following statement contains a magic number: int end = offset + count - 5;
Magic Number,Compress.SevenZip.Filters,BCJFilter,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Filters\BCJFilter.cs,Transform,The following statement contains a magic number: (prevPos & ~3) != 0
Magic Number,Compress.SevenZip.Filters,BCJFilter,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Filters\BCJFilter.cs,Transform,The following statement contains a magic number: int src = buffer[i + 1]                                | (buffer[i + 2] << 8)                                | (buffer[i + 3] << 16)                                | (buffer[i + 4] << 24);
Magic Number,Compress.SevenZip.Filters,BCJFilter,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Filters\BCJFilter.cs,Transform,The following statement contains a magic number: int src = buffer[i + 1]                                | (buffer[i + 2] << 8)                                | (buffer[i + 3] << 16)                                | (buffer[i + 4] << 24);
Magic Number,Compress.SevenZip.Filters,BCJFilter,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Filters\BCJFilter.cs,Transform,The following statement contains a magic number: int src = buffer[i + 1]                                | (buffer[i + 2] << 8)                                | (buffer[i + 3] << 16)                                | (buffer[i + 4] << 24);
Magic Number,Compress.SevenZip.Filters,BCJFilter,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Filters\BCJFilter.cs,Transform,The following statement contains a magic number: int src = buffer[i + 1]                                | (buffer[i + 2] << 8)                                | (buffer[i + 3] << 16)                                | (buffer[i + 4] << 24);
Magic Number,Compress.SevenZip.Filters,BCJFilter,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Filters\BCJFilter.cs,Transform,The following statement contains a magic number: int src = buffer[i + 1]                                | (buffer[i + 2] << 8)                                | (buffer[i + 3] << 16)                                | (buffer[i + 4] << 24);
Magic Number,Compress.SevenZip.Filters,BCJFilter,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Filters\BCJFilter.cs,Transform,The following statement contains a magic number: int src = buffer[i + 1]                                | (buffer[i + 2] << 8)                                | (buffer[i + 3] << 16)                                | (buffer[i + 4] << 24);
Magic Number,Compress.SevenZip.Filters,BCJFilter,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Filters\BCJFilter.cs,Transform,The following statement contains a magic number: int index = MASK_TO_BIT_NUMBER[prevMask] * 8;
Magic Number,Compress.SevenZip.Filters,BCJFilter,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Filters\BCJFilter.cs,Transform,The following statement contains a magic number: !test86MSByte((byte)(dest >> (24 - index)))
Magic Number,Compress.SevenZip.Filters,BCJFilter,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Filters\BCJFilter.cs,Transform,The following statement contains a magic number: src = dest ^ ((1 << (32 - index)) - 1);
Magic Number,Compress.SevenZip.Filters,BCJFilter,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Filters\BCJFilter.cs,Transform,The following statement contains a magic number: buffer[i + 2] = (byte)(dest >> 8);
Magic Number,Compress.SevenZip.Filters,BCJFilter,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Filters\BCJFilter.cs,Transform,The following statement contains a magic number: buffer[i + 2] = (byte)(dest >> 8);
Magic Number,Compress.SevenZip.Filters,BCJFilter,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Filters\BCJFilter.cs,Transform,The following statement contains a magic number: buffer[i + 3] = (byte)(dest >> 16);
Magic Number,Compress.SevenZip.Filters,BCJFilter,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Filters\BCJFilter.cs,Transform,The following statement contains a magic number: buffer[i + 3] = (byte)(dest >> 16);
Magic Number,Compress.SevenZip.Filters,BCJFilter,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Filters\BCJFilter.cs,Transform,The following statement contains a magic number: buffer[i + 4] = (byte)(~(((dest >> 24) & 1) - 1));
Magic Number,Compress.SevenZip.Filters,BCJFilter,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Filters\BCJFilter.cs,Transform,The following statement contains a magic number: buffer[i + 4] = (byte)(~(((dest >> 24) & 1) - 1));
Magic Number,Compress.SevenZip.Filters,BCJFilter,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Filters\BCJFilter.cs,Transform,The following statement contains a magic number: i += 4;
Magic Number,Compress.SevenZip.Filters,BCJFilter,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Filters\BCJFilter.cs,Transform,The following statement contains a magic number: test86MSByte(buffer[i + 4])
Magic Number,Compress.SevenZip.Filters,BCJFilter,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Filters\BCJFilter.cs,Transform,The following statement contains a magic number: prevMask = ((prevPos & ~3) != 0) ? 0 : prevMask << (prevPos - 1);
Magic Number,Compress.SevenZip.Filters,Delta,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Filters\Delta.cs,Seek,The following statement contains a magic number: const int bufferSize = 10240;
Magic Number,Compress.SevenZip.Filters,Filter,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Filters\Filter.cs,Filter,The following statement contains a magic number: window = new byte[tail.Length * 2];
Magic Number,Compress.SevenZip.Filters,Filter,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Filters\Filter.cs,Seek,The following statement contains a magic number: const int bufferSize = 10240;
Magic Number,Compress.SevenZip.Structure,Header,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Structure\Header.cs,ReadHeaderOrPackedHeader,The following statement contains a magic number: switch (hp)              {                  case HeaderProperty.kEncodedHeader:                  {                      StreamsInfo streamsInfo = new StreamsInfo();                      streamsInfo.Read(br);                        if (streamsInfo.Folders.Length > 1)                      {                          return ZipReturn.ZipUnsupportedCompression;                      }                        Folder firstFolder = streamsInfo.Folders[0];                      if (firstFolder.Coders.Length > 1)                      {                          return ZipReturn.ZipUnsupportedCompression;                      }                        byte[] method = firstFolder.Coders[0].Method;                      if (!((method.Length == 3) && (method[0] == 3) && (method[1] == 1) && (method[2] == 1))) // LZMA                      {                          return ZipReturn.ZipUnsupportedCompression;                      }                        stream.Seek(baseOffset + (long) streamsInfo.PackPosition' SeekOrigin.Begin);                      using (LzmaStream decoder = new LzmaStream(firstFolder.Coders[0].Properties' stream))                      {                          ZipReturn zr = ReadHeaderOrPackedHeader(decoder' baseOffset' out header);                          if (zr != ZipReturn.ZipGood)                          {                              return zr;                          }                      }                      return ZipReturn.ZipGood;                  }                  case HeaderProperty.kHeader:                  {                      header = new Header();                      header.Read(br);                      return ZipReturn.ZipGood;                  }              }
Magic Number,Compress.SevenZip.Structure,Header,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Structure\Header.cs,ReadHeaderOrPackedHeader,The following statement contains a magic number: switch (hp)              {                  case HeaderProperty.kEncodedHeader:                  {                      StreamsInfo streamsInfo = new StreamsInfo();                      streamsInfo.Read(br);                        if (streamsInfo.Folders.Length > 1)                      {                          return ZipReturn.ZipUnsupportedCompression;                      }                        Folder firstFolder = streamsInfo.Folders[0];                      if (firstFolder.Coders.Length > 1)                      {                          return ZipReturn.ZipUnsupportedCompression;                      }                        byte[] method = firstFolder.Coders[0].Method;                      if (!((method.Length == 3) && (method[0] == 3) && (method[1] == 1) && (method[2] == 1))) // LZMA                      {                          return ZipReturn.ZipUnsupportedCompression;                      }                        stream.Seek(baseOffset + (long) streamsInfo.PackPosition' SeekOrigin.Begin);                      using (LzmaStream decoder = new LzmaStream(firstFolder.Coders[0].Properties' stream))                      {                          ZipReturn zr = ReadHeaderOrPackedHeader(decoder' baseOffset' out header);                          if (zr != ZipReturn.ZipGood)                          {                              return zr;                          }                      }                      return ZipReturn.ZipGood;                  }                  case HeaderProperty.kHeader:                  {                      header = new Header();                      header.Read(br);                      return ZipReturn.ZipGood;                  }              }
Magic Number,Compress.SevenZip.Structure,Header,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Structure\Header.cs,ReadHeaderOrPackedHeader,The following statement contains a magic number: switch (hp)              {                  case HeaderProperty.kEncodedHeader:                  {                      StreamsInfo streamsInfo = new StreamsInfo();                      streamsInfo.Read(br);                        if (streamsInfo.Folders.Length > 1)                      {                          return ZipReturn.ZipUnsupportedCompression;                      }                        Folder firstFolder = streamsInfo.Folders[0];                      if (firstFolder.Coders.Length > 1)                      {                          return ZipReturn.ZipUnsupportedCompression;                      }                        byte[] method = firstFolder.Coders[0].Method;                      if (!((method.Length == 3) && (method[0] == 3) && (method[1] == 1) && (method[2] == 1))) // LZMA                      {                          return ZipReturn.ZipUnsupportedCompression;                      }                        stream.Seek(baseOffset + (long) streamsInfo.PackPosition' SeekOrigin.Begin);                      using (LzmaStream decoder = new LzmaStream(firstFolder.Coders[0].Properties' stream))                      {                          ZipReturn zr = ReadHeaderOrPackedHeader(decoder' baseOffset' out header);                          if (zr != ZipReturn.ZipGood)                          {                              return zr;                          }                      }                      return ZipReturn.ZipGood;                  }                  case HeaderProperty.kHeader:                  {                      header = new Header();                      header.Read(br);                      return ZipReturn.ZipGood;                  }              }
Magic Number,Compress.SevenZip.Structure,SignatureHeader,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Structure\SignatureHeader.cs,Read,The following statement contains a magic number: byte[] signatureBytes = br.ReadBytes(6);
Magic Number,Compress.SevenZip.Structure,SignatureHeader,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Structure\SignatureHeader.cs,Read,The following statement contains a magic number: byte[] mainHeader = new byte[8 + 8 + 4];
Magic Number,Compress.SevenZip.Structure,SignatureHeader,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Structure\SignatureHeader.cs,Read,The following statement contains a magic number: byte[] mainHeader = new byte[8 + 8 + 4];
Magic Number,Compress.SevenZip.Structure,SignatureHeader,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Structure\SignatureHeader.cs,Read,The following statement contains a magic number: byte[] mainHeader = new byte[8 + 8 + 4];
Magic Number,Compress.SevenZip.Structure,SignatureHeader,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Structure\SignatureHeader.cs,Write,The following statement contains a magic number: bw.Write((byte) 3);
Magic Number,Compress.ThreadReaders,ThreadCRC,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ThreadReaders\ThreadCRC.cs,ThreadCRC,The following statement contains a magic number: const int CRC_NUM_TABLES = 8;
Magic Number,Compress.ThreadReaders,ThreadCRC,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ThreadReaders\ThreadCRC.cs,ThreadCRC,The following statement contains a magic number: _crc32Lookup = new uint[256*CRC_NUM_TABLES];
Magic Number,Compress.ThreadReaders,ThreadCRC,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ThreadReaders\ThreadCRC.cs,ThreadCRC,The following statement contains a magic number: j < 8
Magic Number,Compress.ThreadReaders,ThreadCRC,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ThreadReaders\ThreadCRC.cs,ThreadCRC,The following statement contains a magic number: i < 256
Magic Number,Compress.ThreadReaders,ThreadCRC,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ThreadReaders\ThreadCRC.cs,ThreadCRC,The following statement contains a magic number: uint r = _crc32Lookup[i - 256];
Magic Number,Compress.ThreadReaders,ThreadCRC,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ThreadReaders\ThreadCRC.cs,ThreadCRC,The following statement contains a magic number: _crc32Lookup[i] = _crc32Lookup[r & 0xFF] ^ (r >> 8);
Magic Number,Compress.ThreadReaders,ThreadCRC,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ThreadReaders\ThreadCRC.cs,ThreadCRC,The following statement contains a magic number: i < 256*CRC_NUM_TABLES
Magic Number,Compress.ThreadReaders,ThreadCRC,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ThreadReaders\ThreadCRC.cs,MainLoop,The following statement contains a magic number: int end = (_size - 8) & ~7;
Magic Number,Compress.ThreadReaders,ThreadCRC,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ThreadReaders\ThreadCRC.cs,MainLoop,The following statement contains a magic number: int end = (_size - 8) & ~7;
Magic Number,Compress.ThreadReaders,ThreadCRC,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ThreadReaders\ThreadCRC.cs,MainLoop,The following statement contains a magic number: crc ^= (uint) (_buffer[offset] + (_buffer[offset + 1] << 8) + (_buffer[offset + 2] << 16) + (_buffer[offset + 3] << 24));
Magic Number,Compress.ThreadReaders,ThreadCRC,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ThreadReaders\ThreadCRC.cs,MainLoop,The following statement contains a magic number: crc ^= (uint) (_buffer[offset] + (_buffer[offset + 1] << 8) + (_buffer[offset + 2] << 16) + (_buffer[offset + 3] << 24));
Magic Number,Compress.ThreadReaders,ThreadCRC,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ThreadReaders\ThreadCRC.cs,MainLoop,The following statement contains a magic number: crc ^= (uint) (_buffer[offset] + (_buffer[offset + 1] << 8) + (_buffer[offset + 2] << 16) + (_buffer[offset + 3] << 24));
Magic Number,Compress.ThreadReaders,ThreadCRC,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ThreadReaders\ThreadCRC.cs,MainLoop,The following statement contains a magic number: crc ^= (uint) (_buffer[offset] + (_buffer[offset + 1] << 8) + (_buffer[offset + 2] << 16) + (_buffer[offset + 3] << 24));
Magic Number,Compress.ThreadReaders,ThreadCRC,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ThreadReaders\ThreadCRC.cs,MainLoop,The following statement contains a magic number: crc ^= (uint) (_buffer[offset] + (_buffer[offset + 1] << 8) + (_buffer[offset + 2] << 16) + (_buffer[offset + 3] << 24));
Magic Number,Compress.ThreadReaders,ThreadCRC,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ThreadReaders\ThreadCRC.cs,MainLoop,The following statement contains a magic number: uint high = (uint) (_buffer[offset + 4] + (_buffer[offset + 5] << 8) + (_buffer[offset + 6] << 16) + (_buffer[offset + 7] << 24));
Magic Number,Compress.ThreadReaders,ThreadCRC,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ThreadReaders\ThreadCRC.cs,MainLoop,The following statement contains a magic number: uint high = (uint) (_buffer[offset + 4] + (_buffer[offset + 5] << 8) + (_buffer[offset + 6] << 16) + (_buffer[offset + 7] << 24));
Magic Number,Compress.ThreadReaders,ThreadCRC,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ThreadReaders\ThreadCRC.cs,MainLoop,The following statement contains a magic number: uint high = (uint) (_buffer[offset + 4] + (_buffer[offset + 5] << 8) + (_buffer[offset + 6] << 16) + (_buffer[offset + 7] << 24));
Magic Number,Compress.ThreadReaders,ThreadCRC,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ThreadReaders\ThreadCRC.cs,MainLoop,The following statement contains a magic number: uint high = (uint) (_buffer[offset + 4] + (_buffer[offset + 5] << 8) + (_buffer[offset + 6] << 16) + (_buffer[offset + 7] << 24));
Magic Number,Compress.ThreadReaders,ThreadCRC,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ThreadReaders\ThreadCRC.cs,MainLoop,The following statement contains a magic number: uint high = (uint) (_buffer[offset + 4] + (_buffer[offset + 5] << 8) + (_buffer[offset + 6] << 16) + (_buffer[offset + 7] << 24));
Magic Number,Compress.ThreadReaders,ThreadCRC,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ThreadReaders\ThreadCRC.cs,MainLoop,The following statement contains a magic number: uint high = (uint) (_buffer[offset + 4] + (_buffer[offset + 5] << 8) + (_buffer[offset + 6] << 16) + (_buffer[offset + 7] << 24));
Magic Number,Compress.ThreadReaders,ThreadCRC,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ThreadReaders\ThreadCRC.cs,MainLoop,The following statement contains a magic number: uint high = (uint) (_buffer[offset + 4] + (_buffer[offset + 5] << 8) + (_buffer[offset + 6] << 16) + (_buffer[offset + 7] << 24));
Magic Number,Compress.ThreadReaders,ThreadCRC,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ThreadReaders\ThreadCRC.cs,MainLoop,The following statement contains a magic number: offset += 8;
Magic Number,Compress.ThreadReaders,ThreadCRC,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ThreadReaders\ThreadCRC.cs,MainLoop,The following statement contains a magic number: crc = _crc32Lookup[(byte) crc + 0x700]                                ^ _crc32Lookup[(byte) (crc >>= 8) + 0x600]                                ^ _crc32Lookup[(byte) (crc >>= 8) + 0x500]                                ^ _crc32Lookup[ /*(byte)*/(crc >> 8) + 0x400]                                ^ _crc32Lookup[(byte) high + 0x300]                                ^ _crc32Lookup[(byte) (high >>= 8) + 0x200]                                ^ _crc32Lookup[(byte) (high >>= 8) + 0x100]                                ^ _crc32Lookup[ /*(byte)*/(high >> 8) + 0x000];
Magic Number,Compress.ThreadReaders,ThreadCRC,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ThreadReaders\ThreadCRC.cs,MainLoop,The following statement contains a magic number: crc = _crc32Lookup[(byte) crc + 0x700]                                ^ _crc32Lookup[(byte) (crc >>= 8) + 0x600]                                ^ _crc32Lookup[(byte) (crc >>= 8) + 0x500]                                ^ _crc32Lookup[ /*(byte)*/(crc >> 8) + 0x400]                                ^ _crc32Lookup[(byte) high + 0x300]                                ^ _crc32Lookup[(byte) (high >>= 8) + 0x200]                                ^ _crc32Lookup[(byte) (high >>= 8) + 0x100]                                ^ _crc32Lookup[ /*(byte)*/(high >> 8) + 0x000];
Magic Number,Compress.ThreadReaders,ThreadCRC,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ThreadReaders\ThreadCRC.cs,MainLoop,The following statement contains a magic number: crc = _crc32Lookup[(byte) crc + 0x700]                                ^ _crc32Lookup[(byte) (crc >>= 8) + 0x600]                                ^ _crc32Lookup[(byte) (crc >>= 8) + 0x500]                                ^ _crc32Lookup[ /*(byte)*/(crc >> 8) + 0x400]                                ^ _crc32Lookup[(byte) high + 0x300]                                ^ _crc32Lookup[(byte) (high >>= 8) + 0x200]                                ^ _crc32Lookup[(byte) (high >>= 8) + 0x100]                                ^ _crc32Lookup[ /*(byte)*/(high >> 8) + 0x000];
Magic Number,Compress.ThreadReaders,ThreadCRC,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ThreadReaders\ThreadCRC.cs,MainLoop,The following statement contains a magic number: crc = _crc32Lookup[(byte) crc + 0x700]                                ^ _crc32Lookup[(byte) (crc >>= 8) + 0x600]                                ^ _crc32Lookup[(byte) (crc >>= 8) + 0x500]                                ^ _crc32Lookup[ /*(byte)*/(crc >> 8) + 0x400]                                ^ _crc32Lookup[(byte) high + 0x300]                                ^ _crc32Lookup[(byte) (high >>= 8) + 0x200]                                ^ _crc32Lookup[(byte) (high >>= 8) + 0x100]                                ^ _crc32Lookup[ /*(byte)*/(high >> 8) + 0x000];
Magic Number,Compress.ThreadReaders,ThreadCRC,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ThreadReaders\ThreadCRC.cs,MainLoop,The following statement contains a magic number: crc = _crc32Lookup[(byte) crc + 0x700]                                ^ _crc32Lookup[(byte) (crc >>= 8) + 0x600]                                ^ _crc32Lookup[(byte) (crc >>= 8) + 0x500]                                ^ _crc32Lookup[ /*(byte)*/(crc >> 8) + 0x400]                                ^ _crc32Lookup[(byte) high + 0x300]                                ^ _crc32Lookup[(byte) (high >>= 8) + 0x200]                                ^ _crc32Lookup[(byte) (high >>= 8) + 0x100]                                ^ _crc32Lookup[ /*(byte)*/(high >> 8) + 0x000];
Magic Number,Compress.ThreadReaders,ThreadCRC,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ThreadReaders\ThreadCRC.cs,MainLoop,The following statement contains a magic number: crc = _crc32Lookup[(byte) crc + 0x700]                                ^ _crc32Lookup[(byte) (crc >>= 8) + 0x600]                                ^ _crc32Lookup[(byte) (crc >>= 8) + 0x500]                                ^ _crc32Lookup[ /*(byte)*/(crc >> 8) + 0x400]                                ^ _crc32Lookup[(byte) high + 0x300]                                ^ _crc32Lookup[(byte) (high >>= 8) + 0x200]                                ^ _crc32Lookup[(byte) (high >>= 8) + 0x100]                                ^ _crc32Lookup[ /*(byte)*/(high >> 8) + 0x000];
Magic Number,Compress.ThreadReaders,ThreadCRC,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ThreadReaders\ThreadCRC.cs,MainLoop,The following statement contains a magic number: _size >= 8
Magic Number,Compress.ThreadReaders,ThreadCRC,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ThreadReaders\ThreadCRC.cs,MainLoop,The following statement contains a magic number: crc = (crc >> 8) ^ _crc32Lookup[(byte) crc ^ _buffer[offset++]];
Magic Number,Compress.ZipFile,ZipFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,LocalHeader,The following statement contains a magic number: return (_localFiles[i]._generalPurposeBitFlag & 8) == 0 ? (ulong?) _localFiles[i].RelativeOffsetOfLocalHeader : null;
Magic Number,Compress.ZipFile,ZipFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,FindEndOfCentralDirSignature,The following statement contains a magic number: byte[] buffer = new byte[buffSize + 4];
Magic Number,Compress.ZipFile,ZipFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,FindEndOfCentralDirSignature,The following statement contains a magic number: long backPosition = 4;
Magic Number,Compress.ZipFile,ZipFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,FindEndOfCentralDirSignature,The following statement contains a magic number: long readSize = backPosition > buffSize + 4 ? buffSize + 4 : backPosition;
Magic Number,Compress.ZipFile,ZipFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,FindEndOfCentralDirSignature,The following statement contains a magic number: long readSize = backPosition > buffSize + 4 ? buffSize + 4 : backPosition;
Magic Number,Compress.ZipFile,ZipFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,FindEndOfCentralDirSignature,The following statement contains a magic number: (buffer[i] != 0x50) || (buffer[i + 1] != 0x4b) || (buffer[i + 2] != 0x05) || (buffer[i + 3] != 0x06)
Magic Number,Compress.ZipFile,ZipFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,FindEndOfCentralDirSignature,The following statement contains a magic number: (buffer[i] != 0x50) || (buffer[i + 1] != 0x4b) || (buffer[i + 2] != 0x05) || (buffer[i + 3] != 0x06)
Magic Number,Compress.ZipFile,ZipFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,Zip64EndOfCentralDirRead,The following statement contains a magic number: tulong != 44
Magic Number,Compress.ZipFile,ZipFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,Zip64EndOfCentralDirRead,The following statement contains a magic number: tushort != 45
Magic Number,Compress.ZipFile,ZipFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,Zip64EndOfCentralDirWrite,The following statement contains a magic number: bw.Write((ulong) 44);
Magic Number,Compress.ZipFile,ZipFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,Zip64EndOfCentralDirWrite,The following statement contains a magic number: bw.Write((ushort) 45);
Magic Number,Compress.ZipFile,ZipFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,Zip64EndOfCentralDirWrite,The following statement contains a magic number: bw.Write((ushort) 45);
Magic Number,Compress.ZipFile,ZipFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,ZipFileOpen,The following statement contains a magic number: errorCode == 32
Magic Number,Compress.ZipFile,ZipFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,ZipFileReadHeaders,The following statement contains a magic number: _zipFs.Position = endOfCentralDir - 20;
Magic Number,Compress.ZipFile,ZipFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,ZipFileReadHeaders,The following statement contains a magic number: string tcrc = GetString(_fileComment).Substring(14' 8);
Magic Number,Compress.ZipFile,ZipFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,ZipFileReadHeaders,The following statement contains a magic number: string tcrc = GetString(_fileComment).Substring(14' 8);
Magic Number,Compress.ZipFile,ZipFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,ZipFileReadHeaders,The following statement contains a magic number: GetString(_fileComment).Substring(0' 14) == "TORRENTZIPPED-"
Magic Number,Compress.ZipFile,ZipFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,ZipFileReadHeaders,The following statement contains a magic number: _fileComment.Length == 22
Magic Number,Compress.ZipFile,ZipFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,GetBytes,The following statement contains a magic number: b[i] = t > 255 ? (byte) '?' : (byte) c[i];
Magic Number,Compress.ZipFile,ZipFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,IsUnicode,The following statement contains a magic number: c[i] > 255
Magic Number,Compress.ZipFile,ZipFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,TrrntZipStringCompare,The following statement contains a magic number: (byte1 >= 65) && (byte1 <= 90)
Magic Number,Compress.ZipFile,ZipFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,TrrntZipStringCompare,The following statement contains a magic number: (byte1 >= 65) && (byte1 <= 90)
Magic Number,Compress.ZipFile,ZipFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,TrrntZipStringCompare,The following statement contains a magic number: (byte2 >= 65) && (byte2 <= 90)
Magic Number,Compress.ZipFile,ZipFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,TrrntZipStringCompare,The following statement contains a magic number: (byte2 >= 65) && (byte2 <= 90)
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,LocalFile,The following statement contains a magic number: _generalPurposeBitFlag = 2;
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,LocalFile,The following statement contains a magic number: _compressionMethod = 8;
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,LocalFile,The following statement contains a magic number: _lastModFileTime = 48128;
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,LocalFile,The following statement contains a magic number: _lastModFileDate = 8600;
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,CenteralDirectoryRead,The following statement contains a magic number: (_compressionMethod != 8) && (_compressionMethod != 0)
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,CenteralDirectoryRead,The following statement contains a magic number: FileName = (_generalPurposeBitFlag & (1 << 11)) == 0 ?                          GetString(bFileName) :                          Encoding.UTF8.GetString(bFileName' 0' fileNameLength);
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,CenteralDirectoryRead,The following statement contains a magic number: pos += 2;
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,CenteralDirectoryRead,The following statement contains a magic number: pos += 2;
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,CenteralDirectoryRead,The following statement contains a magic number: switch (type)                          {                              case 0x0001:                                  Zip64 = true;                                  if (UncompressedSize == 0xffffffff)                                  {                                      UncompressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  if (_compressedSize == 0xffffffff)                                  {                                      _compressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  if (RelativeOffsetOfLocalHeader == 0xffffffff)                                  {                                      RelativeOffsetOfLocalHeader = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  break;                              case 0x7075:                                  //byte version = extraField[pos];                                  pos += 1;                                  uint nameCRC32 = BitConverter.ToUInt32(extraField' pos);                                  pos += 4;                                    CRC32 crcTest = new CRC32();                                  crcTest.SlurpBlock(bFileName' 0' fileNameLength);                                  uint fCRC = crcTest.Crc32ResultU;                                    if (nameCRC32 != fCRC)                                  {                                      return ZipReturn.ZipCenteralDirError;                                  }                                    int charLen = blockLength - 5;                                    FileName = Encoding.UTF8.GetString(extraField' pos' charLen);                                  pos += charLen;                                    break;                              default:                                  pos += blockLength;                                  break;                          }
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,CenteralDirectoryRead,The following statement contains a magic number: switch (type)                          {                              case 0x0001:                                  Zip64 = true;                                  if (UncompressedSize == 0xffffffff)                                  {                                      UncompressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  if (_compressedSize == 0xffffffff)                                  {                                      _compressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  if (RelativeOffsetOfLocalHeader == 0xffffffff)                                  {                                      RelativeOffsetOfLocalHeader = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  break;                              case 0x7075:                                  //byte version = extraField[pos];                                  pos += 1;                                  uint nameCRC32 = BitConverter.ToUInt32(extraField' pos);                                  pos += 4;                                    CRC32 crcTest = new CRC32();                                  crcTest.SlurpBlock(bFileName' 0' fileNameLength);                                  uint fCRC = crcTest.Crc32ResultU;                                    if (nameCRC32 != fCRC)                                  {                                      return ZipReturn.ZipCenteralDirError;                                  }                                    int charLen = blockLength - 5;                                    FileName = Encoding.UTF8.GetString(extraField' pos' charLen);                                  pos += charLen;                                    break;                              default:                                  pos += blockLength;                                  break;                          }
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,CenteralDirectoryRead,The following statement contains a magic number: switch (type)                          {                              case 0x0001:                                  Zip64 = true;                                  if (UncompressedSize == 0xffffffff)                                  {                                      UncompressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  if (_compressedSize == 0xffffffff)                                  {                                      _compressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  if (RelativeOffsetOfLocalHeader == 0xffffffff)                                  {                                      RelativeOffsetOfLocalHeader = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  break;                              case 0x7075:                                  //byte version = extraField[pos];                                  pos += 1;                                  uint nameCRC32 = BitConverter.ToUInt32(extraField' pos);                                  pos += 4;                                    CRC32 crcTest = new CRC32();                                  crcTest.SlurpBlock(bFileName' 0' fileNameLength);                                  uint fCRC = crcTest.Crc32ResultU;                                    if (nameCRC32 != fCRC)                                  {                                      return ZipReturn.ZipCenteralDirError;                                  }                                    int charLen = blockLength - 5;                                    FileName = Encoding.UTF8.GetString(extraField' pos' charLen);                                  pos += charLen;                                    break;                              default:                                  pos += blockLength;                                  break;                          }
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,CenteralDirectoryRead,The following statement contains a magic number: switch (type)                          {                              case 0x0001:                                  Zip64 = true;                                  if (UncompressedSize == 0xffffffff)                                  {                                      UncompressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  if (_compressedSize == 0xffffffff)                                  {                                      _compressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  if (RelativeOffsetOfLocalHeader == 0xffffffff)                                  {                                      RelativeOffsetOfLocalHeader = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  break;                              case 0x7075:                                  //byte version = extraField[pos];                                  pos += 1;                                  uint nameCRC32 = BitConverter.ToUInt32(extraField' pos);                                  pos += 4;                                    CRC32 crcTest = new CRC32();                                  crcTest.SlurpBlock(bFileName' 0' fileNameLength);                                  uint fCRC = crcTest.Crc32ResultU;                                    if (nameCRC32 != fCRC)                                  {                                      return ZipReturn.ZipCenteralDirError;                                  }                                    int charLen = blockLength - 5;                                    FileName = Encoding.UTF8.GetString(extraField' pos' charLen);                                  pos += charLen;                                    break;                              default:                                  pos += blockLength;                                  break;                          }
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,CenteralDirectoryRead,The following statement contains a magic number: switch (type)                          {                              case 0x0001:                                  Zip64 = true;                                  if (UncompressedSize == 0xffffffff)                                  {                                      UncompressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  if (_compressedSize == 0xffffffff)                                  {                                      _compressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  if (RelativeOffsetOfLocalHeader == 0xffffffff)                                  {                                      RelativeOffsetOfLocalHeader = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  break;                              case 0x7075:                                  //byte version = extraField[pos];                                  pos += 1;                                  uint nameCRC32 = BitConverter.ToUInt32(extraField' pos);                                  pos += 4;                                    CRC32 crcTest = new CRC32();                                  crcTest.SlurpBlock(bFileName' 0' fileNameLength);                                  uint fCRC = crcTest.Crc32ResultU;                                    if (nameCRC32 != fCRC)                                  {                                      return ZipReturn.ZipCenteralDirError;                                  }                                    int charLen = blockLength - 5;                                    FileName = Encoding.UTF8.GetString(extraField' pos' charLen);                                  pos += charLen;                                    break;                              default:                                  pos += blockLength;                                  break;                          }
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,CenteralDirectoryWrite,The following statement contains a magic number: extraField.InsertRange(2' BitConverter.GetBytes(exfl));
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,CenteralDirectoryWrite,The following statement contains a magic number: _generalPurposeBitFlag |= 1 << 11;
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,CenteralDirectoryWrite,The following statement contains a magic number: ushort versionNeededToExtract = (ushort) (Zip64 ? 45 : 20);
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,CenteralDirectoryWrite,The following statement contains a magic number: ushort versionNeededToExtract = (ushort) (Zip64 ? 45 : 20);
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,CenteralDirectoryWrite,The following statement contains a magic number: bw.Write(CRC[3]);
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,CenteralDirectoryWrite,The following statement contains a magic number: bw.Write(CRC[2]);
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,LocalFileHeaderRead,The following statement contains a magic number: string tFileName = (generalPurposeBitFlagLocal & (1 << 11)) == 0 ?                          GetString(bFileName) :                          Encoding.UTF8.GetString(bFileName' 0' fileNameLength);
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,LocalFileHeaderRead,The following statement contains a magic number: pos += 2;
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,LocalFileHeaderRead,The following statement contains a magic number: pos += 2;
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,LocalFileHeaderRead,The following statement contains a magic number: switch (type)                          {                              case 0x0001:                                  Zip64 = true;                                  if (tUnCompressedSize == 0xffffffff)                                  {                                      tUnCompressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  if (tCompressedSize == 0xffffffff)                                  {                                      tCompressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  break;                              case 0x7075:                                  //byte version = extraField[pos];                                  pos += 1;                                  uint nameCRC32 = BitConverter.ToUInt32(extraField' pos);                                  pos += 4;                                    CRC32 crcTest = new CRC32();                                  crcTest.SlurpBlock(bFileName' 0' fileNameLength);                                  uint fCRC = crcTest.Crc32ResultU;                                    if (nameCRC32 != fCRC)                                  {                                      return ZipReturn.ZipLocalFileHeaderError;                                  }                                    int charLen = blockLength - 5;                                    tFileName = Encoding.UTF8.GetString(extraField' pos' charLen);                                  pos += charLen;                                    break;                              default:                                  pos += blockLength;                                  break;                          }
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,LocalFileHeaderRead,The following statement contains a magic number: switch (type)                          {                              case 0x0001:                                  Zip64 = true;                                  if (tUnCompressedSize == 0xffffffff)                                  {                                      tUnCompressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  if (tCompressedSize == 0xffffffff)                                  {                                      tCompressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  break;                              case 0x7075:                                  //byte version = extraField[pos];                                  pos += 1;                                  uint nameCRC32 = BitConverter.ToUInt32(extraField' pos);                                  pos += 4;                                    CRC32 crcTest = new CRC32();                                  crcTest.SlurpBlock(bFileName' 0' fileNameLength);                                  uint fCRC = crcTest.Crc32ResultU;                                    if (nameCRC32 != fCRC)                                  {                                      return ZipReturn.ZipLocalFileHeaderError;                                  }                                    int charLen = blockLength - 5;                                    tFileName = Encoding.UTF8.GetString(extraField' pos' charLen);                                  pos += charLen;                                    break;                              default:                                  pos += blockLength;                                  break;                          }
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,LocalFileHeaderRead,The following statement contains a magic number: switch (type)                          {                              case 0x0001:                                  Zip64 = true;                                  if (tUnCompressedSize == 0xffffffff)                                  {                                      tUnCompressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  if (tCompressedSize == 0xffffffff)                                  {                                      tCompressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  break;                              case 0x7075:                                  //byte version = extraField[pos];                                  pos += 1;                                  uint nameCRC32 = BitConverter.ToUInt32(extraField' pos);                                  pos += 4;                                    CRC32 crcTest = new CRC32();                                  crcTest.SlurpBlock(bFileName' 0' fileNameLength);                                  uint fCRC = crcTest.Crc32ResultU;                                    if (nameCRC32 != fCRC)                                  {                                      return ZipReturn.ZipLocalFileHeaderError;                                  }                                    int charLen = blockLength - 5;                                    tFileName = Encoding.UTF8.GetString(extraField' pos' charLen);                                  pos += charLen;                                    break;                              default:                                  pos += blockLength;                                  break;                          }
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,LocalFileHeaderRead,The following statement contains a magic number: switch (type)                          {                              case 0x0001:                                  Zip64 = true;                                  if (tUnCompressedSize == 0xffffffff)                                  {                                      tUnCompressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  if (tCompressedSize == 0xffffffff)                                  {                                      tCompressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  break;                              case 0x7075:                                  //byte version = extraField[pos];                                  pos += 1;                                  uint nameCRC32 = BitConverter.ToUInt32(extraField' pos);                                  pos += 4;                                    CRC32 crcTest = new CRC32();                                  crcTest.SlurpBlock(bFileName' 0' fileNameLength);                                  uint fCRC = crcTest.Crc32ResultU;                                    if (nameCRC32 != fCRC)                                  {                                      return ZipReturn.ZipLocalFileHeaderError;                                  }                                    int charLen = blockLength - 5;                                    tFileName = Encoding.UTF8.GetString(extraField' pos' charLen);                                  pos += charLen;                                    break;                              default:                                  pos += blockLength;                                  break;                          }
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,LocalFileHeaderRead,The following statement contains a magic number: (_generalPurposeBitFlag & 8) == 8
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,LocalFileHeaderRead,The following statement contains a magic number: (_generalPurposeBitFlag & 8) == 8
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,LocalFileHeaderReadQuick,The following statement contains a magic number: (_generalPurposeBitFlag & 8) == 8
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,LocalFileHeaderReadQuick,The following statement contains a magic number: (_generalPurposeBitFlag & 8) == 8
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,LocalFileHeaderReadQuick,The following statement contains a magic number: FileName = (_generalPurposeBitFlag & (1 << 11)) == 0 ?                          GetString(bFileName) :                          Encoding.UTF8.GetString(bFileName' 0' fileNameLength);
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,LocalFileHeaderReadQuick,The following statement contains a magic number: pos += 2;
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,LocalFileHeaderReadQuick,The following statement contains a magic number: pos += 2;
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,LocalFileHeaderReadQuick,The following statement contains a magic number: switch (type)                          {                              case 0x0001:                                  Zip64 = true;                                  if (UncompressedSize == 0xffffffff)                                  {                                      UncompressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  if (_compressedSize == 0xffffffff)                                  {                                      _compressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  break;                              case 0x7075:                                  pos += 1;                                  uint nameCRC32 = BitConverter.ToUInt32(extraField' pos);                                  pos += 4;                                    CRC32 crcTest = new CRC32();                                  crcTest.SlurpBlock(bFileName' 0' fileNameLength);                                  uint fCRC = crcTest.Crc32ResultU;                                    if (nameCRC32 != fCRC)                                  {                                      return ZipReturn.ZipLocalFileHeaderError;                                  }                                    int charLen = blockLength - 5;                                    FileName = Encoding.UTF8.GetString(extraField' pos' charLen);                                    pos += charLen;                                    break;                              default:                                  pos += blockLength;                                  break;                          }
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,LocalFileHeaderReadQuick,The following statement contains a magic number: switch (type)                          {                              case 0x0001:                                  Zip64 = true;                                  if (UncompressedSize == 0xffffffff)                                  {                                      UncompressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  if (_compressedSize == 0xffffffff)                                  {                                      _compressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  break;                              case 0x7075:                                  pos += 1;                                  uint nameCRC32 = BitConverter.ToUInt32(extraField' pos);                                  pos += 4;                                    CRC32 crcTest = new CRC32();                                  crcTest.SlurpBlock(bFileName' 0' fileNameLength);                                  uint fCRC = crcTest.Crc32ResultU;                                    if (nameCRC32 != fCRC)                                  {                                      return ZipReturn.ZipLocalFileHeaderError;                                  }                                    int charLen = blockLength - 5;                                    FileName = Encoding.UTF8.GetString(extraField' pos' charLen);                                    pos += charLen;                                    break;                              default:                                  pos += blockLength;                                  break;                          }
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,LocalFileHeaderReadQuick,The following statement contains a magic number: switch (type)                          {                              case 0x0001:                                  Zip64 = true;                                  if (UncompressedSize == 0xffffffff)                                  {                                      UncompressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  if (_compressedSize == 0xffffffff)                                  {                                      _compressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  break;                              case 0x7075:                                  pos += 1;                                  uint nameCRC32 = BitConverter.ToUInt32(extraField' pos);                                  pos += 4;                                    CRC32 crcTest = new CRC32();                                  crcTest.SlurpBlock(bFileName' 0' fileNameLength);                                  uint fCRC = crcTest.Crc32ResultU;                                    if (nameCRC32 != fCRC)                                  {                                      return ZipReturn.ZipLocalFileHeaderError;                                  }                                    int charLen = blockLength - 5;                                    FileName = Encoding.UTF8.GetString(extraField' pos' charLen);                                    pos += charLen;                                    break;                              default:                                  pos += blockLength;                                  break;                          }
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,LocalFileHeaderReadQuick,The following statement contains a magic number: switch (type)                          {                              case 0x0001:                                  Zip64 = true;                                  if (UncompressedSize == 0xffffffff)                                  {                                      UncompressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  if (_compressedSize == 0xffffffff)                                  {                                      _compressedSize = BitConverter.ToUInt64(extraField' pos);                                      pos += 8;                                  }                                  break;                              case 0x7075:                                  pos += 1;                                  uint nameCRC32 = BitConverter.ToUInt32(extraField' pos);                                  pos += 4;                                    CRC32 crcTest = new CRC32();                                  crcTest.SlurpBlock(bFileName' 0' fileNameLength);                                  uint fCRC = crcTest.Crc32ResultU;                                    if (nameCRC32 != fCRC)                                  {                                      return ZipReturn.ZipLocalFileHeaderError;                                  }                                    int charLen = blockLength - 5;                                    FileName = Encoding.UTF8.GetString(extraField' pos' charLen);                                    pos += charLen;                                    break;                              default:                                  pos += blockLength;                                  break;                          }
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,LocalFileHeaderWrite,The following statement contains a magic number: _generalPurposeBitFlag |= 1 << 11;
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,LocalFileHeaderWrite,The following statement contains a magic number: ushort versionNeededToExtract = (ushort) (Zip64 ? 45 : 20);
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,LocalFileHeaderWrite,The following statement contains a magic number: ushort versionNeededToExtract = (ushort) (Zip64 ? 45 : 20);
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,LocalFileHeaderWrite,The following statement contains a magic number: i < 20
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,LocalFileHeaderFake,The following statement contains a magic number: _generalPurposeBitFlag |= 1 << 11;
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,LocalFileHeaderFake,The following statement contains a magic number: ushort versionNeededToExtract = (ushort) (Zip64 ? 45 : 20);
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,LocalFileHeaderFake,The following statement contains a magic number: ushort versionNeededToExtract = (ushort) (Zip64 ? 45 : 20);
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,LocalFileHeaderFake,The following statement contains a magic number: bw.Write(CRC[3]);
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,LocalFileHeaderFake,The following statement contains a magic number: bw.Write(CRC[2]);
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,LocalFileHeaderFake,The following statement contains a magic number: ushort extraFieldLength = (ushort) (Zip64 ? 20 : 0);
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,LocalFileHeaderFake,The following statement contains a magic number: bw.Write((ushort) 16);
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,LocalFileOpenReadStream,The following statement contains a magic number: switch (_compressionMethod)                  {                      case 8:                          if (raw)                          {                              _readStream = _zipFs;                              streamSize = _compressedSize;                          }                          else                          {                              _readStream = new DeflateStream(_zipFs' CompressionMode.Decompress' true);                              streamSize = UncompressedSize;                          }                          break;                      case 0:                          _readStream = _zipFs;                          streamSize = _compressedSize; // same as UncompressedSize                          break;                  }
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,FixFileForZip64,The following statement contains a magic number: _zipFs.Seek((long)_crc32Location - 10' SeekOrigin.Begin);
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,FixFileForZip64,The following statement contains a magic number: ushort versionNeededToExtract = 45;
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,FixFileForZip64,The following statement contains a magic number: _zipFs.Seek((long)_crc32Location + 14' SeekOrigin.Begin);
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,FixFileForZip64,The following statement contains a magic number: ushort extraFieldLength = 20;
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,FixFileForZip64,The following statement contains a magic number: ExpandFile(_zipFs' (long)_extraLocation' posNow' 20);
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,FixFileForZip64,The following statement contains a magic number: _zipFs.Position = posNow + 20;
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,ExpandFile,The following statement contains a magic number: const int bufferSize = 40960;
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,WriteCompressedSize,The following statement contains a magic number: bw.Write(CRC[3]);
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,WriteCompressedSize,The following statement contains a magic number: bw.Write(CRC[2]);
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,WriteCompressedSize,The following statement contains a magic number: bw.Write((ushort) 16);
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,LocalFileCheck,The following statement contains a magic number: switch (_compressionMethod)                      {                          case 8:                              sInput = new DeflateStream(_zipFs' CompressionMode.Decompress' true);                              break;                          case 0:                              sInput = _zipFs;                              break;                      }
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,LocalFileCheck,The following statement contains a magic number: _compressionMethod == 8
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,LocalFileCheck,The following statement contains a magic number: _compressionMethod == 8
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,LocalFileAddDirectory,The following statement contains a magic number: ds.WriteByte(03);
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,ReadCRC,The following statement contains a magic number: byte[] tCRC = new byte[4];
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,ReadCRC,The following statement contains a magic number: tCRC[3] = br.ReadByte();
Magic Number,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,ReadCRC,The following statement contains a magic number: tCRC[2] = br.ReadByte();
Magic Number,Compress.ZipFile.ZLib,CRC32,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Crc32.cs,_InternalComputeCrc32,The following statement contains a magic number: return (Int32)(crc32Table[(W ^ B) & 0xFF] ^ (W >> 8));
Magic Number,Compress.ZipFile.ZLib,CRC32,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Crc32.cs,SlurpBlock,The following statement contains a magic number: UInt32 temp = (_register >> 24) ^ b;
Magic Number,Compress.ZipFile.ZLib,CRC32,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Crc32.cs,SlurpBlock,The following statement contains a magic number: _register = (_register << 8) ^ crc32Table[temp];
Magic Number,Compress.ZipFile.ZLib,CRC32,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Crc32.cs,UpdateCRC,The following statement contains a magic number: UInt32 temp = (_register >> 24) ^ b;
Magic Number,Compress.ZipFile.ZLib,CRC32,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Crc32.cs,UpdateCRC,The following statement contains a magic number: _register = (_register << 8) ^ crc32Table[temp];
Magic Number,Compress.ZipFile.ZLib,CRC32,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Crc32.cs,UpdateCRC,The following statement contains a magic number: uint temp = (_register >> 24) ^ b;
Magic Number,Compress.ZipFile.ZLib,CRC32,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Crc32.cs,UpdateCRC,The following statement contains a magic number: _register = (_register << 8) ^ crc32Table[(temp >= 0)                                                                ? temp                                                                : (temp + 256)];
Magic Number,Compress.ZipFile.ZLib,CRC32,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Crc32.cs,UpdateCRC,The following statement contains a magic number: _register = (_register << 8) ^ crc32Table[(temp >= 0)                                                                ? temp                                                                : (temp + 256)];
Magic Number,Compress.ZipFile.ZLib,CRC32,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Crc32.cs,ReverseBits,The following statement contains a magic number: ret = (ret & 0x33333333) << 2 | (ret >> 2) & 0x33333333;
Magic Number,Compress.ZipFile.ZLib,CRC32,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Crc32.cs,ReverseBits,The following statement contains a magic number: ret = (ret & 0x33333333) << 2 | (ret >> 2) & 0x33333333;
Magic Number,Compress.ZipFile.ZLib,CRC32,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Crc32.cs,ReverseBits,The following statement contains a magic number: ret = (ret & 0x0F0F0F0F) << 4 | (ret >> 4) & 0x0F0F0F0F;
Magic Number,Compress.ZipFile.ZLib,CRC32,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Crc32.cs,ReverseBits,The following statement contains a magic number: ret = (ret & 0x0F0F0F0F) << 4 | (ret >> 4) & 0x0F0F0F0F;
Magic Number,Compress.ZipFile.ZLib,CRC32,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Crc32.cs,ReverseBits,The following statement contains a magic number: ret = (ret << 24) | ((ret & 0xFF00) << 8) | ((ret >> 8) & 0xFF00) | (ret >> 24);
Magic Number,Compress.ZipFile.ZLib,CRC32,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Crc32.cs,ReverseBits,The following statement contains a magic number: ret = (ret << 24) | ((ret & 0xFF00) << 8) | ((ret >> 8) & 0xFF00) | (ret >> 24);
Magic Number,Compress.ZipFile.ZLib,CRC32,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Crc32.cs,ReverseBits,The following statement contains a magic number: ret = (ret << 24) | ((ret & 0xFF00) << 8) | ((ret >> 8) & 0xFF00) | (ret >> 24);
Magic Number,Compress.ZipFile.ZLib,CRC32,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Crc32.cs,ReverseBits,The following statement contains a magic number: ret = (ret << 24) | ((ret & 0xFF00) << 8) | ((ret >> 8) & 0xFF00) | (ret >> 24);
Magic Number,Compress.ZipFile.ZLib,CRC32,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Crc32.cs,ReverseBits,The following statement contains a magic number: uint t = (u << 2) & (m << 1);
Magic Number,Compress.ZipFile.ZLib,CRC32,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Crc32.cs,ReverseBits,The following statement contains a magic number: return (byte)((0x01001001 * (s + t)) >> 24);
Magic Number,Compress.ZipFile.ZLib,CRC32,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Crc32.cs,GenerateLookupTable,The following statement contains a magic number: crc32Table = new UInt32[256];
Magic Number,Compress.ZipFile.ZLib,CRC32,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Crc32.cs,gf2_matrix_square,The following statement contains a magic number: i < 32
Magic Number,Compress.ZipFile.ZLib,CRC32,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Crc32.cs,Combine,The following statement contains a magic number: uint[] even = new uint[32];
Magic Number,Compress.ZipFile.ZLib,CRC32,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Crc32.cs,Combine,The following statement contains a magic number: uint[] odd = new uint[32];
Magic Number,Compress.ZipFile.ZLib,CRC32,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Crc32.cs,Combine,The following statement contains a magic number: i < 32
Magic Number,Compress.ZipFile.ZLib,CRC32Hash,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Crc32.cs,HashFinal,The following statement contains a magic number: HashValue = new[]                                   {                                       (byte) ((crcValue >> 24) & 0xff)'                                       (byte) ((crcValue >> 16) & 0xff)'                                       (byte) ((crcValue >> 8) & 0xff)'                                       (byte) (crcValue & 0xff)                                   };
Magic Number,Compress.ZipFile.ZLib,CRC32Hash,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Crc32.cs,HashFinal,The following statement contains a magic number: HashValue = new[]                                   {                                       (byte) ((crcValue >> 24) & 0xff)'                                       (byte) ((crcValue >> 16) & 0xff)'                                       (byte) ((crcValue >> 8) & 0xff)'                                       (byte) (crcValue & 0xff)                                   };
Magic Number,Compress.ZipFile.ZLib,CRC32Hash,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Crc32.cs,HashFinal,The following statement contains a magic number: HashValue = new[]                                   {                                       (byte) ((crcValue >> 24) & 0xff)'                                       (byte) ((crcValue >> 16) & 0xff)'                                       (byte) ((crcValue >> 8) & 0xff)'                                       (byte) (crcValue & 0xff)                                   };
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,DeflateManager,The following statement contains a magic number: dyn_ltree = new short[HEAP_SIZE * 2];
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,DeflateManager,The following statement contains a magic number: dyn_dtree = new short[(2 * InternalConstants.D_CODES + 1) * 2];
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,DeflateManager,The following statement contains a magic number: dyn_dtree = new short[(2 * InternalConstants.D_CODES + 1) * 2];
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,DeflateManager,The following statement contains a magic number: bl_tree = new short[(2 * InternalConstants.BL_CODES + 1) * 2];
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,DeflateManager,The following statement contains a magic number: bl_tree = new short[(2 * InternalConstants.BL_CODES + 1) * 2];
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,_InitializeLazyMatch,The following statement contains a magic number: window_size = 2 * w_size;
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,_InitializeTreeData,The following statement contains a magic number: last_eob_len = 8;
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,_InitializeBlocks,The following statement contains a magic number: dyn_ltree[i * 2] = 0;
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,_InitializeBlocks,The following statement contains a magic number: dyn_dtree[i * 2] = 0;
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,_InitializeBlocks,The following statement contains a magic number: bl_tree[i * 2] = 0;
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,_InitializeBlocks,The following statement contains a magic number: dyn_ltree[END_BLOCK * 2] = 1;
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,_IsSmaller,The following statement contains a magic number: short tn2 = tree[n * 2];
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,_IsSmaller,The following statement contains a magic number: short tm2 = tree[m * 2];
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,scan_tree,The following statement contains a magic number: int nextlen = (int)tree[0 * 2 + 1];
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,scan_tree,The following statement contains a magic number: int max_count = 7;
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,scan_tree,The following statement contains a magic number: int min_count = 4;
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,scan_tree,The following statement contains a magic number: max_count = 138;
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,scan_tree,The following statement contains a magic number: min_count = 3;
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,scan_tree,The following statement contains a magic number: tree[(max_code + 1) * 2 + 1] = (short)0x7fff;
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,scan_tree,The following statement contains a magic number: nextlen = (int)tree[(n + 1) * 2 + 1];
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,scan_tree,The following statement contains a magic number: max_count = 138;
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,scan_tree,The following statement contains a magic number: min_count = 3;
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,build_bl_tree,The following statement contains a magic number: bl_tree[Tree.bl_order[max_blindex] * 2 + 1] != 0
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,build_bl_tree,The following statement contains a magic number: max_blindex >= 3
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(lcodes - 257' 5);
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(lcodes - 257' 5);
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(dcodes - 1' 5);
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(blcodes - 4' 4);
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(blcodes - 4' 4);
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(bl_tree[Tree.bl_order[rank] * 2 + 1]' 3);
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(bl_tree[Tree.bl_order[rank] * 2 + 1]' 3);
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,send_tree,The following statement contains a magic number: int nextlen   = tree[0 * 2 + 1];
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,send_tree,The following statement contains a magic number: int max_count = 7;
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,send_tree,The following statement contains a magic number: int min_count = 4;
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,send_tree,The following statement contains a magic number: max_count = 138;
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,send_tree,The following statement contains a magic number: min_count = 3;
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,send_tree,The following statement contains a magic number: nextlen = tree[(n + 1) * 2 + 1];
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,send_tree,The following statement contains a magic number: max_count = 138;
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,send_tree,The following statement contains a magic number: min_count = 3;
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,send_code,The following statement contains a magic number: int c2 = c * 2;
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,send_bits,The following statement contains a magic number: pending[pendingCount++] = (byte)(bi_buf >> 8);
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,_tr_align,The following statement contains a magic number: send_bits(STATIC_TREES << 1' 3);
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,_tr_align,The following statement contains a magic number: send_bits(STATIC_TREES << 1' 3);
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,_tr_align,The following statement contains a magic number: 1 + last_eob_len + 10 - bi_valid < 9
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,_tr_align,The following statement contains a magic number: 1 + last_eob_len + 10 - bi_valid < 9
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,_tr_align,The following statement contains a magic number: last_eob_len = 7;
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,_tr_tally,The following statement contains a magic number: pending[_distanceOffset + last_lit * 2] = unchecked((byte)((uint)dist >> 8));
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,_tr_tally,The following statement contains a magic number: pending[_distanceOffset + last_lit * 2] = unchecked((byte)((uint)dist >> 8));
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,_tr_tally,The following statement contains a magic number: pending[_distanceOffset + last_lit * 2 + 1] = unchecked((byte)dist);
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,_tr_tally,The following statement contains a magic number: dyn_ltree[lc * 2]++;
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,_tr_tally,The following statement contains a magic number: int out_length = last_lit << 3;
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,_tr_tally,The following statement contains a magic number: out_length = (int)(out_length + (int)dyn_dtree[dcode * 2] * (5L + Tree.ExtraDistanceBits[dcode]));
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,_tr_tally,The following statement contains a magic number: out_length = (int)(out_length + (int)dyn_dtree[dcode * 2] * (5L + Tree.ExtraDistanceBits[dcode]));
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,_tr_tally,The following statement contains a magic number: out_length >>= 3;
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,_tr_tally,The following statement contains a magic number: (matches < (last_lit / 2)) && out_length < in_length / 2
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,_tr_tally,The following statement contains a magic number: (matches < (last_lit / 2)) && out_length < in_length / 2
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,_tr_tally,The following statement contains a magic number: (last_lit & 0x1fff) == 0 && (int)compressionLevel > 2
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,send_compressed_block,The following statement contains a magic number: int ix = _distanceOffset + lx * 2;
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,send_compressed_block,The following statement contains a magic number: distance = ((pending[ix] << 8) & 0xff00) |                          (pending[ix + 1] & 0xff);
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,send_compressed_block,The following statement contains a magic number: last_eob_len = ltree[END_BLOCK * 2 + 1];
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,set_data_type,The following statement contains a magic number: bin_freq += dyn_ltree[n * 2];
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,set_data_type,The following statement contains a magic number: n < 7
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,set_data_type,The following statement contains a magic number: ascii_freq += dyn_ltree[n * 2];
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,set_data_type,The following statement contains a magic number: n < 128
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,set_data_type,The following statement contains a magic number: bin_freq += dyn_ltree[n * 2];
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,set_data_type,The following statement contains a magic number: data_type = (sbyte)(bin_freq > (ascii_freq >> 2) ? Z_BINARY : Z_ASCII);
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,bi_flush,The following statement contains a magic number: pending[pendingCount++] = (byte)(bi_buf >> 8);
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,bi_flush,The following statement contains a magic number: bi_valid == 16
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,bi_windup,The following statement contains a magic number: pending[pendingCount++] = (byte)(bi_buf >> 8);
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,bi_windup,The following statement contains a magic number: bi_valid > 8
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,copy_block,The following statement contains a magic number: last_eob_len = 8;
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,copy_block,The following statement contains a magic number: unchecked                  {                      //put_short((short)len);                      pending[pendingCount++] = (byte)len;                      pending[pendingCount++] = (byte)(len >> 8);                      //put_short((short)~len);                      pending[pendingCount++] = (byte)~len;                      pending[pendingCount++] = (byte)(~len >> 8);                  }
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,copy_block,The following statement contains a magic number: unchecked                  {                      //put_short((short)len);                      pending[pendingCount++] = (byte)len;                      pending[pendingCount++] = (byte)(len >> 8);                      //put_short((short)~len);                      pending[pendingCount++] = (byte)~len;                      pending[pendingCount++] = (byte)(~len >> 8);                  }
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,DeflateNone,The following statement contains a magic number: max_block_size = pending.Length - 5;
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,DeflateNone,The following statement contains a magic number: max_block_size > pending.Length - 5
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,_tr_stored_block,The following statement contains a magic number: send_bits((STORED_BLOCK << 1) + (eof ? 1 : 0)' 3);
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: opt_lenb = (opt_len + 3 + 7) >> 3;
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: opt_lenb = (opt_len + 3 + 7) >> 3;
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: opt_lenb = (opt_len + 3 + 7) >> 3;
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: static_lenb = (static_len + 3 + 7) >> 3;
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: static_lenb = (static_len + 3 + 7) >> 3;
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: static_lenb = (static_len + 3 + 7) >> 3;
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: stored_len + 4 <= opt_lenb && buf != -1
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,DeflateSlow,The following statement contains a magic number: match_length <= 5 && (compressionStrategy == CompressionStrategy.Filtered ||                                                (match_length == MIN_MATCH && strstart - match_start > 4096))
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,DeflateSlow,The following statement contains a magic number: match_length <= 5 && (compressionStrategy == CompressionStrategy.Filtered ||                                                (match_length == MIN_MATCH && strstart - match_start > 4096))
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,DeflateSlow,The following statement contains a magic number: prev_length -= 2;
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,longest_match,The following statement contains a magic number: chain_length >>= 2;
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,longest_match,The following statement contains a magic number: scan += 2;
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Initialize,The following statement contains a magic number: windowBits < 9 || windowBits > 15
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Initialize,The following statement contains a magic number: windowBits < 9 || windowBits > 15
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Initialize,The following statement contains a magic number: hash_bits = memLevel + 7;
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Initialize,The following statement contains a magic number: window = new byte[w_size * 2];
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Initialize,The following statement contains a magic number: lit_bufsize = 1 << (memLevel + 6);
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Initialize,The following statement contains a magic number: pending = new byte[lit_bufsize * 4];
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Initialize,The following statement contains a magic number: _lengthOffset = (1 + 2) * lit_bufsize;
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Deflate,The following statement contains a magic number: int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Deflate,The following statement contains a magic number: int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Deflate,The following statement contains a magic number: int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Deflate,The following statement contains a magic number: level_flags = 3;
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Deflate,The following statement contains a magic number: level_flags > 3
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Deflate,The following statement contains a magic number: header |= (level_flags << 6);
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Deflate,The following statement contains a magic number: header += 31 - (header % 31);
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Deflate,The following statement contains a magic number: header += 31 - (header % 31);
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Deflate,The following statement contains a magic number: pending[pendingCount++] = (byte)(header >> 8);
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Deflate,The following statement contains a magic number: pending[pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000) >> 24);
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Deflate,The following statement contains a magic number: pending[pendingCount++] = (byte)((_codec._Adler32 & 0x00FF0000) >> 16);
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Deflate,The following statement contains a magic number: pending[pendingCount++] = (byte)((_codec._Adler32 & 0x0000FF00) >> 8);
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Deflate,The following statement contains a magic number: pending[pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000) >> 24);
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Deflate,The following statement contains a magic number: pending[pendingCount++] = (byte)((_codec._Adler32 & 0x00FF0000) >> 16);
Magic Number,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Deflate,The following statement contains a magic number: pending[pendingCount++] = (byte)((_codec._Adler32 & 0x0000FF00) >> 8);
Magic Number,Compress.ZipFile.ZLib,Config,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Compress.ZipFile.ZLib,Config,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Compress.ZipFile.ZLib,Config,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Compress.ZipFile.ZLib,Config,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Compress.ZipFile.ZLib,Config,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Compress.ZipFile.ZLib,Config,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Compress.ZipFile.ZLib,Config,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Compress.ZipFile.ZLib,Config,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Compress.ZipFile.ZLib,Config,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Compress.ZipFile.ZLib,Config,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Compress.ZipFile.ZLib,Config,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Compress.ZipFile.ZLib,Config,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Compress.ZipFile.ZLib,Config,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Compress.ZipFile.ZLib,Config,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Compress.ZipFile.ZLib,Config,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Compress.ZipFile.ZLib,Config,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Compress.ZipFile.ZLib,Config,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Compress.ZipFile.ZLib,Config,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Compress.ZipFile.ZLib,Config,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Compress.ZipFile.ZLib,Config,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Compress.ZipFile.ZLib,Config,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Compress.ZipFile.ZLib,Config,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Compress.ZipFile.ZLib,Config,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Compress.ZipFile.ZLib,Config,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Compress.ZipFile.ZLib,Config,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Compress.ZipFile.ZLib,Config,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Compress.ZipFile.ZLib,Config,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Compress.ZipFile.ZLib,Config,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Compress.ZipFile.ZLib,Config,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Compress.ZipFile.ZLib,Config,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Compress.ZipFile.ZLib,Config,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Compress.ZipFile.ZLib,Config,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Compress.ZipFile.ZLib,Config,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Compress.ZipFile.ZLib,Config,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Compress.ZipFile.ZLib,Config,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Compress.ZipFile.ZLib,Config,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Compress.ZipFile.ZLib,GZipStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\GZipStream.cs,EmitHeader,The following statement contains a magic number: int bufferLength = 10 + cbLength + fnLength;
Magic Number,Compress.ZipFile.ZLib,GZipStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\GZipStream.cs,EmitHeader,The following statement contains a magic number: header[i++] = 8;
Magic Number,Compress.ZipFile.ZLib,GZipStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\GZipStream.cs,EmitHeader,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(timet)' 0' header' i' 4);
Magic Number,Compress.ZipFile.ZLib,GZipStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\GZipStream.cs,EmitHeader,The following statement contains a magic number: i += 4;
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,InflateBlocks,The following statement contains a magic number: hufts = new int[MANY * 3];
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Flush,The following statement contains a magic number: pass < 2
Magic Number,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: k += 8;
Magic Number,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: k < (20)
Magic Number,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: tp_index_t_3 = (tp_index + t) * 3;
Magic Number,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: s.window[q++] = (byte)tp[tp_index_t_3 + 2];
Magic Number,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: e &= 15;
Magic Number,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);
Magic Number,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: k += 8;
Magic Number,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: k < 15
Magic Number,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: tp_index_t_3 = (tp_index + t) * 3;
Magic Number,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: e &= 15;
Magic Number,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: k += 8;
Magic Number,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);
Magic Number,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: c -= 2;
Magic Number,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: q - r > 0 && 2 > (q - r)
Magic Number,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: (e & 16) != 0
Magic Number,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: (e & 16) != 0
Magic Number,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: t += tp[tp_index_t_3 + 2];
Magic Number,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: tp_index_t_3 = (tp_index + t) * 3;
Magic Number,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: s.window[q++] = (byte)tp[tp_index_t_3 + 2];
Magic Number,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: (e & 64) == 0
Magic Number,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;
Magic Number,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;
Magic Number,Compress.ZipFile.ZLib,InflateCodes,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,InflateFast,The following statement contains a magic number: k -= (c << 3);
Magic Number,Compress.ZipFile.ZLib,InflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Initialize,The following statement contains a magic number: w < 8 || w > 15
Magic Number,Compress.ZipFile.ZLib,InflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Initialize,The following statement contains a magic number: w < 8 || w > 15
Magic Number,Compress.ZipFile.ZLib,InflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }
Magic Number,Compress.ZipFile.ZLib,InflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }
Magic Number,Compress.ZipFile.ZLib,InflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }
Magic Number,Compress.ZipFile.ZLib,InflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }
Magic Number,Compress.ZipFile.ZLib,InflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }
Magic Number,Compress.ZipFile.ZLib,InflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }
Magic Number,Compress.ZipFile.ZLib,InflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }
Magic Number,Compress.ZipFile.ZLib,InflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }
Magic Number,Compress.ZipFile.ZLib,InflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }
Magic Number,Compress.ZipFile.ZLib,InflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }
Magic Number,Compress.ZipFile.ZLib,InflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }
Magic Number,Compress.ZipFile.ZLib,InflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }
Magic Number,Compress.ZipFile.ZLib,InflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }
Magic Number,Compress.ZipFile.ZLib,InflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }
Magic Number,Compress.ZipFile.ZLib,InflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }
Magic Number,Compress.ZipFile.ZLib,InflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }
Magic Number,Compress.ZipFile.ZLib,InflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Sync,The following statement contains a magic number: n != 0 && m < 4
Magic Number,Compress.ZipFile.ZLib,InflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Sync,The following statement contains a magic number: m != 4
Magic Number,Compress.ZipFile.ZLib,InfTree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\InfTree.cs,huft_build,The following statement contains a magic number: xp = 2;
Magic Number,Compress.ZipFile.ZLib,InfTree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\InfTree.cs,huft_build,The following statement contains a magic number: r[2] = (int) (q - u[h - 1] - j);
Magic Number,Compress.ZipFile.ZLib,InfTree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\InfTree.cs,huft_build,The following statement contains a magic number: Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3);
Magic Number,Compress.ZipFile.ZLib,InfTree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\InfTree.cs,huft_build,The following statement contains a magic number: Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3);
Magic Number,Compress.ZipFile.ZLib,InfTree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\InfTree.cs,huft_build,The following statement contains a magic number: r[0] = 128 + 64;
Magic Number,Compress.ZipFile.ZLib,InfTree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\InfTree.cs,huft_build,The following statement contains a magic number: r[0] = 128 + 64;
Magic Number,Compress.ZipFile.ZLib,InfTree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\InfTree.cs,huft_build,The following statement contains a magic number: Array.Copy(r' 0' hp' (q + j) * 3' 3);
Magic Number,Compress.ZipFile.ZLib,InfTree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\InfTree.cs,huft_build,The following statement contains a magic number: Array.Copy(r' 0' hp' (q + j) * 3' 3);
Magic Number,Compress.ZipFile.ZLib,InfTree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: initWorkArea(19);
Magic Number,Compress.ZipFile.ZLib,InfTree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: result = huft_build(c' 0' 19' 19' null' null' tb' bb' hp' hn' v);
Magic Number,Compress.ZipFile.ZLib,InfTree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: result = huft_build(c' 0' 19' 19' null' null' tb' bb' hp' hn' v);
Magic Number,Compress.ZipFile.ZLib,InfTree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: initWorkArea(288);
Magic Number,Compress.ZipFile.ZLib,InfTree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: result = huft_build(c' 0' nl' 257' cplens' cplext' tl' bl' hp' hn' v);
Magic Number,Compress.ZipFile.ZLib,InfTree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: initWorkArea(288);
Magic Number,Compress.ZipFile.ZLib,InfTree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: result != Z_OK || (bd[0] == 0 && nl > 257)
Magic Number,Compress.ZipFile.ZLib,InfTree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\InfTree.cs,initWorkArea,The following statement contains a magic number: r = new int[3];
Magic Number,Compress.ZipFile.ZLib,Tree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Tree.cs,DistanceCode,The following statement contains a magic number: return (dist < 256)                  ? _dist_code[dist]                  : _dist_code[256 + SharedUtils.URShift(dist' 7)];
Magic Number,Compress.ZipFile.ZLib,Tree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Tree.cs,DistanceCode,The following statement contains a magic number: return (dist < 256)                  ? _dist_code[dist]                  : _dist_code[256 + SharedUtils.URShift(dist' 7)];
Magic Number,Compress.ZipFile.ZLib,Tree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Tree.cs,DistanceCode,The following statement contains a magic number: return (dist < 256)                  ? _dist_code[dist]                  : _dist_code[256 + SharedUtils.URShift(dist' 7)];
Magic Number,Compress.ZipFile.ZLib,Tree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Tree.cs,gen_bitlen,The following statement contains a magic number: tree[s.heap[s.heap_max] * 2 + 1] = 0;
Magic Number,Compress.ZipFile.ZLib,Tree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Tree.cs,gen_bitlen,The following statement contains a magic number: bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
Magic Number,Compress.ZipFile.ZLib,Tree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Tree.cs,gen_bitlen,The following statement contains a magic number: bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
Magic Number,Compress.ZipFile.ZLib,Tree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Tree.cs,gen_bitlen,The following statement contains a magic number: tree[n * 2 + 1] = (short) bits;
Magic Number,Compress.ZipFile.ZLib,Tree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Tree.cs,gen_bitlen,The following statement contains a magic number: f = tree[n * 2];
Magic Number,Compress.ZipFile.ZLib,Tree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Tree.cs,gen_bitlen,The following statement contains a magic number: s.static_len += f * (stree[n * 2 + 1] + xbits);
Magic Number,Compress.ZipFile.ZLib,Tree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Tree.cs,gen_bitlen,The following statement contains a magic number: s.bl_count[bits + 1] = (short) (s.bl_count[bits + 1] + 2);
Magic Number,Compress.ZipFile.ZLib,Tree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Tree.cs,gen_bitlen,The following statement contains a magic number: overflow -= 2;
Magic Number,Compress.ZipFile.ZLib,Tree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Tree.cs,gen_bitlen,The following statement contains a magic number: s.opt_len = (int) (s.opt_len + ((long) bits - (long) tree[m * 2 + 1]) * (long) tree[m * 2]);
Magic Number,Compress.ZipFile.ZLib,Tree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Tree.cs,gen_bitlen,The following statement contains a magic number: s.opt_len = (int) (s.opt_len + ((long) bits - (long) tree[m * 2 + 1]) * (long) tree[m * 2]);
Magic Number,Compress.ZipFile.ZLib,Tree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Tree.cs,gen_bitlen,The following statement contains a magic number: tree[m * 2 + 1] = (short) bits;
Magic Number,Compress.ZipFile.ZLib,Tree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Tree.cs,gen_bitlen,The following statement contains a magic number: tree[m * 2 + 1] != bits
Magic Number,Compress.ZipFile.ZLib,Tree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Tree.cs,build_tree,The following statement contains a magic number: tree[n * 2] != 0
Magic Number,Compress.ZipFile.ZLib,Tree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Tree.cs,build_tree,The following statement contains a magic number: node = s.heap[++s.heap_len] = (max_code < 2?++max_code:0);
Magic Number,Compress.ZipFile.ZLib,Tree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Tree.cs,build_tree,The following statement contains a magic number: tree[node * 2] = 1;
Magic Number,Compress.ZipFile.ZLib,Tree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Tree.cs,build_tree,The following statement contains a magic number: s.static_len -= stree[node * 2 + 1];
Magic Number,Compress.ZipFile.ZLib,Tree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Tree.cs,build_tree,The following statement contains a magic number: s.heap_len < 2
Magic Number,Compress.ZipFile.ZLib,Tree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Tree.cs,build_tree,The following statement contains a magic number: tree[node * 2] = unchecked((short) (tree[n * 2] + tree[m * 2]));
Magic Number,Compress.ZipFile.ZLib,Tree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Tree.cs,build_tree,The following statement contains a magic number: tree[node * 2] = unchecked((short) (tree[n * 2] + tree[m * 2]));
Magic Number,Compress.ZipFile.ZLib,Tree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Tree.cs,build_tree,The following statement contains a magic number: tree[node * 2] = unchecked((short) (tree[n * 2] + tree[m * 2]));
Magic Number,Compress.ZipFile.ZLib,Tree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Tree.cs,build_tree,The following statement contains a magic number: tree[n * 2 + 1] = tree[m * 2 + 1] = (short) node;
Magic Number,Compress.ZipFile.ZLib,Tree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Tree.cs,build_tree,The following statement contains a magic number: tree[n * 2 + 1] = tree[m * 2 + 1] = (short) node;
Magic Number,Compress.ZipFile.ZLib,Tree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Tree.cs,gen_codes,The following statement contains a magic number: int len = tree[n * 2 + 1];
Magic Number,Compress.ZipFile.ZLib,Tree,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Tree.cs,gen_codes,The following statement contains a magic number: tree[n * 2] =  unchecked((short) (bi_reverse(next_code[len]++' len)));
Magic Number,Compress.ZipFile.ZLib,Adler,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Zlib.cs,Adler32,The following statement contains a magic number: uint s2 = (uint) ((adler >> 16) & 0xffff);
Magic Number,Compress.ZipFile.ZLib,Adler,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Zlib.cs,Adler32,The following statement contains a magic number: k -= 16;
Magic Number,Compress.ZipFile.ZLib,Adler,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Zlib.cs,Adler32,The following statement contains a magic number: k >= 16
Magic Number,Compress.ZipFile.ZLib,Adler,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Zlib.cs,Adler32,The following statement contains a magic number: return (uint)((s2 << 16) | s1);
Magic Number,Compress.ZipFile.ZLib,ZlibBaseStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\ZlibBaseStream.cs,Write,The following statement contains a magic number: done = (_z.AvailableBytesIn == 8 && _z.AvailableBytesOut != 0);
Magic Number,Compress.ZipFile.ZLib,ZlibBaseStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\ZlibBaseStream.cs,finish,The following statement contains a magic number: done = (_z.AvailableBytesIn == 8 && _z.AvailableBytesOut != 0);
Magic Number,Compress.ZipFile.ZLib,ZlibBaseStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\ZlibBaseStream.cs,finish,The following statement contains a magic number: _stream.Write(BitConverter.GetBytes(c1)' 0' 4);
Magic Number,Compress.ZipFile.ZLib,ZlibBaseStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\ZlibBaseStream.cs,finish,The following statement contains a magic number: _stream.Write(BitConverter.GetBytes(c2)' 0' 4);
Magic Number,Compress.ZipFile.ZLib,ZlibBaseStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: byte[] header = new byte[10];
Magic Number,Compress.ZipFile.ZLib,ZlibBaseStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: n != 10
Magic Number,Compress.ZipFile.ZLib,ZlibBaseStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: header[0] != 0x1F || header[1] != 0x8B || header[2] != 8
Magic Number,Compress.ZipFile.ZLib,ZlibBaseStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: header[0] != 0x1F || header[1] != 0x8B || header[2] != 8
Magic Number,Compress.ZipFile.ZLib,ZlibBaseStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: Int32 timet = BitConverter.ToInt32(header' 4);
Magic Number,Compress.ZipFile.ZLib,ZlibBaseStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: n = _stream.Read(header' 0' 2);
Magic Number,Compress.ZipFile.ZLib,ZlibBaseStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: Int16 extraLength = (Int16)(header[0] + header[1] * 256);
Magic Number,Compress.ZipFile.ZLib,ZlibBaseStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: (header[3] & 0x04) == 0x04
Magic Number,Compress.ZipFile.ZLib,ZlibBaseStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: (header[3] & 0x08) == 0x08
Magic Number,Compress.ZipFile.ZLib,ZlibBaseStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: (header[3] & 0x10) == 0x010
Magic Number,Compress.ZipFile.ZLib,ZlibBaseStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: (header[3] & 0x02) == 0x02
Magic Number,Compress.ZipFile.ZLib,ZlibBaseStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\ZlibBaseStream.cs,UncompressString,The following statement contains a magic number: byte[] working = new byte[1024];
Magic Number,Compress.ZipFile.ZLib,ZlibBaseStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\ZlibBaseStream.cs,UncompressBuffer,The following statement contains a magic number: byte[] working = new byte[1024];
Duplicate Code,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,GetAndMoveToFrontDecode,The method contains a code clone-set at the following line numbers (starting from the method definition): ((32' 75)' (101' 144))
Duplicate Code,Compress.SevenZip.Compress.BZip2,CBZip2InputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2InputStream.cs,GetAndMoveToFrontDecode,The method contains a code clone-set at the following line numbers (starting from the method definition): ((32' 59)' (198' 225)' (101' 128))
Duplicate Code,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,HbMakeCodeLengths,The method contains a code clone-set at the following line numbers (starting from the method definition): ((52' 78)' (80' 106))
Duplicate Code,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,FullGtU,The method contains a code clone-set at the following line numbers (starting from the method definition): ((5' 24)' (14' 33)' (23' 42)' (32' 51))
Duplicate Code,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,FullGtU,The method contains a code clone-set at the following line numbers (starting from the method definition): ((5' 50)' (14' 59))
Duplicate Code,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,FullGtU,The method contains a code clone-set at the following line numbers (starting from the method definition): ((5' 24)' (23' 42)' (32' 51))
Duplicate Code,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,FullGtU,The method contains a code clone-set at the following line numbers (starting from the method definition): ((64' 97)' (79' 112))
Duplicate Code,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,FullGtU,The method contains a code clone-set at the following line numbers (starting from the method definition): ((64' 83)' (94' 113))
Duplicate Code,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The method contains a code clone-set at the following line numbers (starting from the method definition): ((28' 47)' (245' 264)' (186' 205)' (246' 265))
Duplicate Code,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The method contains a code clone-set at the following line numbers (starting from the method definition): ((186' 205)' (313' 332)' (348' 367)' (246' 265))
Missing Default,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,GenerateMTFValues,The following switch statement is missing a default case: switch (zPend % 2)                              {                                  case 0:                                      szptr[wr] = (short)BZip2Constants.RUNA;                                      wr++;                                      mtfFreq[BZip2Constants.RUNA]++;                                      break;                                  case 1:                                      szptr[wr] = (short)BZip2Constants.RUNB;                                      wr++;                                      mtfFreq[BZip2Constants.RUNB]++;                                      break;                              }
Missing Default,Compress.SevenZip.Compress.BZip2,CBZip2OutputStream,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Compress\BZip2\CBZip2OutputStream.cs,GenerateMTFValues,The following switch statement is missing a default case: switch (zPend % 2)                      {                          case 0:                              szptr[wr] = (short)BZip2Constants.RUNA;                              wr++;                              mtfFreq[BZip2Constants.RUNA]++;                              break;                          case 1:                              szptr[wr] = (short)BZip2Constants.RUNB;                              wr++;                              mtfFreq[BZip2Constants.RUNB]++;                              break;                      }
Missing Default,Compress.SevenZip,SevenZ,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\SevenZip.cs,ZipFileClose,The following switch statement is missing a default case: switch (ZipOpen)              {                  case ZipOpenType.Closed:                      return;                  case ZipOpenType.OpenRead:                      ZipFileCloseReadStream();                      if (_zipFs != null)                      {                          _zipFs.Close();                          _zipFs.Dispose();                      }                      _memoryZipFile = null;                      ZipOpen = ZipOpenType.Closed;                      return;                  case ZipOpenType.OpenWrite:                      CloseWriting7Zip();                      if (_zipFileInfo != null)                          _zipFileInfo = new FileInfo(_zipFileInfo.FullName);                      break;              }
Missing Default,Compress.SevenZip.Structure,Folder,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Structure\Folder.cs,ReadUnPackInfo,The following switch statement is missing a default case: switch (external)                          {                              case 0:                              {                                  ulong folderIndex = 0;                                  for (uint i = 0; i < numFolders; i++)                                  {                                      Folders[i] = new Folder();                                      Folders[i].ReadFolder(br);                                      Folders[i].PackedStreamIndexBase = folderIndex;                                      folderIndex += (ulong) Folders[i].PackedStreamIndices.Length;                                  }                                  break;                              }                              case 1:                                  throw new NotSupportedException("External flag");                          }
Missing Default,Compress.SevenZip.Structure,Header,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\SevenZip\Structure\Header.cs,ReadHeaderOrPackedHeader,The following switch statement is missing a default case: switch (hp)              {                  case HeaderProperty.kEncodedHeader:                  {                      StreamsInfo streamsInfo = new StreamsInfo();                      streamsInfo.Read(br);                        if (streamsInfo.Folders.Length > 1)                      {                          return ZipReturn.ZipUnsupportedCompression;                      }                        Folder firstFolder = streamsInfo.Folders[0];                      if (firstFolder.Coders.Length > 1)                      {                          return ZipReturn.ZipUnsupportedCompression;                      }                        byte[] method = firstFolder.Coders[0].Method;                      if (!((method.Length == 3) && (method[0] == 3) && (method[1] == 1) && (method[2] == 1))) // LZMA                      {                          return ZipReturn.ZipUnsupportedCompression;                      }                        stream.Seek(baseOffset + (long) streamsInfo.PackPosition' SeekOrigin.Begin);                      using (LzmaStream decoder = new LzmaStream(firstFolder.Coders[0].Properties' stream))                      {                          ZipReturn zr = ReadHeaderOrPackedHeader(decoder' baseOffset' out header);                          if (zr != ZipReturn.ZipGood)                          {                              return zr;                          }                      }                      return ZipReturn.ZipGood;                  }                  case HeaderProperty.kHeader:                  {                      header = new Header();                      header.Read(br);                      return ZipReturn.ZipGood;                  }              }
Missing Default,Compress.ZipFile,ZipFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,ZipErrorMessageText,The following switch statement is missing a default case: switch (zS)              {                  case ZipReturn.ZipGood:                      ret = "";                      break;                  case ZipReturn.ZipFileCountError:                      ret = "The number of file in the Zip does not mach the number of files in the Zips Centeral Directory";                      break;                  case ZipReturn.ZipSignatureError:                      ret = "An unknown Signature Block was found in the Zip";                      break;                  case ZipReturn.ZipExtraDataOnEndOfZip:                      ret = "Extra Data was found on the end of the Zip";                      break;                  case ZipReturn.ZipUnsupportedCompression:                      ret = "An unsupported Compression method was found in the Zip' if you recompress this zip it will be usable";                      break;                  case ZipReturn.ZipLocalFileHeaderError:                      ret = "Error reading a zipped file header information";                      break;                  case ZipReturn.ZipCenteralDirError:                      ret = "There is an error in the Zip Centeral Directory";                      break;                  case ZipReturn.ZipReadingFromOutputFile:                      ret = "Trying to write to a Zip file open for output only";                      break;                  case ZipReturn.ZipWritingToInputFile:                      ret = "Tring to read from a Zip file open for input only";                      break;                  case ZipReturn.ZipErrorGettingDataStream:                      ret = "Error creating Data Stream";                      break;                  case ZipReturn.ZipCRCDecodeError:                      ret = "CRC error";                      break;                  case ZipReturn.ZipDecodeError:                      ret = "Error unzipping a file";                      break;              }
Missing Default,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,LocalFileOpenReadStream,The following switch statement is missing a default case: switch (_compressionMethod)                  {                      case 8:                          if (raw)                          {                              _readStream = _zipFs;                              streamSize = _compressedSize;                          }                          else                          {                              _readStream = new DeflateStream(_zipFs' CompressionMode.Decompress' true);                              streamSize = UncompressedSize;                          }                          break;                      case 0:                          _readStream = _zipFs;                          streamSize = _compressedSize; // same as UncompressedSize                          break;                  }
Missing Default,Compress.ZipFile,LocalFile,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\zipFile.cs,LocalFileCheck,The following switch statement is missing a default case: switch (_compressionMethod)                      {                          case 8:                              sInput = new DeflateStream(_zipFs' CompressionMode.Decompress' true);                              break;                          case 0:                              sInput = _zipFs;                              break;                      }
Missing Default,Compress.ZipFile.ZLib,DeflateManager,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Deflate.cs,SetDeflater,The following switch statement is missing a default case: switch (config.Flavor)              {                  case DeflateFlavor.Store:                      DeflateFunction = DeflateNone;                      break;                  case DeflateFlavor.Fast:                      DeflateFunction = DeflateFast;                      break;                  case DeflateFlavor.Slow:                      DeflateFunction = DeflateSlow;                      break;              }
Missing Default,Compress.ZipFile.ZLib,InflateBlocks,D:\research\architectureSmells\repos\gjefferyes_RomVault\Compress\ZipFile\ZLib\Inflate.cs,Process,The following switch statement is missing a default case: switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }
