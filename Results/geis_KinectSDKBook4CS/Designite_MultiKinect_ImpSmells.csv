Implementation smell,Namespace,Class,File,Method,Description
Long Statement,MultiKinect,KinectWindow,C:\repos\geis_KinectSDKBook4CS\1_basic\MultiKinect\KinectWindow.xaml.cs,Connect,The length of the statement  "            this.comboBoxRange.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.comboBoxRange_SelectionChanged); " is 133.
Long Statement,MultiKinect,KinectWindow,C:\repos\geis_KinectSDKBook4CS\1_basic\MultiKinect\KinectWindow.xaml.cs,Connect,The length of the statement  "            this.sliderTiltAngle.ValueChanged += new System.Windows.RoutedPropertyChangedEventHandler<double>(this.sliderTiltAngle_ValueChanged); " is 133.
Long Statement,MultiKinect,MainWindow,C:\repos\geis_KinectSDKBook4CS\1_basic\MultiKinect\MainWindow.xaml.cs,Connect,The length of the statement  "            this.comboBoxSkeleton.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.comboBox1_SelectionChanged); " is 132.
Long Statement,XamlGeneratedNamespace,GeneratedInternalTypeHelper,C:\repos\geis_KinectSDKBook4CS\1_basic\MultiKinect\obj\x86\Debug\GeneratedInternalTypeHelper.g.cs,CreateInstance,The length of the statement  "            return System.Activator.CreateInstance(type' ((System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.NonPublic)  " is 128.
Magic Number,MultiKinect,KinectWindow,C:\repos\geis_KinectSDKBook4CS\1_basic\MultiKinect\KinectWindow.xaml.cs,kinect_AllFramesReady,The following statement contains a magic number: try {          // Kinectのインスタンスを取得する          KinectSensor kinect = sender as KinectSensor;          if ( kinect == null ) {            return;          }            // RGBカメラのフレームデータを取得する          using ( ColorImageFrame colorFrame = e.OpenColorImageFrame() ) {            if ( colorFrame != null ) {              // RGBカメラのピクセルデータを取得する              byte[] colorPixel = new byte[colorFrame.PixelDataLength];              colorFrame.CopyPixelDataTo( colorPixel );                // ピクセルデータをビットマップに変換する              imageRgb.Source = BitmapSource.Create( colorFrame.Width' colorFrame.Height' 96' 96'                  PixelFormats.Bgr32' null' colorPixel' colorFrame.Width * colorFrame.BytesPerPixel );            }          }            //// 距離カメラのフレームデータを取得する          //using ( DepthImageFrame depthFrame = e.OpenDepthImageFrame() ) {          //  if ( depthFrame != null ) {          //    // 距離データを画像化して表示          //    imageDepth.Source = BitmapSource.Create( depthFrame.Width' depthFrame.Height' 96' 96'          //        PixelFormats.Bgr32' null' ConvertDepthColor( kinect' depthFrame )'          //        depthFrame.Width * Bgr32BytesPerPixel );          //  }          //}            // スケルトンのフレームを取得する          using ( SkeletonFrame skeletonFrame = e.OpenSkeletonFrame() ) {            if ( skeletonFrame != null ) {              imageRgb.Source = DrawSkeleton( kinect' skeletonFrame' imageRgb.Source );            }          }        }        catch ( Exception ex ) {          MessageBox.Show( ex.Message );        }
Magic Number,MultiKinect,KinectWindow,C:\repos\geis_KinectSDKBook4CS\1_basic\MultiKinect\KinectWindow.xaml.cs,kinect_AllFramesReady,The following statement contains a magic number: try {          // Kinectのインスタンスを取得する          KinectSensor kinect = sender as KinectSensor;          if ( kinect == null ) {            return;          }            // RGBカメラのフレームデータを取得する          using ( ColorImageFrame colorFrame = e.OpenColorImageFrame() ) {            if ( colorFrame != null ) {              // RGBカメラのピクセルデータを取得する              byte[] colorPixel = new byte[colorFrame.PixelDataLength];              colorFrame.CopyPixelDataTo( colorPixel );                // ピクセルデータをビットマップに変換する              imageRgb.Source = BitmapSource.Create( colorFrame.Width' colorFrame.Height' 96' 96'                  PixelFormats.Bgr32' null' colorPixel' colorFrame.Width * colorFrame.BytesPerPixel );            }          }            //// 距離カメラのフレームデータを取得する          //using ( DepthImageFrame depthFrame = e.OpenDepthImageFrame() ) {          //  if ( depthFrame != null ) {          //    // 距離データを画像化して表示          //    imageDepth.Source = BitmapSource.Create( depthFrame.Width' depthFrame.Height' 96' 96'          //        PixelFormats.Bgr32' null' ConvertDepthColor( kinect' depthFrame )'          //        depthFrame.Width * Bgr32BytesPerPixel );          //  }          //}            // スケルトンのフレームを取得する          using ( SkeletonFrame skeletonFrame = e.OpenSkeletonFrame() ) {            if ( skeletonFrame != null ) {              imageRgb.Source = DrawSkeleton( kinect' skeletonFrame' imageRgb.Source );            }          }        }        catch ( Exception ex ) {          MessageBox.Show( ex.Message );        }
Magic Number,MultiKinect,KinectWindow,C:\repos\geis_KinectSDKBook4CS\1_basic\MultiKinect\KinectWindow.xaml.cs,DrawSkeleton,The following statement contains a magic number: using ( DrawingContext drawingContext = drawingVisual.RenderOpen() ) {          // ImageSourceを描画する          drawingContext.DrawImage( source' new Rect( 0' 0' source.Width' source.Height ) );            // トラッキングされているスケルトンのジョイントを描画する          const int R = 5;          foreach ( var skeleton in skeletons ) {            // スケルトンがトラッキングされていなければ次へ            if ( skeleton.TrackingState != SkeletonTrackingState.Tracked ) {              continue;            }              // ジョイントを描画する            foreach ( Joint joint in skeleton.Joints ) {              // ジョイントがトラッキングされていなければ次へ              if ( joint.TrackingState != JointTrackingState.Tracked ) {                continue;              }                // スケルトンの座標を、RGBカメラの座標に変換して円を書く              ColorImagePoint point = kinect.MapSkeletonPointToColor( joint.Position'                kinect.ColorStream.Format );              drawingContext.DrawEllipse( new SolidColorBrush( Colors.Red )'                  new Pen( Brushes.Red' 1 )' new Point( point.X' point.Y )' R' R );            }          }        }
Magic Number,MultiKinect,KinectWindow,C:\repos\geis_KinectSDKBook4CS\1_basic\MultiKinect\KinectWindow.xaml.cs,DrawSkeleton,The following statement contains a magic number: RenderTargetBitmap bitmap = new RenderTargetBitmap( (int)source.Width' (int)source.Height'          96' 96' PixelFormats.Default );
Magic Number,MultiKinect,KinectWindow,C:\repos\geis_KinectSDKBook4CS\1_basic\MultiKinect\KinectWindow.xaml.cs,DrawSkeleton,The following statement contains a magic number: RenderTargetBitmap bitmap = new RenderTargetBitmap( (int)source.Width' (int)source.Height'          96' 96' PixelFormats.Default );
Magic Number,MultiKinect,KinectWindow,C:\repos\geis_KinectSDKBook4CS\1_basic\MultiKinect\KinectWindow.xaml.cs,ConvertDepthColor,The following statement contains a magic number: for ( int index = 0; index < depthPixel.Length; index++ ) {          // 距離カメラのデータから、プレイヤーIDと距離を取得する          int player = depthPixel[index] & DepthImageFrame.PlayerIndexBitmask;          int distance = depthPixel[index] >> DepthImageFrame.PlayerIndexBitmaskWidth;            // 変換した結果が、フレームサイズを超えることがあるため、小さいほうを使う          int x = Math.Min( colorPoint[index].X' colorStream.FrameWidth - 1 );          int y = Math.Min( colorPoint[index].Y' colorStream.FrameHeight - 1 );          int colorIndex = ((y * depthFrame.Width) + x) * Bgr32BytesPerPixel;            // プレイヤーがいるピクセルの場合          if ( player != 0 ) {            depthColor[colorIndex] = 255;            depthColor[colorIndex + 1] = 255;            depthColor[colorIndex + 2] = 255;          }          // プレイヤーではないピクセルの場合          else {            // サポート外 0-40cm            if ( distance == depthStream.UnknownDepth ) {              depthColor[colorIndex] = 0;              depthColor[colorIndex + 1] = 0;              depthColor[colorIndex + 2] = 255;            }            // 近すぎ 40cm-80cm(default mode)            else if ( distance == depthStream.TooNearDepth ) {              depthColor[colorIndex] = 0;              depthColor[colorIndex + 1] = 255;              depthColor[colorIndex + 2] = 0;            }            // 遠すぎ 3m(Near)'4m(Default)-8m            else if ( distance == depthStream.TooFarDepth ) {              depthColor[colorIndex] = 255;              depthColor[colorIndex + 1] = 0;              depthColor[colorIndex + 2] = 0;            }            // 有効な距離データ            else {              depthColor[colorIndex] = 0;              depthColor[colorIndex + 1] = 255;              depthColor[colorIndex + 2] = 255;            }          }        }
Magic Number,MultiKinect,KinectWindow,C:\repos\geis_KinectSDKBook4CS\1_basic\MultiKinect\KinectWindow.xaml.cs,ConvertDepthColor,The following statement contains a magic number: for ( int index = 0; index < depthPixel.Length; index++ ) {          // 距離カメラのデータから、プレイヤーIDと距離を取得する          int player = depthPixel[index] & DepthImageFrame.PlayerIndexBitmask;          int distance = depthPixel[index] >> DepthImageFrame.PlayerIndexBitmaskWidth;            // 変換した結果が、フレームサイズを超えることがあるため、小さいほうを使う          int x = Math.Min( colorPoint[index].X' colorStream.FrameWidth - 1 );          int y = Math.Min( colorPoint[index].Y' colorStream.FrameHeight - 1 );          int colorIndex = ((y * depthFrame.Width) + x) * Bgr32BytesPerPixel;            // プレイヤーがいるピクセルの場合          if ( player != 0 ) {            depthColor[colorIndex] = 255;            depthColor[colorIndex + 1] = 255;            depthColor[colorIndex + 2] = 255;          }          // プレイヤーではないピクセルの場合          else {            // サポート外 0-40cm            if ( distance == depthStream.UnknownDepth ) {              depthColor[colorIndex] = 0;              depthColor[colorIndex + 1] = 0;              depthColor[colorIndex + 2] = 255;            }            // 近すぎ 40cm-80cm(default mode)            else if ( distance == depthStream.TooNearDepth ) {              depthColor[colorIndex] = 0;              depthColor[colorIndex + 1] = 255;              depthColor[colorIndex + 2] = 0;            }            // 遠すぎ 3m(Near)'4m(Default)-8m            else if ( distance == depthStream.TooFarDepth ) {              depthColor[colorIndex] = 255;              depthColor[colorIndex + 1] = 0;              depthColor[colorIndex + 2] = 0;            }            // 有効な距離データ            else {              depthColor[colorIndex] = 0;              depthColor[colorIndex + 1] = 255;              depthColor[colorIndex + 2] = 255;            }          }        }
Magic Number,MultiKinect,KinectWindow,C:\repos\geis_KinectSDKBook4CS\1_basic\MultiKinect\KinectWindow.xaml.cs,ConvertDepthColor,The following statement contains a magic number: for ( int index = 0; index < depthPixel.Length; index++ ) {          // 距離カメラのデータから、プレイヤーIDと距離を取得する          int player = depthPixel[index] & DepthImageFrame.PlayerIndexBitmask;          int distance = depthPixel[index] >> DepthImageFrame.PlayerIndexBitmaskWidth;            // 変換した結果が、フレームサイズを超えることがあるため、小さいほうを使う          int x = Math.Min( colorPoint[index].X' colorStream.FrameWidth - 1 );          int y = Math.Min( colorPoint[index].Y' colorStream.FrameHeight - 1 );          int colorIndex = ((y * depthFrame.Width) + x) * Bgr32BytesPerPixel;            // プレイヤーがいるピクセルの場合          if ( player != 0 ) {            depthColor[colorIndex] = 255;            depthColor[colorIndex + 1] = 255;            depthColor[colorIndex + 2] = 255;          }          // プレイヤーではないピクセルの場合          else {            // サポート外 0-40cm            if ( distance == depthStream.UnknownDepth ) {              depthColor[colorIndex] = 0;              depthColor[colorIndex + 1] = 0;              depthColor[colorIndex + 2] = 255;            }            // 近すぎ 40cm-80cm(default mode)            else if ( distance == depthStream.TooNearDepth ) {              depthColor[colorIndex] = 0;              depthColor[colorIndex + 1] = 255;              depthColor[colorIndex + 2] = 0;            }            // 遠すぎ 3m(Near)'4m(Default)-8m            else if ( distance == depthStream.TooFarDepth ) {              depthColor[colorIndex] = 255;              depthColor[colorIndex + 1] = 0;              depthColor[colorIndex + 2] = 0;            }            // 有効な距離データ            else {              depthColor[colorIndex] = 0;              depthColor[colorIndex + 1] = 255;              depthColor[colorIndex + 2] = 255;            }          }        }
Magic Number,MultiKinect,KinectWindow,C:\repos\geis_KinectSDKBook4CS\1_basic\MultiKinect\KinectWindow.xaml.cs,ConvertDepthColor,The following statement contains a magic number: for ( int index = 0; index < depthPixel.Length; index++ ) {          // 距離カメラのデータから、プレイヤーIDと距離を取得する          int player = depthPixel[index] & DepthImageFrame.PlayerIndexBitmask;          int distance = depthPixel[index] >> DepthImageFrame.PlayerIndexBitmaskWidth;            // 変換した結果が、フレームサイズを超えることがあるため、小さいほうを使う          int x = Math.Min( colorPoint[index].X' colorStream.FrameWidth - 1 );          int y = Math.Min( colorPoint[index].Y' colorStream.FrameHeight - 1 );          int colorIndex = ((y * depthFrame.Width) + x) * Bgr32BytesPerPixel;            // プレイヤーがいるピクセルの場合          if ( player != 0 ) {            depthColor[colorIndex] = 255;            depthColor[colorIndex + 1] = 255;            depthColor[colorIndex + 2] = 255;          }          // プレイヤーではないピクセルの場合          else {            // サポート外 0-40cm            if ( distance == depthStream.UnknownDepth ) {              depthColor[colorIndex] = 0;              depthColor[colorIndex + 1] = 0;              depthColor[colorIndex + 2] = 255;            }            // 近すぎ 40cm-80cm(default mode)            else if ( distance == depthStream.TooNearDepth ) {              depthColor[colorIndex] = 0;              depthColor[colorIndex + 1] = 255;              depthColor[colorIndex + 2] = 0;            }            // 遠すぎ 3m(Near)'4m(Default)-8m            else if ( distance == depthStream.TooFarDepth ) {              depthColor[colorIndex] = 255;              depthColor[colorIndex + 1] = 0;              depthColor[colorIndex + 2] = 0;            }            // 有効な距離データ            else {              depthColor[colorIndex] = 0;              depthColor[colorIndex + 1] = 255;              depthColor[colorIndex + 2] = 255;            }          }        }
Magic Number,MultiKinect,KinectWindow,C:\repos\geis_KinectSDKBook4CS\1_basic\MultiKinect\KinectWindow.xaml.cs,ConvertDepthColor,The following statement contains a magic number: for ( int index = 0; index < depthPixel.Length; index++ ) {          // 距離カメラのデータから、プレイヤーIDと距離を取得する          int player = depthPixel[index] & DepthImageFrame.PlayerIndexBitmask;          int distance = depthPixel[index] >> DepthImageFrame.PlayerIndexBitmaskWidth;            // 変換した結果が、フレームサイズを超えることがあるため、小さいほうを使う          int x = Math.Min( colorPoint[index].X' colorStream.FrameWidth - 1 );          int y = Math.Min( colorPoint[index].Y' colorStream.FrameHeight - 1 );          int colorIndex = ((y * depthFrame.Width) + x) * Bgr32BytesPerPixel;            // プレイヤーがいるピクセルの場合          if ( player != 0 ) {            depthColor[colorIndex] = 255;            depthColor[colorIndex + 1] = 255;            depthColor[colorIndex + 2] = 255;          }          // プレイヤーではないピクセルの場合          else {            // サポート外 0-40cm            if ( distance == depthStream.UnknownDepth ) {              depthColor[colorIndex] = 0;              depthColor[colorIndex + 1] = 0;              depthColor[colorIndex + 2] = 255;            }            // 近すぎ 40cm-80cm(default mode)            else if ( distance == depthStream.TooNearDepth ) {              depthColor[colorIndex] = 0;              depthColor[colorIndex + 1] = 255;              depthColor[colorIndex + 2] = 0;            }            // 遠すぎ 3m(Near)'4m(Default)-8m            else if ( distance == depthStream.TooFarDepth ) {              depthColor[colorIndex] = 255;              depthColor[colorIndex + 1] = 0;              depthColor[colorIndex + 2] = 0;            }            // 有効な距離データ            else {              depthColor[colorIndex] = 0;              depthColor[colorIndex + 1] = 255;              depthColor[colorIndex + 2] = 255;            }          }        }
Magic Number,MultiKinect,KinectWindow,C:\repos\geis_KinectSDKBook4CS\1_basic\MultiKinect\KinectWindow.xaml.cs,ConvertDepthColor,The following statement contains a magic number: for ( int index = 0; index < depthPixel.Length; index++ ) {          // 距離カメラのデータから、プレイヤーIDと距離を取得する          int player = depthPixel[index] & DepthImageFrame.PlayerIndexBitmask;          int distance = depthPixel[index] >> DepthImageFrame.PlayerIndexBitmaskWidth;            // 変換した結果が、フレームサイズを超えることがあるため、小さいほうを使う          int x = Math.Min( colorPoint[index].X' colorStream.FrameWidth - 1 );          int y = Math.Min( colorPoint[index].Y' colorStream.FrameHeight - 1 );          int colorIndex = ((y * depthFrame.Width) + x) * Bgr32BytesPerPixel;            // プレイヤーがいるピクセルの場合          if ( player != 0 ) {            depthColor[colorIndex] = 255;            depthColor[colorIndex + 1] = 255;            depthColor[colorIndex + 2] = 255;          }          // プレイヤーではないピクセルの場合          else {            // サポート外 0-40cm            if ( distance == depthStream.UnknownDepth ) {              depthColor[colorIndex] = 0;              depthColor[colorIndex + 1] = 0;              depthColor[colorIndex + 2] = 255;            }            // 近すぎ 40cm-80cm(default mode)            else if ( distance == depthStream.TooNearDepth ) {              depthColor[colorIndex] = 0;              depthColor[colorIndex + 1] = 255;              depthColor[colorIndex + 2] = 0;            }            // 遠すぎ 3m(Near)'4m(Default)-8m            else if ( distance == depthStream.TooFarDepth ) {              depthColor[colorIndex] = 255;              depthColor[colorIndex + 1] = 0;              depthColor[colorIndex + 2] = 0;            }            // 有効な距離データ            else {              depthColor[colorIndex] = 0;              depthColor[colorIndex + 1] = 255;              depthColor[colorIndex + 2] = 255;            }          }        }
Magic Number,MultiKinect,KinectWindow,C:\repos\geis_KinectSDKBook4CS\1_basic\MultiKinect\KinectWindow.xaml.cs,ConvertDepthColor,The following statement contains a magic number: for ( int index = 0; index < depthPixel.Length; index++ ) {          // 距離カメラのデータから、プレイヤーIDと距離を取得する          int player = depthPixel[index] & DepthImageFrame.PlayerIndexBitmask;          int distance = depthPixel[index] >> DepthImageFrame.PlayerIndexBitmaskWidth;            // 変換した結果が、フレームサイズを超えることがあるため、小さいほうを使う          int x = Math.Min( colorPoint[index].X' colorStream.FrameWidth - 1 );          int y = Math.Min( colorPoint[index].Y' colorStream.FrameHeight - 1 );          int colorIndex = ((y * depthFrame.Width) + x) * Bgr32BytesPerPixel;            // プレイヤーがいるピクセルの場合          if ( player != 0 ) {            depthColor[colorIndex] = 255;            depthColor[colorIndex + 1] = 255;            depthColor[colorIndex + 2] = 255;          }          // プレイヤーではないピクセルの場合          else {            // サポート外 0-40cm            if ( distance == depthStream.UnknownDepth ) {              depthColor[colorIndex] = 0;              depthColor[colorIndex + 1] = 0;              depthColor[colorIndex + 2] = 255;            }            // 近すぎ 40cm-80cm(default mode)            else if ( distance == depthStream.TooNearDepth ) {              depthColor[colorIndex] = 0;              depthColor[colorIndex + 1] = 255;              depthColor[colorIndex + 2] = 0;            }            // 遠すぎ 3m(Near)'4m(Default)-8m            else if ( distance == depthStream.TooFarDepth ) {              depthColor[colorIndex] = 255;              depthColor[colorIndex + 1] = 0;              depthColor[colorIndex + 2] = 0;            }            // 有効な距離データ            else {              depthColor[colorIndex] = 0;              depthColor[colorIndex + 1] = 255;              depthColor[colorIndex + 2] = 255;            }          }        }
Magic Number,MultiKinect,KinectWindow,C:\repos\geis_KinectSDKBook4CS\1_basic\MultiKinect\KinectWindow.xaml.cs,ConvertDepthColor,The following statement contains a magic number: for ( int index = 0; index < depthPixel.Length; index++ ) {          // 距離カメラのデータから、プレイヤーIDと距離を取得する          int player = depthPixel[index] & DepthImageFrame.PlayerIndexBitmask;          int distance = depthPixel[index] >> DepthImageFrame.PlayerIndexBitmaskWidth;            // 変換した結果が、フレームサイズを超えることがあるため、小さいほうを使う          int x = Math.Min( colorPoint[index].X' colorStream.FrameWidth - 1 );          int y = Math.Min( colorPoint[index].Y' colorStream.FrameHeight - 1 );          int colorIndex = ((y * depthFrame.Width) + x) * Bgr32BytesPerPixel;            // プレイヤーがいるピクセルの場合          if ( player != 0 ) {            depthColor[colorIndex] = 255;            depthColor[colorIndex + 1] = 255;            depthColor[colorIndex + 2] = 255;          }          // プレイヤーではないピクセルの場合          else {            // サポート外 0-40cm            if ( distance == depthStream.UnknownDepth ) {              depthColor[colorIndex] = 0;              depthColor[colorIndex + 1] = 0;              depthColor[colorIndex + 2] = 255;            }            // 近すぎ 40cm-80cm(default mode)            else if ( distance == depthStream.TooNearDepth ) {              depthColor[colorIndex] = 0;              depthColor[colorIndex + 1] = 255;              depthColor[colorIndex + 2] = 0;            }            // 遠すぎ 3m(Near)'4m(Default)-8m            else if ( distance == depthStream.TooFarDepth ) {              depthColor[colorIndex] = 255;              depthColor[colorIndex + 1] = 0;              depthColor[colorIndex + 2] = 0;            }            // 有効な距離データ            else {              depthColor[colorIndex] = 0;              depthColor[colorIndex + 1] = 255;              depthColor[colorIndex + 2] = 255;            }          }        }
Magic Number,MultiKinect,KinectWindow,C:\repos\geis_KinectSDKBook4CS\1_basic\MultiKinect\KinectWindow.xaml.cs,ConvertDepthColor,The following statement contains a magic number: for ( int index = 0; index < depthPixel.Length; index++ ) {          // 距離カメラのデータから、プレイヤーIDと距離を取得する          int player = depthPixel[index] & DepthImageFrame.PlayerIndexBitmask;          int distance = depthPixel[index] >> DepthImageFrame.PlayerIndexBitmaskWidth;            // 変換した結果が、フレームサイズを超えることがあるため、小さいほうを使う          int x = Math.Min( colorPoint[index].X' colorStream.FrameWidth - 1 );          int y = Math.Min( colorPoint[index].Y' colorStream.FrameHeight - 1 );          int colorIndex = ((y * depthFrame.Width) + x) * Bgr32BytesPerPixel;            // プレイヤーがいるピクセルの場合          if ( player != 0 ) {            depthColor[colorIndex] = 255;            depthColor[colorIndex + 1] = 255;            depthColor[colorIndex + 2] = 255;          }          // プレイヤーではないピクセルの場合          else {            // サポート外 0-40cm            if ( distance == depthStream.UnknownDepth ) {              depthColor[colorIndex] = 0;              depthColor[colorIndex + 1] = 0;              depthColor[colorIndex + 2] = 255;            }            // 近すぎ 40cm-80cm(default mode)            else if ( distance == depthStream.TooNearDepth ) {              depthColor[colorIndex] = 0;              depthColor[colorIndex + 1] = 255;              depthColor[colorIndex + 2] = 0;            }            // 遠すぎ 3m(Near)'4m(Default)-8m            else if ( distance == depthStream.TooFarDepth ) {              depthColor[colorIndex] = 255;              depthColor[colorIndex + 1] = 0;              depthColor[colorIndex + 2] = 0;            }            // 有効な距離データ            else {              depthColor[colorIndex] = 0;              depthColor[colorIndex + 1] = 255;              depthColor[colorIndex + 2] = 255;            }          }        }
Magic Number,MultiKinect,KinectWindow,C:\repos\geis_KinectSDKBook4CS\1_basic\MultiKinect\KinectWindow.xaml.cs,ConvertDepthColor,The following statement contains a magic number: for ( int index = 0; index < depthPixel.Length; index++ ) {          // 距離カメラのデータから、プレイヤーIDと距離を取得する          int player = depthPixel[index] & DepthImageFrame.PlayerIndexBitmask;          int distance = depthPixel[index] >> DepthImageFrame.PlayerIndexBitmaskWidth;            // 変換した結果が、フレームサイズを超えることがあるため、小さいほうを使う          int x = Math.Min( colorPoint[index].X' colorStream.FrameWidth - 1 );          int y = Math.Min( colorPoint[index].Y' colorStream.FrameHeight - 1 );          int colorIndex = ((y * depthFrame.Width) + x) * Bgr32BytesPerPixel;            // プレイヤーがいるピクセルの場合          if ( player != 0 ) {            depthColor[colorIndex] = 255;            depthColor[colorIndex + 1] = 255;            depthColor[colorIndex + 2] = 255;          }          // プレイヤーではないピクセルの場合          else {            // サポート外 0-40cm            if ( distance == depthStream.UnknownDepth ) {              depthColor[colorIndex] = 0;              depthColor[colorIndex + 1] = 0;              depthColor[colorIndex + 2] = 255;            }            // 近すぎ 40cm-80cm(default mode)            else if ( distance == depthStream.TooNearDepth ) {              depthColor[colorIndex] = 0;              depthColor[colorIndex + 1] = 255;              depthColor[colorIndex + 2] = 0;            }            // 遠すぎ 3m(Near)'4m(Default)-8m            else if ( distance == depthStream.TooFarDepth ) {              depthColor[colorIndex] = 255;              depthColor[colorIndex + 1] = 0;              depthColor[colorIndex + 2] = 0;            }            // 有効な距離データ            else {              depthColor[colorIndex] = 0;              depthColor[colorIndex + 1] = 255;              depthColor[colorIndex + 2] = 255;            }          }        }
Magic Number,MultiKinect,KinectWindow,C:\repos\geis_KinectSDKBook4CS\1_basic\MultiKinect\KinectWindow.xaml.cs,ConvertDepthColor,The following statement contains a magic number: for ( int index = 0; index < depthPixel.Length; index++ ) {          // 距離カメラのデータから、プレイヤーIDと距離を取得する          int player = depthPixel[index] & DepthImageFrame.PlayerIndexBitmask;          int distance = depthPixel[index] >> DepthImageFrame.PlayerIndexBitmaskWidth;            // 変換した結果が、フレームサイズを超えることがあるため、小さいほうを使う          int x = Math.Min( colorPoint[index].X' colorStream.FrameWidth - 1 );          int y = Math.Min( colorPoint[index].Y' colorStream.FrameHeight - 1 );          int colorIndex = ((y * depthFrame.Width) + x) * Bgr32BytesPerPixel;            // プレイヤーがいるピクセルの場合          if ( player != 0 ) {            depthColor[colorIndex] = 255;            depthColor[colorIndex + 1] = 255;            depthColor[colorIndex + 2] = 255;          }          // プレイヤーではないピクセルの場合          else {            // サポート外 0-40cm            if ( distance == depthStream.UnknownDepth ) {              depthColor[colorIndex] = 0;              depthColor[colorIndex + 1] = 0;              depthColor[colorIndex + 2] = 255;            }            // 近すぎ 40cm-80cm(default mode)            else if ( distance == depthStream.TooNearDepth ) {              depthColor[colorIndex] = 0;              depthColor[colorIndex + 1] = 255;              depthColor[colorIndex + 2] = 0;            }            // 遠すぎ 3m(Near)'4m(Default)-8m            else if ( distance == depthStream.TooFarDepth ) {              depthColor[colorIndex] = 255;              depthColor[colorIndex + 1] = 0;              depthColor[colorIndex + 2] = 0;            }            // 有効な距離データ            else {              depthColor[colorIndex] = 0;              depthColor[colorIndex + 1] = 255;              depthColor[colorIndex + 2] = 255;            }          }        }
Magic Number,MultiKinect,KinectWindow,C:\repos\geis_KinectSDKBook4CS\1_basic\MultiKinect\KinectWindow.xaml.cs,ConvertDepthColor,The following statement contains a magic number: for ( int index = 0; index < depthPixel.Length; index++ ) {          // 距離カメラのデータから、プレイヤーIDと距離を取得する          int player = depthPixel[index] & DepthImageFrame.PlayerIndexBitmask;          int distance = depthPixel[index] >> DepthImageFrame.PlayerIndexBitmaskWidth;            // 変換した結果が、フレームサイズを超えることがあるため、小さいほうを使う          int x = Math.Min( colorPoint[index].X' colorStream.FrameWidth - 1 );          int y = Math.Min( colorPoint[index].Y' colorStream.FrameHeight - 1 );          int colorIndex = ((y * depthFrame.Width) + x) * Bgr32BytesPerPixel;            // プレイヤーがいるピクセルの場合          if ( player != 0 ) {            depthColor[colorIndex] = 255;            depthColor[colorIndex + 1] = 255;            depthColor[colorIndex + 2] = 255;          }          // プレイヤーではないピクセルの場合          else {            // サポート外 0-40cm            if ( distance == depthStream.UnknownDepth ) {              depthColor[colorIndex] = 0;              depthColor[colorIndex + 1] = 0;              depthColor[colorIndex + 2] = 255;            }            // 近すぎ 40cm-80cm(default mode)            else if ( distance == depthStream.TooNearDepth ) {              depthColor[colorIndex] = 0;              depthColor[colorIndex + 1] = 255;              depthColor[colorIndex + 2] = 0;            }            // 遠すぎ 3m(Near)'4m(Default)-8m            else if ( distance == depthStream.TooFarDepth ) {              depthColor[colorIndex] = 255;              depthColor[colorIndex + 1] = 0;              depthColor[colorIndex + 2] = 0;            }            // 有効な距離データ            else {              depthColor[colorIndex] = 0;              depthColor[colorIndex + 1] = 255;              depthColor[colorIndex + 2] = 255;            }          }        }
Magic Number,MultiKinect,KinectWindow,C:\repos\geis_KinectSDKBook4CS\1_basic\MultiKinect\KinectWindow.xaml.cs,ConvertDepthColor,The following statement contains a magic number: for ( int index = 0; index < depthPixel.Length; index++ ) {          // 距離カメラのデータから、プレイヤーIDと距離を取得する          int player = depthPixel[index] & DepthImageFrame.PlayerIndexBitmask;          int distance = depthPixel[index] >> DepthImageFrame.PlayerIndexBitmaskWidth;            // 変換した結果が、フレームサイズを超えることがあるため、小さいほうを使う          int x = Math.Min( colorPoint[index].X' colorStream.FrameWidth - 1 );          int y = Math.Min( colorPoint[index].Y' colorStream.FrameHeight - 1 );          int colorIndex = ((y * depthFrame.Width) + x) * Bgr32BytesPerPixel;            // プレイヤーがいるピクセルの場合          if ( player != 0 ) {            depthColor[colorIndex] = 255;            depthColor[colorIndex + 1] = 255;            depthColor[colorIndex + 2] = 255;          }          // プレイヤーではないピクセルの場合          else {            // サポート外 0-40cm            if ( distance == depthStream.UnknownDepth ) {              depthColor[colorIndex] = 0;              depthColor[colorIndex + 1] = 0;              depthColor[colorIndex + 2] = 255;            }            // 近すぎ 40cm-80cm(default mode)            else if ( distance == depthStream.TooNearDepth ) {              depthColor[colorIndex] = 0;              depthColor[colorIndex + 1] = 255;              depthColor[colorIndex + 2] = 0;            }            // 遠すぎ 3m(Near)'4m(Default)-8m            else if ( distance == depthStream.TooFarDepth ) {              depthColor[colorIndex] = 255;              depthColor[colorIndex + 1] = 0;              depthColor[colorIndex + 2] = 0;            }            // 有効な距離データ            else {              depthColor[colorIndex] = 0;              depthColor[colorIndex + 1] = 255;              depthColor[colorIndex + 2] = 255;            }          }        }
Magic Number,MultiKinect,KinectWindow,C:\repos\geis_KinectSDKBook4CS\1_basic\MultiKinect\KinectWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.imageRgb = ((System.Windows.Controls.Image)(target));              return;              case 2:              this.imageDepth = ((System.Windows.Controls.Image)(target));              return;              case 3:              this.comboBoxRange = ((System.Windows.Controls.ComboBox)(target));                            #line 11 "..\..\..\KinectWindow.xaml"              this.comboBoxRange.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.comboBoxRange_SelectionChanged);                            #line default              #line hidden              return;              case 4:              this.soundSource = ((System.Windows.Media.RotateTransform)(target));              return;              case 5:              this.beam = ((System.Windows.Media.RotateTransform)(target));              return;              case 6:              this.sliderTiltAngle = ((System.Windows.Controls.Slider)(target));                            #line 24 "..\..\..\KinectWindow.xaml"              this.sliderTiltAngle.ValueChanged += new System.Windows.RoutedPropertyChangedEventHandler<double>(this.sliderTiltAngle_ValueChanged);                            #line default              #line hidden              return;              case 7:              this.label1 = ((System.Windows.Controls.Label)(target));              return;              }
Magic Number,MultiKinect,KinectWindow,C:\repos\geis_KinectSDKBook4CS\1_basic\MultiKinect\KinectWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.imageRgb = ((System.Windows.Controls.Image)(target));              return;              case 2:              this.imageDepth = ((System.Windows.Controls.Image)(target));              return;              case 3:              this.comboBoxRange = ((System.Windows.Controls.ComboBox)(target));                            #line 11 "..\..\..\KinectWindow.xaml"              this.comboBoxRange.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.comboBoxRange_SelectionChanged);                            #line default              #line hidden              return;              case 4:              this.soundSource = ((System.Windows.Media.RotateTransform)(target));              return;              case 5:              this.beam = ((System.Windows.Media.RotateTransform)(target));              return;              case 6:              this.sliderTiltAngle = ((System.Windows.Controls.Slider)(target));                            #line 24 "..\..\..\KinectWindow.xaml"              this.sliderTiltAngle.ValueChanged += new System.Windows.RoutedPropertyChangedEventHandler<double>(this.sliderTiltAngle_ValueChanged);                            #line default              #line hidden              return;              case 7:              this.label1 = ((System.Windows.Controls.Label)(target));              return;              }
Magic Number,MultiKinect,KinectWindow,C:\repos\geis_KinectSDKBook4CS\1_basic\MultiKinect\KinectWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.imageRgb = ((System.Windows.Controls.Image)(target));              return;              case 2:              this.imageDepth = ((System.Windows.Controls.Image)(target));              return;              case 3:              this.comboBoxRange = ((System.Windows.Controls.ComboBox)(target));                            #line 11 "..\..\..\KinectWindow.xaml"              this.comboBoxRange.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.comboBoxRange_SelectionChanged);                            #line default              #line hidden              return;              case 4:              this.soundSource = ((System.Windows.Media.RotateTransform)(target));              return;              case 5:              this.beam = ((System.Windows.Media.RotateTransform)(target));              return;              case 6:              this.sliderTiltAngle = ((System.Windows.Controls.Slider)(target));                            #line 24 "..\..\..\KinectWindow.xaml"              this.sliderTiltAngle.ValueChanged += new System.Windows.RoutedPropertyChangedEventHandler<double>(this.sliderTiltAngle_ValueChanged);                            #line default              #line hidden              return;              case 7:              this.label1 = ((System.Windows.Controls.Label)(target));              return;              }
Magic Number,MultiKinect,KinectWindow,C:\repos\geis_KinectSDKBook4CS\1_basic\MultiKinect\KinectWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.imageRgb = ((System.Windows.Controls.Image)(target));              return;              case 2:              this.imageDepth = ((System.Windows.Controls.Image)(target));              return;              case 3:              this.comboBoxRange = ((System.Windows.Controls.ComboBox)(target));                            #line 11 "..\..\..\KinectWindow.xaml"              this.comboBoxRange.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.comboBoxRange_SelectionChanged);                            #line default              #line hidden              return;              case 4:              this.soundSource = ((System.Windows.Media.RotateTransform)(target));              return;              case 5:              this.beam = ((System.Windows.Media.RotateTransform)(target));              return;              case 6:              this.sliderTiltAngle = ((System.Windows.Controls.Slider)(target));                            #line 24 "..\..\..\KinectWindow.xaml"              this.sliderTiltAngle.ValueChanged += new System.Windows.RoutedPropertyChangedEventHandler<double>(this.sliderTiltAngle_ValueChanged);                            #line default              #line hidden              return;              case 7:              this.label1 = ((System.Windows.Controls.Label)(target));              return;              }
Magic Number,MultiKinect,KinectWindow,C:\repos\geis_KinectSDKBook4CS\1_basic\MultiKinect\KinectWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.imageRgb = ((System.Windows.Controls.Image)(target));              return;              case 2:              this.imageDepth = ((System.Windows.Controls.Image)(target));              return;              case 3:              this.comboBoxRange = ((System.Windows.Controls.ComboBox)(target));                            #line 11 "..\..\..\KinectWindow.xaml"              this.comboBoxRange.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.comboBoxRange_SelectionChanged);                            #line default              #line hidden              return;              case 4:              this.soundSource = ((System.Windows.Media.RotateTransform)(target));              return;              case 5:              this.beam = ((System.Windows.Media.RotateTransform)(target));              return;              case 6:              this.sliderTiltAngle = ((System.Windows.Controls.Slider)(target));                            #line 24 "..\..\..\KinectWindow.xaml"              this.sliderTiltAngle.ValueChanged += new System.Windows.RoutedPropertyChangedEventHandler<double>(this.sliderTiltAngle_ValueChanged);                            #line default              #line hidden              return;              case 7:              this.label1 = ((System.Windows.Controls.Label)(target));              return;              }
Magic Number,MultiKinect,KinectWindow,C:\repos\geis_KinectSDKBook4CS\1_basic\MultiKinect\KinectWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.imageRgb = ((System.Windows.Controls.Image)(target));              return;              case 2:              this.imageDepth = ((System.Windows.Controls.Image)(target));              return;              case 3:              this.comboBoxRange = ((System.Windows.Controls.ComboBox)(target));                            #line 11 "..\..\..\KinectWindow.xaml"              this.comboBoxRange.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.comboBoxRange_SelectionChanged);                            #line default              #line hidden              return;              case 4:              this.soundSource = ((System.Windows.Media.RotateTransform)(target));              return;              case 5:              this.beam = ((System.Windows.Media.RotateTransform)(target));              return;              case 6:              this.sliderTiltAngle = ((System.Windows.Controls.Slider)(target));                            #line 24 "..\..\..\KinectWindow.xaml"              this.sliderTiltAngle.ValueChanged += new System.Windows.RoutedPropertyChangedEventHandler<double>(this.sliderTiltAngle_ValueChanged);                            #line default              #line hidden              return;              case 7:              this.label1 = ((System.Windows.Controls.Label)(target));              return;              }
Magic Number,MultiKinect,MainWindow,C:\repos\geis_KinectSDKBook4CS\1_basic\MultiKinect\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:                            #line 4 "..\..\..\MainWindow.xaml"              ((MultiKinect.MainWindow)(target)).Closing += new System.ComponentModel.CancelEventHandler(this.Window_Closing);                            #line default              #line hidden              return;              case 2:              this.kinectWindow1 = ((MultiKinect.KinectWindow)(target));              return;              case 3:              this.kinectWindow2 = ((MultiKinect.KinectWindow)(target));              return;              case 4:              this.kinectWindow3 = ((MultiKinect.KinectWindow)(target));              return;              case 5:              this.kinectWindow4 = ((MultiKinect.KinectWindow)(target));              return;              case 6:              this.comboBoxSkeleton = ((System.Windows.Controls.ComboBox)(target));                            #line 15 "..\..\..\MainWindow.xaml"              this.comboBoxSkeleton.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.comboBox1_SelectionChanged);                            #line default              #line hidden              return;              }
Magic Number,MultiKinect,MainWindow,C:\repos\geis_KinectSDKBook4CS\1_basic\MultiKinect\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:                            #line 4 "..\..\..\MainWindow.xaml"              ((MultiKinect.MainWindow)(target)).Closing += new System.ComponentModel.CancelEventHandler(this.Window_Closing);                            #line default              #line hidden              return;              case 2:              this.kinectWindow1 = ((MultiKinect.KinectWindow)(target));              return;              case 3:              this.kinectWindow2 = ((MultiKinect.KinectWindow)(target));              return;              case 4:              this.kinectWindow3 = ((MultiKinect.KinectWindow)(target));              return;              case 5:              this.kinectWindow4 = ((MultiKinect.KinectWindow)(target));              return;              case 6:              this.comboBoxSkeleton = ((System.Windows.Controls.ComboBox)(target));                            #line 15 "..\..\..\MainWindow.xaml"              this.comboBoxSkeleton.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.comboBox1_SelectionChanged);                            #line default              #line hidden              return;              }
Magic Number,MultiKinect,MainWindow,C:\repos\geis_KinectSDKBook4CS\1_basic\MultiKinect\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:                            #line 4 "..\..\..\MainWindow.xaml"              ((MultiKinect.MainWindow)(target)).Closing += new System.ComponentModel.CancelEventHandler(this.Window_Closing);                            #line default              #line hidden              return;              case 2:              this.kinectWindow1 = ((MultiKinect.KinectWindow)(target));              return;              case 3:              this.kinectWindow2 = ((MultiKinect.KinectWindow)(target));              return;              case 4:              this.kinectWindow3 = ((MultiKinect.KinectWindow)(target));              return;              case 5:              this.kinectWindow4 = ((MultiKinect.KinectWindow)(target));              return;              case 6:              this.comboBoxSkeleton = ((System.Windows.Controls.ComboBox)(target));                            #line 15 "..\..\..\MainWindow.xaml"              this.comboBoxSkeleton.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.comboBox1_SelectionChanged);                            #line default              #line hidden              return;              }
Magic Number,MultiKinect,MainWindow,C:\repos\geis_KinectSDKBook4CS\1_basic\MultiKinect\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:                            #line 4 "..\..\..\MainWindow.xaml"              ((MultiKinect.MainWindow)(target)).Closing += new System.ComponentModel.CancelEventHandler(this.Window_Closing);                            #line default              #line hidden              return;              case 2:              this.kinectWindow1 = ((MultiKinect.KinectWindow)(target));              return;              case 3:              this.kinectWindow2 = ((MultiKinect.KinectWindow)(target));              return;              case 4:              this.kinectWindow3 = ((MultiKinect.KinectWindow)(target));              return;              case 5:              this.kinectWindow4 = ((MultiKinect.KinectWindow)(target));              return;              case 6:              this.comboBoxSkeleton = ((System.Windows.Controls.ComboBox)(target));                            #line 15 "..\..\..\MainWindow.xaml"              this.comboBoxSkeleton.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.comboBox1_SelectionChanged);                            #line default              #line hidden              return;              }
Magic Number,MultiKinect,MainWindow,C:\repos\geis_KinectSDKBook4CS\1_basic\MultiKinect\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:                            #line 4 "..\..\..\MainWindow.xaml"              ((MultiKinect.MainWindow)(target)).Closing += new System.ComponentModel.CancelEventHandler(this.Window_Closing);                            #line default              #line hidden              return;              case 2:              this.kinectWindow1 = ((MultiKinect.KinectWindow)(target));              return;              case 3:              this.kinectWindow2 = ((MultiKinect.KinectWindow)(target));              return;              case 4:              this.kinectWindow3 = ((MultiKinect.KinectWindow)(target));              return;              case 5:              this.kinectWindow4 = ((MultiKinect.KinectWindow)(target));              return;              case 6:              this.comboBoxSkeleton = ((System.Windows.Controls.ComboBox)(target));                            #line 15 "..\..\..\MainWindow.xaml"              this.comboBoxSkeleton.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.comboBox1_SelectionChanged);                            #line default              #line hidden              return;              }
Missing Default,MultiKinect,KinectWindow,C:\repos\geis_KinectSDKBook4CS\1_basic\MultiKinect\KinectWindow.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:              this.imageRgb = ((System.Windows.Controls.Image)(target));              return;              case 2:              this.imageDepth = ((System.Windows.Controls.Image)(target));              return;              case 3:              this.comboBoxRange = ((System.Windows.Controls.ComboBox)(target));                            #line 11 "..\..\..\KinectWindow.xaml"              this.comboBoxRange.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.comboBoxRange_SelectionChanged);                            #line default              #line hidden              return;              case 4:              this.soundSource = ((System.Windows.Media.RotateTransform)(target));              return;              case 5:              this.beam = ((System.Windows.Media.RotateTransform)(target));              return;              case 6:              this.sliderTiltAngle = ((System.Windows.Controls.Slider)(target));                            #line 24 "..\..\..\KinectWindow.xaml"              this.sliderTiltAngle.ValueChanged += new System.Windows.RoutedPropertyChangedEventHandler<double>(this.sliderTiltAngle_ValueChanged);                            #line default              #line hidden              return;              case 7:              this.label1 = ((System.Windows.Controls.Label)(target));              return;              }
Missing Default,MultiKinect,MainWindow,C:\repos\geis_KinectSDKBook4CS\1_basic\MultiKinect\MainWindow.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:                            #line 4 "..\..\..\MainWindow.xaml"              ((MultiKinect.MainWindow)(target)).Closing += new System.ComponentModel.CancelEventHandler(this.Window_Closing);                            #line default              #line hidden              return;              case 2:              this.kinectWindow1 = ((MultiKinect.KinectWindow)(target));              return;              case 3:              this.kinectWindow2 = ((MultiKinect.KinectWindow)(target));              return;              case 4:              this.kinectWindow3 = ((MultiKinect.KinectWindow)(target));              return;              case 5:              this.kinectWindow4 = ((MultiKinect.KinectWindow)(target));              return;              case 6:              this.comboBoxSkeleton = ((System.Windows.Controls.ComboBox)(target));                            #line 15 "..\..\..\MainWindow.xaml"              this.comboBoxSkeleton.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.comboBox1_SelectionChanged);                            #line default              #line hidden              return;              }
