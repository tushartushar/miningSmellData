Implementation smell,Namespace,Class,File,Method,Description
Long Method,MatterHackers.Agg.UI,WindowsFormsBitmapBackBuffer,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmapBackBuffer.cs,UpdateHardwareSurface,The method has 126 lines of code.
Long Parameter List,MatterHackers.Agg,DirtyRects,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\DirtyRects.cs,BuildDirtyRect,The method has 6 parameters. Parameters: x' y' XStart' YStart' XEnd' YEnd
Long Parameter List,MatterHackers.Agg.UI,WindowsFormBitmap,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmap.cs,BitBlt,The method has 9 parameters. Parameters: hdcDest' nXDest' nYDest' nWidth' nHeight' hdcSrc' nXSrc' nYSrc' dwRop
Long Identifier,MatterHackers.Agg,SystemWindowCreator_WindowsForms,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\SystemWindowCreator_WindowsForms.cs,,The length of the parameter pendingSetInitialDesktopPosition is 32.
Long Statement,MatterHackers.Agg,FileSystemStaticData,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\FileSystemStaticData.cs,LoadSequence,The length of the statement  "				var pngFiles = GetFiles(pathToImages).Where(fileName => Path.GetExtension(fileName).ToUpper() == ".PNG").OrderBy(s => s); " is 121.
Long Statement,MatterHackers.Agg,DirtyRects,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\DirtyRects.cs,SetDirty,The length of the statement  "							currCell.coverage.Left = Math.Max(Math.Min(Math.Min(currCell.coverage.Left' (areaToSetDirty.Left - CurCellBounds.Left))' xCellSize)' 0); " is 136.
Long Statement,MatterHackers.Agg,DirtyRects,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\DirtyRects.cs,SetDirty,The length of the statement  "							currCell.coverage.Bottom = Math.Max(Math.Min(Math.Min(currCell.coverage.Bottom' (areaToSetDirty.Bottom - CurCellBounds.Bottom))' yCellSize)' 0); " is 144.
Long Statement,MatterHackers.Agg,DirtyRects,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\DirtyRects.cs,SetDirty,The length of the statement  "							currCell.coverage.Right = Math.Max(Math.Min(Math.Max(currCell.coverage.Right' (areaToSetDirty.Right - CurCellBounds.Left))' xCellSize)' 0); " is 139.
Long Statement,MatterHackers.Agg,DirtyRects,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\DirtyRects.cs,SetDirty,The length of the statement  "							currCell.coverage.Top = Math.Max(Math.Min(Math.Max(currCell.coverage.Top' (areaToSetDirty.Top - CurCellBounds.Bottom))' yCellSize)' 0); " is 135.
Long Statement,MatterHackers.Agg,SystemWindowCreator_WindowsForms,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\SystemWindowCreator_WindowsForms.cs,SetDesktopPosition,The length of the statement  "				// Make sure the window is on screen' but allow for a small amount of negative positioning to account for Form.DesktopLocation quirks " is 133.
Long Statement,MatterHackers.Agg.UI,HookWindowsInputAndSendToWidget,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\HookWindowsInputAndSendToWidget.cs,controlToHook_MouseLeave,The length of the statement  "			widgetToSendTo.OnMouseMove(new MatterHackers.Agg.UI.MouseEventArgs(MatterHackers.Agg.UI.MouseButtons.None' 0' -10' -10' 0)); " is 124.
Long Statement,MatterHackers.Agg.UI,HookWindowsInputAndSendToWidget,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\HookWindowsInputAndSendToWidget.cs,controlToHook_KeyDown,The length of the statement  "				aggKeyEvent = new MatterHackers.Agg.UI.KeyEventArgs((MatterHackers.Agg.UI.Keys)(System.Windows.Forms.Keys.Control | (windowsKeyEvent.KeyData & ~System.Windows.Forms.Keys.Alt))); " is 177.
Long Statement,MatterHackers.Agg.UI,HookWindowsInputAndSendToWidget,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\HookWindowsInputAndSendToWidget.cs,controlToHook_KeyUp,The length of the statement  "			MatterHackers.Agg.UI.KeyEventArgs aggKeyEvent = new MatterHackers.Agg.UI.KeyEventArgs((MatterHackers.Agg.UI.Keys)windowsKeyEvent.KeyData); " is 138.
Long Statement,MatterHackers.Agg.UI,HookWindowsInputAndSendToWidget,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\HookWindowsInputAndSendToWidget.cs,controlToHook_KeyPress,The length of the statement  "			MatterHackers.Agg.UI.KeyPressEventArgs aggKeyPressEvent = new MatterHackers.Agg.UI.KeyPressEventArgs(windowsKeyPressEvent.KeyChar); " is 131.
Long Statement,MatterHackers.Agg.UI,HookWindowsInputAndSendToWidget,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\HookWindowsInputAndSendToWidget.cs,ConvertWindowsMouseEventToAggMouseEvent,The length of the statement  "			return new MatterHackers.Agg.UI.MouseEventArgs((MatterHackers.Agg.UI.MouseButtons)windowsMouseEvent.Button' windowsMouseEvent.Clicks' windowsMouseEvent.X' Y' windowsMouseEvent.Delta); " is 183.
Long Statement,MatterHackers.Agg.UI,HookWindowsInputAndSendToWidget,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\HookWindowsInputAndSendToWidget.cs,formToHook_MouseMove,The length of the statement  "			// TODO: Remove short term workaround for automation issues where mouse events fire differently if mouse is within window region " is 128.
Long Statement,MatterHackers.Agg.UI,WidgetForWindowsFormsAbstract,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WidgetForWindowsFormsAbstract.cs,Show,The length of the statement  "				windowsFormsWindow.Top = desktopBounds.Y + desktopBounds.Height / 2 - (int) newItemBounds.Height / 2 - TitleBarHeight/2; " is 120.
Long Statement,MatterHackers.Agg.UI,WidgetForWindowsFormsOpenGL,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WidgetForWindowsFormsOpenGL.cs,SetAndClearViewPort,The length of the statement  "			GL.Viewport(0' 0' WindowsFormsWindow.ClientSize.Width' WindowsFormsWindow.ClientSize.Height);					// Reset The Current Viewport " is 127.
Long Statement,MatterHackers.Agg.UI,WindowsFormsBitmapBackBuffer,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmapBackBuffer.cs,Lock,The length of the statement  "			bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat); " is 175.
Long Statement,MatterHackers.Agg.UI,WindowsFormsBitmapBackBuffer,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmapBackBuffer.cs,UpdateHardwareSurface,The length of the statement  "					bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat); " is 175.
Long Statement,MatterHackers.Agg.UI,WindowsFormsBitmapBackBuffer,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmapBackBuffer.cs,UpdateHardwareSurface,The length of the statement  "							BitmapData bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat); " is 186.
Long Statement,MatterHackers.Agg.UI,WindowsFormBitmap,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmap.cs,CopyBackBufferToScreen,The length of the statement  "				//displayGraphics.DrawImage(aggBitmapAppWidget.bitmapBackBuffer.windowsBitmap' windowsRect' windowsRect' GraphicsUnit.Pixel);  // around 250 ms for full screen " is 159.
Long Statement,MatterHackers.Agg.UI,WindowsFormBitmap,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmap.cs,CopyBackBufferToScreen,The length of the statement  "				displayGraphics.DrawImageUnscaled(aggBitmapAppWidget.bitmapBackBuffer.windowsBitmap' 0' 0); // around 200 ms for full screnn " is 124.
Long Statement,MatterHackers.Agg.UI,WindowsFormBitmap,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmap.cs,CopyBackBufferToScreen,The length of the statement  "					int result = BitBlt(displayHDC' 0' 0' aggBitmapAppWidget.bitmapBackBuffer.windowsBitmap.Width' aggBitmapAppWidget.bitmapBackBuffer.windowsBitmap.Height' bitmapHDC' 0' 0' SRCCOPY); " is 179.
Long Statement,MatterHackers.Agg.UI,WindowsFormsOpenGL,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsOpenGL.cs,OnResize,The length of the statement  "			// due to cascading control regeneration and avoids the associated performance hit and visible rendering lag during Restore " is 123.
Long Statement,MatterHackers.Agg.Image,ImageIOWindowsPlugin,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\ImageIOWindowsPlugin.cs,ConvertBitmapToImage,The length of the statement  "							BitmapData bitmapData = bitmap.LockBits(new Rectangle(0' 0' bitmap.Width' bitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' bitmap.PixelFormat); " is 158.
Long Statement,MatterHackers.Agg.Image,ImageIOWindowsPlugin,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\ImageIOWindowsPlugin.cs,ConvertBitmapToImage,The length of the statement  "                                            RGBA_Bytes notPreMultiplied = new RGBA_Bytes(pSourceBuffer[sourceIndex + 0]' pSourceBuffer[sourceIndex + 1]' pSourceBuffer[sourceIndex + 2]' pSourceBuffer[sourceIndex + 3]); " is 173.
Long Statement,MatterHackers.Agg.Image,ImageIOWindowsPlugin,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\ImageIOWindowsPlugin.cs,ConvertBitmapToImage,The length of the statement  "							BitmapData bitmapData = bitmap.LockBits(new Rectangle(0' 0' bitmap.Width' bitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' bitmap.PixelFormat); " is 158.
Long Statement,MatterHackers.Agg.Image,ImageIOWindowsPlugin,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\ImageIOWindowsPlugin.cs,Copy8BitDataToImage,The length of the statement  "			BitmapData bitmapData = bitmap.LockBits(new Rectangle(0' 0' bitmap.Width' bitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' bitmap.PixelFormat); " is 158.
Long Statement,MatterHackers.Agg.Image,ImageIOWindowsPlugin,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\ImageIOWindowsPlugin.cs,SaveImageData,The length of the statement  "						BitmapData bitmapData = bitmapToSave.LockBits(new Rectangle(0' 0' bitmapToSave.Width' bitmapToSave.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' bitmapToSave.PixelFormat); " is 182.
Long Statement,MatterHackers.Agg.Image,ImageIOWindowsPlugin,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\ImageIOWindowsPlugin.cs,SaveImageData,The length of the statement  "						BitmapData bitmapData = bitmapToSave.LockBits(new Rectangle(0' 0' bitmapToSave.Width' bitmapToSave.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' bitmapToSave.PixelFormat); " is 182.
Long Statement,MatterHackers.Agg.Image,ImageIOWindowsPlugin,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\ImageIOWindowsPlugin.cs,LoadImageData,The length of the statement  "					BitmapData bitmapData = bitmap.LockBits(new Rectangle(0' 0' bitmap.Width' bitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' bitmap.PixelFormat); " is 158.
Complex Conditional,MatterHackers.Agg,DirtyRects,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\DirtyRects.cs,BuildDirtyRect,The conditional expression  "curCell.coverage.Right == (int)XCellSize // it touches the right side of the cell  				&& nextCell != null && nextCell.isDirty // there is a next cell  				&& nextCell.coverage.Left == 0 // that touches the left  				&& curCell.coverage.Top == nextCell.coverage.Top // and they have the same top  				&& curCell.coverage.Bottom == nextCell.coverage.Bottom"  is complex.
Complex Conditional,MatterHackers.Agg,DirtyRects,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\DirtyRects.cs,BuildDirtyRect,The conditional expression  "x + 1 < LastX  					&& curCell.coverage.Right == (int)XCellSize // it touches the right side of the cell  					&& nextCell != null && nextCell.isDirty // there is a next cell  					&& nextCell.coverage.Left == 0 // that touches the left  					&& curCell.coverage.Top == nextCell.coverage.Top // and they have the same top  					&& curCell.coverage.Bottom == nextCell.coverage.Bottom"  is complex.
Virtual Method Call from Constructor,MatterHackers.Agg.UI,WidgetForWindowsFormsAbstract,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WidgetForWindowsFormsAbstract.cs,WidgetForWindowsFormsAbstract,The constructor "WidgetForWindowsFormsAbstract" calls a virtual method "Focus".
Empty Catch Block,MatterHackers.Agg.PlatformAbstract,OsInformationWindowsPlugin,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\OsInformationWindowsPlugin.cs,IsRunningOnMac,The method has an empty catch block.
Empty Catch Block,MatterHackers.Agg.UI,WindowsFormsAbstract,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsAbstract.cs,InvokePendingOnIdleActions,The method has an empty catch block.
Empty Catch Block,MatterHackers.Agg.UI,WindowsFormsAbstract,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsAbstract.cs,RequestInvalidate,The method has an empty catch block.
Magic Number,MatterHackers.Agg,FileSystemStaticData,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\FileSystemStaticData.cs,GetFiles,The following statement contains a magic number: return Directory.GetFiles(MapPath(path)).Select(p => p.Substring(p.IndexOf("StaticData") + 11));
Magic Number,MatterHackers.Agg,FileSystemStaticData,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\FileSystemStaticData.cs,LoadImage,The following statement contains a magic number: lock (locker)  			{  				ImageBuffer cachedImage;  				if (!cachedImages.TryGetValue(path' out cachedImage))  				{  					using (var imageStream = OpenSteam(path))  					using (var bitmap = new Bitmap(imageStream))  					{  						cachedImage = new ImageBuffer();  						ImageIOWindowsPlugin.ConvertBitmapToImage(cachedImage' bitmap);  					}    					if (cachedImage.Width < 200 && cachedImage.Height < 200)  					{  						// only cache relatively small images  						cachedImages.Add(path' cachedImage);  					}  				}    				destImage.CopyFrom(cachedImage);  			}
Magic Number,MatterHackers.Agg,FileSystemStaticData,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\FileSystemStaticData.cs,LoadImage,The following statement contains a magic number: lock (locker)  			{  				ImageBuffer cachedImage;  				if (!cachedImages.TryGetValue(path' out cachedImage))  				{  					using (var imageStream = OpenSteam(path))  					using (var bitmap = new Bitmap(imageStream))  					{  						cachedImage = new ImageBuffer();  						ImageIOWindowsPlugin.ConvertBitmapToImage(cachedImage' bitmap);  					}    					if (cachedImage.Width < 200 && cachedImage.Height < 200)  					{  						// only cache relatively small images  						cachedImages.Add(path' cachedImage);  					}  				}    				destImage.CopyFrom(cachedImage);  			}
Magic Number,MatterHackers.Agg,SystemWindowCreator_WindowsForms,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\SystemWindowCreator_WindowsForms.cs,SetDesktopPosition,The following statement contains a magic number: if (systemWindow.AbstractOsMappingWidget != null)  			{  				// Make sure the window is on screen' but allow for a small amount of negative positioning to account for Form.DesktopLocation quirks  				position.x = Math.Max(-10' position.x);  				position.y = Math.Max(-10' position.y);    				// Auto-center if set to (-1'-1)  				if (position == new Point2D(-1' -1))  				{  					Point2D desktopSize = OsInformation.DesktopSize;  					position = new Point2D(  						(desktopSize.x - systemWindow.Width) / 2'   						(desktopSize.y - systemWindow.Height - systemWindow.AbstractOsMappingWidget.TitleBarHeight) / 2);  				}    				// If it's mac make sure we are not completely under the menu bar.  				if (OsInformation.OperatingSystem == OSType.Mac)  				{  					position.y = Math.Max(5' position.y);  				}    				systemWindow.AbstractOsMappingWidget.DesktopPosition = position;  			}  			else  			{  				pendingSetInitialDesktopPosition = true;  				InitialDesktopPosition = position;  			}
Magic Number,MatterHackers.Agg,SystemWindowCreator_WindowsForms,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\SystemWindowCreator_WindowsForms.cs,SetDesktopPosition,The following statement contains a magic number: if (systemWindow.AbstractOsMappingWidget != null)  			{  				// Make sure the window is on screen' but allow for a small amount of negative positioning to account for Form.DesktopLocation quirks  				position.x = Math.Max(-10' position.x);  				position.y = Math.Max(-10' position.y);    				// Auto-center if set to (-1'-1)  				if (position == new Point2D(-1' -1))  				{  					Point2D desktopSize = OsInformation.DesktopSize;  					position = new Point2D(  						(desktopSize.x - systemWindow.Width) / 2'   						(desktopSize.y - systemWindow.Height - systemWindow.AbstractOsMappingWidget.TitleBarHeight) / 2);  				}    				// If it's mac make sure we are not completely under the menu bar.  				if (OsInformation.OperatingSystem == OSType.Mac)  				{  					position.y = Math.Max(5' position.y);  				}    				systemWindow.AbstractOsMappingWidget.DesktopPosition = position;  			}  			else  			{  				pendingSetInitialDesktopPosition = true;  				InitialDesktopPosition = position;  			}
Magic Number,MatterHackers.Agg,SystemWindowCreator_WindowsForms,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\SystemWindowCreator_WindowsForms.cs,SetDesktopPosition,The following statement contains a magic number: if (systemWindow.AbstractOsMappingWidget != null)  			{  				// Make sure the window is on screen' but allow for a small amount of negative positioning to account for Form.DesktopLocation quirks  				position.x = Math.Max(-10' position.x);  				position.y = Math.Max(-10' position.y);    				// Auto-center if set to (-1'-1)  				if (position == new Point2D(-1' -1))  				{  					Point2D desktopSize = OsInformation.DesktopSize;  					position = new Point2D(  						(desktopSize.x - systemWindow.Width) / 2'   						(desktopSize.y - systemWindow.Height - systemWindow.AbstractOsMappingWidget.TitleBarHeight) / 2);  				}    				// If it's mac make sure we are not completely under the menu bar.  				if (OsInformation.OperatingSystem == OSType.Mac)  				{  					position.y = Math.Max(5' position.y);  				}    				systemWindow.AbstractOsMappingWidget.DesktopPosition = position;  			}  			else  			{  				pendingSetInitialDesktopPosition = true;  				InitialDesktopPosition = position;  			}
Magic Number,MatterHackers.Agg,SystemWindowCreator_WindowsForms,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\SystemWindowCreator_WindowsForms.cs,SetDesktopPosition,The following statement contains a magic number: if (systemWindow.AbstractOsMappingWidget != null)  			{  				// Make sure the window is on screen' but allow for a small amount of negative positioning to account for Form.DesktopLocation quirks  				position.x = Math.Max(-10' position.x);  				position.y = Math.Max(-10' position.y);    				// Auto-center if set to (-1'-1)  				if (position == new Point2D(-1' -1))  				{  					Point2D desktopSize = OsInformation.DesktopSize;  					position = new Point2D(  						(desktopSize.x - systemWindow.Width) / 2'   						(desktopSize.y - systemWindow.Height - systemWindow.AbstractOsMappingWidget.TitleBarHeight) / 2);  				}    				// If it's mac make sure we are not completely under the menu bar.  				if (OsInformation.OperatingSystem == OSType.Mac)  				{  					position.y = Math.Max(5' position.y);  				}    				systemWindow.AbstractOsMappingWidget.DesktopPosition = position;  			}  			else  			{  				pendingSetInitialDesktopPosition = true;  				InitialDesktopPosition = position;  			}
Magic Number,MatterHackers.Agg,SystemWindowCreator_WindowsForms,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\SystemWindowCreator_WindowsForms.cs,SetDesktopPosition,The following statement contains a magic number: if (systemWindow.AbstractOsMappingWidget != null)  			{  				// Make sure the window is on screen' but allow for a small amount of negative positioning to account for Form.DesktopLocation quirks  				position.x = Math.Max(-10' position.x);  				position.y = Math.Max(-10' position.y);    				// Auto-center if set to (-1'-1)  				if (position == new Point2D(-1' -1))  				{  					Point2D desktopSize = OsInformation.DesktopSize;  					position = new Point2D(  						(desktopSize.x - systemWindow.Width) / 2'   						(desktopSize.y - systemWindow.Height - systemWindow.AbstractOsMappingWidget.TitleBarHeight) / 2);  				}    				// If it's mac make sure we are not completely under the menu bar.  				if (OsInformation.OperatingSystem == OSType.Mac)  				{  					position.y = Math.Max(5' position.y);  				}    				systemWindow.AbstractOsMappingWidget.DesktopPosition = position;  			}  			else  			{  				pendingSetInitialDesktopPosition = true;  				InitialDesktopPosition = position;  			}
Magic Number,MatterHackers.Agg.PlatformAbstract,OsInformationWindowsPlugin,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\OsInformationWindowsPlugin.cs,IsRunningOnMac,The following statement contains a magic number: try  			{  				buf = Marshal.AllocHGlobal(8192);  				// This is a hacktastic way of getting sysname from uname ()  				if (uname(buf) == 0)  				{  					string os = Marshal.PtrToStringAnsi(buf);  					if (os == "Darwin")  					{  						return true;  					}  				}  			}  			catch  			{  			}  			finally  			{  				if (buf != IntPtr.Zero)  				{  					Marshal.FreeHGlobal(buf);  				}  			}
Magic Number,MatterHackers.Agg.UI,HookWindowsInputAndSendToWidget,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\HookWindowsInputAndSendToWidget.cs,controlToHook_MouseLeave,The following statement contains a magic number: widgetToSendTo.OnMouseMove(new MatterHackers.Agg.UI.MouseEventArgs(MatterHackers.Agg.UI.MouseButtons.None' 0' -10' -10' 0));
Magic Number,MatterHackers.Agg.UI,HookWindowsInputAndSendToWidget,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\HookWindowsInputAndSendToWidget.cs,controlToHook_MouseLeave,The following statement contains a magic number: widgetToSendTo.OnMouseMove(new MatterHackers.Agg.UI.MouseEventArgs(MatterHackers.Agg.UI.MouseButtons.None' 0' -10' -10' 0));
Magic Number,MatterHackers.Agg.UI,HookWindowsInputAndSendToWidget,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\HookWindowsInputAndSendToWidget.cs,controlToHook_MouseCaptureChanged,The following statement contains a magic number: if (widgetToSendTo.ChildHasMouseCaptured || widgetToSendTo.MouseCaptured)  			{  				widgetToSendTo.OnMouseUp(new MatterHackers.Agg.UI.MouseEventArgs(MouseButtons.Left' 0' -10' -10' 0));  			}
Magic Number,MatterHackers.Agg.UI,HookWindowsInputAndSendToWidget,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\HookWindowsInputAndSendToWidget.cs,controlToHook_MouseCaptureChanged,The following statement contains a magic number: if (widgetToSendTo.ChildHasMouseCaptured || widgetToSendTo.MouseCaptured)  			{  				widgetToSendTo.OnMouseUp(new MatterHackers.Agg.UI.MouseEventArgs(MouseButtons.Left' 0' -10' -10' 0));  			}
Magic Number,MatterHackers.Agg.UI,WidgetForWindowsFormsBitmap,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WidgetForWindowsFormsBitmap.cs,OnBoundsChanged,The following statement contains a magic number: if (childSystemWindow != null)  			{  				System.Drawing.Imaging.PixelFormat format = System.Drawing.Imaging.PixelFormat.Undefined;  				switch (childSystemWindow.BitDepth)  				{  					case 24:  						format = System.Drawing.Imaging.PixelFormat.Format24bppRgb;  						break;    					case 32:  						format = System.Drawing.Imaging.PixelFormat.Format32bppArgb;  						break;    					default:  						throw new NotImplementedException();  				}  				int bitDepth = System.Drawing.Image.GetPixelFormatSize(format);  				bitmapBackBuffer.Initialize((int)Width' (int)Height' bitDepth);  				NewGraphics2D().Clear(new RGBA_Floats(1' 1' 1' 1));  			}
Magic Number,MatterHackers.Agg.UI,WidgetForWindowsFormsBitmap,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WidgetForWindowsFormsBitmap.cs,OnBoundsChanged,The following statement contains a magic number: if (childSystemWindow != null)  			{  				System.Drawing.Imaging.PixelFormat format = System.Drawing.Imaging.PixelFormat.Undefined;  				switch (childSystemWindow.BitDepth)  				{  					case 24:  						format = System.Drawing.Imaging.PixelFormat.Format24bppRgb;  						break;    					case 32:  						format = System.Drawing.Imaging.PixelFormat.Format32bppArgb;  						break;    					default:  						throw new NotImplementedException();  				}  				int bitDepth = System.Drawing.Image.GetPixelFormatSize(format);  				bitmapBackBuffer.Initialize((int)Width' (int)Height' bitDepth);  				NewGraphics2D().Clear(new RGBA_Floats(1' 1' 1' 1));  			}
Magic Number,MatterHackers.Agg.UI,WindowsFormsAbstract,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsAbstract.cs,WindowsFormsAbstract,The following statement contains a magic number: if (idleCallBackTimer == null)  			{  				idleCallBackTimer = new System.Timers.Timer();  				mainForm = this;  				// call up to 100 times a second  				idleCallBackTimer.Interval = 10;  				idleCallBackTimer.Elapsed += InvokePendingOnIdleActions;  				idleCallBackTimer.Start();  			}
Magic Number,MatterHackers.Agg.UI,Joystick_HAL,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\Joystick_win32.cs,GetJoysticState,The following statement contains a magic number: if (result == 0)  			{  				joy.x1 = ((float)joystickInfo.X / 32768.0f - 1.0f);  				joy.y1 = -((float)joystickInfo.Y / 32768.0f - 1.0f);  				joy.b1 = joystickInfo.Z < 18000;  			}  			else  			{  				joy.x1 = 0;  				joy.y1 = 0;  				joy.b1 = false;  			}
Magic Number,MatterHackers.Agg.UI,WidgetForWindowsFormsAbstract,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WidgetForWindowsFormsAbstract.cs,Show,The following statement contains a magic number: if (mainWindowsFormsWindow != WindowsFormsWindow && childSystemWindow.CenterInParent)  			{  				Rectangle desktopBounds = mainWindowsFormsWindow.DesktopBounds;  				RectangleDouble newItemBounds = childSystemWindow.LocalBounds;    				windowsFormsWindow.Left = desktopBounds.X + desktopBounds.Width / 2 - (int) newItemBounds.Width / 2;  				windowsFormsWindow.Top = desktopBounds.Y + desktopBounds.Height / 2 - (int) newItemBounds.Height / 2 - TitleBarHeight/2;  			}
Magic Number,MatterHackers.Agg.UI,WidgetForWindowsFormsAbstract,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WidgetForWindowsFormsAbstract.cs,Show,The following statement contains a magic number: if (mainWindowsFormsWindow != WindowsFormsWindow && childSystemWindow.CenterInParent)  			{  				Rectangle desktopBounds = mainWindowsFormsWindow.DesktopBounds;  				RectangleDouble newItemBounds = childSystemWindow.LocalBounds;    				windowsFormsWindow.Left = desktopBounds.X + desktopBounds.Width / 2 - (int) newItemBounds.Width / 2;  				windowsFormsWindow.Top = desktopBounds.Y + desktopBounds.Height / 2 - (int) newItemBounds.Height / 2 - TitleBarHeight/2;  			}
Magic Number,MatterHackers.Agg.UI,WidgetForWindowsFormsAbstract,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WidgetForWindowsFormsAbstract.cs,Show,The following statement contains a magic number: if (mainWindowsFormsWindow != WindowsFormsWindow && childSystemWindow.CenterInParent)  			{  				Rectangle desktopBounds = mainWindowsFormsWindow.DesktopBounds;  				RectangleDouble newItemBounds = childSystemWindow.LocalBounds;    				windowsFormsWindow.Left = desktopBounds.X + desktopBounds.Width / 2 - (int) newItemBounds.Width / 2;  				windowsFormsWindow.Top = desktopBounds.Y + desktopBounds.Height / 2 - (int) newItemBounds.Height / 2 - TitleBarHeight/2;  			}
Magic Number,MatterHackers.Agg.UI,WidgetForWindowsFormsAbstract,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WidgetForWindowsFormsAbstract.cs,Show,The following statement contains a magic number: if (mainWindowsFormsWindow != WindowsFormsWindow && childSystemWindow.CenterInParent)  			{  				Rectangle desktopBounds = mainWindowsFormsWindow.DesktopBounds;  				RectangleDouble newItemBounds = childSystemWindow.LocalBounds;    				windowsFormsWindow.Left = desktopBounds.X + desktopBounds.Width / 2 - (int) newItemBounds.Width / 2;  				windowsFormsWindow.Top = desktopBounds.Y + desktopBounds.Height / 2 - (int) newItemBounds.Height / 2 - TitleBarHeight/2;  			}
Magic Number,MatterHackers.Agg.UI,WidgetForWindowsFormsAbstract,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WidgetForWindowsFormsAbstract.cs,Show,The following statement contains a magic number: if (mainWindowsFormsWindow != WindowsFormsWindow && childSystemWindow.CenterInParent)  			{  				Rectangle desktopBounds = mainWindowsFormsWindow.DesktopBounds;  				RectangleDouble newItemBounds = childSystemWindow.LocalBounds;    				windowsFormsWindow.Left = desktopBounds.X + desktopBounds.Width / 2 - (int) newItemBounds.Width / 2;  				windowsFormsWindow.Top = desktopBounds.Y + desktopBounds.Height / 2 - (int) newItemBounds.Height / 2 - TitleBarHeight/2;  			}
Magic Number,MatterHackers.Agg.UI,WidgetForWindowsFormsAbstract,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WidgetForWindowsFormsAbstract.cs,ShowModal,The following statement contains a magic number: if (mainWindowsFormsWindow != WindowsFormsWindow && childSystemWindow.CenterInParent)  			{  				Rectangle mainBounds = mainWindowsFormsWindow.DesktopBounds;  				RectangleDouble newItemBounds = childSystemWindow.LocalBounds;    				windowsFormsWindow.Left = mainBounds.X + mainBounds.Width / 2 - (int)newItemBounds.Width / 2;  				windowsFormsWindow.Top = mainBounds.Y + mainBounds.Height / 2 - (int)newItemBounds.Height / 2;  			}
Magic Number,MatterHackers.Agg.UI,WidgetForWindowsFormsAbstract,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WidgetForWindowsFormsAbstract.cs,ShowModal,The following statement contains a magic number: if (mainWindowsFormsWindow != WindowsFormsWindow && childSystemWindow.CenterInParent)  			{  				Rectangle mainBounds = mainWindowsFormsWindow.DesktopBounds;  				RectangleDouble newItemBounds = childSystemWindow.LocalBounds;    				windowsFormsWindow.Left = mainBounds.X + mainBounds.Width / 2 - (int)newItemBounds.Width / 2;  				windowsFormsWindow.Top = mainBounds.Y + mainBounds.Height / 2 - (int)newItemBounds.Height / 2;  			}
Magic Number,MatterHackers.Agg.UI,WidgetForWindowsFormsAbstract,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WidgetForWindowsFormsAbstract.cs,ShowModal,The following statement contains a magic number: if (mainWindowsFormsWindow != WindowsFormsWindow && childSystemWindow.CenterInParent)  			{  				Rectangle mainBounds = mainWindowsFormsWindow.DesktopBounds;  				RectangleDouble newItemBounds = childSystemWindow.LocalBounds;    				windowsFormsWindow.Left = mainBounds.X + mainBounds.Width / 2 - (int)newItemBounds.Width / 2;  				windowsFormsWindow.Top = mainBounds.Y + mainBounds.Height / 2 - (int)newItemBounds.Height / 2;  			}
Magic Number,MatterHackers.Agg.UI,WidgetForWindowsFormsAbstract,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WidgetForWindowsFormsAbstract.cs,ShowModal,The following statement contains a magic number: if (mainWindowsFormsWindow != WindowsFormsWindow && childSystemWindow.CenterInParent)  			{  				Rectangle mainBounds = mainWindowsFormsWindow.DesktopBounds;  				RectangleDouble newItemBounds = childSystemWindow.LocalBounds;    				windowsFormsWindow.Left = mainBounds.X + mainBounds.Width / 2 - (int)newItemBounds.Width / 2;  				windowsFormsWindow.Top = mainBounds.Y + mainBounds.Height / 2 - (int)newItemBounds.Height / 2;  			}
Magic Number,MatterHackers.Agg.UI,WindowsFormsBitmapBackBuffer,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmapBackBuffer.cs,UpdateHardwareSurface,The following statement contains a magic number: if (backingImageBufferByte != null)  			{  				if (!externallyLocked && !currentlyLocked)  				{  					currentlyLocked = true;  					bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat);  				}  				int backBufferStrideInBytes = backingImageBufferByte.StrideInBytes();  				int backBufferStrideInInts = backBufferStrideInBytes / 4;  				int backBufferHeight = backingImageBufferByte.Height;  				int backBufferHeightMinusOne = backBufferHeight - 1;  				int bitmapDataStride = bitmapData.Stride;  				int offset;  				byte[] buffer = backingImageBufferByte.GetBuffer(out offset);  				switch (backingImageBufferByte.BitDepth)  				{  					case 24:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = 0; y < backBufferHeight; y++)  									{  										int* pSourceInt = (int*)pSource;  										int* pDestBufferInt = (int*)pDestBuffer;  										for (int x = 0; x < backBufferStrideInInts; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  										for (int x = backBufferStrideInInts * 4; x < backBufferStrideInBytes; x++)  										{  											pDestBuffer[x] = pSource[x];  										}  										pDestBuffer -= bitmapDataStride;  										pSource += backBufferStrideInBytes;  									}  								}  							}  						}  						break;    					case 32:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = rect.Bottom; y < rect.Top; y++)  									{  										int* pSourceInt = (int*)pSource;  										pSourceInt += (backBufferStrideInBytes * y / 4);    										int* pDestBufferInt = (int*)pDestBuffer;  										pDestBufferInt -= (bitmapDataStride * y / 4);    										for (int x = rect.Left; x < rect.Right; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  									}  								}  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  				if (!externallyLocked)  				{  					windowsBitmap.UnlockBits(bitmapData);  					currentlyLocked = false;  				}  			}  			else  			{  				switch (backingImageBufferFloat.BitDepth)  				{  					case 128:  						{  							BitmapData bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat);  							int index = 0;  							unsafe  							{  								unchecked  								{  									int offset;  									float[] buffer = backingImageBufferFloat.GetBuffer(out offset);  									fixed (float* pSource = &buffer[offset])  									{  										for (int y = 0; y < backingImageBufferFloat.Height; y++)  										{  											byte* pDestBuffer = (byte*)bitmapData.Scan0 + (bitmapData.Stride * (backingImageBufferFloat.Height - 1 - y));  											for (int x = 0; x < backingImageBufferFloat.Width; x++)  											{  #if true  												pDestBuffer[x * 4 + 0] = (byte)(pSource[index * 4 + 0] * 255);  												pDestBuffer[x * 4 + 1] = (byte)(pSource[index * 4 + 1] * 255);  												pDestBuffer[x * 4 + 2] = (byte)(pSource[index * 4 + 2] * 255);  												pDestBuffer[x * 4 + 3] = (byte)(pSource[index * 4 + 3] * 255);  												index++;  #else                                                  pDestBuffer[x * 4 + 0] = (byte)255;                                                  pDestBuffer[x * 4 + 1] = (byte)0;                                                  pDestBuffer[x * 4 + 2] = (byte)128;                                                  pDestBuffer[x * 4 + 3] = (byte)255;  #endif  											}  										}  									}  								}  							}    							windowsBitmap.UnlockBits(bitmapData);  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.Agg.UI,WindowsFormsBitmapBackBuffer,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmapBackBuffer.cs,UpdateHardwareSurface,The following statement contains a magic number: if (backingImageBufferByte != null)  			{  				if (!externallyLocked && !currentlyLocked)  				{  					currentlyLocked = true;  					bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat);  				}  				int backBufferStrideInBytes = backingImageBufferByte.StrideInBytes();  				int backBufferStrideInInts = backBufferStrideInBytes / 4;  				int backBufferHeight = backingImageBufferByte.Height;  				int backBufferHeightMinusOne = backBufferHeight - 1;  				int bitmapDataStride = bitmapData.Stride;  				int offset;  				byte[] buffer = backingImageBufferByte.GetBuffer(out offset);  				switch (backingImageBufferByte.BitDepth)  				{  					case 24:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = 0; y < backBufferHeight; y++)  									{  										int* pSourceInt = (int*)pSource;  										int* pDestBufferInt = (int*)pDestBuffer;  										for (int x = 0; x < backBufferStrideInInts; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  										for (int x = backBufferStrideInInts * 4; x < backBufferStrideInBytes; x++)  										{  											pDestBuffer[x] = pSource[x];  										}  										pDestBuffer -= bitmapDataStride;  										pSource += backBufferStrideInBytes;  									}  								}  							}  						}  						break;    					case 32:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = rect.Bottom; y < rect.Top; y++)  									{  										int* pSourceInt = (int*)pSource;  										pSourceInt += (backBufferStrideInBytes * y / 4);    										int* pDestBufferInt = (int*)pDestBuffer;  										pDestBufferInt -= (bitmapDataStride * y / 4);    										for (int x = rect.Left; x < rect.Right; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  									}  								}  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  				if (!externallyLocked)  				{  					windowsBitmap.UnlockBits(bitmapData);  					currentlyLocked = false;  				}  			}  			else  			{  				switch (backingImageBufferFloat.BitDepth)  				{  					case 128:  						{  							BitmapData bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat);  							int index = 0;  							unsafe  							{  								unchecked  								{  									int offset;  									float[] buffer = backingImageBufferFloat.GetBuffer(out offset);  									fixed (float* pSource = &buffer[offset])  									{  										for (int y = 0; y < backingImageBufferFloat.Height; y++)  										{  											byte* pDestBuffer = (byte*)bitmapData.Scan0 + (bitmapData.Stride * (backingImageBufferFloat.Height - 1 - y));  											for (int x = 0; x < backingImageBufferFloat.Width; x++)  											{  #if true  												pDestBuffer[x * 4 + 0] = (byte)(pSource[index * 4 + 0] * 255);  												pDestBuffer[x * 4 + 1] = (byte)(pSource[index * 4 + 1] * 255);  												pDestBuffer[x * 4 + 2] = (byte)(pSource[index * 4 + 2] * 255);  												pDestBuffer[x * 4 + 3] = (byte)(pSource[index * 4 + 3] * 255);  												index++;  #else                                                  pDestBuffer[x * 4 + 0] = (byte)255;                                                  pDestBuffer[x * 4 + 1] = (byte)0;                                                  pDestBuffer[x * 4 + 2] = (byte)128;                                                  pDestBuffer[x * 4 + 3] = (byte)255;  #endif  											}  										}  									}  								}  							}    							windowsBitmap.UnlockBits(bitmapData);  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.Agg.UI,WindowsFormsBitmapBackBuffer,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmapBackBuffer.cs,UpdateHardwareSurface,The following statement contains a magic number: if (backingImageBufferByte != null)  			{  				if (!externallyLocked && !currentlyLocked)  				{  					currentlyLocked = true;  					bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat);  				}  				int backBufferStrideInBytes = backingImageBufferByte.StrideInBytes();  				int backBufferStrideInInts = backBufferStrideInBytes / 4;  				int backBufferHeight = backingImageBufferByte.Height;  				int backBufferHeightMinusOne = backBufferHeight - 1;  				int bitmapDataStride = bitmapData.Stride;  				int offset;  				byte[] buffer = backingImageBufferByte.GetBuffer(out offset);  				switch (backingImageBufferByte.BitDepth)  				{  					case 24:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = 0; y < backBufferHeight; y++)  									{  										int* pSourceInt = (int*)pSource;  										int* pDestBufferInt = (int*)pDestBuffer;  										for (int x = 0; x < backBufferStrideInInts; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  										for (int x = backBufferStrideInInts * 4; x < backBufferStrideInBytes; x++)  										{  											pDestBuffer[x] = pSource[x];  										}  										pDestBuffer -= bitmapDataStride;  										pSource += backBufferStrideInBytes;  									}  								}  							}  						}  						break;    					case 32:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = rect.Bottom; y < rect.Top; y++)  									{  										int* pSourceInt = (int*)pSource;  										pSourceInt += (backBufferStrideInBytes * y / 4);    										int* pDestBufferInt = (int*)pDestBuffer;  										pDestBufferInt -= (bitmapDataStride * y / 4);    										for (int x = rect.Left; x < rect.Right; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  									}  								}  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  				if (!externallyLocked)  				{  					windowsBitmap.UnlockBits(bitmapData);  					currentlyLocked = false;  				}  			}  			else  			{  				switch (backingImageBufferFloat.BitDepth)  				{  					case 128:  						{  							BitmapData bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat);  							int index = 0;  							unsafe  							{  								unchecked  								{  									int offset;  									float[] buffer = backingImageBufferFloat.GetBuffer(out offset);  									fixed (float* pSource = &buffer[offset])  									{  										for (int y = 0; y < backingImageBufferFloat.Height; y++)  										{  											byte* pDestBuffer = (byte*)bitmapData.Scan0 + (bitmapData.Stride * (backingImageBufferFloat.Height - 1 - y));  											for (int x = 0; x < backingImageBufferFloat.Width; x++)  											{  #if true  												pDestBuffer[x * 4 + 0] = (byte)(pSource[index * 4 + 0] * 255);  												pDestBuffer[x * 4 + 1] = (byte)(pSource[index * 4 + 1] * 255);  												pDestBuffer[x * 4 + 2] = (byte)(pSource[index * 4 + 2] * 255);  												pDestBuffer[x * 4 + 3] = (byte)(pSource[index * 4 + 3] * 255);  												index++;  #else                                                  pDestBuffer[x * 4 + 0] = (byte)255;                                                  pDestBuffer[x * 4 + 1] = (byte)0;                                                  pDestBuffer[x * 4 + 2] = (byte)128;                                                  pDestBuffer[x * 4 + 3] = (byte)255;  #endif  											}  										}  									}  								}  							}    							windowsBitmap.UnlockBits(bitmapData);  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.Agg.UI,WindowsFormsBitmapBackBuffer,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmapBackBuffer.cs,UpdateHardwareSurface,The following statement contains a magic number: if (backingImageBufferByte != null)  			{  				if (!externallyLocked && !currentlyLocked)  				{  					currentlyLocked = true;  					bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat);  				}  				int backBufferStrideInBytes = backingImageBufferByte.StrideInBytes();  				int backBufferStrideInInts = backBufferStrideInBytes / 4;  				int backBufferHeight = backingImageBufferByte.Height;  				int backBufferHeightMinusOne = backBufferHeight - 1;  				int bitmapDataStride = bitmapData.Stride;  				int offset;  				byte[] buffer = backingImageBufferByte.GetBuffer(out offset);  				switch (backingImageBufferByte.BitDepth)  				{  					case 24:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = 0; y < backBufferHeight; y++)  									{  										int* pSourceInt = (int*)pSource;  										int* pDestBufferInt = (int*)pDestBuffer;  										for (int x = 0; x < backBufferStrideInInts; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  										for (int x = backBufferStrideInInts * 4; x < backBufferStrideInBytes; x++)  										{  											pDestBuffer[x] = pSource[x];  										}  										pDestBuffer -= bitmapDataStride;  										pSource += backBufferStrideInBytes;  									}  								}  							}  						}  						break;    					case 32:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = rect.Bottom; y < rect.Top; y++)  									{  										int* pSourceInt = (int*)pSource;  										pSourceInt += (backBufferStrideInBytes * y / 4);    										int* pDestBufferInt = (int*)pDestBuffer;  										pDestBufferInt -= (bitmapDataStride * y / 4);    										for (int x = rect.Left; x < rect.Right; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  									}  								}  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  				if (!externallyLocked)  				{  					windowsBitmap.UnlockBits(bitmapData);  					currentlyLocked = false;  				}  			}  			else  			{  				switch (backingImageBufferFloat.BitDepth)  				{  					case 128:  						{  							BitmapData bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat);  							int index = 0;  							unsafe  							{  								unchecked  								{  									int offset;  									float[] buffer = backingImageBufferFloat.GetBuffer(out offset);  									fixed (float* pSource = &buffer[offset])  									{  										for (int y = 0; y < backingImageBufferFloat.Height; y++)  										{  											byte* pDestBuffer = (byte*)bitmapData.Scan0 + (bitmapData.Stride * (backingImageBufferFloat.Height - 1 - y));  											for (int x = 0; x < backingImageBufferFloat.Width; x++)  											{  #if true  												pDestBuffer[x * 4 + 0] = (byte)(pSource[index * 4 + 0] * 255);  												pDestBuffer[x * 4 + 1] = (byte)(pSource[index * 4 + 1] * 255);  												pDestBuffer[x * 4 + 2] = (byte)(pSource[index * 4 + 2] * 255);  												pDestBuffer[x * 4 + 3] = (byte)(pSource[index * 4 + 3] * 255);  												index++;  #else                                                  pDestBuffer[x * 4 + 0] = (byte)255;                                                  pDestBuffer[x * 4 + 1] = (byte)0;                                                  pDestBuffer[x * 4 + 2] = (byte)128;                                                  pDestBuffer[x * 4 + 3] = (byte)255;  #endif  											}  										}  									}  								}  							}    							windowsBitmap.UnlockBits(bitmapData);  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.Agg.UI,WindowsFormsBitmapBackBuffer,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmapBackBuffer.cs,UpdateHardwareSurface,The following statement contains a magic number: if (backingImageBufferByte != null)  			{  				if (!externallyLocked && !currentlyLocked)  				{  					currentlyLocked = true;  					bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat);  				}  				int backBufferStrideInBytes = backingImageBufferByte.StrideInBytes();  				int backBufferStrideInInts = backBufferStrideInBytes / 4;  				int backBufferHeight = backingImageBufferByte.Height;  				int backBufferHeightMinusOne = backBufferHeight - 1;  				int bitmapDataStride = bitmapData.Stride;  				int offset;  				byte[] buffer = backingImageBufferByte.GetBuffer(out offset);  				switch (backingImageBufferByte.BitDepth)  				{  					case 24:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = 0; y < backBufferHeight; y++)  									{  										int* pSourceInt = (int*)pSource;  										int* pDestBufferInt = (int*)pDestBuffer;  										for (int x = 0; x < backBufferStrideInInts; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  										for (int x = backBufferStrideInInts * 4; x < backBufferStrideInBytes; x++)  										{  											pDestBuffer[x] = pSource[x];  										}  										pDestBuffer -= bitmapDataStride;  										pSource += backBufferStrideInBytes;  									}  								}  							}  						}  						break;    					case 32:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = rect.Bottom; y < rect.Top; y++)  									{  										int* pSourceInt = (int*)pSource;  										pSourceInt += (backBufferStrideInBytes * y / 4);    										int* pDestBufferInt = (int*)pDestBuffer;  										pDestBufferInt -= (bitmapDataStride * y / 4);    										for (int x = rect.Left; x < rect.Right; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  									}  								}  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  				if (!externallyLocked)  				{  					windowsBitmap.UnlockBits(bitmapData);  					currentlyLocked = false;  				}  			}  			else  			{  				switch (backingImageBufferFloat.BitDepth)  				{  					case 128:  						{  							BitmapData bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat);  							int index = 0;  							unsafe  							{  								unchecked  								{  									int offset;  									float[] buffer = backingImageBufferFloat.GetBuffer(out offset);  									fixed (float* pSource = &buffer[offset])  									{  										for (int y = 0; y < backingImageBufferFloat.Height; y++)  										{  											byte* pDestBuffer = (byte*)bitmapData.Scan0 + (bitmapData.Stride * (backingImageBufferFloat.Height - 1 - y));  											for (int x = 0; x < backingImageBufferFloat.Width; x++)  											{  #if true  												pDestBuffer[x * 4 + 0] = (byte)(pSource[index * 4 + 0] * 255);  												pDestBuffer[x * 4 + 1] = (byte)(pSource[index * 4 + 1] * 255);  												pDestBuffer[x * 4 + 2] = (byte)(pSource[index * 4 + 2] * 255);  												pDestBuffer[x * 4 + 3] = (byte)(pSource[index * 4 + 3] * 255);  												index++;  #else                                                  pDestBuffer[x * 4 + 0] = (byte)255;                                                  pDestBuffer[x * 4 + 1] = (byte)0;                                                  pDestBuffer[x * 4 + 2] = (byte)128;                                                  pDestBuffer[x * 4 + 3] = (byte)255;  #endif  											}  										}  									}  								}  							}    							windowsBitmap.UnlockBits(bitmapData);  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.Agg.UI,WindowsFormsBitmapBackBuffer,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmapBackBuffer.cs,UpdateHardwareSurface,The following statement contains a magic number: if (backingImageBufferByte != null)  			{  				if (!externallyLocked && !currentlyLocked)  				{  					currentlyLocked = true;  					bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat);  				}  				int backBufferStrideInBytes = backingImageBufferByte.StrideInBytes();  				int backBufferStrideInInts = backBufferStrideInBytes / 4;  				int backBufferHeight = backingImageBufferByte.Height;  				int backBufferHeightMinusOne = backBufferHeight - 1;  				int bitmapDataStride = bitmapData.Stride;  				int offset;  				byte[] buffer = backingImageBufferByte.GetBuffer(out offset);  				switch (backingImageBufferByte.BitDepth)  				{  					case 24:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = 0; y < backBufferHeight; y++)  									{  										int* pSourceInt = (int*)pSource;  										int* pDestBufferInt = (int*)pDestBuffer;  										for (int x = 0; x < backBufferStrideInInts; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  										for (int x = backBufferStrideInInts * 4; x < backBufferStrideInBytes; x++)  										{  											pDestBuffer[x] = pSource[x];  										}  										pDestBuffer -= bitmapDataStride;  										pSource += backBufferStrideInBytes;  									}  								}  							}  						}  						break;    					case 32:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = rect.Bottom; y < rect.Top; y++)  									{  										int* pSourceInt = (int*)pSource;  										pSourceInt += (backBufferStrideInBytes * y / 4);    										int* pDestBufferInt = (int*)pDestBuffer;  										pDestBufferInt -= (bitmapDataStride * y / 4);    										for (int x = rect.Left; x < rect.Right; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  									}  								}  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  				if (!externallyLocked)  				{  					windowsBitmap.UnlockBits(bitmapData);  					currentlyLocked = false;  				}  			}  			else  			{  				switch (backingImageBufferFloat.BitDepth)  				{  					case 128:  						{  							BitmapData bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat);  							int index = 0;  							unsafe  							{  								unchecked  								{  									int offset;  									float[] buffer = backingImageBufferFloat.GetBuffer(out offset);  									fixed (float* pSource = &buffer[offset])  									{  										for (int y = 0; y < backingImageBufferFloat.Height; y++)  										{  											byte* pDestBuffer = (byte*)bitmapData.Scan0 + (bitmapData.Stride * (backingImageBufferFloat.Height - 1 - y));  											for (int x = 0; x < backingImageBufferFloat.Width; x++)  											{  #if true  												pDestBuffer[x * 4 + 0] = (byte)(pSource[index * 4 + 0] * 255);  												pDestBuffer[x * 4 + 1] = (byte)(pSource[index * 4 + 1] * 255);  												pDestBuffer[x * 4 + 2] = (byte)(pSource[index * 4 + 2] * 255);  												pDestBuffer[x * 4 + 3] = (byte)(pSource[index * 4 + 3] * 255);  												index++;  #else                                                  pDestBuffer[x * 4 + 0] = (byte)255;                                                  pDestBuffer[x * 4 + 1] = (byte)0;                                                  pDestBuffer[x * 4 + 2] = (byte)128;                                                  pDestBuffer[x * 4 + 3] = (byte)255;  #endif  											}  										}  									}  								}  							}    							windowsBitmap.UnlockBits(bitmapData);  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.Agg.UI,WindowsFormsBitmapBackBuffer,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmapBackBuffer.cs,UpdateHardwareSurface,The following statement contains a magic number: if (backingImageBufferByte != null)  			{  				if (!externallyLocked && !currentlyLocked)  				{  					currentlyLocked = true;  					bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat);  				}  				int backBufferStrideInBytes = backingImageBufferByte.StrideInBytes();  				int backBufferStrideInInts = backBufferStrideInBytes / 4;  				int backBufferHeight = backingImageBufferByte.Height;  				int backBufferHeightMinusOne = backBufferHeight - 1;  				int bitmapDataStride = bitmapData.Stride;  				int offset;  				byte[] buffer = backingImageBufferByte.GetBuffer(out offset);  				switch (backingImageBufferByte.BitDepth)  				{  					case 24:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = 0; y < backBufferHeight; y++)  									{  										int* pSourceInt = (int*)pSource;  										int* pDestBufferInt = (int*)pDestBuffer;  										for (int x = 0; x < backBufferStrideInInts; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  										for (int x = backBufferStrideInInts * 4; x < backBufferStrideInBytes; x++)  										{  											pDestBuffer[x] = pSource[x];  										}  										pDestBuffer -= bitmapDataStride;  										pSource += backBufferStrideInBytes;  									}  								}  							}  						}  						break;    					case 32:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = rect.Bottom; y < rect.Top; y++)  									{  										int* pSourceInt = (int*)pSource;  										pSourceInt += (backBufferStrideInBytes * y / 4);    										int* pDestBufferInt = (int*)pDestBuffer;  										pDestBufferInt -= (bitmapDataStride * y / 4);    										for (int x = rect.Left; x < rect.Right; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  									}  								}  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  				if (!externallyLocked)  				{  					windowsBitmap.UnlockBits(bitmapData);  					currentlyLocked = false;  				}  			}  			else  			{  				switch (backingImageBufferFloat.BitDepth)  				{  					case 128:  						{  							BitmapData bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat);  							int index = 0;  							unsafe  							{  								unchecked  								{  									int offset;  									float[] buffer = backingImageBufferFloat.GetBuffer(out offset);  									fixed (float* pSource = &buffer[offset])  									{  										for (int y = 0; y < backingImageBufferFloat.Height; y++)  										{  											byte* pDestBuffer = (byte*)bitmapData.Scan0 + (bitmapData.Stride * (backingImageBufferFloat.Height - 1 - y));  											for (int x = 0; x < backingImageBufferFloat.Width; x++)  											{  #if true  												pDestBuffer[x * 4 + 0] = (byte)(pSource[index * 4 + 0] * 255);  												pDestBuffer[x * 4 + 1] = (byte)(pSource[index * 4 + 1] * 255);  												pDestBuffer[x * 4 + 2] = (byte)(pSource[index * 4 + 2] * 255);  												pDestBuffer[x * 4 + 3] = (byte)(pSource[index * 4 + 3] * 255);  												index++;  #else                                                  pDestBuffer[x * 4 + 0] = (byte)255;                                                  pDestBuffer[x * 4 + 1] = (byte)0;                                                  pDestBuffer[x * 4 + 2] = (byte)128;                                                  pDestBuffer[x * 4 + 3] = (byte)255;  #endif  											}  										}  									}  								}  							}    							windowsBitmap.UnlockBits(bitmapData);  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.Agg.UI,WindowsFormsBitmapBackBuffer,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmapBackBuffer.cs,UpdateHardwareSurface,The following statement contains a magic number: if (backingImageBufferByte != null)  			{  				if (!externallyLocked && !currentlyLocked)  				{  					currentlyLocked = true;  					bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat);  				}  				int backBufferStrideInBytes = backingImageBufferByte.StrideInBytes();  				int backBufferStrideInInts = backBufferStrideInBytes / 4;  				int backBufferHeight = backingImageBufferByte.Height;  				int backBufferHeightMinusOne = backBufferHeight - 1;  				int bitmapDataStride = bitmapData.Stride;  				int offset;  				byte[] buffer = backingImageBufferByte.GetBuffer(out offset);  				switch (backingImageBufferByte.BitDepth)  				{  					case 24:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = 0; y < backBufferHeight; y++)  									{  										int* pSourceInt = (int*)pSource;  										int* pDestBufferInt = (int*)pDestBuffer;  										for (int x = 0; x < backBufferStrideInInts; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  										for (int x = backBufferStrideInInts * 4; x < backBufferStrideInBytes; x++)  										{  											pDestBuffer[x] = pSource[x];  										}  										pDestBuffer -= bitmapDataStride;  										pSource += backBufferStrideInBytes;  									}  								}  							}  						}  						break;    					case 32:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = rect.Bottom; y < rect.Top; y++)  									{  										int* pSourceInt = (int*)pSource;  										pSourceInt += (backBufferStrideInBytes * y / 4);    										int* pDestBufferInt = (int*)pDestBuffer;  										pDestBufferInt -= (bitmapDataStride * y / 4);    										for (int x = rect.Left; x < rect.Right; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  									}  								}  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  				if (!externallyLocked)  				{  					windowsBitmap.UnlockBits(bitmapData);  					currentlyLocked = false;  				}  			}  			else  			{  				switch (backingImageBufferFloat.BitDepth)  				{  					case 128:  						{  							BitmapData bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat);  							int index = 0;  							unsafe  							{  								unchecked  								{  									int offset;  									float[] buffer = backingImageBufferFloat.GetBuffer(out offset);  									fixed (float* pSource = &buffer[offset])  									{  										for (int y = 0; y < backingImageBufferFloat.Height; y++)  										{  											byte* pDestBuffer = (byte*)bitmapData.Scan0 + (bitmapData.Stride * (backingImageBufferFloat.Height - 1 - y));  											for (int x = 0; x < backingImageBufferFloat.Width; x++)  											{  #if true  												pDestBuffer[x * 4 + 0] = (byte)(pSource[index * 4 + 0] * 255);  												pDestBuffer[x * 4 + 1] = (byte)(pSource[index * 4 + 1] * 255);  												pDestBuffer[x * 4 + 2] = (byte)(pSource[index * 4 + 2] * 255);  												pDestBuffer[x * 4 + 3] = (byte)(pSource[index * 4 + 3] * 255);  												index++;  #else                                                  pDestBuffer[x * 4 + 0] = (byte)255;                                                  pDestBuffer[x * 4 + 1] = (byte)0;                                                  pDestBuffer[x * 4 + 2] = (byte)128;                                                  pDestBuffer[x * 4 + 3] = (byte)255;  #endif  											}  										}  									}  								}  							}    							windowsBitmap.UnlockBits(bitmapData);  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.Agg.UI,WindowsFormsBitmapBackBuffer,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmapBackBuffer.cs,UpdateHardwareSurface,The following statement contains a magic number: if (backingImageBufferByte != null)  			{  				if (!externallyLocked && !currentlyLocked)  				{  					currentlyLocked = true;  					bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat);  				}  				int backBufferStrideInBytes = backingImageBufferByte.StrideInBytes();  				int backBufferStrideInInts = backBufferStrideInBytes / 4;  				int backBufferHeight = backingImageBufferByte.Height;  				int backBufferHeightMinusOne = backBufferHeight - 1;  				int bitmapDataStride = bitmapData.Stride;  				int offset;  				byte[] buffer = backingImageBufferByte.GetBuffer(out offset);  				switch (backingImageBufferByte.BitDepth)  				{  					case 24:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = 0; y < backBufferHeight; y++)  									{  										int* pSourceInt = (int*)pSource;  										int* pDestBufferInt = (int*)pDestBuffer;  										for (int x = 0; x < backBufferStrideInInts; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  										for (int x = backBufferStrideInInts * 4; x < backBufferStrideInBytes; x++)  										{  											pDestBuffer[x] = pSource[x];  										}  										pDestBuffer -= bitmapDataStride;  										pSource += backBufferStrideInBytes;  									}  								}  							}  						}  						break;    					case 32:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = rect.Bottom; y < rect.Top; y++)  									{  										int* pSourceInt = (int*)pSource;  										pSourceInt += (backBufferStrideInBytes * y / 4);    										int* pDestBufferInt = (int*)pDestBuffer;  										pDestBufferInt -= (bitmapDataStride * y / 4);    										for (int x = rect.Left; x < rect.Right; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  									}  								}  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  				if (!externallyLocked)  				{  					windowsBitmap.UnlockBits(bitmapData);  					currentlyLocked = false;  				}  			}  			else  			{  				switch (backingImageBufferFloat.BitDepth)  				{  					case 128:  						{  							BitmapData bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat);  							int index = 0;  							unsafe  							{  								unchecked  								{  									int offset;  									float[] buffer = backingImageBufferFloat.GetBuffer(out offset);  									fixed (float* pSource = &buffer[offset])  									{  										for (int y = 0; y < backingImageBufferFloat.Height; y++)  										{  											byte* pDestBuffer = (byte*)bitmapData.Scan0 + (bitmapData.Stride * (backingImageBufferFloat.Height - 1 - y));  											for (int x = 0; x < backingImageBufferFloat.Width; x++)  											{  #if true  												pDestBuffer[x * 4 + 0] = (byte)(pSource[index * 4 + 0] * 255);  												pDestBuffer[x * 4 + 1] = (byte)(pSource[index * 4 + 1] * 255);  												pDestBuffer[x * 4 + 2] = (byte)(pSource[index * 4 + 2] * 255);  												pDestBuffer[x * 4 + 3] = (byte)(pSource[index * 4 + 3] * 255);  												index++;  #else                                                  pDestBuffer[x * 4 + 0] = (byte)255;                                                  pDestBuffer[x * 4 + 1] = (byte)0;                                                  pDestBuffer[x * 4 + 2] = (byte)128;                                                  pDestBuffer[x * 4 + 3] = (byte)255;  #endif  											}  										}  									}  								}  							}    							windowsBitmap.UnlockBits(bitmapData);  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.Agg.UI,WindowsFormsBitmapBackBuffer,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmapBackBuffer.cs,UpdateHardwareSurface,The following statement contains a magic number: if (backingImageBufferByte != null)  			{  				if (!externallyLocked && !currentlyLocked)  				{  					currentlyLocked = true;  					bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat);  				}  				int backBufferStrideInBytes = backingImageBufferByte.StrideInBytes();  				int backBufferStrideInInts = backBufferStrideInBytes / 4;  				int backBufferHeight = backingImageBufferByte.Height;  				int backBufferHeightMinusOne = backBufferHeight - 1;  				int bitmapDataStride = bitmapData.Stride;  				int offset;  				byte[] buffer = backingImageBufferByte.GetBuffer(out offset);  				switch (backingImageBufferByte.BitDepth)  				{  					case 24:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = 0; y < backBufferHeight; y++)  									{  										int* pSourceInt = (int*)pSource;  										int* pDestBufferInt = (int*)pDestBuffer;  										for (int x = 0; x < backBufferStrideInInts; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  										for (int x = backBufferStrideInInts * 4; x < backBufferStrideInBytes; x++)  										{  											pDestBuffer[x] = pSource[x];  										}  										pDestBuffer -= bitmapDataStride;  										pSource += backBufferStrideInBytes;  									}  								}  							}  						}  						break;    					case 32:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = rect.Bottom; y < rect.Top; y++)  									{  										int* pSourceInt = (int*)pSource;  										pSourceInt += (backBufferStrideInBytes * y / 4);    										int* pDestBufferInt = (int*)pDestBuffer;  										pDestBufferInt -= (bitmapDataStride * y / 4);    										for (int x = rect.Left; x < rect.Right; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  									}  								}  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  				if (!externallyLocked)  				{  					windowsBitmap.UnlockBits(bitmapData);  					currentlyLocked = false;  				}  			}  			else  			{  				switch (backingImageBufferFloat.BitDepth)  				{  					case 128:  						{  							BitmapData bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat);  							int index = 0;  							unsafe  							{  								unchecked  								{  									int offset;  									float[] buffer = backingImageBufferFloat.GetBuffer(out offset);  									fixed (float* pSource = &buffer[offset])  									{  										for (int y = 0; y < backingImageBufferFloat.Height; y++)  										{  											byte* pDestBuffer = (byte*)bitmapData.Scan0 + (bitmapData.Stride * (backingImageBufferFloat.Height - 1 - y));  											for (int x = 0; x < backingImageBufferFloat.Width; x++)  											{  #if true  												pDestBuffer[x * 4 + 0] = (byte)(pSource[index * 4 + 0] * 255);  												pDestBuffer[x * 4 + 1] = (byte)(pSource[index * 4 + 1] * 255);  												pDestBuffer[x * 4 + 2] = (byte)(pSource[index * 4 + 2] * 255);  												pDestBuffer[x * 4 + 3] = (byte)(pSource[index * 4 + 3] * 255);  												index++;  #else                                                  pDestBuffer[x * 4 + 0] = (byte)255;                                                  pDestBuffer[x * 4 + 1] = (byte)0;                                                  pDestBuffer[x * 4 + 2] = (byte)128;                                                  pDestBuffer[x * 4 + 3] = (byte)255;  #endif  											}  										}  									}  								}  							}    							windowsBitmap.UnlockBits(bitmapData);  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.Agg.UI,WindowsFormsBitmapBackBuffer,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmapBackBuffer.cs,UpdateHardwareSurface,The following statement contains a magic number: if (backingImageBufferByte != null)  			{  				if (!externallyLocked && !currentlyLocked)  				{  					currentlyLocked = true;  					bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat);  				}  				int backBufferStrideInBytes = backingImageBufferByte.StrideInBytes();  				int backBufferStrideInInts = backBufferStrideInBytes / 4;  				int backBufferHeight = backingImageBufferByte.Height;  				int backBufferHeightMinusOne = backBufferHeight - 1;  				int bitmapDataStride = bitmapData.Stride;  				int offset;  				byte[] buffer = backingImageBufferByte.GetBuffer(out offset);  				switch (backingImageBufferByte.BitDepth)  				{  					case 24:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = 0; y < backBufferHeight; y++)  									{  										int* pSourceInt = (int*)pSource;  										int* pDestBufferInt = (int*)pDestBuffer;  										for (int x = 0; x < backBufferStrideInInts; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  										for (int x = backBufferStrideInInts * 4; x < backBufferStrideInBytes; x++)  										{  											pDestBuffer[x] = pSource[x];  										}  										pDestBuffer -= bitmapDataStride;  										pSource += backBufferStrideInBytes;  									}  								}  							}  						}  						break;    					case 32:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = rect.Bottom; y < rect.Top; y++)  									{  										int* pSourceInt = (int*)pSource;  										pSourceInt += (backBufferStrideInBytes * y / 4);    										int* pDestBufferInt = (int*)pDestBuffer;  										pDestBufferInt -= (bitmapDataStride * y / 4);    										for (int x = rect.Left; x < rect.Right; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  									}  								}  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  				if (!externallyLocked)  				{  					windowsBitmap.UnlockBits(bitmapData);  					currentlyLocked = false;  				}  			}  			else  			{  				switch (backingImageBufferFloat.BitDepth)  				{  					case 128:  						{  							BitmapData bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat);  							int index = 0;  							unsafe  							{  								unchecked  								{  									int offset;  									float[] buffer = backingImageBufferFloat.GetBuffer(out offset);  									fixed (float* pSource = &buffer[offset])  									{  										for (int y = 0; y < backingImageBufferFloat.Height; y++)  										{  											byte* pDestBuffer = (byte*)bitmapData.Scan0 + (bitmapData.Stride * (backingImageBufferFloat.Height - 1 - y));  											for (int x = 0; x < backingImageBufferFloat.Width; x++)  											{  #if true  												pDestBuffer[x * 4 + 0] = (byte)(pSource[index * 4 + 0] * 255);  												pDestBuffer[x * 4 + 1] = (byte)(pSource[index * 4 + 1] * 255);  												pDestBuffer[x * 4 + 2] = (byte)(pSource[index * 4 + 2] * 255);  												pDestBuffer[x * 4 + 3] = (byte)(pSource[index * 4 + 3] * 255);  												index++;  #else                                                  pDestBuffer[x * 4 + 0] = (byte)255;                                                  pDestBuffer[x * 4 + 1] = (byte)0;                                                  pDestBuffer[x * 4 + 2] = (byte)128;                                                  pDestBuffer[x * 4 + 3] = (byte)255;  #endif  											}  										}  									}  								}  							}    							windowsBitmap.UnlockBits(bitmapData);  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.Agg.UI,WindowsFormsBitmapBackBuffer,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmapBackBuffer.cs,UpdateHardwareSurface,The following statement contains a magic number: if (backingImageBufferByte != null)  			{  				if (!externallyLocked && !currentlyLocked)  				{  					currentlyLocked = true;  					bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat);  				}  				int backBufferStrideInBytes = backingImageBufferByte.StrideInBytes();  				int backBufferStrideInInts = backBufferStrideInBytes / 4;  				int backBufferHeight = backingImageBufferByte.Height;  				int backBufferHeightMinusOne = backBufferHeight - 1;  				int bitmapDataStride = bitmapData.Stride;  				int offset;  				byte[] buffer = backingImageBufferByte.GetBuffer(out offset);  				switch (backingImageBufferByte.BitDepth)  				{  					case 24:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = 0; y < backBufferHeight; y++)  									{  										int* pSourceInt = (int*)pSource;  										int* pDestBufferInt = (int*)pDestBuffer;  										for (int x = 0; x < backBufferStrideInInts; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  										for (int x = backBufferStrideInInts * 4; x < backBufferStrideInBytes; x++)  										{  											pDestBuffer[x] = pSource[x];  										}  										pDestBuffer -= bitmapDataStride;  										pSource += backBufferStrideInBytes;  									}  								}  							}  						}  						break;    					case 32:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = rect.Bottom; y < rect.Top; y++)  									{  										int* pSourceInt = (int*)pSource;  										pSourceInt += (backBufferStrideInBytes * y / 4);    										int* pDestBufferInt = (int*)pDestBuffer;  										pDestBufferInt -= (bitmapDataStride * y / 4);    										for (int x = rect.Left; x < rect.Right; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  									}  								}  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  				if (!externallyLocked)  				{  					windowsBitmap.UnlockBits(bitmapData);  					currentlyLocked = false;  				}  			}  			else  			{  				switch (backingImageBufferFloat.BitDepth)  				{  					case 128:  						{  							BitmapData bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat);  							int index = 0;  							unsafe  							{  								unchecked  								{  									int offset;  									float[] buffer = backingImageBufferFloat.GetBuffer(out offset);  									fixed (float* pSource = &buffer[offset])  									{  										for (int y = 0; y < backingImageBufferFloat.Height; y++)  										{  											byte* pDestBuffer = (byte*)bitmapData.Scan0 + (bitmapData.Stride * (backingImageBufferFloat.Height - 1 - y));  											for (int x = 0; x < backingImageBufferFloat.Width; x++)  											{  #if true  												pDestBuffer[x * 4 + 0] = (byte)(pSource[index * 4 + 0] * 255);  												pDestBuffer[x * 4 + 1] = (byte)(pSource[index * 4 + 1] * 255);  												pDestBuffer[x * 4 + 2] = (byte)(pSource[index * 4 + 2] * 255);  												pDestBuffer[x * 4 + 3] = (byte)(pSource[index * 4 + 3] * 255);  												index++;  #else                                                  pDestBuffer[x * 4 + 0] = (byte)255;                                                  pDestBuffer[x * 4 + 1] = (byte)0;                                                  pDestBuffer[x * 4 + 2] = (byte)128;                                                  pDestBuffer[x * 4 + 3] = (byte)255;  #endif  											}  										}  									}  								}  							}    							windowsBitmap.UnlockBits(bitmapData);  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.Agg.UI,WindowsFormsBitmapBackBuffer,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmapBackBuffer.cs,UpdateHardwareSurface,The following statement contains a magic number: if (backingImageBufferByte != null)  			{  				if (!externallyLocked && !currentlyLocked)  				{  					currentlyLocked = true;  					bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat);  				}  				int backBufferStrideInBytes = backingImageBufferByte.StrideInBytes();  				int backBufferStrideInInts = backBufferStrideInBytes / 4;  				int backBufferHeight = backingImageBufferByte.Height;  				int backBufferHeightMinusOne = backBufferHeight - 1;  				int bitmapDataStride = bitmapData.Stride;  				int offset;  				byte[] buffer = backingImageBufferByte.GetBuffer(out offset);  				switch (backingImageBufferByte.BitDepth)  				{  					case 24:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = 0; y < backBufferHeight; y++)  									{  										int* pSourceInt = (int*)pSource;  										int* pDestBufferInt = (int*)pDestBuffer;  										for (int x = 0; x < backBufferStrideInInts; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  										for (int x = backBufferStrideInInts * 4; x < backBufferStrideInBytes; x++)  										{  											pDestBuffer[x] = pSource[x];  										}  										pDestBuffer -= bitmapDataStride;  										pSource += backBufferStrideInBytes;  									}  								}  							}  						}  						break;    					case 32:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = rect.Bottom; y < rect.Top; y++)  									{  										int* pSourceInt = (int*)pSource;  										pSourceInt += (backBufferStrideInBytes * y / 4);    										int* pDestBufferInt = (int*)pDestBuffer;  										pDestBufferInt -= (bitmapDataStride * y / 4);    										for (int x = rect.Left; x < rect.Right; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  									}  								}  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  				if (!externallyLocked)  				{  					windowsBitmap.UnlockBits(bitmapData);  					currentlyLocked = false;  				}  			}  			else  			{  				switch (backingImageBufferFloat.BitDepth)  				{  					case 128:  						{  							BitmapData bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat);  							int index = 0;  							unsafe  							{  								unchecked  								{  									int offset;  									float[] buffer = backingImageBufferFloat.GetBuffer(out offset);  									fixed (float* pSource = &buffer[offset])  									{  										for (int y = 0; y < backingImageBufferFloat.Height; y++)  										{  											byte* pDestBuffer = (byte*)bitmapData.Scan0 + (bitmapData.Stride * (backingImageBufferFloat.Height - 1 - y));  											for (int x = 0; x < backingImageBufferFloat.Width; x++)  											{  #if true  												pDestBuffer[x * 4 + 0] = (byte)(pSource[index * 4 + 0] * 255);  												pDestBuffer[x * 4 + 1] = (byte)(pSource[index * 4 + 1] * 255);  												pDestBuffer[x * 4 + 2] = (byte)(pSource[index * 4 + 2] * 255);  												pDestBuffer[x * 4 + 3] = (byte)(pSource[index * 4 + 3] * 255);  												index++;  #else                                                  pDestBuffer[x * 4 + 0] = (byte)255;                                                  pDestBuffer[x * 4 + 1] = (byte)0;                                                  pDestBuffer[x * 4 + 2] = (byte)128;                                                  pDestBuffer[x * 4 + 3] = (byte)255;  #endif  											}  										}  									}  								}  							}    							windowsBitmap.UnlockBits(bitmapData);  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.Agg.UI,WindowsFormsBitmapBackBuffer,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmapBackBuffer.cs,UpdateHardwareSurface,The following statement contains a magic number: if (backingImageBufferByte != null)  			{  				if (!externallyLocked && !currentlyLocked)  				{  					currentlyLocked = true;  					bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat);  				}  				int backBufferStrideInBytes = backingImageBufferByte.StrideInBytes();  				int backBufferStrideInInts = backBufferStrideInBytes / 4;  				int backBufferHeight = backingImageBufferByte.Height;  				int backBufferHeightMinusOne = backBufferHeight - 1;  				int bitmapDataStride = bitmapData.Stride;  				int offset;  				byte[] buffer = backingImageBufferByte.GetBuffer(out offset);  				switch (backingImageBufferByte.BitDepth)  				{  					case 24:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = 0; y < backBufferHeight; y++)  									{  										int* pSourceInt = (int*)pSource;  										int* pDestBufferInt = (int*)pDestBuffer;  										for (int x = 0; x < backBufferStrideInInts; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  										for (int x = backBufferStrideInInts * 4; x < backBufferStrideInBytes; x++)  										{  											pDestBuffer[x] = pSource[x];  										}  										pDestBuffer -= bitmapDataStride;  										pSource += backBufferStrideInBytes;  									}  								}  							}  						}  						break;    					case 32:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = rect.Bottom; y < rect.Top; y++)  									{  										int* pSourceInt = (int*)pSource;  										pSourceInt += (backBufferStrideInBytes * y / 4);    										int* pDestBufferInt = (int*)pDestBuffer;  										pDestBufferInt -= (bitmapDataStride * y / 4);    										for (int x = rect.Left; x < rect.Right; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  									}  								}  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  				if (!externallyLocked)  				{  					windowsBitmap.UnlockBits(bitmapData);  					currentlyLocked = false;  				}  			}  			else  			{  				switch (backingImageBufferFloat.BitDepth)  				{  					case 128:  						{  							BitmapData bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat);  							int index = 0;  							unsafe  							{  								unchecked  								{  									int offset;  									float[] buffer = backingImageBufferFloat.GetBuffer(out offset);  									fixed (float* pSource = &buffer[offset])  									{  										for (int y = 0; y < backingImageBufferFloat.Height; y++)  										{  											byte* pDestBuffer = (byte*)bitmapData.Scan0 + (bitmapData.Stride * (backingImageBufferFloat.Height - 1 - y));  											for (int x = 0; x < backingImageBufferFloat.Width; x++)  											{  #if true  												pDestBuffer[x * 4 + 0] = (byte)(pSource[index * 4 + 0] * 255);  												pDestBuffer[x * 4 + 1] = (byte)(pSource[index * 4 + 1] * 255);  												pDestBuffer[x * 4 + 2] = (byte)(pSource[index * 4 + 2] * 255);  												pDestBuffer[x * 4 + 3] = (byte)(pSource[index * 4 + 3] * 255);  												index++;  #else                                                  pDestBuffer[x * 4 + 0] = (byte)255;                                                  pDestBuffer[x * 4 + 1] = (byte)0;                                                  pDestBuffer[x * 4 + 2] = (byte)128;                                                  pDestBuffer[x * 4 + 3] = (byte)255;  #endif  											}  										}  									}  								}  							}    							windowsBitmap.UnlockBits(bitmapData);  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.Agg.UI,WindowsFormsBitmapBackBuffer,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmapBackBuffer.cs,UpdateHardwareSurface,The following statement contains a magic number: if (backingImageBufferByte != null)  			{  				if (!externallyLocked && !currentlyLocked)  				{  					currentlyLocked = true;  					bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat);  				}  				int backBufferStrideInBytes = backingImageBufferByte.StrideInBytes();  				int backBufferStrideInInts = backBufferStrideInBytes / 4;  				int backBufferHeight = backingImageBufferByte.Height;  				int backBufferHeightMinusOne = backBufferHeight - 1;  				int bitmapDataStride = bitmapData.Stride;  				int offset;  				byte[] buffer = backingImageBufferByte.GetBuffer(out offset);  				switch (backingImageBufferByte.BitDepth)  				{  					case 24:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = 0; y < backBufferHeight; y++)  									{  										int* pSourceInt = (int*)pSource;  										int* pDestBufferInt = (int*)pDestBuffer;  										for (int x = 0; x < backBufferStrideInInts; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  										for (int x = backBufferStrideInInts * 4; x < backBufferStrideInBytes; x++)  										{  											pDestBuffer[x] = pSource[x];  										}  										pDestBuffer -= bitmapDataStride;  										pSource += backBufferStrideInBytes;  									}  								}  							}  						}  						break;    					case 32:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = rect.Bottom; y < rect.Top; y++)  									{  										int* pSourceInt = (int*)pSource;  										pSourceInt += (backBufferStrideInBytes * y / 4);    										int* pDestBufferInt = (int*)pDestBuffer;  										pDestBufferInt -= (bitmapDataStride * y / 4);    										for (int x = rect.Left; x < rect.Right; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  									}  								}  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  				if (!externallyLocked)  				{  					windowsBitmap.UnlockBits(bitmapData);  					currentlyLocked = false;  				}  			}  			else  			{  				switch (backingImageBufferFloat.BitDepth)  				{  					case 128:  						{  							BitmapData bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat);  							int index = 0;  							unsafe  							{  								unchecked  								{  									int offset;  									float[] buffer = backingImageBufferFloat.GetBuffer(out offset);  									fixed (float* pSource = &buffer[offset])  									{  										for (int y = 0; y < backingImageBufferFloat.Height; y++)  										{  											byte* pDestBuffer = (byte*)bitmapData.Scan0 + (bitmapData.Stride * (backingImageBufferFloat.Height - 1 - y));  											for (int x = 0; x < backingImageBufferFloat.Width; x++)  											{  #if true  												pDestBuffer[x * 4 + 0] = (byte)(pSource[index * 4 + 0] * 255);  												pDestBuffer[x * 4 + 1] = (byte)(pSource[index * 4 + 1] * 255);  												pDestBuffer[x * 4 + 2] = (byte)(pSource[index * 4 + 2] * 255);  												pDestBuffer[x * 4 + 3] = (byte)(pSource[index * 4 + 3] * 255);  												index++;  #else                                                  pDestBuffer[x * 4 + 0] = (byte)255;                                                  pDestBuffer[x * 4 + 1] = (byte)0;                                                  pDestBuffer[x * 4 + 2] = (byte)128;                                                  pDestBuffer[x * 4 + 3] = (byte)255;  #endif  											}  										}  									}  								}  							}    							windowsBitmap.UnlockBits(bitmapData);  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.Agg.UI,WindowsFormsBitmapBackBuffer,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmapBackBuffer.cs,UpdateHardwareSurface,The following statement contains a magic number: if (backingImageBufferByte != null)  			{  				if (!externallyLocked && !currentlyLocked)  				{  					currentlyLocked = true;  					bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat);  				}  				int backBufferStrideInBytes = backingImageBufferByte.StrideInBytes();  				int backBufferStrideInInts = backBufferStrideInBytes / 4;  				int backBufferHeight = backingImageBufferByte.Height;  				int backBufferHeightMinusOne = backBufferHeight - 1;  				int bitmapDataStride = bitmapData.Stride;  				int offset;  				byte[] buffer = backingImageBufferByte.GetBuffer(out offset);  				switch (backingImageBufferByte.BitDepth)  				{  					case 24:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = 0; y < backBufferHeight; y++)  									{  										int* pSourceInt = (int*)pSource;  										int* pDestBufferInt = (int*)pDestBuffer;  										for (int x = 0; x < backBufferStrideInInts; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  										for (int x = backBufferStrideInInts * 4; x < backBufferStrideInBytes; x++)  										{  											pDestBuffer[x] = pSource[x];  										}  										pDestBuffer -= bitmapDataStride;  										pSource += backBufferStrideInBytes;  									}  								}  							}  						}  						break;    					case 32:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = rect.Bottom; y < rect.Top; y++)  									{  										int* pSourceInt = (int*)pSource;  										pSourceInt += (backBufferStrideInBytes * y / 4);    										int* pDestBufferInt = (int*)pDestBuffer;  										pDestBufferInt -= (bitmapDataStride * y / 4);    										for (int x = rect.Left; x < rect.Right; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  									}  								}  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  				if (!externallyLocked)  				{  					windowsBitmap.UnlockBits(bitmapData);  					currentlyLocked = false;  				}  			}  			else  			{  				switch (backingImageBufferFloat.BitDepth)  				{  					case 128:  						{  							BitmapData bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat);  							int index = 0;  							unsafe  							{  								unchecked  								{  									int offset;  									float[] buffer = backingImageBufferFloat.GetBuffer(out offset);  									fixed (float* pSource = &buffer[offset])  									{  										for (int y = 0; y < backingImageBufferFloat.Height; y++)  										{  											byte* pDestBuffer = (byte*)bitmapData.Scan0 + (bitmapData.Stride * (backingImageBufferFloat.Height - 1 - y));  											for (int x = 0; x < backingImageBufferFloat.Width; x++)  											{  #if true  												pDestBuffer[x * 4 + 0] = (byte)(pSource[index * 4 + 0] * 255);  												pDestBuffer[x * 4 + 1] = (byte)(pSource[index * 4 + 1] * 255);  												pDestBuffer[x * 4 + 2] = (byte)(pSource[index * 4 + 2] * 255);  												pDestBuffer[x * 4 + 3] = (byte)(pSource[index * 4 + 3] * 255);  												index++;  #else                                                  pDestBuffer[x * 4 + 0] = (byte)255;                                                  pDestBuffer[x * 4 + 1] = (byte)0;                                                  pDestBuffer[x * 4 + 2] = (byte)128;                                                  pDestBuffer[x * 4 + 3] = (byte)255;  #endif  											}  										}  									}  								}  							}    							windowsBitmap.UnlockBits(bitmapData);  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.Agg.UI,WindowsFormsBitmapBackBuffer,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmapBackBuffer.cs,UpdateHardwareSurface,The following statement contains a magic number: if (backingImageBufferByte != null)  			{  				if (!externallyLocked && !currentlyLocked)  				{  					currentlyLocked = true;  					bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat);  				}  				int backBufferStrideInBytes = backingImageBufferByte.StrideInBytes();  				int backBufferStrideInInts = backBufferStrideInBytes / 4;  				int backBufferHeight = backingImageBufferByte.Height;  				int backBufferHeightMinusOne = backBufferHeight - 1;  				int bitmapDataStride = bitmapData.Stride;  				int offset;  				byte[] buffer = backingImageBufferByte.GetBuffer(out offset);  				switch (backingImageBufferByte.BitDepth)  				{  					case 24:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = 0; y < backBufferHeight; y++)  									{  										int* pSourceInt = (int*)pSource;  										int* pDestBufferInt = (int*)pDestBuffer;  										for (int x = 0; x < backBufferStrideInInts; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  										for (int x = backBufferStrideInInts * 4; x < backBufferStrideInBytes; x++)  										{  											pDestBuffer[x] = pSource[x];  										}  										pDestBuffer -= bitmapDataStride;  										pSource += backBufferStrideInBytes;  									}  								}  							}  						}  						break;    					case 32:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = rect.Bottom; y < rect.Top; y++)  									{  										int* pSourceInt = (int*)pSource;  										pSourceInt += (backBufferStrideInBytes * y / 4);    										int* pDestBufferInt = (int*)pDestBuffer;  										pDestBufferInt -= (bitmapDataStride * y / 4);    										for (int x = rect.Left; x < rect.Right; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  									}  								}  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  				if (!externallyLocked)  				{  					windowsBitmap.UnlockBits(bitmapData);  					currentlyLocked = false;  				}  			}  			else  			{  				switch (backingImageBufferFloat.BitDepth)  				{  					case 128:  						{  							BitmapData bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat);  							int index = 0;  							unsafe  							{  								unchecked  								{  									int offset;  									float[] buffer = backingImageBufferFloat.GetBuffer(out offset);  									fixed (float* pSource = &buffer[offset])  									{  										for (int y = 0; y < backingImageBufferFloat.Height; y++)  										{  											byte* pDestBuffer = (byte*)bitmapData.Scan0 + (bitmapData.Stride * (backingImageBufferFloat.Height - 1 - y));  											for (int x = 0; x < backingImageBufferFloat.Width; x++)  											{  #if true  												pDestBuffer[x * 4 + 0] = (byte)(pSource[index * 4 + 0] * 255);  												pDestBuffer[x * 4 + 1] = (byte)(pSource[index * 4 + 1] * 255);  												pDestBuffer[x * 4 + 2] = (byte)(pSource[index * 4 + 2] * 255);  												pDestBuffer[x * 4 + 3] = (byte)(pSource[index * 4 + 3] * 255);  												index++;  #else                                                  pDestBuffer[x * 4 + 0] = (byte)255;                                                  pDestBuffer[x * 4 + 1] = (byte)0;                                                  pDestBuffer[x * 4 + 2] = (byte)128;                                                  pDestBuffer[x * 4 + 3] = (byte)255;  #endif  											}  										}  									}  								}  							}    							windowsBitmap.UnlockBits(bitmapData);  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.Agg.UI,WindowsFormsBitmapBackBuffer,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmapBackBuffer.cs,UpdateHardwareSurface,The following statement contains a magic number: if (backingImageBufferByte != null)  			{  				if (!externallyLocked && !currentlyLocked)  				{  					currentlyLocked = true;  					bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat);  				}  				int backBufferStrideInBytes = backingImageBufferByte.StrideInBytes();  				int backBufferStrideInInts = backBufferStrideInBytes / 4;  				int backBufferHeight = backingImageBufferByte.Height;  				int backBufferHeightMinusOne = backBufferHeight - 1;  				int bitmapDataStride = bitmapData.Stride;  				int offset;  				byte[] buffer = backingImageBufferByte.GetBuffer(out offset);  				switch (backingImageBufferByte.BitDepth)  				{  					case 24:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = 0; y < backBufferHeight; y++)  									{  										int* pSourceInt = (int*)pSource;  										int* pDestBufferInt = (int*)pDestBuffer;  										for (int x = 0; x < backBufferStrideInInts; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  										for (int x = backBufferStrideInInts * 4; x < backBufferStrideInBytes; x++)  										{  											pDestBuffer[x] = pSource[x];  										}  										pDestBuffer -= bitmapDataStride;  										pSource += backBufferStrideInBytes;  									}  								}  							}  						}  						break;    					case 32:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = rect.Bottom; y < rect.Top; y++)  									{  										int* pSourceInt = (int*)pSource;  										pSourceInt += (backBufferStrideInBytes * y / 4);    										int* pDestBufferInt = (int*)pDestBuffer;  										pDestBufferInt -= (bitmapDataStride * y / 4);    										for (int x = rect.Left; x < rect.Right; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  									}  								}  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  				if (!externallyLocked)  				{  					windowsBitmap.UnlockBits(bitmapData);  					currentlyLocked = false;  				}  			}  			else  			{  				switch (backingImageBufferFloat.BitDepth)  				{  					case 128:  						{  							BitmapData bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat);  							int index = 0;  							unsafe  							{  								unchecked  								{  									int offset;  									float[] buffer = backingImageBufferFloat.GetBuffer(out offset);  									fixed (float* pSource = &buffer[offset])  									{  										for (int y = 0; y < backingImageBufferFloat.Height; y++)  										{  											byte* pDestBuffer = (byte*)bitmapData.Scan0 + (bitmapData.Stride * (backingImageBufferFloat.Height - 1 - y));  											for (int x = 0; x < backingImageBufferFloat.Width; x++)  											{  #if true  												pDestBuffer[x * 4 + 0] = (byte)(pSource[index * 4 + 0] * 255);  												pDestBuffer[x * 4 + 1] = (byte)(pSource[index * 4 + 1] * 255);  												pDestBuffer[x * 4 + 2] = (byte)(pSource[index * 4 + 2] * 255);  												pDestBuffer[x * 4 + 3] = (byte)(pSource[index * 4 + 3] * 255);  												index++;  #else                                                  pDestBuffer[x * 4 + 0] = (byte)255;                                                  pDestBuffer[x * 4 + 1] = (byte)0;                                                  pDestBuffer[x * 4 + 2] = (byte)128;                                                  pDestBuffer[x * 4 + 3] = (byte)255;  #endif  											}  										}  									}  								}  							}    							windowsBitmap.UnlockBits(bitmapData);  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.Agg.UI,WindowsFormsBitmapBackBuffer,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmapBackBuffer.cs,UpdateHardwareSurface,The following statement contains a magic number: if (backingImageBufferByte != null)  			{  				if (!externallyLocked && !currentlyLocked)  				{  					currentlyLocked = true;  					bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat);  				}  				int backBufferStrideInBytes = backingImageBufferByte.StrideInBytes();  				int backBufferStrideInInts = backBufferStrideInBytes / 4;  				int backBufferHeight = backingImageBufferByte.Height;  				int backBufferHeightMinusOne = backBufferHeight - 1;  				int bitmapDataStride = bitmapData.Stride;  				int offset;  				byte[] buffer = backingImageBufferByte.GetBuffer(out offset);  				switch (backingImageBufferByte.BitDepth)  				{  					case 24:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = 0; y < backBufferHeight; y++)  									{  										int* pSourceInt = (int*)pSource;  										int* pDestBufferInt = (int*)pDestBuffer;  										for (int x = 0; x < backBufferStrideInInts; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  										for (int x = backBufferStrideInInts * 4; x < backBufferStrideInBytes; x++)  										{  											pDestBuffer[x] = pSource[x];  										}  										pDestBuffer -= bitmapDataStride;  										pSource += backBufferStrideInBytes;  									}  								}  							}  						}  						break;    					case 32:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = rect.Bottom; y < rect.Top; y++)  									{  										int* pSourceInt = (int*)pSource;  										pSourceInt += (backBufferStrideInBytes * y / 4);    										int* pDestBufferInt = (int*)pDestBuffer;  										pDestBufferInt -= (bitmapDataStride * y / 4);    										for (int x = rect.Left; x < rect.Right; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  									}  								}  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  				if (!externallyLocked)  				{  					windowsBitmap.UnlockBits(bitmapData);  					currentlyLocked = false;  				}  			}  			else  			{  				switch (backingImageBufferFloat.BitDepth)  				{  					case 128:  						{  							BitmapData bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat);  							int index = 0;  							unsafe  							{  								unchecked  								{  									int offset;  									float[] buffer = backingImageBufferFloat.GetBuffer(out offset);  									fixed (float* pSource = &buffer[offset])  									{  										for (int y = 0; y < backingImageBufferFloat.Height; y++)  										{  											byte* pDestBuffer = (byte*)bitmapData.Scan0 + (bitmapData.Stride * (backingImageBufferFloat.Height - 1 - y));  											for (int x = 0; x < backingImageBufferFloat.Width; x++)  											{  #if true  												pDestBuffer[x * 4 + 0] = (byte)(pSource[index * 4 + 0] * 255);  												pDestBuffer[x * 4 + 1] = (byte)(pSource[index * 4 + 1] * 255);  												pDestBuffer[x * 4 + 2] = (byte)(pSource[index * 4 + 2] * 255);  												pDestBuffer[x * 4 + 3] = (byte)(pSource[index * 4 + 3] * 255);  												index++;  #else                                                  pDestBuffer[x * 4 + 0] = (byte)255;                                                  pDestBuffer[x * 4 + 1] = (byte)0;                                                  pDestBuffer[x * 4 + 2] = (byte)128;                                                  pDestBuffer[x * 4 + 3] = (byte)255;  #endif  											}  										}  									}  								}  							}    							windowsBitmap.UnlockBits(bitmapData);  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.Agg.UI,WindowsFormsBitmapBackBuffer,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmapBackBuffer.cs,UpdateHardwareSurface,The following statement contains a magic number: if (backingImageBufferByte != null)  			{  				if (!externallyLocked && !currentlyLocked)  				{  					currentlyLocked = true;  					bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat);  				}  				int backBufferStrideInBytes = backingImageBufferByte.StrideInBytes();  				int backBufferStrideInInts = backBufferStrideInBytes / 4;  				int backBufferHeight = backingImageBufferByte.Height;  				int backBufferHeightMinusOne = backBufferHeight - 1;  				int bitmapDataStride = bitmapData.Stride;  				int offset;  				byte[] buffer = backingImageBufferByte.GetBuffer(out offset);  				switch (backingImageBufferByte.BitDepth)  				{  					case 24:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = 0; y < backBufferHeight; y++)  									{  										int* pSourceInt = (int*)pSource;  										int* pDestBufferInt = (int*)pDestBuffer;  										for (int x = 0; x < backBufferStrideInInts; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  										for (int x = backBufferStrideInInts * 4; x < backBufferStrideInBytes; x++)  										{  											pDestBuffer[x] = pSource[x];  										}  										pDestBuffer -= bitmapDataStride;  										pSource += backBufferStrideInBytes;  									}  								}  							}  						}  						break;    					case 32:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = rect.Bottom; y < rect.Top; y++)  									{  										int* pSourceInt = (int*)pSource;  										pSourceInt += (backBufferStrideInBytes * y / 4);    										int* pDestBufferInt = (int*)pDestBuffer;  										pDestBufferInt -= (bitmapDataStride * y / 4);    										for (int x = rect.Left; x < rect.Right; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  									}  								}  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  				if (!externallyLocked)  				{  					windowsBitmap.UnlockBits(bitmapData);  					currentlyLocked = false;  				}  			}  			else  			{  				switch (backingImageBufferFloat.BitDepth)  				{  					case 128:  						{  							BitmapData bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat);  							int index = 0;  							unsafe  							{  								unchecked  								{  									int offset;  									float[] buffer = backingImageBufferFloat.GetBuffer(out offset);  									fixed (float* pSource = &buffer[offset])  									{  										for (int y = 0; y < backingImageBufferFloat.Height; y++)  										{  											byte* pDestBuffer = (byte*)bitmapData.Scan0 + (bitmapData.Stride * (backingImageBufferFloat.Height - 1 - y));  											for (int x = 0; x < backingImageBufferFloat.Width; x++)  											{  #if true  												pDestBuffer[x * 4 + 0] = (byte)(pSource[index * 4 + 0] * 255);  												pDestBuffer[x * 4 + 1] = (byte)(pSource[index * 4 + 1] * 255);  												pDestBuffer[x * 4 + 2] = (byte)(pSource[index * 4 + 2] * 255);  												pDestBuffer[x * 4 + 3] = (byte)(pSource[index * 4 + 3] * 255);  												index++;  #else                                                  pDestBuffer[x * 4 + 0] = (byte)255;                                                  pDestBuffer[x * 4 + 1] = (byte)0;                                                  pDestBuffer[x * 4 + 2] = (byte)128;                                                  pDestBuffer[x * 4 + 3] = (byte)255;  #endif  											}  										}  									}  								}  							}    							windowsBitmap.UnlockBits(bitmapData);  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.Agg.UI,WindowsFormsBitmapBackBuffer,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmapBackBuffer.cs,UpdateHardwareSurface,The following statement contains a magic number: if (backingImageBufferByte != null)  			{  				if (!externallyLocked && !currentlyLocked)  				{  					currentlyLocked = true;  					bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat);  				}  				int backBufferStrideInBytes = backingImageBufferByte.StrideInBytes();  				int backBufferStrideInInts = backBufferStrideInBytes / 4;  				int backBufferHeight = backingImageBufferByte.Height;  				int backBufferHeightMinusOne = backBufferHeight - 1;  				int bitmapDataStride = bitmapData.Stride;  				int offset;  				byte[] buffer = backingImageBufferByte.GetBuffer(out offset);  				switch (backingImageBufferByte.BitDepth)  				{  					case 24:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = 0; y < backBufferHeight; y++)  									{  										int* pSourceInt = (int*)pSource;  										int* pDestBufferInt = (int*)pDestBuffer;  										for (int x = 0; x < backBufferStrideInInts; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  										for (int x = backBufferStrideInInts * 4; x < backBufferStrideInBytes; x++)  										{  											pDestBuffer[x] = pSource[x];  										}  										pDestBuffer -= bitmapDataStride;  										pSource += backBufferStrideInBytes;  									}  								}  							}  						}  						break;    					case 32:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = rect.Bottom; y < rect.Top; y++)  									{  										int* pSourceInt = (int*)pSource;  										pSourceInt += (backBufferStrideInBytes * y / 4);    										int* pDestBufferInt = (int*)pDestBuffer;  										pDestBufferInt -= (bitmapDataStride * y / 4);    										for (int x = rect.Left; x < rect.Right; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  									}  								}  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  				if (!externallyLocked)  				{  					windowsBitmap.UnlockBits(bitmapData);  					currentlyLocked = false;  				}  			}  			else  			{  				switch (backingImageBufferFloat.BitDepth)  				{  					case 128:  						{  							BitmapData bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat);  							int index = 0;  							unsafe  							{  								unchecked  								{  									int offset;  									float[] buffer = backingImageBufferFloat.GetBuffer(out offset);  									fixed (float* pSource = &buffer[offset])  									{  										for (int y = 0; y < backingImageBufferFloat.Height; y++)  										{  											byte* pDestBuffer = (byte*)bitmapData.Scan0 + (bitmapData.Stride * (backingImageBufferFloat.Height - 1 - y));  											for (int x = 0; x < backingImageBufferFloat.Width; x++)  											{  #if true  												pDestBuffer[x * 4 + 0] = (byte)(pSource[index * 4 + 0] * 255);  												pDestBuffer[x * 4 + 1] = (byte)(pSource[index * 4 + 1] * 255);  												pDestBuffer[x * 4 + 2] = (byte)(pSource[index * 4 + 2] * 255);  												pDestBuffer[x * 4 + 3] = (byte)(pSource[index * 4 + 3] * 255);  												index++;  #else                                                  pDestBuffer[x * 4 + 0] = (byte)255;                                                  pDestBuffer[x * 4 + 1] = (byte)0;                                                  pDestBuffer[x * 4 + 2] = (byte)128;                                                  pDestBuffer[x * 4 + 3] = (byte)255;  #endif  											}  										}  									}  								}  							}    							windowsBitmap.UnlockBits(bitmapData);  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.Agg.UI,WindowsFormsBitmapBackBuffer,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmapBackBuffer.cs,UpdateHardwareSurface,The following statement contains a magic number: if (backingImageBufferByte != null)  			{  				if (!externallyLocked && !currentlyLocked)  				{  					currentlyLocked = true;  					bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat);  				}  				int backBufferStrideInBytes = backingImageBufferByte.StrideInBytes();  				int backBufferStrideInInts = backBufferStrideInBytes / 4;  				int backBufferHeight = backingImageBufferByte.Height;  				int backBufferHeightMinusOne = backBufferHeight - 1;  				int bitmapDataStride = bitmapData.Stride;  				int offset;  				byte[] buffer = backingImageBufferByte.GetBuffer(out offset);  				switch (backingImageBufferByte.BitDepth)  				{  					case 24:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = 0; y < backBufferHeight; y++)  									{  										int* pSourceInt = (int*)pSource;  										int* pDestBufferInt = (int*)pDestBuffer;  										for (int x = 0; x < backBufferStrideInInts; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  										for (int x = backBufferStrideInInts * 4; x < backBufferStrideInBytes; x++)  										{  											pDestBuffer[x] = pSource[x];  										}  										pDestBuffer -= bitmapDataStride;  										pSource += backBufferStrideInBytes;  									}  								}  							}  						}  						break;    					case 32:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = rect.Bottom; y < rect.Top; y++)  									{  										int* pSourceInt = (int*)pSource;  										pSourceInt += (backBufferStrideInBytes * y / 4);    										int* pDestBufferInt = (int*)pDestBuffer;  										pDestBufferInt -= (bitmapDataStride * y / 4);    										for (int x = rect.Left; x < rect.Right; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  									}  								}  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  				if (!externallyLocked)  				{  					windowsBitmap.UnlockBits(bitmapData);  					currentlyLocked = false;  				}  			}  			else  			{  				switch (backingImageBufferFloat.BitDepth)  				{  					case 128:  						{  							BitmapData bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat);  							int index = 0;  							unsafe  							{  								unchecked  								{  									int offset;  									float[] buffer = backingImageBufferFloat.GetBuffer(out offset);  									fixed (float* pSource = &buffer[offset])  									{  										for (int y = 0; y < backingImageBufferFloat.Height; y++)  										{  											byte* pDestBuffer = (byte*)bitmapData.Scan0 + (bitmapData.Stride * (backingImageBufferFloat.Height - 1 - y));  											for (int x = 0; x < backingImageBufferFloat.Width; x++)  											{  #if true  												pDestBuffer[x * 4 + 0] = (byte)(pSource[index * 4 + 0] * 255);  												pDestBuffer[x * 4 + 1] = (byte)(pSource[index * 4 + 1] * 255);  												pDestBuffer[x * 4 + 2] = (byte)(pSource[index * 4 + 2] * 255);  												pDestBuffer[x * 4 + 3] = (byte)(pSource[index * 4 + 3] * 255);  												index++;  #else                                                  pDestBuffer[x * 4 + 0] = (byte)255;                                                  pDestBuffer[x * 4 + 1] = (byte)0;                                                  pDestBuffer[x * 4 + 2] = (byte)128;                                                  pDestBuffer[x * 4 + 3] = (byte)255;  #endif  											}  										}  									}  								}  							}    							windowsBitmap.UnlockBits(bitmapData);  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.Agg.UI,WindowsFormsBitmapBackBuffer,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmapBackBuffer.cs,UpdateHardwareSurface,The following statement contains a magic number: if (backingImageBufferByte != null)  			{  				if (!externallyLocked && !currentlyLocked)  				{  					currentlyLocked = true;  					bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat);  				}  				int backBufferStrideInBytes = backingImageBufferByte.StrideInBytes();  				int backBufferStrideInInts = backBufferStrideInBytes / 4;  				int backBufferHeight = backingImageBufferByte.Height;  				int backBufferHeightMinusOne = backBufferHeight - 1;  				int bitmapDataStride = bitmapData.Stride;  				int offset;  				byte[] buffer = backingImageBufferByte.GetBuffer(out offset);  				switch (backingImageBufferByte.BitDepth)  				{  					case 24:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = 0; y < backBufferHeight; y++)  									{  										int* pSourceInt = (int*)pSource;  										int* pDestBufferInt = (int*)pDestBuffer;  										for (int x = 0; x < backBufferStrideInInts; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  										for (int x = backBufferStrideInInts * 4; x < backBufferStrideInBytes; x++)  										{  											pDestBuffer[x] = pSource[x];  										}  										pDestBuffer -= bitmapDataStride;  										pSource += backBufferStrideInBytes;  									}  								}  							}  						}  						break;    					case 32:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = rect.Bottom; y < rect.Top; y++)  									{  										int* pSourceInt = (int*)pSource;  										pSourceInt += (backBufferStrideInBytes * y / 4);    										int* pDestBufferInt = (int*)pDestBuffer;  										pDestBufferInt -= (bitmapDataStride * y / 4);    										for (int x = rect.Left; x < rect.Right; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  									}  								}  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  				if (!externallyLocked)  				{  					windowsBitmap.UnlockBits(bitmapData);  					currentlyLocked = false;  				}  			}  			else  			{  				switch (backingImageBufferFloat.BitDepth)  				{  					case 128:  						{  							BitmapData bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat);  							int index = 0;  							unsafe  							{  								unchecked  								{  									int offset;  									float[] buffer = backingImageBufferFloat.GetBuffer(out offset);  									fixed (float* pSource = &buffer[offset])  									{  										for (int y = 0; y < backingImageBufferFloat.Height; y++)  										{  											byte* pDestBuffer = (byte*)bitmapData.Scan0 + (bitmapData.Stride * (backingImageBufferFloat.Height - 1 - y));  											for (int x = 0; x < backingImageBufferFloat.Width; x++)  											{  #if true  												pDestBuffer[x * 4 + 0] = (byte)(pSource[index * 4 + 0] * 255);  												pDestBuffer[x * 4 + 1] = (byte)(pSource[index * 4 + 1] * 255);  												pDestBuffer[x * 4 + 2] = (byte)(pSource[index * 4 + 2] * 255);  												pDestBuffer[x * 4 + 3] = (byte)(pSource[index * 4 + 3] * 255);  												index++;  #else                                                  pDestBuffer[x * 4 + 0] = (byte)255;                                                  pDestBuffer[x * 4 + 1] = (byte)0;                                                  pDestBuffer[x * 4 + 2] = (byte)128;                                                  pDestBuffer[x * 4 + 3] = (byte)255;  #endif  											}  										}  									}  								}  							}    							windowsBitmap.UnlockBits(bitmapData);  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.Agg.UI,WindowsFormsBitmapBackBuffer,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmapBackBuffer.cs,Initialize,The following statement contains a magic number: if (width > 0 && height > 0)  			{  				switch (bitDepth)  				{  					case 24:  						windowsBitmap = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  						backingImageBufferByte = new ImageBuffer(width' height' 24' new BlenderBGR());  						break;    					case 32:  						windowsBitmap = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format32bppRgb);  						//widowsBitmap = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format32bppPArgb);  						//widowsBitmap = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format32bppArgb);  						//32bppPArgb  						backingImageBufferByte = new ImageBuffer(width' height);  						break;    					case 128:  						windowsBitmap = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format32bppRgb);  						backingImageBufferByte = null;  						backingImageBufferFloat = new ImageBufferFloat(width' height' 128' new BlenderBGRAFloat());  						break;    					default:  						throw new NotImplementedException("Don't support this bit depth yet.");  				}  			}
Magic Number,MatterHackers.Agg.UI,WindowsFormsBitmapBackBuffer,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmapBackBuffer.cs,Initialize,The following statement contains a magic number: if (width > 0 && height > 0)  			{  				switch (bitDepth)  				{  					case 24:  						windowsBitmap = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  						backingImageBufferByte = new ImageBuffer(width' height' 24' new BlenderBGR());  						break;    					case 32:  						windowsBitmap = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format32bppRgb);  						//widowsBitmap = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format32bppPArgb);  						//widowsBitmap = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format32bppArgb);  						//32bppPArgb  						backingImageBufferByte = new ImageBuffer(width' height);  						break;    					case 128:  						windowsBitmap = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format32bppRgb);  						backingImageBufferByte = null;  						backingImageBufferFloat = new ImageBufferFloat(width' height' 128' new BlenderBGRAFloat());  						break;    					default:  						throw new NotImplementedException("Don't support this bit depth yet.");  				}  			}
Magic Number,MatterHackers.Agg.UI,WindowsFormsBitmapBackBuffer,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmapBackBuffer.cs,Initialize,The following statement contains a magic number: if (width > 0 && height > 0)  			{  				switch (bitDepth)  				{  					case 24:  						windowsBitmap = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  						backingImageBufferByte = new ImageBuffer(width' height' 24' new BlenderBGR());  						break;    					case 32:  						windowsBitmap = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format32bppRgb);  						//widowsBitmap = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format32bppPArgb);  						//widowsBitmap = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format32bppArgb);  						//32bppPArgb  						backingImageBufferByte = new ImageBuffer(width' height);  						break;    					case 128:  						windowsBitmap = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format32bppRgb);  						backingImageBufferByte = null;  						backingImageBufferFloat = new ImageBufferFloat(width' height' 128' new BlenderBGRAFloat());  						break;    					default:  						throw new NotImplementedException("Don't support this bit depth yet.");  				}  			}
Magic Number,MatterHackers.Agg.UI,WindowsFormsBitmapBackBuffer,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmapBackBuffer.cs,Initialize,The following statement contains a magic number: if (width > 0 && height > 0)  			{  				switch (bitDepth)  				{  					case 24:  						windowsBitmap = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  						backingImageBufferByte = new ImageBuffer(width' height' 24' new BlenderBGR());  						break;    					case 32:  						windowsBitmap = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format32bppRgb);  						//widowsBitmap = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format32bppPArgb);  						//widowsBitmap = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format32bppArgb);  						//32bppPArgb  						backingImageBufferByte = new ImageBuffer(width' height);  						break;    					case 128:  						windowsBitmap = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format32bppRgb);  						backingImageBufferByte = null;  						backingImageBufferFloat = new ImageBufferFloat(width' height' 128' new BlenderBGRAFloat());  						break;    					default:  						throw new NotImplementedException("Don't support this bit depth yet.");  				}  			}
Magic Number,MatterHackers.Agg.UI,WindowsFormsBitmapBackBuffer,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmapBackBuffer.cs,Initialize,The following statement contains a magic number: if (width > 0 && height > 0)  			{  				switch (bitDepth)  				{  					case 24:  						windowsBitmap = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  						backingImageBufferByte = new ImageBuffer(width' height' 24' new BlenderBGR());  						break;    					case 32:  						windowsBitmap = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format32bppRgb);  						//widowsBitmap = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format32bppPArgb);  						//widowsBitmap = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format32bppArgb);  						//32bppPArgb  						backingImageBufferByte = new ImageBuffer(width' height);  						break;    					case 128:  						windowsBitmap = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format32bppRgb);  						backingImageBufferByte = null;  						backingImageBufferFloat = new ImageBufferFloat(width' height' 128' new BlenderBGRAFloat());  						break;    					default:  						throw new NotImplementedException("Don't support this bit depth yet.");  				}  			}
Magic Number,MatterHackers.Agg.UI,MyGLControl,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsOpenGL.cs,MyGLControl,The following statement contains a magic number: if (!checkedCapabilities)              {  				try  				{  					IntPtr address = (this.Context as OpenTK.Graphics.IGraphicsContextInternal).GetAddress("glGenBuffers");    					string versionString = GL.GetString(StringName.Version);  					int firstSpace = versionString.IndexOf(' ');  					if (firstSpace != -1)  					{  						versionString = versionString.Substring(0' firstSpace);  					}    					Version openGLVersion = new Version(versionString);  					string glExtensionsString = GL.GetString(StringName.Extensions);  					bool extensionSupport = glExtensionsString.Contains("GL_ARB_vertex_attrib_binding");    					if (openGLVersion.CompareTo(new Version(2' 1)) < 0 && !extensionSupport)  					{  						MatterHackers.RenderOpenGl.OpenGl.GL.DisableGlBuffers();  					}  				}  				catch  				{  					MatterHackers.RenderOpenGl.OpenGl.GL.DisableGlBuffers();  				}    				checkedCapabilities = true;              }
Magic Number,MatterHackers.Agg.UI,WindowsFormsOpenGL,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsOpenGL.cs,WindowsFormsOpenGL,The following statement contains a magic number: switch (childSystemWindow.BitDepth)  			{  				case 32:  					glControl = new MyGLControl(32' childSystemWindow.StencilBufferDepth);  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.UI,WindowsFormsOpenGL,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsOpenGL.cs,WindowsFormsOpenGL,The following statement contains a magic number: switch (childSystemWindow.BitDepth)  			{  				case 32:  					glControl = new MyGLControl(32' childSystemWindow.StencilBufferDepth);  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.UI,WindowsFormsOpenGLFactory,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsOpenGLFactory.cs,CreateSurface,The following statement contains a magic number: switch (childSystemWindow.BitDepth)  			{  				case 24:  				case 32:  					newSurface = new WidgetForWindowsFormsOpenGL(childSystemWindow);  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.UI,WindowsFormsOpenGLFactory,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsOpenGLFactory.cs,CreateSurface,The following statement contains a magic number: switch (childSystemWindow.BitDepth)  			{  				case 24:  				case 32:  					newSurface = new WidgetForWindowsFormsOpenGL(childSystemWindow);  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.Image,ImageIOWindowsPlugin,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\ImageIOWindowsPlugin.cs,LoadImageData,The following statement contains a magic number: if (gifImg != null)  			{  				FrameDimension dimension = new FrameDimension(gifImg.FrameDimensionsList[0]);  				// Number of frames  				int frameCount = gifImg.GetFrameCount(dimension);    				for (int i = 0; i < frameCount; i++)  				{  					// Return an Image at a certain index  					gifImg.SelectActiveFrame(dimension' i);    					using (var bitmap = new Bitmap(gifImg))  					{  						var frame = new ImageBuffer();  						ConvertBitmapToImage(frame' bitmap);  						destImageSequence.AddImage(frame);  					}  				}    				try  				{  					PropertyItem item = gifImg.GetPropertyItem(0x5100); // FrameDelay in libgdiplus  					// Time is in 1/100th of a second  					destImageSequence.SecondsPerFrame = (item.Value[0] + item.Value[1] * 256) / 100.0;  				}  				catch (Exception e)  				{  					Debug.Print(e.Message);  					GuiWidget.BreakInDebugger();  					destImageSequence.SecondsPerFrame = 2;  				}    				return true;  			}
Magic Number,MatterHackers.Agg.Image,ImageIOWindowsPlugin,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\ImageIOWindowsPlugin.cs,LoadImageData,The following statement contains a magic number: if (gifImg != null)  			{  				FrameDimension dimension = new FrameDimension(gifImg.FrameDimensionsList[0]);  				// Number of frames  				int frameCount = gifImg.GetFrameCount(dimension);    				for (int i = 0; i < frameCount; i++)  				{  					// Return an Image at a certain index  					gifImg.SelectActiveFrame(dimension' i);    					using (var bitmap = new Bitmap(gifImg))  					{  						var frame = new ImageBuffer();  						ConvertBitmapToImage(frame' bitmap);  						destImageSequence.AddImage(frame);  					}  				}    				try  				{  					PropertyItem item = gifImg.GetPropertyItem(0x5100); // FrameDelay in libgdiplus  					// Time is in 1/100th of a second  					destImageSequence.SecondsPerFrame = (item.Value[0] + item.Value[1] * 256) / 100.0;  				}  				catch (Exception e)  				{  					Debug.Print(e.Message);  					GuiWidget.BreakInDebugger();  					destImageSequence.SecondsPerFrame = 2;  				}    				return true;  			}
Magic Number,MatterHackers.Agg.Image,ImageIOWindowsPlugin,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\ImageIOWindowsPlugin.cs,LoadImageData,The following statement contains a magic number: if (gifImg != null)  			{  				FrameDimension dimension = new FrameDimension(gifImg.FrameDimensionsList[0]);  				// Number of frames  				int frameCount = gifImg.GetFrameCount(dimension);    				for (int i = 0; i < frameCount; i++)  				{  					// Return an Image at a certain index  					gifImg.SelectActiveFrame(dimension' i);    					using (var bitmap = new Bitmap(gifImg))  					{  						var frame = new ImageBuffer();  						ConvertBitmapToImage(frame' bitmap);  						destImageSequence.AddImage(frame);  					}  				}    				try  				{  					PropertyItem item = gifImg.GetPropertyItem(0x5100); // FrameDelay in libgdiplus  					// Time is in 1/100th of a second  					destImageSequence.SecondsPerFrame = (item.Value[0] + item.Value[1] * 256) / 100.0;  				}  				catch (Exception e)  				{  					Debug.Print(e.Message);  					GuiWidget.BreakInDebugger();  					destImageSequence.SecondsPerFrame = 2;  				}    				return true;  			}
Magic Number,MatterHackers.Agg.Image,ImageIOWindowsPlugin,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\ImageIOWindowsPlugin.cs,ConvertBitmapToImage,The following statement contains a magic number: if (bitmap != null)  			{  				switch (bitmap.PixelFormat)  				{  					case System.Drawing.Imaging.PixelFormat.Format32bppArgb:  						{  							destImage.Allocate(bitmap.Width' bitmap.Height' bitmap.Width * 4' 32);  							if (destImage.GetRecieveBlender() == null)  							{  								destImage.SetRecieveBlender(new BlenderBGRA());  							}    							BitmapData bitmapData = bitmap.LockBits(new Rectangle(0' 0' bitmap.Width' bitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' bitmap.PixelFormat);  							int sourceIndex = 0;  							int destIndex = 0;  							unsafe  							{  								int offset;  								byte[] destBuffer = destImage.GetBuffer(out offset);  								byte* pSourceBuffer = (byte*)bitmapData.Scan0;  								for (int y = 0; y < destImage.Height; y++)  								{  									destIndex = destImage.GetBufferOffsetXY(0' destImage.Height - 1 - y);  									for (int x = 0; x < destImage.Width; x++)  									{  #if true  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  #else                                              RGBA_Bytes notPreMultiplied = new RGBA_Bytes(pSourceBuffer[sourceIndex + 0]' pSourceBuffer[sourceIndex + 1]' pSourceBuffer[sourceIndex + 2]' pSourceBuffer[sourceIndex + 3]);                                              sourceIndex += 4;                                              RGBA_Bytes preMultiplied = notPreMultiplied.GetAsRGBA_Floats().premultiply().GetAsRGBA_Bytes();                                              destBuffer[destIndex++] = preMultiplied.blue;                                              destBuffer[destIndex++] = preMultiplied.green;                                              destBuffer[destIndex++] = preMultiplied.red;                                              destBuffer[destIndex++] = preMultiplied.alpha;  #endif  									}  								}  							}    							bitmap.UnlockBits(bitmapData);    							return true;  						}    					case System.Drawing.Imaging.PixelFormat.Format24bppRgb:  						{  							destImage.Allocate(bitmap.Width' bitmap.Height' bitmap.Width * 4' 32);    							BitmapData bitmapData = bitmap.LockBits(new Rectangle(0' 0' bitmap.Width' bitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' bitmap.PixelFormat);  							int sourceIndex = 0;  							int destIndex = 0;  							unsafe  							{  								int offset;  								byte[] destBuffer = destImage.GetBuffer(out offset);  								byte* pSourceBuffer = (byte*)bitmapData.Scan0;  								for (int y = 0; y < destImage.Height; y++)  								{  									sourceIndex = y * bitmapData.Stride;  									destIndex = destImage.GetBufferOffsetXY(0' destImage.Height - 1 - y);  									for (int x = 0; x < destImage.Width; x++)  									{  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = 255;  									}  								}  							}    							bitmap.UnlockBits(bitmapData);  							return true;  						}    					case System.Drawing.Imaging.PixelFormat.Format8bppIndexed:  						{  							Copy8BitDataToImage(destImage' bitmap);  							return true;  						}    					default:  						// let this code fall through and return false  						break;  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageIOWindowsPlugin,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\ImageIOWindowsPlugin.cs,ConvertBitmapToImage,The following statement contains a magic number: if (bitmap != null)  			{  				switch (bitmap.PixelFormat)  				{  					case System.Drawing.Imaging.PixelFormat.Format32bppArgb:  						{  							destImage.Allocate(bitmap.Width' bitmap.Height' bitmap.Width * 4' 32);  							if (destImage.GetRecieveBlender() == null)  							{  								destImage.SetRecieveBlender(new BlenderBGRA());  							}    							BitmapData bitmapData = bitmap.LockBits(new Rectangle(0' 0' bitmap.Width' bitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' bitmap.PixelFormat);  							int sourceIndex = 0;  							int destIndex = 0;  							unsafe  							{  								int offset;  								byte[] destBuffer = destImage.GetBuffer(out offset);  								byte* pSourceBuffer = (byte*)bitmapData.Scan0;  								for (int y = 0; y < destImage.Height; y++)  								{  									destIndex = destImage.GetBufferOffsetXY(0' destImage.Height - 1 - y);  									for (int x = 0; x < destImage.Width; x++)  									{  #if true  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  #else                                              RGBA_Bytes notPreMultiplied = new RGBA_Bytes(pSourceBuffer[sourceIndex + 0]' pSourceBuffer[sourceIndex + 1]' pSourceBuffer[sourceIndex + 2]' pSourceBuffer[sourceIndex + 3]);                                              sourceIndex += 4;                                              RGBA_Bytes preMultiplied = notPreMultiplied.GetAsRGBA_Floats().premultiply().GetAsRGBA_Bytes();                                              destBuffer[destIndex++] = preMultiplied.blue;                                              destBuffer[destIndex++] = preMultiplied.green;                                              destBuffer[destIndex++] = preMultiplied.red;                                              destBuffer[destIndex++] = preMultiplied.alpha;  #endif  									}  								}  							}    							bitmap.UnlockBits(bitmapData);    							return true;  						}    					case System.Drawing.Imaging.PixelFormat.Format24bppRgb:  						{  							destImage.Allocate(bitmap.Width' bitmap.Height' bitmap.Width * 4' 32);    							BitmapData bitmapData = bitmap.LockBits(new Rectangle(0' 0' bitmap.Width' bitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' bitmap.PixelFormat);  							int sourceIndex = 0;  							int destIndex = 0;  							unsafe  							{  								int offset;  								byte[] destBuffer = destImage.GetBuffer(out offset);  								byte* pSourceBuffer = (byte*)bitmapData.Scan0;  								for (int y = 0; y < destImage.Height; y++)  								{  									sourceIndex = y * bitmapData.Stride;  									destIndex = destImage.GetBufferOffsetXY(0' destImage.Height - 1 - y);  									for (int x = 0; x < destImage.Width; x++)  									{  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = 255;  									}  								}  							}    							bitmap.UnlockBits(bitmapData);  							return true;  						}    					case System.Drawing.Imaging.PixelFormat.Format8bppIndexed:  						{  							Copy8BitDataToImage(destImage' bitmap);  							return true;  						}    					default:  						// let this code fall through and return false  						break;  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageIOWindowsPlugin,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\ImageIOWindowsPlugin.cs,ConvertBitmapToImage,The following statement contains a magic number: if (bitmap != null)  			{  				switch (bitmap.PixelFormat)  				{  					case System.Drawing.Imaging.PixelFormat.Format32bppArgb:  						{  							destImage.Allocate(bitmap.Width' bitmap.Height' bitmap.Width * 4' 32);  							if (destImage.GetRecieveBlender() == null)  							{  								destImage.SetRecieveBlender(new BlenderBGRA());  							}    							BitmapData bitmapData = bitmap.LockBits(new Rectangle(0' 0' bitmap.Width' bitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' bitmap.PixelFormat);  							int sourceIndex = 0;  							int destIndex = 0;  							unsafe  							{  								int offset;  								byte[] destBuffer = destImage.GetBuffer(out offset);  								byte* pSourceBuffer = (byte*)bitmapData.Scan0;  								for (int y = 0; y < destImage.Height; y++)  								{  									destIndex = destImage.GetBufferOffsetXY(0' destImage.Height - 1 - y);  									for (int x = 0; x < destImage.Width; x++)  									{  #if true  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  #else                                              RGBA_Bytes notPreMultiplied = new RGBA_Bytes(pSourceBuffer[sourceIndex + 0]' pSourceBuffer[sourceIndex + 1]' pSourceBuffer[sourceIndex + 2]' pSourceBuffer[sourceIndex + 3]);                                              sourceIndex += 4;                                              RGBA_Bytes preMultiplied = notPreMultiplied.GetAsRGBA_Floats().premultiply().GetAsRGBA_Bytes();                                              destBuffer[destIndex++] = preMultiplied.blue;                                              destBuffer[destIndex++] = preMultiplied.green;                                              destBuffer[destIndex++] = preMultiplied.red;                                              destBuffer[destIndex++] = preMultiplied.alpha;  #endif  									}  								}  							}    							bitmap.UnlockBits(bitmapData);    							return true;  						}    					case System.Drawing.Imaging.PixelFormat.Format24bppRgb:  						{  							destImage.Allocate(bitmap.Width' bitmap.Height' bitmap.Width * 4' 32);    							BitmapData bitmapData = bitmap.LockBits(new Rectangle(0' 0' bitmap.Width' bitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' bitmap.PixelFormat);  							int sourceIndex = 0;  							int destIndex = 0;  							unsafe  							{  								int offset;  								byte[] destBuffer = destImage.GetBuffer(out offset);  								byte* pSourceBuffer = (byte*)bitmapData.Scan0;  								for (int y = 0; y < destImage.Height; y++)  								{  									sourceIndex = y * bitmapData.Stride;  									destIndex = destImage.GetBufferOffsetXY(0' destImage.Height - 1 - y);  									for (int x = 0; x < destImage.Width; x++)  									{  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = 255;  									}  								}  							}    							bitmap.UnlockBits(bitmapData);  							return true;  						}    					case System.Drawing.Imaging.PixelFormat.Format8bppIndexed:  						{  							Copy8BitDataToImage(destImage' bitmap);  							return true;  						}    					default:  						// let this code fall through and return false  						break;  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageIOWindowsPlugin,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\ImageIOWindowsPlugin.cs,ConvertBitmapToImage,The following statement contains a magic number: if (bitmap != null)  			{  				switch (bitmap.PixelFormat)  				{  					case System.Drawing.Imaging.PixelFormat.Format32bppArgb:  						{  							destImage.Allocate(bitmap.Width' bitmap.Height' bitmap.Width * 4' 32);  							if (destImage.GetRecieveBlender() == null)  							{  								destImage.SetRecieveBlender(new BlenderBGRA());  							}    							BitmapData bitmapData = bitmap.LockBits(new Rectangle(0' 0' bitmap.Width' bitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' bitmap.PixelFormat);  							int sourceIndex = 0;  							int destIndex = 0;  							unsafe  							{  								int offset;  								byte[] destBuffer = destImage.GetBuffer(out offset);  								byte* pSourceBuffer = (byte*)bitmapData.Scan0;  								for (int y = 0; y < destImage.Height; y++)  								{  									destIndex = destImage.GetBufferOffsetXY(0' destImage.Height - 1 - y);  									for (int x = 0; x < destImage.Width; x++)  									{  #if true  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  #else                                              RGBA_Bytes notPreMultiplied = new RGBA_Bytes(pSourceBuffer[sourceIndex + 0]' pSourceBuffer[sourceIndex + 1]' pSourceBuffer[sourceIndex + 2]' pSourceBuffer[sourceIndex + 3]);                                              sourceIndex += 4;                                              RGBA_Bytes preMultiplied = notPreMultiplied.GetAsRGBA_Floats().premultiply().GetAsRGBA_Bytes();                                              destBuffer[destIndex++] = preMultiplied.blue;                                              destBuffer[destIndex++] = preMultiplied.green;                                              destBuffer[destIndex++] = preMultiplied.red;                                              destBuffer[destIndex++] = preMultiplied.alpha;  #endif  									}  								}  							}    							bitmap.UnlockBits(bitmapData);    							return true;  						}    					case System.Drawing.Imaging.PixelFormat.Format24bppRgb:  						{  							destImage.Allocate(bitmap.Width' bitmap.Height' bitmap.Width * 4' 32);    							BitmapData bitmapData = bitmap.LockBits(new Rectangle(0' 0' bitmap.Width' bitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' bitmap.PixelFormat);  							int sourceIndex = 0;  							int destIndex = 0;  							unsafe  							{  								int offset;  								byte[] destBuffer = destImage.GetBuffer(out offset);  								byte* pSourceBuffer = (byte*)bitmapData.Scan0;  								for (int y = 0; y < destImage.Height; y++)  								{  									sourceIndex = y * bitmapData.Stride;  									destIndex = destImage.GetBufferOffsetXY(0' destImage.Height - 1 - y);  									for (int x = 0; x < destImage.Width; x++)  									{  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = 255;  									}  								}  							}    							bitmap.UnlockBits(bitmapData);  							return true;  						}    					case System.Drawing.Imaging.PixelFormat.Format8bppIndexed:  						{  							Copy8BitDataToImage(destImage' bitmap);  							return true;  						}    					default:  						// let this code fall through and return false  						break;  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageIOWindowsPlugin,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\ImageIOWindowsPlugin.cs,ConvertBitmapToImage,The following statement contains a magic number: if (bitmap != null)  			{  				switch (bitmap.PixelFormat)  				{  					case System.Drawing.Imaging.PixelFormat.Format32bppArgb:  						{  							destImage.Allocate(bitmap.Width' bitmap.Height' bitmap.Width * 4' 32);  							if (destImage.GetRecieveBlender() == null)  							{  								destImage.SetRecieveBlender(new BlenderBGRA());  							}    							BitmapData bitmapData = bitmap.LockBits(new Rectangle(0' 0' bitmap.Width' bitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' bitmap.PixelFormat);  							int sourceIndex = 0;  							int destIndex = 0;  							unsafe  							{  								int offset;  								byte[] destBuffer = destImage.GetBuffer(out offset);  								byte* pSourceBuffer = (byte*)bitmapData.Scan0;  								for (int y = 0; y < destImage.Height; y++)  								{  									destIndex = destImage.GetBufferOffsetXY(0' destImage.Height - 1 - y);  									for (int x = 0; x < destImage.Width; x++)  									{  #if true  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  #else                                              RGBA_Bytes notPreMultiplied = new RGBA_Bytes(pSourceBuffer[sourceIndex + 0]' pSourceBuffer[sourceIndex + 1]' pSourceBuffer[sourceIndex + 2]' pSourceBuffer[sourceIndex + 3]);                                              sourceIndex += 4;                                              RGBA_Bytes preMultiplied = notPreMultiplied.GetAsRGBA_Floats().premultiply().GetAsRGBA_Bytes();                                              destBuffer[destIndex++] = preMultiplied.blue;                                              destBuffer[destIndex++] = preMultiplied.green;                                              destBuffer[destIndex++] = preMultiplied.red;                                              destBuffer[destIndex++] = preMultiplied.alpha;  #endif  									}  								}  							}    							bitmap.UnlockBits(bitmapData);    							return true;  						}    					case System.Drawing.Imaging.PixelFormat.Format24bppRgb:  						{  							destImage.Allocate(bitmap.Width' bitmap.Height' bitmap.Width * 4' 32);    							BitmapData bitmapData = bitmap.LockBits(new Rectangle(0' 0' bitmap.Width' bitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' bitmap.PixelFormat);  							int sourceIndex = 0;  							int destIndex = 0;  							unsafe  							{  								int offset;  								byte[] destBuffer = destImage.GetBuffer(out offset);  								byte* pSourceBuffer = (byte*)bitmapData.Scan0;  								for (int y = 0; y < destImage.Height; y++)  								{  									sourceIndex = y * bitmapData.Stride;  									destIndex = destImage.GetBufferOffsetXY(0' destImage.Height - 1 - y);  									for (int x = 0; x < destImage.Width; x++)  									{  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = 255;  									}  								}  							}    							bitmap.UnlockBits(bitmapData);  							return true;  						}    					case System.Drawing.Imaging.PixelFormat.Format8bppIndexed:  						{  							Copy8BitDataToImage(destImage' bitmap);  							return true;  						}    					default:  						// let this code fall through and return false  						break;  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageIOWindowsPlugin,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\ImageIOWindowsPlugin.cs,Copy8BitDataToImage,The following statement contains a magic number: destImage.Allocate(bitmap.Width' bitmap.Height' bitmap.Width * 4' 32);
Magic Number,MatterHackers.Agg.Image,ImageIOWindowsPlugin,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\ImageIOWindowsPlugin.cs,Copy8BitDataToImage,The following statement contains a magic number: destImage.Allocate(bitmap.Width' bitmap.Height' bitmap.Width * 4' 32);
Magic Number,MatterHackers.Agg.Image,ImageIOWindowsPlugin,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\ImageIOWindowsPlugin.cs,SaveImageData,The following statement contains a magic number: if (!System.IO.File.Exists(filename))  			{  				if (sourceImage.BitDepth == 32)  				{  					using (var bitmapToSave = new Bitmap(sourceImage.Width' sourceImage.Height' PixelFormat.Format32bppArgb))  					{  						BitmapData bitmapData = bitmapToSave.LockBits(new Rectangle(0' 0' bitmapToSave.Width' bitmapToSave.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' bitmapToSave.PixelFormat);  						int destIndex = 0;  						unsafe  						{  							byte[] sourceBuffer = sourceImage.GetBuffer();  							byte* pDestBuffer = (byte*)bitmapData.Scan0;  							int scanlinePadding = bitmapData.Stride - bitmapData.Width * 4;  							for (int y = 0; y < sourceImage.Height; y++)  							{  								int sourceIndex = sourceImage.GetBufferOffsetXY(0' sourceImage.Height - 1 - y);  								for (int x = 0; x < sourceImage.Width; x++)  								{  									pDestBuffer[destIndex++] = sourceBuffer[sourceIndex++];  									pDestBuffer[destIndex++] = sourceBuffer[sourceIndex++];  									pDestBuffer[destIndex++] = sourceBuffer[sourceIndex++];  									pDestBuffer[destIndex++] = sourceBuffer[sourceIndex++];  								}    								destIndex += scanlinePadding;  							}  						}    						bitmapToSave.UnlockBits(bitmapData);  						bitmapToSave.Save(filename' format);  					}    					return true;  				}  				else if (sourceImage.BitDepth == 8 && format == ImageFormat.Png)  				{  					using (Bitmap bitmapToSave = new Bitmap(sourceImage.Width' sourceImage.Height' PixelFormat.Format8bppIndexed))  					{  						ColorPalette palette = bitmapToSave.Palette;  						for (int i = 0; i < palette.Entries.Length; i++)  						{  							palette.Entries[i] = Color.FromArgb(i' i' i);  						}  						bitmapToSave.Palette = palette;  						BitmapData bitmapData = bitmapToSave.LockBits(new Rectangle(0' 0' bitmapToSave.Width' bitmapToSave.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' bitmapToSave.PixelFormat);  						int destIndex = 0;  						unsafe  						{  							byte[] sourceBuffer = sourceImage.GetBuffer();  							byte* pDestBuffer = (byte*)bitmapData.Scan0;  							for (int y = 0; y < sourceImage.Height; y++)  							{  								int sourceIndex = sourceImage.GetBufferOffsetXY(0' sourceImage.Height - 1 - y);  								for (int x = 0; x < sourceImage.Width; x++)  								{  									pDestBuffer[destIndex++] = sourceBuffer[sourceIndex++];  								}  							}  						}  						bitmapToSave.Save(filename' format);  						bitmapToSave.UnlockBits(bitmapData);    						return true;  					}  				}  				else  				{  					throw new System.NotImplementedException();  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageIOWindowsPlugin,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\ImageIOWindowsPlugin.cs,SaveImageData,The following statement contains a magic number: if (!System.IO.File.Exists(filename))  			{  				if (sourceImage.BitDepth == 32)  				{  					using (var bitmapToSave = new Bitmap(sourceImage.Width' sourceImage.Height' PixelFormat.Format32bppArgb))  					{  						BitmapData bitmapData = bitmapToSave.LockBits(new Rectangle(0' 0' bitmapToSave.Width' bitmapToSave.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' bitmapToSave.PixelFormat);  						int destIndex = 0;  						unsafe  						{  							byte[] sourceBuffer = sourceImage.GetBuffer();  							byte* pDestBuffer = (byte*)bitmapData.Scan0;  							int scanlinePadding = bitmapData.Stride - bitmapData.Width * 4;  							for (int y = 0; y < sourceImage.Height; y++)  							{  								int sourceIndex = sourceImage.GetBufferOffsetXY(0' sourceImage.Height - 1 - y);  								for (int x = 0; x < sourceImage.Width; x++)  								{  									pDestBuffer[destIndex++] = sourceBuffer[sourceIndex++];  									pDestBuffer[destIndex++] = sourceBuffer[sourceIndex++];  									pDestBuffer[destIndex++] = sourceBuffer[sourceIndex++];  									pDestBuffer[destIndex++] = sourceBuffer[sourceIndex++];  								}    								destIndex += scanlinePadding;  							}  						}    						bitmapToSave.UnlockBits(bitmapData);  						bitmapToSave.Save(filename' format);  					}    					return true;  				}  				else if (sourceImage.BitDepth == 8 && format == ImageFormat.Png)  				{  					using (Bitmap bitmapToSave = new Bitmap(sourceImage.Width' sourceImage.Height' PixelFormat.Format8bppIndexed))  					{  						ColorPalette palette = bitmapToSave.Palette;  						for (int i = 0; i < palette.Entries.Length; i++)  						{  							palette.Entries[i] = Color.FromArgb(i' i' i);  						}  						bitmapToSave.Palette = palette;  						BitmapData bitmapData = bitmapToSave.LockBits(new Rectangle(0' 0' bitmapToSave.Width' bitmapToSave.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' bitmapToSave.PixelFormat);  						int destIndex = 0;  						unsafe  						{  							byte[] sourceBuffer = sourceImage.GetBuffer();  							byte* pDestBuffer = (byte*)bitmapData.Scan0;  							for (int y = 0; y < sourceImage.Height; y++)  							{  								int sourceIndex = sourceImage.GetBufferOffsetXY(0' sourceImage.Height - 1 - y);  								for (int x = 0; x < sourceImage.Width; x++)  								{  									pDestBuffer[destIndex++] = sourceBuffer[sourceIndex++];  								}  							}  						}  						bitmapToSave.Save(filename' format);  						bitmapToSave.UnlockBits(bitmapData);    						return true;  					}  				}  				else  				{  					throw new System.NotImplementedException();  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageIOWindowsPlugin,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\ImageIOWindowsPlugin.cs,SaveImageData,The following statement contains a magic number: if (!System.IO.File.Exists(filename))  			{  				if (sourceImage.BitDepth == 32)  				{  					using (var bitmapToSave = new Bitmap(sourceImage.Width' sourceImage.Height' PixelFormat.Format32bppArgb))  					{  						BitmapData bitmapData = bitmapToSave.LockBits(new Rectangle(0' 0' bitmapToSave.Width' bitmapToSave.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' bitmapToSave.PixelFormat);  						int destIndex = 0;  						unsafe  						{  							byte[] sourceBuffer = sourceImage.GetBuffer();  							byte* pDestBuffer = (byte*)bitmapData.Scan0;  							int scanlinePadding = bitmapData.Stride - bitmapData.Width * 4;  							for (int y = 0; y < sourceImage.Height; y++)  							{  								int sourceIndex = sourceImage.GetBufferOffsetXY(0' sourceImage.Height - 1 - y);  								for (int x = 0; x < sourceImage.Width; x++)  								{  									pDestBuffer[destIndex++] = sourceBuffer[sourceIndex++];  									pDestBuffer[destIndex++] = sourceBuffer[sourceIndex++];  									pDestBuffer[destIndex++] = sourceBuffer[sourceIndex++];  									pDestBuffer[destIndex++] = sourceBuffer[sourceIndex++];  								}    								destIndex += scanlinePadding;  							}  						}    						bitmapToSave.UnlockBits(bitmapData);  						bitmapToSave.Save(filename' format);  					}    					return true;  				}  				else if (sourceImage.BitDepth == 8 && format == ImageFormat.Png)  				{  					using (Bitmap bitmapToSave = new Bitmap(sourceImage.Width' sourceImage.Height' PixelFormat.Format8bppIndexed))  					{  						ColorPalette palette = bitmapToSave.Palette;  						for (int i = 0; i < palette.Entries.Length; i++)  						{  							palette.Entries[i] = Color.FromArgb(i' i' i);  						}  						bitmapToSave.Palette = palette;  						BitmapData bitmapData = bitmapToSave.LockBits(new Rectangle(0' 0' bitmapToSave.Width' bitmapToSave.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' bitmapToSave.PixelFormat);  						int destIndex = 0;  						unsafe  						{  							byte[] sourceBuffer = sourceImage.GetBuffer();  							byte* pDestBuffer = (byte*)bitmapData.Scan0;  							for (int y = 0; y < sourceImage.Height; y++)  							{  								int sourceIndex = sourceImage.GetBufferOffsetXY(0' sourceImage.Height - 1 - y);  								for (int x = 0; x < sourceImage.Width; x++)  								{  									pDestBuffer[destIndex++] = sourceBuffer[sourceIndex++];  								}  							}  						}  						bitmapToSave.Save(filename' format);  						bitmapToSave.UnlockBits(bitmapData);    						return true;  					}  				}  				else  				{  					throw new System.NotImplementedException();  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageIOWindowsPlugin,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\ImageIOWindowsPlugin.cs,LoadImageData,The following statement contains a magic number: if (System.IO.File.Exists(filename))  			{  				var bitmap = new Bitmap(filename);  				if (bitmap != null)  				{  					switch (bitmap.PixelFormat)  					{  						case System.Drawing.Imaging.PixelFormat.Format24bppRgb:  							destImage.Allocate(bitmap.Width' bitmap.Height' bitmap.Width * 4' 128);  							break;    						default:  							throw new System.NotImplementedException();  					}    					BitmapData bitmapData = bitmap.LockBits(new Rectangle(0' 0' bitmap.Width' bitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' bitmap.PixelFormat);  					int sourceIndex = 0;  					int destIndex = 0;  					unsafe  					{  						int offset;  						float[] destBuffer = destImage.GetBuffer(out offset);  						byte* pSourceBuffer = (byte*)bitmapData.Scan0;  						for (int y = 0; y < destImage.Height; y++)  						{  							destIndex = destImage.GetBufferOffsetXY(0' destImage.Height - 1 - y);  							for (int x = 0; x < destImage.Width; x++)  							{  								destBuffer[destIndex++] = pSourceBuffer[sourceIndex++] / 255.0f;  								destBuffer[destIndex++] = pSourceBuffer[sourceIndex++] / 255.0f;  								destBuffer[destIndex++] = pSourceBuffer[sourceIndex++] / 255.0f;  								destBuffer[destIndex++] = 1.0f;  							}  						}  					}    					bitmap.UnlockBits(bitmapData);    					return true;  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageIOWindowsPlugin,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\ImageIOWindowsPlugin.cs,LoadImageData,The following statement contains a magic number: if (System.IO.File.Exists(filename))  			{  				var bitmap = new Bitmap(filename);  				if (bitmap != null)  				{  					switch (bitmap.PixelFormat)  					{  						case System.Drawing.Imaging.PixelFormat.Format24bppRgb:  							destImage.Allocate(bitmap.Width' bitmap.Height' bitmap.Width * 4' 128);  							break;    						default:  							throw new System.NotImplementedException();  					}    					BitmapData bitmapData = bitmap.LockBits(new Rectangle(0' 0' bitmap.Width' bitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' bitmap.PixelFormat);  					int sourceIndex = 0;  					int destIndex = 0;  					unsafe  					{  						int offset;  						float[] destBuffer = destImage.GetBuffer(out offset);  						byte* pSourceBuffer = (byte*)bitmapData.Scan0;  						for (int y = 0; y < destImage.Height; y++)  						{  							destIndex = destImage.GetBufferOffsetXY(0' destImage.Height - 1 - y);  							for (int x = 0; x < destImage.Width; x++)  							{  								destBuffer[destIndex++] = pSourceBuffer[sourceIndex++] / 255.0f;  								destBuffer[destIndex++] = pSourceBuffer[sourceIndex++] / 255.0f;  								destBuffer[destIndex++] = pSourceBuffer[sourceIndex++] / 255.0f;  								destBuffer[destIndex++] = 1.0f;  							}  						}  					}    					bitmap.UnlockBits(bitmapData);    					return true;  				}  			}
Missing Default,MatterHackers.Agg.UI,WidgetForWindowsFormsAbstract,C:\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WidgetForWindowsFormsAbstract.cs,SetCursorOnEnter,The following switch statement is missing a default case: switch (cursorToSet)  			{  				case Cursors.Arrow:  					WindowsFormsWindow.Cursor = System.Windows.Forms.Cursors.Arrow;  					break;    				case Cursors.Hand:  					WindowsFormsWindow.Cursor = System.Windows.Forms.Cursors.Hand;  					break;    				case Cursors.IBeam:  					WindowsFormsWindow.Cursor = System.Windows.Forms.Cursors.IBeam;  					break;  			}
