Implementation smell,Namespace,Class,File,Method,Description
Long Method,MatterHackers.Agg.UI,WindowsFormsBitmapBackBuffer,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmapBackBuffer.cs,UpdateHardwareSurface,The method has 126 lines of code.
Complex Method,MatterHackers.Agg.UI,WinformsSystemWindow,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WinformsSystemWindow.cs,SetCursor,Cyclomatic complexity of the method is 27
Complex Method,MatterHackers.Agg.Image,ImageIOWindowsPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\ImageIOWindowsPlugin.cs,SaveImageData,Cyclomatic complexity of the method is 8
Long Parameter List,MatterHackers.Agg.UI,NativeMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\NativeMethods.cs,BitBlt,The method has 9 parameters. Parameters: hdcDest' nXDest' nYDest' nWidth' nHeight' hdcSrc' nXSrc' nYSrc' dwRop
Long Parameter List,MatterHackers.Agg.UI,NativeMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\NativeMethods.cs,mouse_event,The method has 5 parameters. Parameters: dwFlags' dx' dy' cButtons' dwExtraInfo
Long Parameter List,MatterHackers.Agg.UI,OpenTkGl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\OpenTkGl.cs,Ortho,The method has 6 parameters. Parameters: left' right' bottom' top' zNear' zFar
Long Parameter List,MatterHackers.Agg.UI,OpenTkGl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\OpenTkGl.cs,TexImage2D,The method has 9 parameters. Parameters: target' level' internalFormat' width' height' border' format' type' pixels
Long Parameter List,MatterHackers.Agg.UI,OpenTkGl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\OpenTkGl.cs,DrawRangeElements,The method has 6 parameters. Parameters: mode' start' end' count' type' indices
Long Parameter List,MatterHackers.Agg,DirtyRects,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\DirtyRects.cs,BuildDirtyRect,The method has 6 parameters. Parameters: x' y' XStart' YStart' XEnd' YEnd
Long Parameter List,MatterHackers.GuiAutomation,WindowsInputMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsInputMethods.cs,CreateMouseEvent,The method has 5 parameters. Parameters: dwFlags' dx' dy' cButtons' dwExtraInfo
Long Identifier,MatterHackers.Agg.UI,OpenTkGl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\OpenTkGl.cs,,The length of the parameter currentElementArrayBufferIndex is 30.
Long Statement,MatterHackers.Agg.UI,BitmapSystemWindow,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\BitmapSystemWindow.cs,CopyBackBufferToScreen,The length of the statement  "				//displayGraphics.DrawImage(aggBitmapAppWidget.bitmapBackBuffer.windowsBitmap' windowsRect' windowsRect' GraphicsUnit.Pixel);  // around 250 ms for full screen " is 159.
Long Statement,MatterHackers.Agg.UI,BitmapSystemWindow,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\BitmapSystemWindow.cs,CopyBackBufferToScreen,The length of the statement  "					int result = NativeMethods.BitBlt(displayHDC' 0' 0' bitmapBackBuffer.windowsBitmap.Width' bitmapBackBuffer.windowsBitmap.Height' bitmapHDC' 0' 0' NativeMethods.SRCCOPY); " is 169.
Long Statement,MatterHackers.Agg.UI,BitmapSystemWindow,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\BitmapSystemWindow.cs,OnLoad,The length of the statement  "			bitmapBackBuffer.Initialize((int)this.AggSystemWindow.Width' (int)this.AggSystemWindow.Height' this.AggSystemWindow.BitDepth); " is 126.
Long Statement,MatterHackers.Agg.UI,OpenGLSystemWindow,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\OpenGLSystemWindow.cs,OnResize,The length of the statement  "			// due to cascading control regeneration and avoids the associated performance hit and visible rendering lag during Restore " is 123.
Long Statement,MatterHackers.Agg.UI,OpenTkGl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\OpenTkGl.cs,BlendFunc,The length of the statement  "				OpenTK.Graphics.OpenGL.GL.BlendFunc((OpenTK.Graphics.OpenGL.BlendingFactorSrc)sfactor' (OpenTK.Graphics.OpenGL.BlendingFactorDest)dfactor); " is 139.
Long Statement,MatterHackers.Agg.UI,OpenTkGl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\OpenTkGl.cs,TexEnv,The length of the statement  "			OpenTK.Graphics.OpenGL.GL.TexEnv((OpenTK.Graphics.OpenGL.TextureEnvTarget)target' (OpenTK.Graphics.OpenGL.TextureEnvParameter)pname' param); " is 140.
Long Statement,MatterHackers.Agg.UI,OpenTkGl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\OpenTkGl.cs,Color4,The length of the statement  "            OpenTK.Graphics.ES11.GL.Color4(ImediateMode.currentColor[0]' ImediateMode.currentColor[1]' ImediateMode.currentColor[2]' ImediateMode.currentColor[3]); " is 151.
Long Statement,MatterHackers.Agg.UI,OpenTkGl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\OpenTkGl.cs,TexParameter,The length of the statement  "				OpenTK.Graphics.OpenGL.GL.TexParameter((OpenTK.Graphics.OpenGL.TextureTarget)target' (OpenTK.Graphics.OpenGL.TextureParameterName)pname' param); " is 144.
Long Statement,MatterHackers.Agg.UI,OpenTkGl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\OpenTkGl.cs,BufferData,The length of the statement  "					OpenTK.Graphics.OpenGL.GL.BufferData((OpenTK.Graphics.OpenGL.BufferTarget)target' (IntPtr)size' data' (OpenTK.Graphics.OpenGL.BufferUsageHint)usage); " is 149.
Long Statement,MatterHackers.Agg.UI,OpenTkGl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\OpenTkGl.cs,BufferData,The length of the statement  "				OpenTK.Graphics.ES11.GL.BufferData((OpenTK.Graphics.ES11.All)target' (IntPtr)size' data' (OpenTK.Graphics.ES11.All)usage); " is 122.
Long Statement,MatterHackers.Agg.UI,OpenTkGl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\OpenTkGl.cs,EnableClientState,The length of the statement  "				if (glHasBufferObjects || arrayCap != ArrayCap.IndexArray) // don't set index array if we don't have buffer objects (we will render through DrawElements instead). " is 162.
Long Statement,MatterHackers.Agg.UI,OpenTkGl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\OpenTkGl.cs,EnableClientState,The length of the statement  "			if (glHasBufferObjects || arrayCap != ArrayCap.IndexArray) // don't set index array if we don't have buffer objects (we will render through DrawElements instead). " is 162.
Long Statement,MatterHackers.Agg.UI,OpenTkGl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\OpenTkGl.cs,ColorPointer,The length of the statement  "							OpenTK.Graphics.OpenGL.GL.ColorPointer(size' (OpenTK.Graphics.OpenGL.ColorPointerType)type' stride' new IntPtr(&buffer[(int)pointer])); " is 135.
Long Statement,MatterHackers.Agg.UI,OpenTkGl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\OpenTkGl.cs,NormalPointer,The length of the statement  "							OpenTK.Graphics.OpenGL.GL.NormalPointer((OpenTK.Graphics.OpenGL.NormalPointerType)type' stride' new IntPtr(&buffer[(int)pointer])); " is 131.
Long Statement,MatterHackers.Agg.UI,OpenTkGl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\OpenTkGl.cs,VertexPointer,The length of the statement  "							OpenTK.Graphics.OpenGL.GL.VertexPointer(size' (OpenTK.Graphics.OpenGL.VertexPointerType)type' stride' new IntPtr(&buffer[(int)pointer])); " is 137.
Long Statement,MatterHackers.Agg.UI,OpenTkGl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\OpenTkGl.cs,DrawRangeElements,The length of the statement  "					OpenTK.Graphics.OpenGL.GL.DrawRangeElements((OpenTK.Graphics.OpenGL.BeginMode)mode' start' end' count' (OpenTK.Graphics.OpenGL.DrawElementsType)type' indices); " is 159.
Long Statement,MatterHackers.Agg.UI,OpenTkGl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\OpenTkGl.cs,DrawRangeElements,The length of the statement  "							OpenTK.Graphics.OpenGL.GL.DrawElements((OpenTK.Graphics.OpenGL.BeginMode)mode' count' (OpenTK.Graphics.OpenGL.DrawElementsType)type' new IntPtr(passedBuffer)); " is 159.
Long Statement,MatterHackers.Agg.UI,OpenTkGl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\OpenTkGl.cs,DrawRangeElements,The length of the statement  "						OpenTK.Graphics.ES11.GL.DrawElements((OpenTK.Graphics.ES11.All)mode' count' (OpenTK.Graphics.ES11.All)type' new IntPtr(passedBuffer)); " is 134.
Long Statement,MatterHackers.Agg.UI,OpenTkGl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\OpenTkGl.cs,Light,The length of the statement  "				OpenTK.Graphics.OpenGL.GL.Light((OpenTK.Graphics.OpenGL.LightName)light' (OpenTK.Graphics.OpenGL.LightParameter)pname' param); " is 126.
Long Statement,MatterHackers.Agg.UI,OpenTkGl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\OpenTkGl.cs,ColorMaterial,The length of the statement  "				OpenTK.Graphics.OpenGL.GL.ColorMaterial((OpenTK.Graphics.OpenGL.MaterialFace)face' (OpenTK.Graphics.OpenGL.ColorMaterialParameter)mode); " is 136.
Long Statement,MatterHackers.Agg.UI,WindowsFormsBitmapBackBuffer,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmapBackBuffer.cs,Lock,The length of the statement  "			bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat); " is 175.
Long Statement,MatterHackers.Agg.UI,WindowsFormsBitmapBackBuffer,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmapBackBuffer.cs,UpdateHardwareSurface,The length of the statement  "					bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat); " is 175.
Long Statement,MatterHackers.Agg.UI,WindowsFormsBitmapBackBuffer,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmapBackBuffer.cs,UpdateHardwareSurface,The length of the statement  "							BitmapData bitmapData = windowsBitmap.LockBits(new Rectangle(0' 0' windowsBitmap.Width' windowsBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' windowsBitmap.PixelFormat); " is 186.
Long Statement,MatterHackers.Agg.UI,WinformsEventSink,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WinformsEventSink.cs,controlToHook_KeyDown,The length of the statement  "				aggKeyEvent = new KeyEventArgs((Keys)(System.Windows.Forms.Keys.Control | (windowsKeyEvent.KeyData & ~System.Windows.Forms.Keys.Alt))); " is 135.
Long Statement,MatterHackers.Agg.UI,WinformsEventSink,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WinformsEventSink.cs,ConvertWindowsDragEventToAggMouseEvent,The length of the statement  "			System.Drawing.Point appWidgetPos = new System.Drawing.Point(dragevent.X - clientTop.X' (int)widgetToSendTo.Height - (dragevent.Y - clientTop.Y)); " is 146.
Long Statement,MatterHackers.Agg.UI,WinformsEventSink,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WinformsEventSink.cs,ConvertWindowsMouseEventToAggMouseEvent,The length of the statement  "			return new MouseEventArgs((MouseButtons)windowsMouseEvent.Button' windowsMouseEvent.Clicks' windowsMouseEvent.X' Y' windowsMouseEvent.Delta' dragFiles); " is 152.
Long Statement,MatterHackers.Agg.UI,WinformsEventSink,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WinformsEventSink.cs,formToHook_MouseMove,The length of the statement  "			// TODO: Remove short term workaround for automation issues where mouse events fire differently if mouse is within window region " is 128.
Long Statement,MatterHackers.Agg.UI,WinformsSystemWindow,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WinformsSystemWindow.cs,OnClosing,The length of the statement  "						// https://stackoverflow.com/a/9669702/84369 - ".Stop() without .DoEvents() is not enough' as it'll dispose objects without waiting for your thread to finish its work" " is 167.
Long Statement,MatterHackers.Agg,DirtyRects,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\DirtyRects.cs,SetDirty,The length of the statement  "							currCell.coverage.Left = Math.Max(Math.Min(Math.Min(currCell.coverage.Left' (areaToSetDirty.Left - CurCellBounds.Left))' xCellSize)' 0); " is 136.
Long Statement,MatterHackers.Agg,DirtyRects,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\DirtyRects.cs,SetDirty,The length of the statement  "							currCell.coverage.Bottom = Math.Max(Math.Min(Math.Min(currCell.coverage.Bottom' (areaToSetDirty.Bottom - CurCellBounds.Bottom))' yCellSize)' 0); " is 144.
Long Statement,MatterHackers.Agg,DirtyRects,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\DirtyRects.cs,SetDirty,The length of the statement  "							currCell.coverage.Right = Math.Max(Math.Min(Math.Max(currCell.coverage.Right' (areaToSetDirty.Right - CurCellBounds.Left))' xCellSize)' 0); " is 139.
Long Statement,MatterHackers.Agg,DirtyRects,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\DirtyRects.cs,SetDirty,The length of the statement  "							currCell.coverage.Top = Math.Max(Math.Min(Math.Max(currCell.coverage.Top' (areaToSetDirty.Top - CurCellBounds.Bottom))' yCellSize)' 0); " is 135.
Long Statement,MatterHackers.Agg.Image,ImageIOWindowsPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\ImageIOWindowsPlugin.cs,ConvertBitmapToImage,The length of the statement  "							BitmapData bitmapData = bitmap.LockBits(new Rectangle(0' 0' bitmap.Width' bitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' bitmap.PixelFormat); " is 158.
Long Statement,MatterHackers.Agg.Image,ImageIOWindowsPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\ImageIOWindowsPlugin.cs,ConvertBitmapToImage,The length of the statement  "                                            Color notPreMultiplied = new Color(pSourceBuffer[sourceIndex + 0]' pSourceBuffer[sourceIndex + 1]' pSourceBuffer[sourceIndex + 2]' pSourceBuffer[sourceIndex + 3]); " is 163.
Long Statement,MatterHackers.Agg.Image,ImageIOWindowsPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\ImageIOWindowsPlugin.cs,ConvertBitmapToImage,The length of the statement  "							BitmapData bitmapData = bitmap.LockBits(new Rectangle(0' 0' bitmap.Width' bitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' bitmap.PixelFormat); " is 158.
Long Statement,MatterHackers.Agg.Image,ImageIOWindowsPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\ImageIOWindowsPlugin.cs,Copy8BitDataToImage,The length of the statement  "			BitmapData bitmapData = bitmap.LockBits(new Rectangle(0' 0' bitmap.Width' bitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' bitmap.PixelFormat); " is 158.
Long Statement,MatterHackers.Agg.Image,ImageIOWindowsPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\ImageIOWindowsPlugin.cs,ConvertImageToBitmap,The length of the statement  "			BitmapData bitmapData = bitmap.LockBits(new Rectangle(0' 0' bitmap.Width' bitmap.Height)' ImageLockMode.ReadWrite' bitmap.PixelFormat); " is 135.
Long Statement,MatterHackers.Agg.Image,ImageIOWindowsPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\ImageIOWindowsPlugin.cs,SaveImageData,The length of the statement  "								BitmapData bitmapData = bitmapToSave.LockBits(new Rectangle(0' 0' bitmapToSave.Width' bitmapToSave.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' bitmapToSave.PixelFormat); " is 182.
Long Statement,MatterHackers.Agg.Image,ImageIOWindowsPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\ImageIOWindowsPlugin.cs,SaveImageData,The length of the statement  "							BitmapData bitmapData = bitmapToSave.LockBits(new Rectangle(0' 0' bitmapToSave.Width' bitmapToSave.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' bitmapToSave.PixelFormat); " is 182.
Long Statement,MatterHackers.Agg.Image,ImageIOWindowsPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\ImageIOWindowsPlugin.cs,LoadImageData,The length of the statement  "					BitmapData bitmapData = bitmap.LockBits(new Rectangle(0' 0' bitmap.Width' bitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' bitmap.PixelFormat); " is 158.
Long Statement,MatterHackers.GuiAutomation,WindowsInputMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsInputMethods.cs,CurrentMousePosition,The length of the statement  "			Point2D mousePos = new Point2D(System.Windows.Forms.Control.MousePosition.X' System.Windows.Forms.Control.MousePosition.Y); " is 123.
Long Statement,MatterHackers.GuiAutomation,WindowsInputMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsInputMethods.cs,GetCurrentScreen,The length of the statement  "			//bool b = NativeMethods.BitBlt(hDest' 0' 0' sz.Width' sz.Height' hSrce' 0' 0' CopyPixelOperation.SourceCopy | CopyPixelOperation.CaptureBlt); " is 142.
Long Statement,MatterHackers.GuiAutomation,WindowsInputMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsInputMethods.cs,GetCurrentScreen,The length of the statement  "			BitmapData bitmapData = bmpScreenCapture.LockBits(new Rectangle(0' 0' bmpScreenCapture.Width' bmpScreenCapture.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' bmpScreenCapture.PixelFormat); " is 198.
Complex Conditional,MatterHackers.Agg.UI,WinformsSystemWindow,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WinformsSystemWindow.cs,CloseSystemWindow,The conditional expression  "(SingleWindowMode && windowTypeName == "RootSystemWindow")  				|| (MainWindowsFormsWindow != null && systemWindow == MainWindowsFormsWindow.systemWindow && !SingleWindowMode)"  is complex.
Complex Conditional,MatterHackers.Agg,DirtyRects,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\DirtyRects.cs,BuildDirtyRect,The conditional expression  "curCell.coverage.Right == (int)XCellSize // it touches the right side of the cell  				&& nextCell != null && nextCell.isDirty // there is a next cell  				&& nextCell.coverage.Left == 0 // that touches the left  				&& curCell.coverage.Top == nextCell.coverage.Top // and they have the same top  				&& curCell.coverage.Bottom == nextCell.coverage.Bottom"  is complex.
Complex Conditional,MatterHackers.Agg,DirtyRects,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\DirtyRects.cs,BuildDirtyRect,The conditional expression  "x + 1 < LastX  					&& curCell.coverage.Right == (int)XCellSize // it touches the right side of the cell  					&& nextCell != null && nextCell.isDirty // there is a next cell  					&& nextCell.coverage.Left == 0 // that touches the left  					&& curCell.coverage.Top == nextCell.coverage.Top // and they have the same top  					&& curCell.coverage.Bottom == nextCell.coverage.Bottom"  is complex.
Empty Catch Block,MatterHackers.Agg.UI,WinformsEventSink,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WinformsEventSink.cs,WinformsEventSink,The method has an empty catch block.
Empty Catch Block,MatterHackers.Agg.UI,WinformsSystemWindow,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WinformsSystemWindow.cs,WinformsSystemWindow,The method has an empty catch block.
Empty Catch Block,MatterHackers.Agg.Platform,WinformsInformationProvider,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WinformsInformationProvider.cs,IsRunningOnMac,The method has an empty catch block.
Magic Number,MatterHackers.Agg.UI,BitmapSystemWindow,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\BitmapSystemWindow.cs,OnResize,The following statement contains a magic number: switch (AggSystemWindow.BitDepth)  				{  					case 24:  						format = System.Drawing.Imaging.PixelFormat.Format24bppRgb;  						break;    					case 32:  						format = System.Drawing.Imaging.PixelFormat.Format32bppArgb;  						break;    					default:  						throw new NotImplementedException();  				}
Magic Number,MatterHackers.Agg.UI,BitmapSystemWindow,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\BitmapSystemWindow.cs,OnResize,The following statement contains a magic number: switch (AggSystemWindow.BitDepth)  				{  					case 24:  						format = System.Drawing.Imaging.PixelFormat.Format24bppRgb;  						break;    					case 32:  						format = System.Drawing.Imaging.PixelFormat.Format32bppArgb;  						break;    					default:  						throw new NotImplementedException();  				}
Magic Number,MatterHackers.Agg.UI,Joystick_HAL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\Joystick_win32.cs,GetJoysticState,The following statement contains a magic number: joy.x1 = ((float)joystickInfo.X / 32768.0f - 1.0f);
Magic Number,MatterHackers.Agg.UI,Joystick_HAL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\Joystick_win32.cs,GetJoysticState,The following statement contains a magic number: joy.y1 = -((float)joystickInfo.Y / 32768.0f - 1.0f);
Magic Number,MatterHackers.Agg.UI,Joystick_HAL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\Joystick_win32.cs,GetJoysticState,The following statement contains a magic number: joy.b1 = joystickInfo.Z < 18000;
Magic Number,MatterHackers.Agg.UI,WindowsFormsBitmapBackBuffer,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmapBackBuffer.cs,UpdateHardwareSurface,The following statement contains a magic number: int backBufferStrideInInts = backBufferStrideInBytes / 4;
Magic Number,MatterHackers.Agg.UI,WindowsFormsBitmapBackBuffer,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmapBackBuffer.cs,UpdateHardwareSurface,The following statement contains a magic number: switch (backingImageBufferByte.BitDepth)  				{  					case 24:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = 0; y < backBufferHeight; y++)  									{  										int* pSourceInt = (int*)pSource;  										int* pDestBufferInt = (int*)pDestBuffer;  										for (int x = 0; x < backBufferStrideInInts; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  										for (int x = backBufferStrideInInts * 4; x < backBufferStrideInBytes; x++)  										{  											pDestBuffer[x] = pSource[x];  										}  										pDestBuffer -= bitmapDataStride;  										pSource += backBufferStrideInBytes;  									}  								}  							}  						}  						break;    					case 32:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = rect.Bottom; y < rect.Top; y++)  									{  										int* pSourceInt = (int*)pSource;  										pSourceInt += (backBufferStrideInBytes * y / 4);    										int* pDestBufferInt = (int*)pDestBuffer;  										pDestBufferInt -= (bitmapDataStride * y / 4);    										for (int x = rect.Left; x < rect.Right; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  									}  								}  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}
Magic Number,MatterHackers.Agg.UI,WindowsFormsBitmapBackBuffer,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmapBackBuffer.cs,UpdateHardwareSurface,The following statement contains a magic number: switch (backingImageBufferByte.BitDepth)  				{  					case 24:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = 0; y < backBufferHeight; y++)  									{  										int* pSourceInt = (int*)pSource;  										int* pDestBufferInt = (int*)pDestBuffer;  										for (int x = 0; x < backBufferStrideInInts; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  										for (int x = backBufferStrideInInts * 4; x < backBufferStrideInBytes; x++)  										{  											pDestBuffer[x] = pSource[x];  										}  										pDestBuffer -= bitmapDataStride;  										pSource += backBufferStrideInBytes;  									}  								}  							}  						}  						break;    					case 32:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = rect.Bottom; y < rect.Top; y++)  									{  										int* pSourceInt = (int*)pSource;  										pSourceInt += (backBufferStrideInBytes * y / 4);    										int* pDestBufferInt = (int*)pDestBuffer;  										pDestBufferInt -= (bitmapDataStride * y / 4);    										for (int x = rect.Left; x < rect.Right; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  									}  								}  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}
Magic Number,MatterHackers.Agg.UI,WindowsFormsBitmapBackBuffer,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmapBackBuffer.cs,UpdateHardwareSurface,The following statement contains a magic number: switch (backingImageBufferByte.BitDepth)  				{  					case 24:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = 0; y < backBufferHeight; y++)  									{  										int* pSourceInt = (int*)pSource;  										int* pDestBufferInt = (int*)pDestBuffer;  										for (int x = 0; x < backBufferStrideInInts; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  										for (int x = backBufferStrideInInts * 4; x < backBufferStrideInBytes; x++)  										{  											pDestBuffer[x] = pSource[x];  										}  										pDestBuffer -= bitmapDataStride;  										pSource += backBufferStrideInBytes;  									}  								}  							}  						}  						break;    					case 32:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = rect.Bottom; y < rect.Top; y++)  									{  										int* pSourceInt = (int*)pSource;  										pSourceInt += (backBufferStrideInBytes * y / 4);    										int* pDestBufferInt = (int*)pDestBuffer;  										pDestBufferInt -= (bitmapDataStride * y / 4);    										for (int x = rect.Left; x < rect.Right; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  									}  								}  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}
Magic Number,MatterHackers.Agg.UI,WindowsFormsBitmapBackBuffer,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmapBackBuffer.cs,UpdateHardwareSurface,The following statement contains a magic number: switch (backingImageBufferByte.BitDepth)  				{  					case 24:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = 0; y < backBufferHeight; y++)  									{  										int* pSourceInt = (int*)pSource;  										int* pDestBufferInt = (int*)pDestBuffer;  										for (int x = 0; x < backBufferStrideInInts; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  										for (int x = backBufferStrideInInts * 4; x < backBufferStrideInBytes; x++)  										{  											pDestBuffer[x] = pSource[x];  										}  										pDestBuffer -= bitmapDataStride;  										pSource += backBufferStrideInBytes;  									}  								}  							}  						}  						break;    					case 32:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = rect.Bottom; y < rect.Top; y++)  									{  										int* pSourceInt = (int*)pSource;  										pSourceInt += (backBufferStrideInBytes * y / 4);    										int* pDestBufferInt = (int*)pDestBuffer;  										pDestBufferInt -= (bitmapDataStride * y / 4);    										for (int x = rect.Left; x < rect.Right; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  									}  								}  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}
Magic Number,MatterHackers.Agg.UI,WindowsFormsBitmapBackBuffer,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmapBackBuffer.cs,UpdateHardwareSurface,The following statement contains a magic number: switch (backingImageBufferByte.BitDepth)  				{  					case 24:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = 0; y < backBufferHeight; y++)  									{  										int* pSourceInt = (int*)pSource;  										int* pDestBufferInt = (int*)pDestBuffer;  										for (int x = 0; x < backBufferStrideInInts; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  										for (int x = backBufferStrideInInts * 4; x < backBufferStrideInBytes; x++)  										{  											pDestBuffer[x] = pSource[x];  										}  										pDestBuffer -= bitmapDataStride;  										pSource += backBufferStrideInBytes;  									}  								}  							}  						}  						break;    					case 32:  						{  							unsafe  							{  								byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;  								fixed (byte* pSourceFixed = &buffer[offset])  								{  									byte* pSource = pSourceFixed;  									byte* pDestBuffer = bitmapDataScan0 + bitmapDataStride * backBufferHeightMinusOne;  									for (int y = rect.Bottom; y < rect.Top; y++)  									{  										int* pSourceInt = (int*)pSource;  										pSourceInt += (backBufferStrideInBytes * y / 4);    										int* pDestBufferInt = (int*)pDestBuffer;  										pDestBufferInt -= (bitmapDataStride * y / 4);    										for (int x = rect.Left; x < rect.Right; x++)  										{  											pDestBufferInt[x] = pSourceInt[x];  										}  									}  								}  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}
Magic Number,MatterHackers.Agg.UI,WindowsFormsBitmapBackBuffer,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmapBackBuffer.cs,Initialize,The following statement contains a magic number: switch (bitDepth)  				{  					case 24:  						windowsBitmap = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  						backingImageBufferByte = new ImageBuffer(width' height' 24' new BlenderBGR());  						break;    					case 32:  						windowsBitmap = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format32bppRgb);  						//widowsBitmap = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format32bppPArgb);  						//widowsBitmap = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format32bppArgb);  						//32bppPArgb  						backingImageBufferByte = new ImageBuffer(width' height);  						break;    					case 128:  						windowsBitmap = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format32bppRgb);  						backingImageBufferByte = null;  						backingImageBufferFloat = new ImageBufferFloat(width' height' 128' new BlenderBGRAFloat());  						break;    					default:  						throw new NotImplementedException("Don't support this bit depth yet.");  				}
Magic Number,MatterHackers.Agg.UI,WindowsFormsBitmapBackBuffer,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmapBackBuffer.cs,Initialize,The following statement contains a magic number: switch (bitDepth)  				{  					case 24:  						windowsBitmap = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  						backingImageBufferByte = new ImageBuffer(width' height' 24' new BlenderBGR());  						break;    					case 32:  						windowsBitmap = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format32bppRgb);  						//widowsBitmap = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format32bppPArgb);  						//widowsBitmap = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format32bppArgb);  						//32bppPArgb  						backingImageBufferByte = new ImageBuffer(width' height);  						break;    					case 128:  						windowsBitmap = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format32bppRgb);  						backingImageBufferByte = null;  						backingImageBufferFloat = new ImageBufferFloat(width' height' 128' new BlenderBGRAFloat());  						break;    					default:  						throw new NotImplementedException("Don't support this bit depth yet.");  				}
Magic Number,MatterHackers.Agg.UI,WindowsFormsBitmapBackBuffer,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmapBackBuffer.cs,Initialize,The following statement contains a magic number: switch (bitDepth)  				{  					case 24:  						windowsBitmap = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  						backingImageBufferByte = new ImageBuffer(width' height' 24' new BlenderBGR());  						break;    					case 32:  						windowsBitmap = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format32bppRgb);  						//widowsBitmap = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format32bppPArgb);  						//widowsBitmap = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format32bppArgb);  						//32bppPArgb  						backingImageBufferByte = new ImageBuffer(width' height);  						break;    					case 128:  						windowsBitmap = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format32bppRgb);  						backingImageBufferByte = null;  						backingImageBufferFloat = new ImageBufferFloat(width' height' 128' new BlenderBGRAFloat());  						break;    					default:  						throw new NotImplementedException("Don't support this bit depth yet.");  				}
Magic Number,MatterHackers.Agg.UI,WindowsFormsBitmapBackBuffer,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmapBackBuffer.cs,Initialize,The following statement contains a magic number: switch (bitDepth)  				{  					case 24:  						windowsBitmap = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  						backingImageBufferByte = new ImageBuffer(width' height' 24' new BlenderBGR());  						break;    					case 32:  						windowsBitmap = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format32bppRgb);  						//widowsBitmap = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format32bppPArgb);  						//widowsBitmap = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format32bppArgb);  						//32bppPArgb  						backingImageBufferByte = new ImageBuffer(width' height);  						break;    					case 128:  						windowsBitmap = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format32bppRgb);  						backingImageBufferByte = null;  						backingImageBufferFloat = new ImageBufferFloat(width' height' 128' new BlenderBGRAFloat());  						break;    					default:  						throw new NotImplementedException("Don't support this bit depth yet.");  				}
Magic Number,MatterHackers.Agg.UI,WindowsFormsBitmapBackBuffer,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsFormsBitmapBackBuffer.cs,Initialize,The following statement contains a magic number: switch (bitDepth)  				{  					case 24:  						windowsBitmap = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  						backingImageBufferByte = new ImageBuffer(width' height' 24' new BlenderBGR());  						break;    					case 32:  						windowsBitmap = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format32bppRgb);  						//widowsBitmap = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format32bppPArgb);  						//widowsBitmap = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format32bppArgb);  						//32bppPArgb  						backingImageBufferByte = new ImageBuffer(width' height);  						break;    					case 128:  						windowsBitmap = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format32bppRgb);  						backingImageBufferByte = null;  						backingImageBufferFloat = new ImageBufferFloat(width' height' 128' new BlenderBGRAFloat());  						break;    					default:  						throw new NotImplementedException("Don't support this bit depth yet.");  				}
Magic Number,MatterHackers.Agg.UI,WinformsEventSink,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WinformsEventSink.cs,controlToHook_MouseCaptureChanged,The following statement contains a magic number: widgetToSendTo.OnMouseUp(new MouseEventArgs(MouseButtons.Left' 0' -10' -10' 0));
Magic Number,MatterHackers.Agg.UI,WinformsEventSink,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WinformsEventSink.cs,controlToHook_MouseCaptureChanged,The following statement contains a magic number: widgetToSendTo.OnMouseUp(new MouseEventArgs(MouseButtons.Left' 0' -10' -10' 0));
Magic Number,MatterHackers.Agg.UI,WinformsEventSink,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WinformsEventSink.cs,controlToHook_MouseLeave,The following statement contains a magic number: widgetToSendTo.OnMouseMove(new MouseEventArgs(MouseButtons.None' 0' -10' -10' 0));
Magic Number,MatterHackers.Agg.UI,WinformsEventSink,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WinformsEventSink.cs,controlToHook_MouseLeave,The following statement contains a magic number: widgetToSendTo.OnMouseMove(new MouseEventArgs(MouseButtons.None' 0' -10' -10' 0));
Magic Number,MatterHackers.Agg.UI,WinformsSystemWindow,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WinformsSystemWindow.cs,WinformsSystemWindow,The following statement contains a magic number: idleCallBackTimer.Interval = 10;
Magic Number,MatterHackers.Agg.UI,WinformsSystemWindow,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WinformsSystemWindow.cs,Show,The following statement contains a magic number: this.Left = desktopBounds.X + desktopBounds.Width / 2 - (int)newItemBounds.Width / 2;
Magic Number,MatterHackers.Agg.UI,WinformsSystemWindow,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WinformsSystemWindow.cs,Show,The following statement contains a magic number: this.Left = desktopBounds.X + desktopBounds.Width / 2 - (int)newItemBounds.Width / 2;
Magic Number,MatterHackers.Agg.UI,WinformsSystemWindow,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WinformsSystemWindow.cs,Show,The following statement contains a magic number: this.Top = desktopBounds.Y + desktopBounds.Height / 2 - (int)newItemBounds.Height / 2 - TitleBarHeight / 2;
Magic Number,MatterHackers.Agg.UI,WinformsSystemWindow,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WinformsSystemWindow.cs,Show,The following statement contains a magic number: this.Top = desktopBounds.Y + desktopBounds.Height / 2 - (int)newItemBounds.Height / 2 - TitleBarHeight / 2;
Magic Number,MatterHackers.Agg.UI,WinformsSystemWindow,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WinformsSystemWindow.cs,Show,The following statement contains a magic number: this.Top = desktopBounds.Y + desktopBounds.Height / 2 - (int)newItemBounds.Height / 2 - TitleBarHeight / 2;
Magic Number,MatterHackers.Agg.UI,WinformsSystemWindow,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WinformsSystemWindow.cs,ShowModal,The following statement contains a magic number: this.Left = mainBounds.X + mainBounds.Width / 2 - (int)newItemBounds.Width / 2;
Magic Number,MatterHackers.Agg.UI,WinformsSystemWindow,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WinformsSystemWindow.cs,ShowModal,The following statement contains a magic number: this.Left = mainBounds.X + mainBounds.Width / 2 - (int)newItemBounds.Width / 2;
Magic Number,MatterHackers.Agg.UI,WinformsSystemWindow,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WinformsSystemWindow.cs,ShowModal,The following statement contains a magic number: this.Top = mainBounds.Y + mainBounds.Height / 2 - (int)newItemBounds.Height / 2;
Magic Number,MatterHackers.Agg.UI,WinformsSystemWindow,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WinformsSystemWindow.cs,ShowModal,The following statement contains a magic number: this.Top = mainBounds.Y + mainBounds.Height / 2 - (int)newItemBounds.Height / 2;
Magic Number,MatterHackers.Agg,FileSystemStaticData,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\FileSystemStaticData.cs,GetFiles,The following statement contains a magic number: return Directory.GetFiles(MapPath(path)).Select(p => p.Substring(p.IndexOf("StaticData") + 11));
Magic Number,MatterHackers.Agg,FileSystemStaticData,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\FileSystemStaticData.cs,LoadImageSequenceData,The following statement contains a magic number: var frameDelay = BitConverter.ToInt32(image.GetPropertyItem(20736).Value' i * 4) * 10;
Magic Number,MatterHackers.Agg,FileSystemStaticData,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\FileSystemStaticData.cs,LoadImageSequenceData,The following statement contains a magic number: var frameDelay = BitConverter.ToInt32(image.GetPropertyItem(20736).Value' i * 4) * 10;
Magic Number,MatterHackers.Agg,FileSystemStaticData,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\FileSystemStaticData.cs,LoadImageSequenceData,The following statement contains a magic number: var frameDelay = BitConverter.ToInt32(image.GetPropertyItem(20736).Value' i * 4) * 10;
Magic Number,MatterHackers.Agg,FileSystemStaticData,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\FileSystemStaticData.cs,LoadImageSequenceData,The following statement contains a magic number: minFrameTimeMs = Math.Max(10' Math.Min(frameDelay' minFrameTimeMs));
Magic Number,MatterHackers.Agg,FileSystemStaticData,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\FileSystemStaticData.cs,LoadImageSequenceData,The following statement contains a magic number: sequence.SecondsPerFrame = minFrameTimeMs / 1000.0;
Magic Number,MatterHackers.Agg,FileSystemStaticData,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\FileSystemStaticData.cs,LoadImage,The following statement contains a magic number: cachedImage.Width < 200 && cachedImage.Height < 200
Magic Number,MatterHackers.Agg,FileSystemStaticData,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\FileSystemStaticData.cs,LoadImage,The following statement contains a magic number: cachedImage.Width < 200 && cachedImage.Height < 200
Magic Number,MatterHackers.Agg.Image,ImageIOWindowsPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\ImageIOWindowsPlugin.cs,LoadImageData,The following statement contains a magic number: destImageSequence.SecondsPerFrame = (item.Value[0] + item.Value[1] * 256) / 100.0;
Magic Number,MatterHackers.Agg.Image,ImageIOWindowsPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\ImageIOWindowsPlugin.cs,LoadImageData,The following statement contains a magic number: destImageSequence.SecondsPerFrame = (item.Value[0] + item.Value[1] * 256) / 100.0;
Magic Number,MatterHackers.Agg.Image,ImageIOWindowsPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\ImageIOWindowsPlugin.cs,ConvertBitmapToImage,The following statement contains a magic number: switch (bitmap.PixelFormat)  				{  					case System.Drawing.Imaging.PixelFormat.Format32bppArgb:  						{  							destImage.Allocate(bitmap.Width' bitmap.Height' bitmap.Width * 4' 32);  							if (destImage.GetRecieveBlender() == null)  							{  								destImage.SetRecieveBlender(new BlenderBGRA());  							}    							BitmapData bitmapData = bitmap.LockBits(new Rectangle(0' 0' bitmap.Width' bitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' bitmap.PixelFormat);  							int sourceIndex = 0;  							int destIndex = 0;  							unsafe  							{  								int offset;  								byte[] destBuffer = destImage.GetBuffer(out offset);  								byte* pSourceBuffer = (byte*)bitmapData.Scan0;  								for (int y = 0; y < destImage.Height; y++)  								{  									destIndex = destImage.GetBufferOffsetXY(0' destImage.Height - 1 - y);  									for (int x = 0; x < destImage.Width; x++)  									{  #if true  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  #else                                              Color notPreMultiplied = new Color(pSourceBuffer[sourceIndex + 0]' pSourceBuffer[sourceIndex + 1]' pSourceBuffer[sourceIndex + 2]' pSourceBuffer[sourceIndex + 3]);                                              sourceIndex += 4;                                              Color preMultiplied = notPreMultiplied.ToColorF().premultiply().ToColor();                                              destBuffer[destIndex++] = preMultiplied.blue;                                              destBuffer[destIndex++] = preMultiplied.green;                                              destBuffer[destIndex++] = preMultiplied.red;                                              destBuffer[destIndex++] = preMultiplied.alpha;  #endif  									}  								}  							}    							bitmap.UnlockBits(bitmapData);    							return true;  						}    					case System.Drawing.Imaging.PixelFormat.Format24bppRgb:  						{  							destImage.Allocate(bitmap.Width' bitmap.Height' bitmap.Width * 4' 32);  							if (destImage.GetRecieveBlender() == null)  							{  								destImage.SetRecieveBlender(new BlenderBGRA());  							}    							BitmapData bitmapData = bitmap.LockBits(new Rectangle(0' 0' bitmap.Width' bitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' bitmap.PixelFormat);  							int sourceIndex = 0;  							int destIndex = 0;  							unsafe  							{  								int offset;  								byte[] destBuffer = destImage.GetBuffer(out offset);  								byte* pSourceBuffer = (byte*)bitmapData.Scan0;  								for (int y = 0; y < destImage.Height; y++)  								{  									sourceIndex = y * bitmapData.Stride;  									destIndex = destImage.GetBufferOffsetXY(0' destImage.Height - 1 - y);  									for (int x = 0; x < destImage.Width; x++)  									{  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = 255;  									}  								}  							}    							bitmap.UnlockBits(bitmapData);  							return true;  						}    					case System.Drawing.Imaging.PixelFormat.Format8bppIndexed:  						{  							Copy8BitDataToImage(destImage' bitmap);  							return true;  						}    					default:  						// let this code fall through and return false  						break;  				}
Magic Number,MatterHackers.Agg.Image,ImageIOWindowsPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\ImageIOWindowsPlugin.cs,ConvertBitmapToImage,The following statement contains a magic number: switch (bitmap.PixelFormat)  				{  					case System.Drawing.Imaging.PixelFormat.Format32bppArgb:  						{  							destImage.Allocate(bitmap.Width' bitmap.Height' bitmap.Width * 4' 32);  							if (destImage.GetRecieveBlender() == null)  							{  								destImage.SetRecieveBlender(new BlenderBGRA());  							}    							BitmapData bitmapData = bitmap.LockBits(new Rectangle(0' 0' bitmap.Width' bitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' bitmap.PixelFormat);  							int sourceIndex = 0;  							int destIndex = 0;  							unsafe  							{  								int offset;  								byte[] destBuffer = destImage.GetBuffer(out offset);  								byte* pSourceBuffer = (byte*)bitmapData.Scan0;  								for (int y = 0; y < destImage.Height; y++)  								{  									destIndex = destImage.GetBufferOffsetXY(0' destImage.Height - 1 - y);  									for (int x = 0; x < destImage.Width; x++)  									{  #if true  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  #else                                              Color notPreMultiplied = new Color(pSourceBuffer[sourceIndex + 0]' pSourceBuffer[sourceIndex + 1]' pSourceBuffer[sourceIndex + 2]' pSourceBuffer[sourceIndex + 3]);                                              sourceIndex += 4;                                              Color preMultiplied = notPreMultiplied.ToColorF().premultiply().ToColor();                                              destBuffer[destIndex++] = preMultiplied.blue;                                              destBuffer[destIndex++] = preMultiplied.green;                                              destBuffer[destIndex++] = preMultiplied.red;                                              destBuffer[destIndex++] = preMultiplied.alpha;  #endif  									}  								}  							}    							bitmap.UnlockBits(bitmapData);    							return true;  						}    					case System.Drawing.Imaging.PixelFormat.Format24bppRgb:  						{  							destImage.Allocate(bitmap.Width' bitmap.Height' bitmap.Width * 4' 32);  							if (destImage.GetRecieveBlender() == null)  							{  								destImage.SetRecieveBlender(new BlenderBGRA());  							}    							BitmapData bitmapData = bitmap.LockBits(new Rectangle(0' 0' bitmap.Width' bitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' bitmap.PixelFormat);  							int sourceIndex = 0;  							int destIndex = 0;  							unsafe  							{  								int offset;  								byte[] destBuffer = destImage.GetBuffer(out offset);  								byte* pSourceBuffer = (byte*)bitmapData.Scan0;  								for (int y = 0; y < destImage.Height; y++)  								{  									sourceIndex = y * bitmapData.Stride;  									destIndex = destImage.GetBufferOffsetXY(0' destImage.Height - 1 - y);  									for (int x = 0; x < destImage.Width; x++)  									{  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = 255;  									}  								}  							}    							bitmap.UnlockBits(bitmapData);  							return true;  						}    					case System.Drawing.Imaging.PixelFormat.Format8bppIndexed:  						{  							Copy8BitDataToImage(destImage' bitmap);  							return true;  						}    					default:  						// let this code fall through and return false  						break;  				}
Magic Number,MatterHackers.Agg.Image,ImageIOWindowsPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\ImageIOWindowsPlugin.cs,ConvertBitmapToImage,The following statement contains a magic number: switch (bitmap.PixelFormat)  				{  					case System.Drawing.Imaging.PixelFormat.Format32bppArgb:  						{  							destImage.Allocate(bitmap.Width' bitmap.Height' bitmap.Width * 4' 32);  							if (destImage.GetRecieveBlender() == null)  							{  								destImage.SetRecieveBlender(new BlenderBGRA());  							}    							BitmapData bitmapData = bitmap.LockBits(new Rectangle(0' 0' bitmap.Width' bitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' bitmap.PixelFormat);  							int sourceIndex = 0;  							int destIndex = 0;  							unsafe  							{  								int offset;  								byte[] destBuffer = destImage.GetBuffer(out offset);  								byte* pSourceBuffer = (byte*)bitmapData.Scan0;  								for (int y = 0; y < destImage.Height; y++)  								{  									destIndex = destImage.GetBufferOffsetXY(0' destImage.Height - 1 - y);  									for (int x = 0; x < destImage.Width; x++)  									{  #if true  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  #else                                              Color notPreMultiplied = new Color(pSourceBuffer[sourceIndex + 0]' pSourceBuffer[sourceIndex + 1]' pSourceBuffer[sourceIndex + 2]' pSourceBuffer[sourceIndex + 3]);                                              sourceIndex += 4;                                              Color preMultiplied = notPreMultiplied.ToColorF().premultiply().ToColor();                                              destBuffer[destIndex++] = preMultiplied.blue;                                              destBuffer[destIndex++] = preMultiplied.green;                                              destBuffer[destIndex++] = preMultiplied.red;                                              destBuffer[destIndex++] = preMultiplied.alpha;  #endif  									}  								}  							}    							bitmap.UnlockBits(bitmapData);    							return true;  						}    					case System.Drawing.Imaging.PixelFormat.Format24bppRgb:  						{  							destImage.Allocate(bitmap.Width' bitmap.Height' bitmap.Width * 4' 32);  							if (destImage.GetRecieveBlender() == null)  							{  								destImage.SetRecieveBlender(new BlenderBGRA());  							}    							BitmapData bitmapData = bitmap.LockBits(new Rectangle(0' 0' bitmap.Width' bitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' bitmap.PixelFormat);  							int sourceIndex = 0;  							int destIndex = 0;  							unsafe  							{  								int offset;  								byte[] destBuffer = destImage.GetBuffer(out offset);  								byte* pSourceBuffer = (byte*)bitmapData.Scan0;  								for (int y = 0; y < destImage.Height; y++)  								{  									sourceIndex = y * bitmapData.Stride;  									destIndex = destImage.GetBufferOffsetXY(0' destImage.Height - 1 - y);  									for (int x = 0; x < destImage.Width; x++)  									{  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = 255;  									}  								}  							}    							bitmap.UnlockBits(bitmapData);  							return true;  						}    					case System.Drawing.Imaging.PixelFormat.Format8bppIndexed:  						{  							Copy8BitDataToImage(destImage' bitmap);  							return true;  						}    					default:  						// let this code fall through and return false  						break;  				}
Magic Number,MatterHackers.Agg.Image,ImageIOWindowsPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\ImageIOWindowsPlugin.cs,ConvertBitmapToImage,The following statement contains a magic number: switch (bitmap.PixelFormat)  				{  					case System.Drawing.Imaging.PixelFormat.Format32bppArgb:  						{  							destImage.Allocate(bitmap.Width' bitmap.Height' bitmap.Width * 4' 32);  							if (destImage.GetRecieveBlender() == null)  							{  								destImage.SetRecieveBlender(new BlenderBGRA());  							}    							BitmapData bitmapData = bitmap.LockBits(new Rectangle(0' 0' bitmap.Width' bitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' bitmap.PixelFormat);  							int sourceIndex = 0;  							int destIndex = 0;  							unsafe  							{  								int offset;  								byte[] destBuffer = destImage.GetBuffer(out offset);  								byte* pSourceBuffer = (byte*)bitmapData.Scan0;  								for (int y = 0; y < destImage.Height; y++)  								{  									destIndex = destImage.GetBufferOffsetXY(0' destImage.Height - 1 - y);  									for (int x = 0; x < destImage.Width; x++)  									{  #if true  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  #else                                              Color notPreMultiplied = new Color(pSourceBuffer[sourceIndex + 0]' pSourceBuffer[sourceIndex + 1]' pSourceBuffer[sourceIndex + 2]' pSourceBuffer[sourceIndex + 3]);                                              sourceIndex += 4;                                              Color preMultiplied = notPreMultiplied.ToColorF().premultiply().ToColor();                                              destBuffer[destIndex++] = preMultiplied.blue;                                              destBuffer[destIndex++] = preMultiplied.green;                                              destBuffer[destIndex++] = preMultiplied.red;                                              destBuffer[destIndex++] = preMultiplied.alpha;  #endif  									}  								}  							}    							bitmap.UnlockBits(bitmapData);    							return true;  						}    					case System.Drawing.Imaging.PixelFormat.Format24bppRgb:  						{  							destImage.Allocate(bitmap.Width' bitmap.Height' bitmap.Width * 4' 32);  							if (destImage.GetRecieveBlender() == null)  							{  								destImage.SetRecieveBlender(new BlenderBGRA());  							}    							BitmapData bitmapData = bitmap.LockBits(new Rectangle(0' 0' bitmap.Width' bitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' bitmap.PixelFormat);  							int sourceIndex = 0;  							int destIndex = 0;  							unsafe  							{  								int offset;  								byte[] destBuffer = destImage.GetBuffer(out offset);  								byte* pSourceBuffer = (byte*)bitmapData.Scan0;  								for (int y = 0; y < destImage.Height; y++)  								{  									sourceIndex = y * bitmapData.Stride;  									destIndex = destImage.GetBufferOffsetXY(0' destImage.Height - 1 - y);  									for (int x = 0; x < destImage.Width; x++)  									{  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = 255;  									}  								}  							}    							bitmap.UnlockBits(bitmapData);  							return true;  						}    					case System.Drawing.Imaging.PixelFormat.Format8bppIndexed:  						{  							Copy8BitDataToImage(destImage' bitmap);  							return true;  						}    					default:  						// let this code fall through and return false  						break;  				}
Magic Number,MatterHackers.Agg.Image,ImageIOWindowsPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\ImageIOWindowsPlugin.cs,ConvertBitmapToImage,The following statement contains a magic number: switch (bitmap.PixelFormat)  				{  					case System.Drawing.Imaging.PixelFormat.Format32bppArgb:  						{  							destImage.Allocate(bitmap.Width' bitmap.Height' bitmap.Width * 4' 32);  							if (destImage.GetRecieveBlender() == null)  							{  								destImage.SetRecieveBlender(new BlenderBGRA());  							}    							BitmapData bitmapData = bitmap.LockBits(new Rectangle(0' 0' bitmap.Width' bitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' bitmap.PixelFormat);  							int sourceIndex = 0;  							int destIndex = 0;  							unsafe  							{  								int offset;  								byte[] destBuffer = destImage.GetBuffer(out offset);  								byte* pSourceBuffer = (byte*)bitmapData.Scan0;  								for (int y = 0; y < destImage.Height; y++)  								{  									destIndex = destImage.GetBufferOffsetXY(0' destImage.Height - 1 - y);  									for (int x = 0; x < destImage.Width; x++)  									{  #if true  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  #else                                              Color notPreMultiplied = new Color(pSourceBuffer[sourceIndex + 0]' pSourceBuffer[sourceIndex + 1]' pSourceBuffer[sourceIndex + 2]' pSourceBuffer[sourceIndex + 3]);                                              sourceIndex += 4;                                              Color preMultiplied = notPreMultiplied.ToColorF().premultiply().ToColor();                                              destBuffer[destIndex++] = preMultiplied.blue;                                              destBuffer[destIndex++] = preMultiplied.green;                                              destBuffer[destIndex++] = preMultiplied.red;                                              destBuffer[destIndex++] = preMultiplied.alpha;  #endif  									}  								}  							}    							bitmap.UnlockBits(bitmapData);    							return true;  						}    					case System.Drawing.Imaging.PixelFormat.Format24bppRgb:  						{  							destImage.Allocate(bitmap.Width' bitmap.Height' bitmap.Width * 4' 32);  							if (destImage.GetRecieveBlender() == null)  							{  								destImage.SetRecieveBlender(new BlenderBGRA());  							}    							BitmapData bitmapData = bitmap.LockBits(new Rectangle(0' 0' bitmap.Width' bitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' bitmap.PixelFormat);  							int sourceIndex = 0;  							int destIndex = 0;  							unsafe  							{  								int offset;  								byte[] destBuffer = destImage.GetBuffer(out offset);  								byte* pSourceBuffer = (byte*)bitmapData.Scan0;  								for (int y = 0; y < destImage.Height; y++)  								{  									sourceIndex = y * bitmapData.Stride;  									destIndex = destImage.GetBufferOffsetXY(0' destImage.Height - 1 - y);  									for (int x = 0; x < destImage.Width; x++)  									{  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = pSourceBuffer[sourceIndex++];  										destBuffer[destIndex++] = 255;  									}  								}  							}    							bitmap.UnlockBits(bitmapData);  							return true;  						}    					case System.Drawing.Imaging.PixelFormat.Format8bppIndexed:  						{  							Copy8BitDataToImage(destImage' bitmap);  							return true;  						}    					default:  						// let this code fall through and return false  						break;  				}
Magic Number,MatterHackers.Agg.Image,ImageIOWindowsPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\ImageIOWindowsPlugin.cs,Copy8BitDataToImage,The following statement contains a magic number: destImage.Allocate(bitmap.Width' bitmap.Height' bitmap.Width * 4' 32);
Magic Number,MatterHackers.Agg.Image,ImageIOWindowsPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\ImageIOWindowsPlugin.cs,Copy8BitDataToImage,The following statement contains a magic number: destImage.Allocate(bitmap.Width' bitmap.Height' bitmap.Width * 4' 32);
Magic Number,MatterHackers.Agg.Image,ImageIOWindowsPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\ImageIOWindowsPlugin.cs,ConvertImageToBitmap,The following statement contains a magic number: int scanlinePadding = bitmapData.Stride - bitmapData.Width * 4;
Magic Number,MatterHackers.Agg.Image,ImageIOWindowsPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\ImageIOWindowsPlugin.cs,SaveImageData,The following statement contains a magic number: int scanlinePadding = bitmapData.Stride - bitmapData.Width * 4;
Magic Number,MatterHackers.Agg.Image,ImageIOWindowsPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\ImageIOWindowsPlugin.cs,SaveImageData,The following statement contains a magic number: sourceImage.BitDepth == 32
Magic Number,MatterHackers.Agg.Image,ImageIOWindowsPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\ImageIOWindowsPlugin.cs,LoadImageData,The following statement contains a magic number: switch (bitmap.PixelFormat)  					{  						case System.Drawing.Imaging.PixelFormat.Format24bppRgb:  							destImage.Allocate(bitmap.Width' bitmap.Height' bitmap.Width * 4' 128);  							break;    						default:  							throw new System.NotImplementedException();  					}
Magic Number,MatterHackers.Agg.Image,ImageIOWindowsPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\ImageIOWindowsPlugin.cs,LoadImageData,The following statement contains a magic number: switch (bitmap.PixelFormat)  					{  						case System.Drawing.Imaging.PixelFormat.Format24bppRgb:  							destImage.Allocate(bitmap.Width' bitmap.Height' bitmap.Width * 4' 128);  							break;    						default:  							throw new System.NotImplementedException();  					}
Magic Number,MatterHackers.Agg.Image,ImageIOWindowsPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\ImageIOWindowsPlugin.cs,LoadImageData,The following statement contains a magic number: destBuffer[destIndex++] = pSourceBuffer[sourceIndex++] / 255.0f;
Magic Number,MatterHackers.Agg.Image,ImageIOWindowsPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\ImageIOWindowsPlugin.cs,LoadImageData,The following statement contains a magic number: destBuffer[destIndex++] = pSourceBuffer[sourceIndex++] / 255.0f;
Magic Number,MatterHackers.Agg.Image,ImageIOWindowsPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\ImageIOWindowsPlugin.cs,LoadImageData,The following statement contains a magic number: destBuffer[destIndex++] = pSourceBuffer[sourceIndex++] / 255.0f;
Magic Number,MatterHackers.GuiAutomation,WindowsInputMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsInputMethods.cs,GetCurrentScreen,The following statement contains a magic number: pSourceInt -= (bitmapDataStride * y / 4);
Magic Number,MatterHackers.GuiAutomation,WindowsInputMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WindowsInputMethods.cs,GetCurrentScreen,The following statement contains a magic number: pDestBufferInt += (backBufferStrideInBytes * y / 4);
Magic Number,MatterHackers.Agg.Platform,WinformsInformationProvider,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WinformsInformationProvider.cs,IsRunningOnMac,The following statement contains a magic number: buf = Marshal.AllocHGlobal(8192);
Duplicate Code,MatterHackers.Agg.UI,OpenTkGl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\OpenTkGl.cs,BufferData,The method contains a code clone-set at the following line numbers (starting from the method definition): ((8' 41)' (47' 80))
Missing Default,MatterHackers.Agg.UI,WinformsEventSink,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WinformsEventSink.cs,WinformsEventSink,The following switch statement is missing a default case: switch (e.KeyCode)  					{  						case System.Windows.Forms.Keys.F12:  							if (inspectForm != null)  							{  							// Toggle mode if window is open  							inspectForm.Inspecting = !inspectForm.Inspecting;  							}  							else  							{  								try  								{  								// Otherwise open  								inspectForm = WinformsSystemWindow.InspectorCreator.Invoke(widgetToSendTo);  									inspectForm.StartPosition = FormStartPosition.Manual;  									inspectForm.Location = new System.Drawing.Point(0' 0);  									inspectForm.FormClosed += (s2' e2) =>  									{  										inspectForm = null;  									};  									inspectForm.Show();    								// Restore focus to ensure keyboard hooks in main SystemWindow work as expected  								controlToHook.Focus();  								}  								catch { }  							}  							return;  					}
Missing Default,MatterHackers.Agg.UI,WinformsSystemWindow,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PlatformWin32\win32\WinformsSystemWindow.cs,SetCursor,The following switch statement is missing a default case: switch (cursorToSet)  			{  				case Cursors.Arrow:  					this.Cursor = System.Windows.Forms.Cursors.Arrow;  					break;    				case Cursors.Hand:  					this.Cursor = System.Windows.Forms.Cursors.Hand;  					break;    				case Cursors.IBeam:  					this.Cursor = System.Windows.Forms.Cursors.IBeam;  					break;  				case Cursors.Cross:  					this.Cursor = System.Windows.Forms.Cursors.Cross;  					break;  				case Cursors.Default:  					this.Cursor = System.Windows.Forms.Cursors.Default;  					break;  				case Cursors.Help:  					this.Cursor = System.Windows.Forms.Cursors.Help;  					break;  				case Cursors.HSplit:  					this.Cursor = System.Windows.Forms.Cursors.HSplit;  					break;  				case Cursors.No:  					this.Cursor = System.Windows.Forms.Cursors.No;  					break;  				case Cursors.NoMove2D:  					this.Cursor = System.Windows.Forms.Cursors.NoMove2D;  					break;  				case Cursors.NoMoveHoriz:  					this.Cursor = System.Windows.Forms.Cursors.NoMoveHoriz;  					break;  				case Cursors.NoMoveVert:  					this.Cursor = System.Windows.Forms.Cursors.NoMoveVert;  					break;  				case Cursors.PanEast:  					this.Cursor = System.Windows.Forms.Cursors.PanEast;  					break;  				case Cursors.PanNE:  					this.Cursor = System.Windows.Forms.Cursors.PanNE;  					break;  				case Cursors.PanNorth:  					this.Cursor = System.Windows.Forms.Cursors.PanNorth;  					break;  				case Cursors.PanNW:  					this.Cursor = System.Windows.Forms.Cursors.PanNW;  					break;  				case Cursors.PanSE:  					this.Cursor = System.Windows.Forms.Cursors.PanSE;  					break;  				case Cursors.PanSouth:  					this.Cursor = System.Windows.Forms.Cursors.PanSouth;  					break;  				case Cursors.PanSW:  					this.Cursor = System.Windows.Forms.Cursors.PanSW;  					break;  				case Cursors.PanWest:  					this.Cursor = System.Windows.Forms.Cursors.PanWest;  					break;  				case Cursors.SizeAll:  					this.Cursor = System.Windows.Forms.Cursors.SizeAll;  					break;  				case Cursors.SizeNESW:  					this.Cursor = System.Windows.Forms.Cursors.SizeNESW;  					break;  				case Cursors.SizeNS:  					this.Cursor = System.Windows.Forms.Cursors.SizeNS;  					break;  				case Cursors.SizeNWSE:  					this.Cursor = System.Windows.Forms.Cursors.SizeNWSE;  					break;  				case Cursors.SizeWE:  					this.Cursor = System.Windows.Forms.Cursors.SizeWE;  					break;  				case Cursors.UpArrow:  					this.Cursor = System.Windows.Forms.Cursors.UpArrow;  					break;  				case Cursors.VSplit:  					this.Cursor = System.Windows.Forms.Cursors.VSplit;  					break;  				case Cursors.WaitCursor:  					this.Cursor = System.Windows.Forms.Cursors.WaitCursor;  					break;  			}
