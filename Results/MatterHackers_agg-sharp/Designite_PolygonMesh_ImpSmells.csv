Implementation smell,Namespace,Class,File,Method,Description
Long Method,MatterHackers.PolygonMesh.Csg,SliceLayer,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Csg\SliceLayer.cs,FindClosedPolygons,The method has 207 lines of code.
Long Method,MatterHackers.PolygonMesh.Processors,StlProcessing,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseFileContents,The method has 150 lines of code.
Complex Method,MatterHackers.PolygonMesh.Csg,SliceLayer,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Csg\SliceLayer.cs,FindClosedPolygons,Cyclomatic complexity of the method is 34
Complex Method,MatterHackers.PolygonMesh.Csg,SliceLayer,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Csg\SliceLayer.cs,GetTouchingSegmentIndex,Cyclomatic complexity of the method is 9
Complex Method,MatterHackers.PolygonMesh.Csg,SortedVector2,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Csg\SortedVector2.cs,FindClosetIndex,Cyclomatic complexity of the method is 9
Complex Method,MatterHackers.PolygonMesh,Mesh,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,MergeVertices,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.PolygonMesh,FaceBspTree,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\FaceBspTree.cs,CalculateCrossingArea,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.PolygonMesh,MeshConvexHull,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\MeshConvexHull.cs,CreateHullMesh,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.PolygonMesh.Processors,StlProcessing,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseFileContents,Cyclomatic complexity of the method is 19
Long Parameter List,MatterHackers.PolygonMesh.Csg,CsgPlane,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Csg\CsgPlane.cs,SplitPolygon,The method has 5 parameters. Parameters: polygon' coplanarFront' coplanarBack' front' back
Long Parameter List,MatterHackers.PolygonMesh,FaceExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,Split,The method has 7 parameters. Parameters: face' faceVertices' plane' newFaces' newVertices' onPlaneDistance' clipFace
Long Parameter List,MatterHackers.PolygonMesh,FaceBspTree,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\FaceBspTree.cs,CreateBackAndFrontFaceLists,The method has 5 parameters. Parameters: mesh' faceIndex' faces' backFaces' frontFaces
Long Parameter List,MatterHackers.PolygonMesh,FaceBspTree,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\FaceBspTree.cs,CreateNoSplittingFast,The method has 6 parameters. Parameters: mesh' sourceFaces' node' faces' maxFacesToTest' tryToBalanceTree
Long Parameter List,MatterHackers.PolygonMesh,VertexXAxisSorter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\VertexSorters\VertexXAxisSorter.cs,AddToListIfSameEnough,The method has 5 parameters. Parameters: vertices' position' findList' maxDistanceToConsiderVertexAsSameSquared' i
Long Parameter List,MatterHackers.PolygonMesh,VertexXYZAxisWithRotation,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\VertexSorters\VertexXYZAxisWithRotation.cs,AddToListIfSameEnough,The method has 5 parameters. Parameters: vertices' position' findList' maxDistanceToConsiderVertexAsSameSquared' i
Long Parameter List,MatterHackers.PolygonMesh.Rendering,OrthographicZProjection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\OrthographicZProjection.cs,DrawTo,The method has 6 parameters. Parameters: graphics2D' mesh' matrix' offset' scale' silhouetteColor
Long Identifier,MatterHackers.PolygonMesh,VertexDistanceFromPointSorter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\VertexSorters\VertexDistanceFromPointSorter.cs,FindVertices,The length of the parameter maxDistanceToConsiderVertexAsSame is 33.
Long Identifier,MatterHackers.PolygonMesh,VertexSorterBase,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\VertexSorters\VertexSorterBase.cs,FindVertices,The length of the parameter maxDistanceToConsiderVertexAsSame is 33.
Long Identifier,MatterHackers.PolygonMesh,VertexXAxisSorter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\VertexSorters\VertexXAxisSorter.cs,FindVertices,The length of the parameter maxDistanceToConsiderVertexAsSame is 33.
Long Identifier,MatterHackers.PolygonMesh,VertexXAxisSorter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\VertexSorters\VertexXAxisSorter.cs,FindVertices,The length of the parameter maxDistanceToConsiderVertexAsSameSquared is 40.
Long Identifier,MatterHackers.PolygonMesh,VertexXAxisSorter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\VertexSorters\VertexXAxisSorter.cs,AddToListIfSameEnough,The length of the parameter maxDistanceToConsiderVertexAsSameSquared is 40.
Long Identifier,MatterHackers.PolygonMesh,VertexXYZAxisWithRotation,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\VertexSorters\VertexXYZAxisWithRotation.cs,FindVertices,The length of the parameter maxDistanceToConsiderVertexAsSame is 33.
Long Identifier,MatterHackers.PolygonMesh,VertexXYZAxisWithRotation,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\VertexSorters\VertexXYZAxisWithRotation.cs,FindVertices,The length of the parameter maxDistanceToConsiderVertexAsSameSquared is 40.
Long Identifier,MatterHackers.PolygonMesh,VertexXYZAxisWithRotation,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\VertexSorters\VertexXYZAxisWithRotation.cs,AddToListIfSameEnough,The length of the parameter maxDistanceToConsiderVertexAsSameSquared is 40.
Long Statement,MatterHackers.PolygonMesh.Csg,FaceHelper,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Csg\CsgProcessing.cs,SplitFaces,The length of the statement  "			AxisAlignedBoundingBox faceEdgeBoundsIntersection = AxisAlignedBoundingBox.Intersection(boundsForEdges' boundsForFaces); " is 120.
Long Statement,MatterHackers.PolygonMesh.Csg,SliceLayer,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Csg\SliceLayer.cs,FindClosedPolygons,The length of the statement  "			// Link up all the missing ends' closing up the smallest gaps first. This is an inefficient implementation which can run in O(n*n*n) time. " is 138.
Long Statement,MatterHackers.PolygonMesh.Csg,SliceLayer,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Csg\SliceLayer.cs,FindClosedPolygons,The length of the statement  "					perimeterLength += (ClosedPolygons[polygonIndex][intPointIndex] - ClosedPolygons[polygonIndex][intPointIndex - 1]).Length; " is 122.
Long Statement,MatterHackers.PolygonMesh,Mesh,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,MergeVertices,The length of the statement  "				.Select((v' i) => new BvhTreeItemData<int>(i' new AxisAlignedBoundingBox(v - tinyDistance' v + tinyDistance))).ToList()); " is 121.
Long Statement,MatterHackers.PolygonMesh,MeshExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,GetMaxPlaneProjection,The length of the statement  "			var textureCoordinateMapping = Matrix4X4.CreateRotation(new Quaternion(mesh.Faces[faces.First()].normal.AsVector3()' Vector3.UnitZ)); " is 133.
Long Statement,MatterHackers.PolygonMesh,MeshExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,GetMaxPlaneProjection,The length of the statement  "			var textureCoordinateMapping = Matrix4X4.CreateRotation(new Quaternion(mesh.Faces[face].normal.AsVector3()' Vector3.UnitZ)); " is 124.
Long Statement,MatterHackers.PolygonMesh,FaceBspTree,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\FaceBspTree.cs,GetFacesInVisibiltyOrder,The length of the statement  "			var renderOrder = new Stack<BspNode>(new BspNode[] { root.RenderOrder(mesh' meshToViewTransform' invMeshToViewTransform) }); " is 124.
Long Statement,MatterHackers.PolygonMesh,PlatonicSolids,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateTetrahedron,The length of the statement  "			//tetrahedron.CreateFace(new IVertex[] { verts[0]' verts[2]' verts[1] }); // add reversed because we want to see the bottom. " is 124.
Long Statement,MatterHackers.PolygonMesh,PlatonicSolids,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The length of the statement  "			//	verts[i] = icosahedron.CreateVertex(new Vector3(icosahedronVertices[i * 3 + 0]' icosahedronVertices[i * 3 + 1]' icosahedronVertices[i * 3 + 2])); " is 148.
Long Statement,MatterHackers.PolygonMesh,VertexXAxisSorter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\VertexSorters\VertexXAxisSorter.cs,FindVertices,The length of the statement  "			double maxDistanceToConsiderVertexAsSameSquared = maxDistanceToConsiderVertexAsSame * maxDistanceToConsiderVertexAsSame; " is 120.
Long Statement,MatterHackers.PolygonMesh,VertexXYZAxisWithRotation,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\VertexSorters\VertexXYZAxisWithRotation.cs,FindVertices,The length of the statement  "			double maxDistanceToConsiderVertexAsSameSquared = maxDistanceToConsiderVertexAsSame * maxDistanceToConsiderVertexAsSame; " is 120.
Long Statement,MatterHackers.PolygonMesh.Processors,StlProcessing,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseFileContents,The length of the statement  "			if (first160Bytes[0] == ByteOredrMark[0] && first160Bytes[0] == ByteOredrMark[0] && first160Bytes[0] == ByteOredrMark[0]) " is 121.
Long Statement,MatterHackers.PolygonMesh.Processors,StlProcessing,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseFileContents,The length of the statement  "			string first160BytesOfSTLFile = System.Text.Encoding.UTF8.GetString(first160Bytes' startOfString' first160Bytes.Length - startOfString); " is 136.
Long Statement,MatterHackers.PolygonMesh.Processors,StlProcessing,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,IsBinary,The length of the statement  "					if (first160Bytes[0] == ByteOredrMark[0] && first160Bytes[0] == ByteOredrMark[0] && first160Bytes[0] == ByteOredrMark[0]) " is 121.
Long Statement,MatterHackers.PolygonMesh.Processors,StlProcessing,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,IsBinary,The length of the statement  "					string first160BytesOfSTLFile = System.Text.Encoding.UTF8.GetString(first160Bytes' startOfString' first160Bytes.Length - startOfString); " is 136.
Complex Conditional,MatterHackers.PolygonMesh,MeshExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,SplitOnPlanes,The conditional expression  "(clipData.Dist[0] < 0 && clipData.Dist[1] < 0)  						|| (clipData.Dist[1] < 0 && clipData.Dist[2] < 0)  						|| (clipData.Dist[2] < 0 && clipData.Dist[0] < 0)"  is complex.
Complex Conditional,MatterHackers.PolygonMesh,MeshConvexHull,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\MeshConvexHull.cs,CreateHullMesh,The conditional expression  "cHVertexList.Count == 0  				|| bounds.XSize == 0  				|| bounds.YSize == 0  				|| bounds.ZSize == 0"  is complex.
Empty Catch Block,MatterHackers.PolygonMesh,MeshConvexHull,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\MeshConvexHull.cs,CreateHullMesh,The method has an empty catch block.
Magic Number,MatterHackers.PolygonMesh.Csg,CsgOperations,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Csg\CsgOperations.cs,MeshFromSolid,The following statement contains a magic number: vertices.Count > 2
Magic Number,MatterHackers.PolygonMesh.Csg,CsgOperations,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Csg\CsgOperations.cs,Union,The following statement contains a magic number: reporter?.Invoke("Mesh to Solid B"' .2);
Magic Number,MatterHackers.PolygonMesh.Csg,CsgOperations,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Csg\CsgOperations.cs,Union,The following statement contains a magic number: reporter?.Invoke("BooleanModeller"' .4);
Magic Number,MatterHackers.PolygonMesh.Csg,CsgOperations,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Csg\CsgOperations.cs,Union,The following statement contains a magic number: var modeller = new BooleanModeller(A' B' (status' progress0To1) =>  			{  				reporter?.Invoke(status' .4 + progress0To1 * .2);  			}' cancellationToken);
Magic Number,MatterHackers.PolygonMesh.Csg,CsgOperations,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Csg\CsgOperations.cs,Union,The following statement contains a magic number: var modeller = new BooleanModeller(A' B' (status' progress0To1) =>  			{  				reporter?.Invoke(status' .4 + progress0To1 * .2);  			}' cancellationToken);
Magic Number,MatterHackers.PolygonMesh.Csg,CsgOperations,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Csg\CsgOperations.cs,Union,The following statement contains a magic number: reporter?.Invoke("Union"' .6);
Magic Number,MatterHackers.PolygonMesh.Csg,CsgOperations,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Csg\CsgOperations.cs,Union,The following statement contains a magic number: reporter?.Invoke("Solid to Mesh"' .8);
Magic Number,MatterHackers.PolygonMesh.Csg,CsgOperations,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Csg\CsgOperations.cs,Subtract,The following statement contains a magic number: reporter?.Invoke("Mesh to Solid B"' .2);
Magic Number,MatterHackers.PolygonMesh.Csg,CsgOperations,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Csg\CsgOperations.cs,Subtract,The following statement contains a magic number: reporter?.Invoke("BooleanModeller"' .4);
Magic Number,MatterHackers.PolygonMesh.Csg,CsgOperations,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Csg\CsgOperations.cs,Subtract,The following statement contains a magic number: var modeller = new BooleanModeller(A' B' (status' progress0To1) =>  			{  				reporter?.Invoke(status' .4 + progress0To1 * .2);  			}' cancellationToken);
Magic Number,MatterHackers.PolygonMesh.Csg,CsgOperations,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Csg\CsgOperations.cs,Subtract,The following statement contains a magic number: var modeller = new BooleanModeller(A' B' (status' progress0To1) =>  			{  				reporter?.Invoke(status' .4 + progress0To1 * .2);  			}' cancellationToken);
Magic Number,MatterHackers.PolygonMesh.Csg,CsgOperations,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Csg\CsgOperations.cs,Subtract,The following statement contains a magic number: reporter?.Invoke("Difference"' .6);
Magic Number,MatterHackers.PolygonMesh.Csg,CsgOperations,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Csg\CsgOperations.cs,Subtract,The following statement contains a magic number: reporter?.Invoke("Solid to Mesh"' .8);
Magic Number,MatterHackers.PolygonMesh.Csg,CsgOperations,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Csg\CsgOperations.cs,Intersect,The following statement contains a magic number: reporter?.Invoke("Mesh to Solid B"' .2);
Magic Number,MatterHackers.PolygonMesh.Csg,CsgOperations,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Csg\CsgOperations.cs,Intersect,The following statement contains a magic number: reporter?.Invoke("BooleanModeller"' .4);
Magic Number,MatterHackers.PolygonMesh.Csg,CsgOperations,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Csg\CsgOperations.cs,Intersect,The following statement contains a magic number: reporter?.Invoke("Intersection"' .6);
Magic Number,MatterHackers.PolygonMesh.Csg,CsgOperations,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Csg\CsgOperations.cs,IntersectAndSubtract,The following statement contains a magic number: reporter?.Invoke("Mesh to Solid B"' .2);
Magic Number,MatterHackers.PolygonMesh.Csg,CsgOperations,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Csg\CsgOperations.cs,IntersectAndSubtract,The following statement contains a magic number: reporter?.Invoke("BooleanModeller"' .4);
Magic Number,MatterHackers.PolygonMesh.Csg,CsgOperations,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Csg\CsgOperations.cs,IntersectAndSubtract,The following statement contains a magic number: var modeller = new BooleanModeller(A' B' (status' progress0To1) =>  			{  				reporter?.Invoke(status' .4 + progress0To1 * .2);  			}' cancellationToken);
Magic Number,MatterHackers.PolygonMesh.Csg,CsgOperations,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Csg\CsgOperations.cs,IntersectAndSubtract,The following statement contains a magic number: var modeller = new BooleanModeller(A' B' (status' progress0To1) =>  			{  				reporter?.Invoke(status' .4 + progress0To1 * .2);  			}' cancellationToken);
Magic Number,MatterHackers.PolygonMesh.Csg,CsgOperations,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Csg\CsgOperations.cs,IntersectAndSubtract,The following statement contains a magic number: reporter?.Invoke("Intersection"' .6);
Magic Number,MatterHackers.PolygonMesh.Csg,CsgOperations,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Csg\CsgOperations.cs,IntersectAndSubtract,The following statement contains a magic number: reporter?.Invoke("Difference"' .6);
Magic Number,MatterHackers.PolygonMesh.Csg,CsgOperations,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Csg\CsgOperations.cs,IntersectAndSubtract,The following statement contains a magic number: reporter?.Invoke("Solid to Mesh"' .8);
Magic Number,MatterHackers.PolygonMesh.Csg,SliceLayer,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Csg\SliceLayer.cs,FindClosedPolygons,The following statement contains a magic number: int minimumPerimeter = 1000;
Magic Number,MatterHackers.PolygonMesh.Csg,SortedVector2,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Csg\SortedVector2.cs,FindClosetIndex,The following statement contains a magic number: currentIndex < sorted.Count  					&& Math.Pow(Math.Abs(sorted[currentIndex].Position.X - position.X)' 2) <= bestDistanceSquared
Magic Number,MatterHackers.PolygonMesh.Csg,SortedVector2,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Csg\SortedVector2.cs,FindClosetIndex,The following statement contains a magic number: prevIndex >= 0  					&& Math.Pow(Math.Abs(sorted[prevIndex].Position.X - position.X)' 2) <= bestDistanceSquared
Magic Number,MatterHackers.PolygonMesh,FaceList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\FaceList.cs,ToIntArray,The following statement contains a magic number: var fa = new int[Count * 3];
Magic Number,MatterHackers.PolygonMesh,Mesh,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,Mesh,The following statement contains a magic number: this.Vertices.Add(new Vector3(v[vertexIndex + 0]'  					v[vertexIndex + 1]'  					v[vertexIndex + 2]));
Magic Number,MatterHackers.PolygonMesh,Mesh,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,Mesh,The following statement contains a magic number: vertexIndex < v.Length - 2
Magic Number,MatterHackers.PolygonMesh,Mesh,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,Mesh,The following statement contains a magic number: this.Faces.Add(f[faceIndex + 0]'  					f[faceIndex + 1]'  					f[faceIndex + 2]'  					this.Vertices);
Magic Number,MatterHackers.PolygonMesh,Mesh,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,Mesh,The following statement contains a magic number: faceIndex < f.Length - 2
Magic Number,MatterHackers.PolygonMesh,Mesh,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,MergeVertices,The following statement contains a magic number: Vertices.Count < 2
Magic Number,MatterHackers.PolygonMesh,Mesh,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,MergeVertices,The following statement contains a magic number: var tinyDistance = new Vector3Float(.001' .001' .001);
Magic Number,MatterHackers.PolygonMesh,Mesh,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,MergeVertices,The following statement contains a magic number: var tinyDistance = new Vector3Float(.001' .001' .001);
Magic Number,MatterHackers.PolygonMesh,Mesh,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,MergeVertices,The following statement contains a magic number: var tinyDistance = new Vector3Float(.001' .001' .001);
Magic Number,MatterHackers.PolygonMesh,Mesh,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,GetLongHashCode,The following statement contains a magic number: int vertexStep = Math.Max(1' Vertices.Count / 1000);
Magic Number,MatterHackers.PolygonMesh,Mesh,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,GetLongHashCode,The following statement contains a magic number: int faceStep = Math.Max(1' Faces.Count / 10000);
Magic Number,MatterHackers.PolygonMesh,Mesh,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,CreateFace,The following statement contains a magic number: this.Faces.Add(firstVertex' firstVertex + i + 1' firstVertex + i + 2' this.Vertices);
Magic Number,MatterHackers.PolygonMesh,Mesh,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,CreateFace,The following statement contains a magic number: i < addedPositions - 2
Magic Number,MatterHackers.PolygonMesh,Mesh,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,CreateFace,The following statement contains a magic number: this.Faces.Add(firstVertex' firstVertex + i + 1' firstVertex + i + 2' this.Vertices);
Magic Number,MatterHackers.PolygonMesh,Mesh,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,CreateFace,The following statement contains a magic number: i < addedPositions - 2
Magic Number,MatterHackers.PolygonMesh,FaceExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,Split,The following statement contains a magic number: var clipSegment = clipPoint.Select((a' i) =>  			{  				var nextI = (i + 1) % 3;  				// if both points are clipped and they are on opposite sides of the clip plane  				return clipPoint[i] && clipPoint[nextI] && ((dist[i] < 0 && dist[nextI] > 0) || (dist[i] > 0 && dist[nextI] < 0));  			}).ToArray();
Magic Number,MatterHackers.PolygonMesh,FaceExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,Split,The following statement contains a magic number: segmentsClipped += clipSegment[2] ? 1 : 0;
Magic Number,MatterHackers.PolygonMesh,FaceExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,Split,The following statement contains a magic number: var vi1 = (vi0 + 1) % 3;
Magic Number,MatterHackers.PolygonMesh,FaceExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,Split,The following statement contains a magic number: var vi2 = (vi0 + 2) % 3;
Magic Number,MatterHackers.PolygonMesh,FaceExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,Split,The following statement contains a magic number: var vi2 = (vi0 + 2) % 3;
Magic Number,MatterHackers.PolygonMesh,FaceExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,Split,The following statement contains a magic number: switch (segmentsClipped)  			{  				// if 2 sides are clipped we will add 2 new vertices and 3 polygons  				case 2:  					if (clipFace?.Invoke(new Mesh.SplitData(face' dist)) != false)  					{  						// find the side we are not going to clip  						int vi0 = clipSegment[0] && clipSegment[1] ? 2  							: clipSegment[0] && clipSegment[2] ? 1 : 0;  						var vi1 = (vi0 + 1) % 3;  						var vi2 = (vi0 + 2) % 3;  						// get the current count  						var vertexStart = newVertices.Count;  						// add the existing vertices  						newVertices.Add(v[vi0]);  						newVertices.Add(v[vi1]);  						newVertices.Add(v[vi2]);  						// clip the edges' will add the new points  						ClipEdge(vi1);  						ClipEdge(vi2);  						// add the new faces  						newFaces.Add(new Face(vertexStart' vertexStart + 1' vertexStart + 3' newVertices));  						newFaces.Add(new Face(vertexStart' vertexStart + 3' vertexStart + 4' newVertices));  						newFaces.Add(new Face(vertexStart + 3' vertexStart + 2' vertexStart + 4' newVertices));  						return true;  					}    					break;    				// if 1 side is clipped we will add 1 new vertex and 2 polygons  				case 1:  					{  						// find the side we are going to clip  						int vi0 = clipSegment[0] ? 0 : clipSegment[1] ? 1 : 2;  						var vi1 = (vi0 + 1) % 3;  						var vi2 = (vi0 + 2) % 3;  						// get the current count  						var vertexStart = newVertices.Count;  						// add the existing vertices  						newVertices.Add(v[vi0]);  						newVertices.Add(v[vi1]);  						newVertices.Add(v[vi2]);  						// clip the edge' will add the new point  						ClipEdge(vi0);  						// add the new faces  						newFaces.Add(new Face(vertexStart' vertexStart + 3' vertexStart + 2' newVertices));  						newFaces.Add(new Face(vertexStart + 3' vertexStart + 1' vertexStart + 2' newVertices));  					}    					return true;  			}
Magic Number,MatterHackers.PolygonMesh,FaceExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,Split,The following statement contains a magic number: switch (segmentsClipped)  			{  				// if 2 sides are clipped we will add 2 new vertices and 3 polygons  				case 2:  					if (clipFace?.Invoke(new Mesh.SplitData(face' dist)) != false)  					{  						// find the side we are not going to clip  						int vi0 = clipSegment[0] && clipSegment[1] ? 2  							: clipSegment[0] && clipSegment[2] ? 1 : 0;  						var vi1 = (vi0 + 1) % 3;  						var vi2 = (vi0 + 2) % 3;  						// get the current count  						var vertexStart = newVertices.Count;  						// add the existing vertices  						newVertices.Add(v[vi0]);  						newVertices.Add(v[vi1]);  						newVertices.Add(v[vi2]);  						// clip the edges' will add the new points  						ClipEdge(vi1);  						ClipEdge(vi2);  						// add the new faces  						newFaces.Add(new Face(vertexStart' vertexStart + 1' vertexStart + 3' newVertices));  						newFaces.Add(new Face(vertexStart' vertexStart + 3' vertexStart + 4' newVertices));  						newFaces.Add(new Face(vertexStart + 3' vertexStart + 2' vertexStart + 4' newVertices));  						return true;  					}    					break;    				// if 1 side is clipped we will add 1 new vertex and 2 polygons  				case 1:  					{  						// find the side we are going to clip  						int vi0 = clipSegment[0] ? 0 : clipSegment[1] ? 1 : 2;  						var vi1 = (vi0 + 1) % 3;  						var vi2 = (vi0 + 2) % 3;  						// get the current count  						var vertexStart = newVertices.Count;  						// add the existing vertices  						newVertices.Add(v[vi0]);  						newVertices.Add(v[vi1]);  						newVertices.Add(v[vi2]);  						// clip the edge' will add the new point  						ClipEdge(vi0);  						// add the new faces  						newFaces.Add(new Face(vertexStart' vertexStart + 3' vertexStart + 2' newVertices));  						newFaces.Add(new Face(vertexStart + 3' vertexStart + 1' vertexStart + 2' newVertices));  					}    					return true;  			}
Magic Number,MatterHackers.PolygonMesh,FaceExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,Split,The following statement contains a magic number: switch (segmentsClipped)  			{  				// if 2 sides are clipped we will add 2 new vertices and 3 polygons  				case 2:  					if (clipFace?.Invoke(new Mesh.SplitData(face' dist)) != false)  					{  						// find the side we are not going to clip  						int vi0 = clipSegment[0] && clipSegment[1] ? 2  							: clipSegment[0] && clipSegment[2] ? 1 : 0;  						var vi1 = (vi0 + 1) % 3;  						var vi2 = (vi0 + 2) % 3;  						// get the current count  						var vertexStart = newVertices.Count;  						// add the existing vertices  						newVertices.Add(v[vi0]);  						newVertices.Add(v[vi1]);  						newVertices.Add(v[vi2]);  						// clip the edges' will add the new points  						ClipEdge(vi1);  						ClipEdge(vi2);  						// add the new faces  						newFaces.Add(new Face(vertexStart' vertexStart + 1' vertexStart + 3' newVertices));  						newFaces.Add(new Face(vertexStart' vertexStart + 3' vertexStart + 4' newVertices));  						newFaces.Add(new Face(vertexStart + 3' vertexStart + 2' vertexStart + 4' newVertices));  						return true;  					}    					break;    				// if 1 side is clipped we will add 1 new vertex and 2 polygons  				case 1:  					{  						// find the side we are going to clip  						int vi0 = clipSegment[0] ? 0 : clipSegment[1] ? 1 : 2;  						var vi1 = (vi0 + 1) % 3;  						var vi2 = (vi0 + 2) % 3;  						// get the current count  						var vertexStart = newVertices.Count;  						// add the existing vertices  						newVertices.Add(v[vi0]);  						newVertices.Add(v[vi1]);  						newVertices.Add(v[vi2]);  						// clip the edge' will add the new point  						ClipEdge(vi0);  						// add the new faces  						newFaces.Add(new Face(vertexStart' vertexStart + 3' vertexStart + 2' newVertices));  						newFaces.Add(new Face(vertexStart + 3' vertexStart + 1' vertexStart + 2' newVertices));  					}    					return true;  			}
Magic Number,MatterHackers.PolygonMesh,FaceExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,Split,The following statement contains a magic number: switch (segmentsClipped)  			{  				// if 2 sides are clipped we will add 2 new vertices and 3 polygons  				case 2:  					if (clipFace?.Invoke(new Mesh.SplitData(face' dist)) != false)  					{  						// find the side we are not going to clip  						int vi0 = clipSegment[0] && clipSegment[1] ? 2  							: clipSegment[0] && clipSegment[2] ? 1 : 0;  						var vi1 = (vi0 + 1) % 3;  						var vi2 = (vi0 + 2) % 3;  						// get the current count  						var vertexStart = newVertices.Count;  						// add the existing vertices  						newVertices.Add(v[vi0]);  						newVertices.Add(v[vi1]);  						newVertices.Add(v[vi2]);  						// clip the edges' will add the new points  						ClipEdge(vi1);  						ClipEdge(vi2);  						// add the new faces  						newFaces.Add(new Face(vertexStart' vertexStart + 1' vertexStart + 3' newVertices));  						newFaces.Add(new Face(vertexStart' vertexStart + 3' vertexStart + 4' newVertices));  						newFaces.Add(new Face(vertexStart + 3' vertexStart + 2' vertexStart + 4' newVertices));  						return true;  					}    					break;    				// if 1 side is clipped we will add 1 new vertex and 2 polygons  				case 1:  					{  						// find the side we are going to clip  						int vi0 = clipSegment[0] ? 0 : clipSegment[1] ? 1 : 2;  						var vi1 = (vi0 + 1) % 3;  						var vi2 = (vi0 + 2) % 3;  						// get the current count  						var vertexStart = newVertices.Count;  						// add the existing vertices  						newVertices.Add(v[vi0]);  						newVertices.Add(v[vi1]);  						newVertices.Add(v[vi2]);  						// clip the edge' will add the new point  						ClipEdge(vi0);  						// add the new faces  						newFaces.Add(new Face(vertexStart' vertexStart + 3' vertexStart + 2' newVertices));  						newFaces.Add(new Face(vertexStart + 3' vertexStart + 1' vertexStart + 2' newVertices));  					}    					return true;  			}
Magic Number,MatterHackers.PolygonMesh,FaceExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,Split,The following statement contains a magic number: switch (segmentsClipped)  			{  				// if 2 sides are clipped we will add 2 new vertices and 3 polygons  				case 2:  					if (clipFace?.Invoke(new Mesh.SplitData(face' dist)) != false)  					{  						// find the side we are not going to clip  						int vi0 = clipSegment[0] && clipSegment[1] ? 2  							: clipSegment[0] && clipSegment[2] ? 1 : 0;  						var vi1 = (vi0 + 1) % 3;  						var vi2 = (vi0 + 2) % 3;  						// get the current count  						var vertexStart = newVertices.Count;  						// add the existing vertices  						newVertices.Add(v[vi0]);  						newVertices.Add(v[vi1]);  						newVertices.Add(v[vi2]);  						// clip the edges' will add the new points  						ClipEdge(vi1);  						ClipEdge(vi2);  						// add the new faces  						newFaces.Add(new Face(vertexStart' vertexStart + 1' vertexStart + 3' newVertices));  						newFaces.Add(new Face(vertexStart' vertexStart + 3' vertexStart + 4' newVertices));  						newFaces.Add(new Face(vertexStart + 3' vertexStart + 2' vertexStart + 4' newVertices));  						return true;  					}    					break;    				// if 1 side is clipped we will add 1 new vertex and 2 polygons  				case 1:  					{  						// find the side we are going to clip  						int vi0 = clipSegment[0] ? 0 : clipSegment[1] ? 1 : 2;  						var vi1 = (vi0 + 1) % 3;  						var vi2 = (vi0 + 2) % 3;  						// get the current count  						var vertexStart = newVertices.Count;  						// add the existing vertices  						newVertices.Add(v[vi0]);  						newVertices.Add(v[vi1]);  						newVertices.Add(v[vi2]);  						// clip the edge' will add the new point  						ClipEdge(vi0);  						// add the new faces  						newFaces.Add(new Face(vertexStart' vertexStart + 3' vertexStart + 2' newVertices));  						newFaces.Add(new Face(vertexStart + 3' vertexStart + 1' vertexStart + 2' newVertices));  					}    					return true;  			}
Magic Number,MatterHackers.PolygonMesh,FaceExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,Split,The following statement contains a magic number: switch (segmentsClipped)  			{  				// if 2 sides are clipped we will add 2 new vertices and 3 polygons  				case 2:  					if (clipFace?.Invoke(new Mesh.SplitData(face' dist)) != false)  					{  						// find the side we are not going to clip  						int vi0 = clipSegment[0] && clipSegment[1] ? 2  							: clipSegment[0] && clipSegment[2] ? 1 : 0;  						var vi1 = (vi0 + 1) % 3;  						var vi2 = (vi0 + 2) % 3;  						// get the current count  						var vertexStart = newVertices.Count;  						// add the existing vertices  						newVertices.Add(v[vi0]);  						newVertices.Add(v[vi1]);  						newVertices.Add(v[vi2]);  						// clip the edges' will add the new points  						ClipEdge(vi1);  						ClipEdge(vi2);  						// add the new faces  						newFaces.Add(new Face(vertexStart' vertexStart + 1' vertexStart + 3' newVertices));  						newFaces.Add(new Face(vertexStart' vertexStart + 3' vertexStart + 4' newVertices));  						newFaces.Add(new Face(vertexStart + 3' vertexStart + 2' vertexStart + 4' newVertices));  						return true;  					}    					break;    				// if 1 side is clipped we will add 1 new vertex and 2 polygons  				case 1:  					{  						// find the side we are going to clip  						int vi0 = clipSegment[0] ? 0 : clipSegment[1] ? 1 : 2;  						var vi1 = (vi0 + 1) % 3;  						var vi2 = (vi0 + 2) % 3;  						// get the current count  						var vertexStart = newVertices.Count;  						// add the existing vertices  						newVertices.Add(v[vi0]);  						newVertices.Add(v[vi1]);  						newVertices.Add(v[vi2]);  						// clip the edge' will add the new point  						ClipEdge(vi0);  						// add the new faces  						newFaces.Add(new Face(vertexStart' vertexStart + 3' vertexStart + 2' newVertices));  						newFaces.Add(new Face(vertexStart + 3' vertexStart + 1' vertexStart + 2' newVertices));  					}    					return true;  			}
Magic Number,MatterHackers.PolygonMesh,FaceExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,Split,The following statement contains a magic number: switch (segmentsClipped)  			{  				// if 2 sides are clipped we will add 2 new vertices and 3 polygons  				case 2:  					if (clipFace?.Invoke(new Mesh.SplitData(face' dist)) != false)  					{  						// find the side we are not going to clip  						int vi0 = clipSegment[0] && clipSegment[1] ? 2  							: clipSegment[0] && clipSegment[2] ? 1 : 0;  						var vi1 = (vi0 + 1) % 3;  						var vi2 = (vi0 + 2) % 3;  						// get the current count  						var vertexStart = newVertices.Count;  						// add the existing vertices  						newVertices.Add(v[vi0]);  						newVertices.Add(v[vi1]);  						newVertices.Add(v[vi2]);  						// clip the edges' will add the new points  						ClipEdge(vi1);  						ClipEdge(vi2);  						// add the new faces  						newFaces.Add(new Face(vertexStart' vertexStart + 1' vertexStart + 3' newVertices));  						newFaces.Add(new Face(vertexStart' vertexStart + 3' vertexStart + 4' newVertices));  						newFaces.Add(new Face(vertexStart + 3' vertexStart + 2' vertexStart + 4' newVertices));  						return true;  					}    					break;    				// if 1 side is clipped we will add 1 new vertex and 2 polygons  				case 1:  					{  						// find the side we are going to clip  						int vi0 = clipSegment[0] ? 0 : clipSegment[1] ? 1 : 2;  						var vi1 = (vi0 + 1) % 3;  						var vi2 = (vi0 + 2) % 3;  						// get the current count  						var vertexStart = newVertices.Count;  						// add the existing vertices  						newVertices.Add(v[vi0]);  						newVertices.Add(v[vi1]);  						newVertices.Add(v[vi2]);  						// clip the edge' will add the new point  						ClipEdge(vi0);  						// add the new faces  						newFaces.Add(new Face(vertexStart' vertexStart + 3' vertexStart + 2' newVertices));  						newFaces.Add(new Face(vertexStart + 3' vertexStart + 1' vertexStart + 2' newVertices));  					}    					return true;  			}
Magic Number,MatterHackers.PolygonMesh,FaceExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,Split,The following statement contains a magic number: switch (segmentsClipped)  			{  				// if 2 sides are clipped we will add 2 new vertices and 3 polygons  				case 2:  					if (clipFace?.Invoke(new Mesh.SplitData(face' dist)) != false)  					{  						// find the side we are not going to clip  						int vi0 = clipSegment[0] && clipSegment[1] ? 2  							: clipSegment[0] && clipSegment[2] ? 1 : 0;  						var vi1 = (vi0 + 1) % 3;  						var vi2 = (vi0 + 2) % 3;  						// get the current count  						var vertexStart = newVertices.Count;  						// add the existing vertices  						newVertices.Add(v[vi0]);  						newVertices.Add(v[vi1]);  						newVertices.Add(v[vi2]);  						// clip the edges' will add the new points  						ClipEdge(vi1);  						ClipEdge(vi2);  						// add the new faces  						newFaces.Add(new Face(vertexStart' vertexStart + 1' vertexStart + 3' newVertices));  						newFaces.Add(new Face(vertexStart' vertexStart + 3' vertexStart + 4' newVertices));  						newFaces.Add(new Face(vertexStart + 3' vertexStart + 2' vertexStart + 4' newVertices));  						return true;  					}    					break;    				// if 1 side is clipped we will add 1 new vertex and 2 polygons  				case 1:  					{  						// find the side we are going to clip  						int vi0 = clipSegment[0] ? 0 : clipSegment[1] ? 1 : 2;  						var vi1 = (vi0 + 1) % 3;  						var vi2 = (vi0 + 2) % 3;  						// get the current count  						var vertexStart = newVertices.Count;  						// add the existing vertices  						newVertices.Add(v[vi0]);  						newVertices.Add(v[vi1]);  						newVertices.Add(v[vi2]);  						// clip the edge' will add the new point  						ClipEdge(vi0);  						// add the new faces  						newFaces.Add(new Face(vertexStart' vertexStart + 3' vertexStart + 2' newVertices));  						newFaces.Add(new Face(vertexStart + 3' vertexStart + 1' vertexStart + 2' newVertices));  					}    					return true;  			}
Magic Number,MatterHackers.PolygonMesh,FaceExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,Split,The following statement contains a magic number: switch (segmentsClipped)  			{  				// if 2 sides are clipped we will add 2 new vertices and 3 polygons  				case 2:  					if (clipFace?.Invoke(new Mesh.SplitData(face' dist)) != false)  					{  						// find the side we are not going to clip  						int vi0 = clipSegment[0] && clipSegment[1] ? 2  							: clipSegment[0] && clipSegment[2] ? 1 : 0;  						var vi1 = (vi0 + 1) % 3;  						var vi2 = (vi0 + 2) % 3;  						// get the current count  						var vertexStart = newVertices.Count;  						// add the existing vertices  						newVertices.Add(v[vi0]);  						newVertices.Add(v[vi1]);  						newVertices.Add(v[vi2]);  						// clip the edges' will add the new points  						ClipEdge(vi1);  						ClipEdge(vi2);  						// add the new faces  						newFaces.Add(new Face(vertexStart' vertexStart + 1' vertexStart + 3' newVertices));  						newFaces.Add(new Face(vertexStart' vertexStart + 3' vertexStart + 4' newVertices));  						newFaces.Add(new Face(vertexStart + 3' vertexStart + 2' vertexStart + 4' newVertices));  						return true;  					}    					break;    				// if 1 side is clipped we will add 1 new vertex and 2 polygons  				case 1:  					{  						// find the side we are going to clip  						int vi0 = clipSegment[0] ? 0 : clipSegment[1] ? 1 : 2;  						var vi1 = (vi0 + 1) % 3;  						var vi2 = (vi0 + 2) % 3;  						// get the current count  						var vertexStart = newVertices.Count;  						// add the existing vertices  						newVertices.Add(v[vi0]);  						newVertices.Add(v[vi1]);  						newVertices.Add(v[vi2]);  						// clip the edge' will add the new point  						ClipEdge(vi0);  						// add the new faces  						newFaces.Add(new Face(vertexStart' vertexStart + 3' vertexStart + 2' newVertices));  						newFaces.Add(new Face(vertexStart + 3' vertexStart + 1' vertexStart + 2' newVertices));  					}    					return true;  			}
Magic Number,MatterHackers.PolygonMesh,FaceExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,Split,The following statement contains a magic number: switch (segmentsClipped)  			{  				// if 2 sides are clipped we will add 2 new vertices and 3 polygons  				case 2:  					if (clipFace?.Invoke(new Mesh.SplitData(face' dist)) != false)  					{  						// find the side we are not going to clip  						int vi0 = clipSegment[0] && clipSegment[1] ? 2  							: clipSegment[0] && clipSegment[2] ? 1 : 0;  						var vi1 = (vi0 + 1) % 3;  						var vi2 = (vi0 + 2) % 3;  						// get the current count  						var vertexStart = newVertices.Count;  						// add the existing vertices  						newVertices.Add(v[vi0]);  						newVertices.Add(v[vi1]);  						newVertices.Add(v[vi2]);  						// clip the edges' will add the new points  						ClipEdge(vi1);  						ClipEdge(vi2);  						// add the new faces  						newFaces.Add(new Face(vertexStart' vertexStart + 1' vertexStart + 3' newVertices));  						newFaces.Add(new Face(vertexStart' vertexStart + 3' vertexStart + 4' newVertices));  						newFaces.Add(new Face(vertexStart + 3' vertexStart + 2' vertexStart + 4' newVertices));  						return true;  					}    					break;    				// if 1 side is clipped we will add 1 new vertex and 2 polygons  				case 1:  					{  						// find the side we are going to clip  						int vi0 = clipSegment[0] ? 0 : clipSegment[1] ? 1 : 2;  						var vi1 = (vi0 + 1) % 3;  						var vi2 = (vi0 + 2) % 3;  						// get the current count  						var vertexStart = newVertices.Count;  						// add the existing vertices  						newVertices.Add(v[vi0]);  						newVertices.Add(v[vi1]);  						newVertices.Add(v[vi2]);  						// clip the edge' will add the new point  						ClipEdge(vi0);  						// add the new faces  						newFaces.Add(new Face(vertexStart' vertexStart + 3' vertexStart + 2' newVertices));  						newFaces.Add(new Face(vertexStart + 3' vertexStart + 1' vertexStart + 2' newVertices));  					}    					return true;  			}
Magic Number,MatterHackers.PolygonMesh,FaceExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,Split,The following statement contains a magic number: switch (segmentsClipped)  			{  				// if 2 sides are clipped we will add 2 new vertices and 3 polygons  				case 2:  					if (clipFace?.Invoke(new Mesh.SplitData(face' dist)) != false)  					{  						// find the side we are not going to clip  						int vi0 = clipSegment[0] && clipSegment[1] ? 2  							: clipSegment[0] && clipSegment[2] ? 1 : 0;  						var vi1 = (vi0 + 1) % 3;  						var vi2 = (vi0 + 2) % 3;  						// get the current count  						var vertexStart = newVertices.Count;  						// add the existing vertices  						newVertices.Add(v[vi0]);  						newVertices.Add(v[vi1]);  						newVertices.Add(v[vi2]);  						// clip the edges' will add the new points  						ClipEdge(vi1);  						ClipEdge(vi2);  						// add the new faces  						newFaces.Add(new Face(vertexStart' vertexStart + 1' vertexStart + 3' newVertices));  						newFaces.Add(new Face(vertexStart' vertexStart + 3' vertexStart + 4' newVertices));  						newFaces.Add(new Face(vertexStart + 3' vertexStart + 2' vertexStart + 4' newVertices));  						return true;  					}    					break;    				// if 1 side is clipped we will add 1 new vertex and 2 polygons  				case 1:  					{  						// find the side we are going to clip  						int vi0 = clipSegment[0] ? 0 : clipSegment[1] ? 1 : 2;  						var vi1 = (vi0 + 1) % 3;  						var vi2 = (vi0 + 2) % 3;  						// get the current count  						var vertexStart = newVertices.Count;  						// add the existing vertices  						newVertices.Add(v[vi0]);  						newVertices.Add(v[vi1]);  						newVertices.Add(v[vi2]);  						// clip the edge' will add the new point  						ClipEdge(vi0);  						// add the new faces  						newFaces.Add(new Face(vertexStart' vertexStart + 3' vertexStart + 2' newVertices));  						newFaces.Add(new Face(vertexStart + 3' vertexStart + 1' vertexStart + 2' newVertices));  					}    					return true;  			}
Magic Number,MatterHackers.PolygonMesh,FaceExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,Split,The following statement contains a magic number: switch (segmentsClipped)  			{  				// if 2 sides are clipped we will add 2 new vertices and 3 polygons  				case 2:  					if (clipFace?.Invoke(new Mesh.SplitData(face' dist)) != false)  					{  						// find the side we are not going to clip  						int vi0 = clipSegment[0] && clipSegment[1] ? 2  							: clipSegment[0] && clipSegment[2] ? 1 : 0;  						var vi1 = (vi0 + 1) % 3;  						var vi2 = (vi0 + 2) % 3;  						// get the current count  						var vertexStart = newVertices.Count;  						// add the existing vertices  						newVertices.Add(v[vi0]);  						newVertices.Add(v[vi1]);  						newVertices.Add(v[vi2]);  						// clip the edges' will add the new points  						ClipEdge(vi1);  						ClipEdge(vi2);  						// add the new faces  						newFaces.Add(new Face(vertexStart' vertexStart + 1' vertexStart + 3' newVertices));  						newFaces.Add(new Face(vertexStart' vertexStart + 3' vertexStart + 4' newVertices));  						newFaces.Add(new Face(vertexStart + 3' vertexStart + 2' vertexStart + 4' newVertices));  						return true;  					}    					break;    				// if 1 side is clipped we will add 1 new vertex and 2 polygons  				case 1:  					{  						// find the side we are going to clip  						int vi0 = clipSegment[0] ? 0 : clipSegment[1] ? 1 : 2;  						var vi1 = (vi0 + 1) % 3;  						var vi2 = (vi0 + 2) % 3;  						// get the current count  						var vertexStart = newVertices.Count;  						// add the existing vertices  						newVertices.Add(v[vi0]);  						newVertices.Add(v[vi1]);  						newVertices.Add(v[vi2]);  						// clip the edge' will add the new point  						ClipEdge(vi0);  						// add the new faces  						newFaces.Add(new Face(vertexStart' vertexStart + 3' vertexStart + 2' newVertices));  						newFaces.Add(new Face(vertexStart + 3' vertexStart + 1' vertexStart + 2' newVertices));  					}    					return true;  			}
Magic Number,MatterHackers.PolygonMesh,FaceExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,Split,The following statement contains a magic number: switch (segmentsClipped)  			{  				// if 2 sides are clipped we will add 2 new vertices and 3 polygons  				case 2:  					if (clipFace?.Invoke(new Mesh.SplitData(face' dist)) != false)  					{  						// find the side we are not going to clip  						int vi0 = clipSegment[0] && clipSegment[1] ? 2  							: clipSegment[0] && clipSegment[2] ? 1 : 0;  						var vi1 = (vi0 + 1) % 3;  						var vi2 = (vi0 + 2) % 3;  						// get the current count  						var vertexStart = newVertices.Count;  						// add the existing vertices  						newVertices.Add(v[vi0]);  						newVertices.Add(v[vi1]);  						newVertices.Add(v[vi2]);  						// clip the edges' will add the new points  						ClipEdge(vi1);  						ClipEdge(vi2);  						// add the new faces  						newFaces.Add(new Face(vertexStart' vertexStart + 1' vertexStart + 3' newVertices));  						newFaces.Add(new Face(vertexStart' vertexStart + 3' vertexStart + 4' newVertices));  						newFaces.Add(new Face(vertexStart + 3' vertexStart + 2' vertexStart + 4' newVertices));  						return true;  					}    					break;    				// if 1 side is clipped we will add 1 new vertex and 2 polygons  				case 1:  					{  						// find the side we are going to clip  						int vi0 = clipSegment[0] ? 0 : clipSegment[1] ? 1 : 2;  						var vi1 = (vi0 + 1) % 3;  						var vi2 = (vi0 + 2) % 3;  						// get the current count  						var vertexStart = newVertices.Count;  						// add the existing vertices  						newVertices.Add(v[vi0]);  						newVertices.Add(v[vi1]);  						newVertices.Add(v[vi2]);  						// clip the edge' will add the new point  						ClipEdge(vi0);  						// add the new faces  						newFaces.Add(new Face(vertexStart' vertexStart + 3' vertexStart + 2' newVertices));  						newFaces.Add(new Face(vertexStart + 3' vertexStart + 1' vertexStart + 2' newVertices));  					}    					return true;  			}
Magic Number,MatterHackers.PolygonMesh,FaceExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,Split,The following statement contains a magic number: switch (segmentsClipped)  			{  				// if 2 sides are clipped we will add 2 new vertices and 3 polygons  				case 2:  					if (clipFace?.Invoke(new Mesh.SplitData(face' dist)) != false)  					{  						// find the side we are not going to clip  						int vi0 = clipSegment[0] && clipSegment[1] ? 2  							: clipSegment[0] && clipSegment[2] ? 1 : 0;  						var vi1 = (vi0 + 1) % 3;  						var vi2 = (vi0 + 2) % 3;  						// get the current count  						var vertexStart = newVertices.Count;  						// add the existing vertices  						newVertices.Add(v[vi0]);  						newVertices.Add(v[vi1]);  						newVertices.Add(v[vi2]);  						// clip the edges' will add the new points  						ClipEdge(vi1);  						ClipEdge(vi2);  						// add the new faces  						newFaces.Add(new Face(vertexStart' vertexStart + 1' vertexStart + 3' newVertices));  						newFaces.Add(new Face(vertexStart' vertexStart + 3' vertexStart + 4' newVertices));  						newFaces.Add(new Face(vertexStart + 3' vertexStart + 2' vertexStart + 4' newVertices));  						return true;  					}    					break;    				// if 1 side is clipped we will add 1 new vertex and 2 polygons  				case 1:  					{  						// find the side we are going to clip  						int vi0 = clipSegment[0] ? 0 : clipSegment[1] ? 1 : 2;  						var vi1 = (vi0 + 1) % 3;  						var vi2 = (vi0 + 2) % 3;  						// get the current count  						var vertexStart = newVertices.Count;  						// add the existing vertices  						newVertices.Add(v[vi0]);  						newVertices.Add(v[vi1]);  						newVertices.Add(v[vi2]);  						// clip the edge' will add the new point  						ClipEdge(vi0);  						// add the new faces  						newFaces.Add(new Face(vertexStart' vertexStart + 3' vertexStart + 2' newVertices));  						newFaces.Add(new Face(vertexStart + 3' vertexStart + 1' vertexStart + 2' newVertices));  					}    					return true;  			}
Magic Number,MatterHackers.PolygonMesh,FaceExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,Split,The following statement contains a magic number: switch (segmentsClipped)  			{  				// if 2 sides are clipped we will add 2 new vertices and 3 polygons  				case 2:  					if (clipFace?.Invoke(new Mesh.SplitData(face' dist)) != false)  					{  						// find the side we are not going to clip  						int vi0 = clipSegment[0] && clipSegment[1] ? 2  							: clipSegment[0] && clipSegment[2] ? 1 : 0;  						var vi1 = (vi0 + 1) % 3;  						var vi2 = (vi0 + 2) % 3;  						// get the current count  						var vertexStart = newVertices.Count;  						// add the existing vertices  						newVertices.Add(v[vi0]);  						newVertices.Add(v[vi1]);  						newVertices.Add(v[vi2]);  						// clip the edges' will add the new points  						ClipEdge(vi1);  						ClipEdge(vi2);  						// add the new faces  						newFaces.Add(new Face(vertexStart' vertexStart + 1' vertexStart + 3' newVertices));  						newFaces.Add(new Face(vertexStart' vertexStart + 3' vertexStart + 4' newVertices));  						newFaces.Add(new Face(vertexStart + 3' vertexStart + 2' vertexStart + 4' newVertices));  						return true;  					}    					break;    				// if 1 side is clipped we will add 1 new vertex and 2 polygons  				case 1:  					{  						// find the side we are going to clip  						int vi0 = clipSegment[0] ? 0 : clipSegment[1] ? 1 : 2;  						var vi1 = (vi0 + 1) % 3;  						var vi2 = (vi0 + 2) % 3;  						// get the current count  						var vertexStart = newVertices.Count;  						// add the existing vertices  						newVertices.Add(v[vi0]);  						newVertices.Add(v[vi1]);  						newVertices.Add(v[vi2]);  						// clip the edge' will add the new point  						ClipEdge(vi0);  						// add the new faces  						newFaces.Add(new Face(vertexStart' vertexStart + 3' vertexStart + 2' newVertices));  						newFaces.Add(new Face(vertexStart + 3' vertexStart + 1' vertexStart + 2' newVertices));  					}    					return true;  			}
Magic Number,MatterHackers.PolygonMesh,FaceExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,Split,The following statement contains a magic number: switch (segmentsClipped)  			{  				// if 2 sides are clipped we will add 2 new vertices and 3 polygons  				case 2:  					if (clipFace?.Invoke(new Mesh.SplitData(face' dist)) != false)  					{  						// find the side we are not going to clip  						int vi0 = clipSegment[0] && clipSegment[1] ? 2  							: clipSegment[0] && clipSegment[2] ? 1 : 0;  						var vi1 = (vi0 + 1) % 3;  						var vi2 = (vi0 + 2) % 3;  						// get the current count  						var vertexStart = newVertices.Count;  						// add the existing vertices  						newVertices.Add(v[vi0]);  						newVertices.Add(v[vi1]);  						newVertices.Add(v[vi2]);  						// clip the edges' will add the new points  						ClipEdge(vi1);  						ClipEdge(vi2);  						// add the new faces  						newFaces.Add(new Face(vertexStart' vertexStart + 1' vertexStart + 3' newVertices));  						newFaces.Add(new Face(vertexStart' vertexStart + 3' vertexStart + 4' newVertices));  						newFaces.Add(new Face(vertexStart + 3' vertexStart + 2' vertexStart + 4' newVertices));  						return true;  					}    					break;    				// if 1 side is clipped we will add 1 new vertex and 2 polygons  				case 1:  					{  						// find the side we are going to clip  						int vi0 = clipSegment[0] ? 0 : clipSegment[1] ? 1 : 2;  						var vi1 = (vi0 + 1) % 3;  						var vi2 = (vi0 + 2) % 3;  						// get the current count  						var vertexStart = newVertices.Count;  						// add the existing vertices  						newVertices.Add(v[vi0]);  						newVertices.Add(v[vi1]);  						newVertices.Add(v[vi2]);  						// clip the edge' will add the new point  						ClipEdge(vi0);  						// add the new faces  						newFaces.Add(new Face(vertexStart' vertexStart + 3' vertexStart + 2' newVertices));  						newFaces.Add(new Face(vertexStart + 3' vertexStart + 1' vertexStart + 2' newVertices));  					}    					return true;  			}
Magic Number,MatterHackers.PolygonMesh,FaceExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,Split,The following statement contains a magic number: switch (segmentsClipped)  			{  				// if 2 sides are clipped we will add 2 new vertices and 3 polygons  				case 2:  					if (clipFace?.Invoke(new Mesh.SplitData(face' dist)) != false)  					{  						// find the side we are not going to clip  						int vi0 = clipSegment[0] && clipSegment[1] ? 2  							: clipSegment[0] && clipSegment[2] ? 1 : 0;  						var vi1 = (vi0 + 1) % 3;  						var vi2 = (vi0 + 2) % 3;  						// get the current count  						var vertexStart = newVertices.Count;  						// add the existing vertices  						newVertices.Add(v[vi0]);  						newVertices.Add(v[vi1]);  						newVertices.Add(v[vi2]);  						// clip the edges' will add the new points  						ClipEdge(vi1);  						ClipEdge(vi2);  						// add the new faces  						newFaces.Add(new Face(vertexStart' vertexStart + 1' vertexStart + 3' newVertices));  						newFaces.Add(new Face(vertexStart' vertexStart + 3' vertexStart + 4' newVertices));  						newFaces.Add(new Face(vertexStart + 3' vertexStart + 2' vertexStart + 4' newVertices));  						return true;  					}    					break;    				// if 1 side is clipped we will add 1 new vertex and 2 polygons  				case 1:  					{  						// find the side we are going to clip  						int vi0 = clipSegment[0] ? 0 : clipSegment[1] ? 1 : 2;  						var vi1 = (vi0 + 1) % 3;  						var vi2 = (vi0 + 2) % 3;  						// get the current count  						var vertexStart = newVertices.Count;  						// add the existing vertices  						newVertices.Add(v[vi0]);  						newVertices.Add(v[vi1]);  						newVertices.Add(v[vi2]);  						// clip the edge' will add the new point  						ClipEdge(vi0);  						// add the new faces  						newFaces.Add(new Face(vertexStart' vertexStart + 3' vertexStart + 2' newVertices));  						newFaces.Add(new Face(vertexStart + 3' vertexStart + 1' vertexStart + 2' newVertices));  					}    					return true;  			}
Magic Number,MatterHackers.PolygonMesh,FaceExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,Split,The following statement contains a magic number: switch (segmentsClipped)  			{  				// if 2 sides are clipped we will add 2 new vertices and 3 polygons  				case 2:  					if (clipFace?.Invoke(new Mesh.SplitData(face' dist)) != false)  					{  						// find the side we are not going to clip  						int vi0 = clipSegment[0] && clipSegment[1] ? 2  							: clipSegment[0] && clipSegment[2] ? 1 : 0;  						var vi1 = (vi0 + 1) % 3;  						var vi2 = (vi0 + 2) % 3;  						// get the current count  						var vertexStart = newVertices.Count;  						// add the existing vertices  						newVertices.Add(v[vi0]);  						newVertices.Add(v[vi1]);  						newVertices.Add(v[vi2]);  						// clip the edges' will add the new points  						ClipEdge(vi1);  						ClipEdge(vi2);  						// add the new faces  						newFaces.Add(new Face(vertexStart' vertexStart + 1' vertexStart + 3' newVertices));  						newFaces.Add(new Face(vertexStart' vertexStart + 3' vertexStart + 4' newVertices));  						newFaces.Add(new Face(vertexStart + 3' vertexStart + 2' vertexStart + 4' newVertices));  						return true;  					}    					break;    				// if 1 side is clipped we will add 1 new vertex and 2 polygons  				case 1:  					{  						// find the side we are going to clip  						int vi0 = clipSegment[0] ? 0 : clipSegment[1] ? 1 : 2;  						var vi1 = (vi0 + 1) % 3;  						var vi2 = (vi0 + 2) % 3;  						// get the current count  						var vertexStart = newVertices.Count;  						// add the existing vertices  						newVertices.Add(v[vi0]);  						newVertices.Add(v[vi1]);  						newVertices.Add(v[vi2]);  						// clip the edge' will add the new point  						ClipEdge(vi0);  						// add the new faces  						newFaces.Add(new Face(vertexStart' vertexStart + 3' vertexStart + 2' newVertices));  						newFaces.Add(new Face(vertexStart + 3' vertexStart + 1' vertexStart + 2' newVertices));  					}    					return true;  			}
Magic Number,MatterHackers.PolygonMesh,FaceExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,Split,The following statement contains a magic number: switch (segmentsClipped)  			{  				// if 2 sides are clipped we will add 2 new vertices and 3 polygons  				case 2:  					if (clipFace?.Invoke(new Mesh.SplitData(face' dist)) != false)  					{  						// find the side we are not going to clip  						int vi0 = clipSegment[0] && clipSegment[1] ? 2  							: clipSegment[0] && clipSegment[2] ? 1 : 0;  						var vi1 = (vi0 + 1) % 3;  						var vi2 = (vi0 + 2) % 3;  						// get the current count  						var vertexStart = newVertices.Count;  						// add the existing vertices  						newVertices.Add(v[vi0]);  						newVertices.Add(v[vi1]);  						newVertices.Add(v[vi2]);  						// clip the edges' will add the new points  						ClipEdge(vi1);  						ClipEdge(vi2);  						// add the new faces  						newFaces.Add(new Face(vertexStart' vertexStart + 1' vertexStart + 3' newVertices));  						newFaces.Add(new Face(vertexStart' vertexStart + 3' vertexStart + 4' newVertices));  						newFaces.Add(new Face(vertexStart + 3' vertexStart + 2' vertexStart + 4' newVertices));  						return true;  					}    					break;    				// if 1 side is clipped we will add 1 new vertex and 2 polygons  				case 1:  					{  						// find the side we are going to clip  						int vi0 = clipSegment[0] ? 0 : clipSegment[1] ? 1 : 2;  						var vi1 = (vi0 + 1) % 3;  						var vi2 = (vi0 + 2) % 3;  						// get the current count  						var vertexStart = newVertices.Count;  						// add the existing vertices  						newVertices.Add(v[vi0]);  						newVertices.Add(v[vi1]);  						newVertices.Add(v[vi2]);  						// clip the edge' will add the new point  						ClipEdge(vi0);  						// add the new faces  						newFaces.Add(new Face(vertexStart' vertexStart + 3' vertexStart + 2' newVertices));  						newFaces.Add(new Face(vertexStart + 3' vertexStart + 1' vertexStart + 2' newVertices));  					}    					return true;  			}
Magic Number,MatterHackers.PolygonMesh,FaceExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,Split,The following statement contains a magic number: switch (segmentsClipped)  			{  				// if 2 sides are clipped we will add 2 new vertices and 3 polygons  				case 2:  					if (clipFace?.Invoke(new Mesh.SplitData(face' dist)) != false)  					{  						// find the side we are not going to clip  						int vi0 = clipSegment[0] && clipSegment[1] ? 2  							: clipSegment[0] && clipSegment[2] ? 1 : 0;  						var vi1 = (vi0 + 1) % 3;  						var vi2 = (vi0 + 2) % 3;  						// get the current count  						var vertexStart = newVertices.Count;  						// add the existing vertices  						newVertices.Add(v[vi0]);  						newVertices.Add(v[vi1]);  						newVertices.Add(v[vi2]);  						// clip the edges' will add the new points  						ClipEdge(vi1);  						ClipEdge(vi2);  						// add the new faces  						newFaces.Add(new Face(vertexStart' vertexStart + 1' vertexStart + 3' newVertices));  						newFaces.Add(new Face(vertexStart' vertexStart + 3' vertexStart + 4' newVertices));  						newFaces.Add(new Face(vertexStart + 3' vertexStart + 2' vertexStart + 4' newVertices));  						return true;  					}    					break;    				// if 1 side is clipped we will add 1 new vertex and 2 polygons  				case 1:  					{  						// find the side we are going to clip  						int vi0 = clipSegment[0] ? 0 : clipSegment[1] ? 1 : 2;  						var vi1 = (vi0 + 1) % 3;  						var vi2 = (vi0 + 2) % 3;  						// get the current count  						var vertexStart = newVertices.Count;  						// add the existing vertices  						newVertices.Add(v[vi0]);  						newVertices.Add(v[vi1]);  						newVertices.Add(v[vi2]);  						// clip the edge' will add the new point  						ClipEdge(vi0);  						// add the new faces  						newFaces.Add(new Face(vertexStart' vertexStart + 3' vertexStart + 2' newVertices));  						newFaces.Add(new Face(vertexStart + 3' vertexStart + 1' vertexStart + 2' newVertices));  					}    					return true;  			}
Magic Number,MatterHackers.PolygonMesh,FaceExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,GetArea,The following statement contains a magic number: return (a * c * Math.Sin(b)) / 2d;
Magic Number,MatterHackers.PolygonMesh,MeshExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,GetCoplanerFaces,The following statement contains a magic number: double normalTolerance = .001;
Magic Number,MatterHackers.PolygonMesh,MeshExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,GetCoplanerFaces,The following statement contains a magic number: double distanceTolerance = .001;
Magic Number,MatterHackers.PolygonMesh,MeshExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,GetSurfaceArea,The following statement contains a magic number: var p = 0.5 * (a + b + c);
Magic Number,MatterHackers.PolygonMesh,MeshExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,SplitOnPlanes,The following statement contains a magic number: mesh.Split(new Plane(planeNormal' distancesFromOrigin[i])' onPlaneDistance' (clipData) =>  				{  					// if two distances are less than 0  					if ((clipData.Dist[0] < 0 && clipData.Dist[1] < 0)  						|| (clipData.Dist[1] < 0 && clipData.Dist[2] < 0)  						|| (clipData.Dist[2] < 0 && clipData.Dist[0] < 0))  					{  						return true;  					}    					return false;  				});
Magic Number,MatterHackers.PolygonMesh,MeshExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,SplitOnPlanes,The following statement contains a magic number: mesh.Split(new Plane(planeNormal' distancesFromOrigin[i])' onPlaneDistance' (clipData) =>  				{  					// if two distances are less than 0  					if ((clipData.Dist[0] < 0 && clipData.Dist[1] < 0)  						|| (clipData.Dist[1] < 0 && clipData.Dist[2] < 0)  						|| (clipData.Dist[2] < 0 && clipData.Dist[0] < 0))  					{  						return true;  					}    					return false;  				});
Magic Number,MatterHackers.PolygonMesh,MeshExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,SplitOnPlanes,The following statement contains a magic number: mesh.Split(new Plane(planeNormal' distancesFromOrigin[i])' .1);
Magic Number,MatterHackers.PolygonMesh,MeshExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,PlaceTextureOnFace,The following statement contains a magic number: var uvs = new Vector2Float[3];
Magic Number,MatterHackers.PolygonMesh,MeshExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,PlaceTextureOnFace,The following statement contains a magic number: mesh.FaceTextures[face] = new FaceTextureData(textureToUse' uvs[0]' uvs[1]' uvs[2]);
Magic Number,MatterHackers.PolygonMesh,MeshExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,PlaceTextureOnFaces,The following statement contains a magic number: var uvs = new Vector2Float[3];
Magic Number,MatterHackers.PolygonMesh,MeshExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,PlaceTextureOnFaces,The following statement contains a magic number: mesh.FaceTextures.Add(face' new FaceTextureData(textureToUse' uvs[0]' uvs[1]' uvs[2]));
Magic Number,MatterHackers.PolygonMesh,MeshEdge,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\MeshEdge.cs,CreateMeshEdgeList,The following statement contains a magic number: var faceEdges = new List<(int face' int start' int end)>(mesh.Faces.Count * 3);
Magic Number,MatterHackers.PolygonMesh,MeshConvexHull,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\MeshConvexHull.cs,GetConvexHull,The following statement contains a magic number: mesh.Faces.Count < 4
Magic Number,MatterHackers.PolygonMesh,MeshConvexHull,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\MeshConvexHull.cs,CreateHullMesh,The following statement contains a magic number: var convexHull = ConvexHull<CHVertex' CHFace>.Create(cHVertexList' .01);
Magic Number,MatterHackers.PolygonMesh,MeshConvexHull,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\MeshConvexHull.cs,CreateHullMesh,The following statement contains a magic number: hullMesh.Vertices.Add(new Vector3(vertex.Position[0]' vertex.Position[1]' vertex.Position[2]));
Magic Number,MatterHackers.PolygonMesh,MeshConvexHull,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\MeshConvexHull.cs,CreateHullMesh,The following statement contains a magic number: hullMesh.Faces.Add(vertexCount' vertexCount + 1' vertexCount + 2' hullMesh.Vertices);
Magic Number,MatterHackers.PolygonMesh,MeshHelper,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\MeshHelper.cs,CreatePlane,The following statement contains a magic number: Vector3 scale = new Vector3(scaleIn * .5);
Magic Number,MatterHackers.PolygonMesh,MeshHelper,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\MeshHelper.cs,CreatePlane,The following statement contains a magic number: plane.Faces.Add(0' 1' 2' plane.Vertices);
Magic Number,MatterHackers.PolygonMesh,MeshHelper,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\MeshHelper.cs,CreatePlane,The following statement contains a magic number: plane.Faces.Add(0' 2' 3' plane.Vertices);
Magic Number,MatterHackers.PolygonMesh,MeshHelper,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\MeshHelper.cs,CreatePlane,The following statement contains a magic number: plane.Faces.Add(0' 2' 3' plane.Vertices);
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: scale *= .5;
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: cube.Faces.Add(0' 1' 2' cube.Vertices);
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: cube.Faces.Add(0' 2' 3' cube.Vertices);
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: cube.Faces.Add(0' 2' 3' cube.Vertices);
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: cube.Faces.Add(4' 0' 3' cube.Vertices);
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: cube.Faces.Add(4' 0' 3' cube.Vertices);
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: cube.Faces.Add(4' 3' 7' cube.Vertices);
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: cube.Faces.Add(4' 3' 7' cube.Vertices);
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: cube.Faces.Add(4' 3' 7' cube.Vertices);
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: cube.Faces.Add(1' 5' 6' cube.Vertices);
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: cube.Faces.Add(1' 5' 6' cube.Vertices);
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: cube.Faces.Add(1' 6' 2' cube.Vertices);
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: cube.Faces.Add(1' 6' 2' cube.Vertices);
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: cube.Faces.Add(4' 7' 6' cube.Vertices);
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: cube.Faces.Add(4' 7' 6' cube.Vertices);
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: cube.Faces.Add(4' 7' 6' cube.Vertices);
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: cube.Faces.Add(4' 6' 5' cube.Vertices);
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: cube.Faces.Add(4' 6' 5' cube.Vertices);
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: cube.Faces.Add(4' 6' 5' cube.Vertices);
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: cube.Faces.Add(3' 2' 6' cube.Vertices);
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: cube.Faces.Add(3' 2' 6' cube.Vertices);
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: cube.Faces.Add(3' 2' 6' cube.Vertices);
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: cube.Faces.Add(3' 6' 7' cube.Vertices);
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: cube.Faces.Add(3' 6' 7' cube.Vertices);
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: cube.Faces.Add(3' 6' 7' cube.Vertices);
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: cube.Faces.Add(4' 5' 1' cube.Vertices);
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: cube.Faces.Add(4' 5' 1' cube.Vertices);
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: cube.Faces.Add(4' 1' 0' cube.Vertices);
Magic Number,MatterHackers.PolygonMesh,TransformedAabbCache,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\TransformedAabbCache.cs,GetAxisAlignedBoundingBox,The following statement contains a magic number: cacheCount > 100
Magic Number,MatterHackers.PolygonMesh,Vector3ListEx,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Vector3List.cs,ToVector3List,The following statement contains a magic number: list.Add(new Vector3(v[i]' v[i + 1]' v[i + 2]));
Magic Number,MatterHackers.PolygonMesh,Vector3ListEx,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Vector3List.cs,ToDoubleArray,The following statement contains a magic number: var da = new double[list.Count * 3];
Magic Number,MatterHackers.PolygonMesh,Vector3ListEx,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Vector3List.cs,ToDoubleArray,The following statement contains a magic number: da[i++] = vertex[2];
Magic Number,MatterHackers.PolygonMesh,Vector3FloatListEx,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Vector3List.cs,ToVector3FloatList,The following statement contains a magic number: list.Add(new Vector3Float(v[i]' v[i + 1]' v[i + 2]));
Magic Number,MatterHackers.PolygonMesh,Vector3FloatListEx,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Vector3List.cs,ToDoubleArray,The following statement contains a magic number: var da = new double[list.Count * 3];
Magic Number,MatterHackers.PolygonMesh,Vector3FloatListEx,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Vector3List.cs,ToDoubleArray,The following statement contains a magic number: da[i++] = transformed[2];
Magic Number,MatterHackers.PolygonMesh.Processors,MeshOutputSettings,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\MeshOutputSettings.cs,MeshOutputSettings,The following statement contains a magic number: MetaDataKeyValue.Add(metaDataKeyValuePairs[i * 2]' metaDataKeyValuePairs[i * 2 + 1]);
Magic Number,MatterHackers.PolygonMesh.Processors,MeshOutputSettings,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\MeshOutputSettings.cs,MeshOutputSettings,The following statement contains a magic number: MetaDataKeyValue.Add(metaDataKeyValuePairs[i * 2]' metaDataKeyValuePairs[i * 2 + 1]);
Magic Number,MatterHackers.PolygonMesh.Processors,MeshOutputSettings,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\MeshOutputSettings.cs,MeshOutputSettings,The following statement contains a magic number: i < metaDataKeyValuePairs.Length / 2
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,Save,The following statement contains a magic number: switch (outputInfo.OutputTypeSetting)  			{  				case MeshOutputSettings.OutputType.Ascii:  					{  						StreamWriter streamWriter = new StreamWriter(stream);    						streamWriter.WriteLine("solid Default");    						for (int faceIndex = 0; faceIndex < mesh.Faces.Count; faceIndex++)  						{  							if (cancellationToken.IsCancellationRequested)  							{  								return false;  							}    							var face = mesh.Faces[faceIndex];    							streamWriter.WriteLine("  facet normal " + FormatForStl(mesh.Faces[faceIndex].normal));  							streamWriter.WriteLine("    outer loop");  							streamWriter.WriteLine("      vertex " + FormatForStl(mesh.Vertices[face.v0]));  							streamWriter.WriteLine("      vertex " + FormatForStl(mesh.Vertices[face.v0]));  							streamWriter.WriteLine("      vertex " + FormatForStl(mesh.Vertices[face.v0]));  							streamWriter.WriteLine("    endloop");  							streamWriter.WriteLine("  endfacet");  						}    						streamWriter.WriteLine("endsolid Default");    						streamWriter.Close();  					}  					break;    				case MeshOutputSettings.OutputType.Binary:  					using (BinaryWriter bw = new BinaryWriter(stream))  					{  						// 80 bytes of nothing  						bw.Write(new Byte[80]);  						// the number of triangles  						bw.Write(mesh.Faces.Count);  						int binaryPolyCount = 0;  						for (int faceIndex = 0; faceIndex < mesh.Faces.Count; faceIndex++)  						{  							if (cancellationToken.IsCancellationRequested)  							{  								return false;  							}    							var face = mesh.Faces[faceIndex];    							binaryPolyCount++;  							// save the normal (all 0 so it can compress better)  							WriteToBinaryStl(bw' mesh.Faces[faceIndex].normal);  							// save the position  							WriteToBinaryStl(bw' mesh.Vertices[face.v0]);  							WriteToBinaryStl(bw' mesh.Vertices[face.v1]);  							WriteToBinaryStl(bw' mesh.Vertices[face.v2]);    							// and the attribute  							bw.Write((ushort)0);  						}    						bw.BaseStream.Position = 80;    						// the number of triangles  						bw.Write(binaryPolyCount);  					}  					break;  			}
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,Save,The following statement contains a magic number: switch (outputInfo.OutputTypeSetting)  			{  				case MeshOutputSettings.OutputType.Ascii:  					{  						StreamWriter streamWriter = new StreamWriter(stream);    						streamWriter.WriteLine("solid Default");    						for (int faceIndex = 0; faceIndex < mesh.Faces.Count; faceIndex++)  						{  							if (cancellationToken.IsCancellationRequested)  							{  								return false;  							}    							var face = mesh.Faces[faceIndex];    							streamWriter.WriteLine("  facet normal " + FormatForStl(mesh.Faces[faceIndex].normal));  							streamWriter.WriteLine("    outer loop");  							streamWriter.WriteLine("      vertex " + FormatForStl(mesh.Vertices[face.v0]));  							streamWriter.WriteLine("      vertex " + FormatForStl(mesh.Vertices[face.v0]));  							streamWriter.WriteLine("      vertex " + FormatForStl(mesh.Vertices[face.v0]));  							streamWriter.WriteLine("    endloop");  							streamWriter.WriteLine("  endfacet");  						}    						streamWriter.WriteLine("endsolid Default");    						streamWriter.Close();  					}  					break;    				case MeshOutputSettings.OutputType.Binary:  					using (BinaryWriter bw = new BinaryWriter(stream))  					{  						// 80 bytes of nothing  						bw.Write(new Byte[80]);  						// the number of triangles  						bw.Write(mesh.Faces.Count);  						int binaryPolyCount = 0;  						for (int faceIndex = 0; faceIndex < mesh.Faces.Count; faceIndex++)  						{  							if (cancellationToken.IsCancellationRequested)  							{  								return false;  							}    							var face = mesh.Faces[faceIndex];    							binaryPolyCount++;  							// save the normal (all 0 so it can compress better)  							WriteToBinaryStl(bw' mesh.Faces[faceIndex].normal);  							// save the position  							WriteToBinaryStl(bw' mesh.Vertices[face.v0]);  							WriteToBinaryStl(bw' mesh.Vertices[face.v1]);  							WriteToBinaryStl(bw' mesh.Vertices[face.v2]);    							// and the attribute  							bw.Write((ushort)0);  						}    						bw.BaseStream.Position = 80;    						// the number of triangles  						bw.Write(binaryPolyCount);  					}  					break;  			}
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseFileContents,The following statement contains a magic number: bytesInFile <= 80
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseFileContents,The following statement contains a magic number: byte[] first160Bytes = new byte[160];
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseFileContents,The following statement contains a magic number: stlStream.Read(first160Bytes' 0' 160);
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseFileContents,The following statement contains a magic number: startOfString = 3;
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseFileContents,The following statement contains a magic number: switch (vectorIndex)  						{  							case 1:  								vector0 = Convert(line);  								break;    							case 2:  								vector1 = Convert(line);  								break;    							case 3:  								vector2 = Convert(line);  								if (!Vector3.Collinear(vector0' vector1' vector2))  								{  									int iv0 = GetIndex(vector0);  									int iv1 = GetIndex(vector1);  									int iv2 = GetIndex(vector2);  									mesh.Faces.Add(iv0' iv1' iv2' mesh.Vertices);  								}  								vectorIndex = 0;  								break;  						}
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseFileContents,The following statement contains a magic number: switch (vectorIndex)  						{  							case 1:  								vector0 = Convert(line);  								break;    							case 2:  								vector1 = Convert(line);  								break;    							case 3:  								vector2 = Convert(line);  								if (!Vector3.Collinear(vector0' vector1' vector2))  								{  									int iv0 = GetIndex(vector0);  									int iv1 = GetIndex(vector1);  									int iv2 = GetIndex(vector2);  									mesh.Faces.Add(iv0' iv1' iv2' mesh.Vertices);  								}  								vectorIndex = 0;  								break;  						}
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseFileContents,The following statement contains a magic number: reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseLine,The following statement contains a magic number: goodParse &= double.TryParse(splitOnSpace[2]' out vertexPosition.Y);
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseLine,The following statement contains a magic number: goodParse &= double.TryParse(splitOnSpace[3]' out vertexPosition.Z);
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,IsBinary,The following statement contains a magic number: bytesInFile <= 80
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,IsBinary,The following statement contains a magic number: byte[] first160Bytes = new byte[160];
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,IsBinary,The following statement contains a magic number: stlStream.Read(first160Bytes' 0' 160);
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,IsBinary,The following statement contains a magic number: startOfString = 3;
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,GetEstimatedMemoryUse,The following statement contains a magic number: return (long)(stream.Length * 13.5);
Magic Number,MatterHackers.PolygonMesh.Rendering,OrthographicZProjection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\OrthographicZProjection.cs,DrawTo,The following statement contains a magic number: graphics2D.Rasterizer.gamma(new gamma_power(.3));
Magic Number,MatterHackers.PolygonMesh.Rendering,OrthographicZProjection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\OrthographicZProjection.cs,GetClipperPolygons,The following statement contains a magic number: polygonProjected = polygonProjected.CreateUnion(polyFace.Offset(100));
Magic Number,MatterHackers.PolygonMesh.Rendering,OrthographicZProjection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\OrthographicZProjection.cs,GetClipperPolygons,The following statement contains a magic number: return polygonProjected.Offset(-100);
Missing Default,MatterHackers.PolygonMesh,FaceExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,Split,The following switch statement is missing a default case: switch (segmentsClipped)  			{  				// if 2 sides are clipped we will add 2 new vertices and 3 polygons  				case 2:  					if (clipFace?.Invoke(new Mesh.SplitData(face' dist)) != false)  					{  						// find the side we are not going to clip  						int vi0 = clipSegment[0] && clipSegment[1] ? 2  							: clipSegment[0] && clipSegment[2] ? 1 : 0;  						var vi1 = (vi0 + 1) % 3;  						var vi2 = (vi0 + 2) % 3;  						// get the current count  						var vertexStart = newVertices.Count;  						// add the existing vertices  						newVertices.Add(v[vi0]);  						newVertices.Add(v[vi1]);  						newVertices.Add(v[vi2]);  						// clip the edges' will add the new points  						ClipEdge(vi1);  						ClipEdge(vi2);  						// add the new faces  						newFaces.Add(new Face(vertexStart' vertexStart + 1' vertexStart + 3' newVertices));  						newFaces.Add(new Face(vertexStart' vertexStart + 3' vertexStart + 4' newVertices));  						newFaces.Add(new Face(vertexStart + 3' vertexStart + 2' vertexStart + 4' newVertices));  						return true;  					}    					break;    				// if 1 side is clipped we will add 1 new vertex and 2 polygons  				case 1:  					{  						// find the side we are going to clip  						int vi0 = clipSegment[0] ? 0 : clipSegment[1] ? 1 : 2;  						var vi1 = (vi0 + 1) % 3;  						var vi2 = (vi0 + 2) % 3;  						// get the current count  						var vertexStart = newVertices.Count;  						// add the existing vertices  						newVertices.Add(v[vi0]);  						newVertices.Add(v[vi1]);  						newVertices.Add(v[vi2]);  						// clip the edge' will add the new point  						ClipEdge(vi0);  						// add the new faces  						newFaces.Add(new Face(vertexStart' vertexStart + 3' vertexStart + 2' newVertices));  						newFaces.Add(new Face(vertexStart + 3' vertexStart + 1' vertexStart + 2' newVertices));  					}    					return true;  			}
Missing Default,MatterHackers.PolygonMesh.Processors,StlProcessing,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,Save,The following switch statement is missing a default case: switch (outputInfo.OutputTypeSetting)  			{  				case MeshOutputSettings.OutputType.Ascii:  					{  						StreamWriter streamWriter = new StreamWriter(stream);    						streamWriter.WriteLine("solid Default");    						for (int faceIndex = 0; faceIndex < mesh.Faces.Count; faceIndex++)  						{  							if (cancellationToken.IsCancellationRequested)  							{  								return false;  							}    							var face = mesh.Faces[faceIndex];    							streamWriter.WriteLine("  facet normal " + FormatForStl(mesh.Faces[faceIndex].normal));  							streamWriter.WriteLine("    outer loop");  							streamWriter.WriteLine("      vertex " + FormatForStl(mesh.Vertices[face.v0]));  							streamWriter.WriteLine("      vertex " + FormatForStl(mesh.Vertices[face.v0]));  							streamWriter.WriteLine("      vertex " + FormatForStl(mesh.Vertices[face.v0]));  							streamWriter.WriteLine("    endloop");  							streamWriter.WriteLine("  endfacet");  						}    						streamWriter.WriteLine("endsolid Default");    						streamWriter.Close();  					}  					break;    				case MeshOutputSettings.OutputType.Binary:  					using (BinaryWriter bw = new BinaryWriter(stream))  					{  						// 80 bytes of nothing  						bw.Write(new Byte[80]);  						// the number of triangles  						bw.Write(mesh.Faces.Count);  						int binaryPolyCount = 0;  						for (int faceIndex = 0; faceIndex < mesh.Faces.Count; faceIndex++)  						{  							if (cancellationToken.IsCancellationRequested)  							{  								return false;  							}    							var face = mesh.Faces[faceIndex];    							binaryPolyCount++;  							// save the normal (all 0 so it can compress better)  							WriteToBinaryStl(bw' mesh.Faces[faceIndex].normal);  							// save the position  							WriteToBinaryStl(bw' mesh.Vertices[face.v0]);  							WriteToBinaryStl(bw' mesh.Vertices[face.v1]);  							WriteToBinaryStl(bw' mesh.Vertices[face.v2]);    							// and the attribute  							bw.Write((ushort)0);  						}    						bw.BaseStream.Position = 80;    						// the number of triangles  						bw.Write(binaryPolyCount);  					}  					break;  			}
Missing Default,MatterHackers.PolygonMesh.Processors,StlProcessing,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseFileContents,The following switch statement is missing a default case: switch (vectorIndex)  						{  							case 1:  								vector0 = Convert(line);  								break;    							case 2:  								vector1 = Convert(line);  								break;    							case 3:  								vector2 = Convert(line);  								if (!Vector3.Collinear(vector0' vector1' vector2))  								{  									int iv0 = GetIndex(vector0);  									int iv1 = GetIndex(vector1);  									int iv2 = GetIndex(vector2);  									mesh.Faces.Add(iv0' iv1' iv2' mesh.Vertices);  								}  								vectorIndex = 0;  								break;  						}
