Implementation smell,Namespace,Class,File,Method,Description
Long Method,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,Save,The method has 134 lines of code.
Long Method,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,ParseFileContents,The method has 114 lines of code.
Long Method,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseFileContents,The method has 162 lines of code.
Complex Method,MatterHackers.PolygonMesh.Csg,CsgNode,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Csg\CsgNode.cs,BuildFromPolygons,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.PolygonMesh,Mesh,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,Copy,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.PolygonMesh,Mesh,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,MergeVertices,Cyclomatic complexity of the method is 10
Complex Method,MatterHackers.PolygonMesh,Mesh,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,MergeMeshEdges,Cyclomatic complexity of the method is 10
Complex Method,MatterHackers.PolygonMesh,Mesh,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,FindFacesAtPosition,Cyclomatic complexity of the method is 9
Complex Method,MatterHackers.PolygonMesh,Mesh,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,Equals,Cyclomatic complexity of the method is 9
Complex Method,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,Save,Cyclomatic complexity of the method is 19
Complex Method,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,ParseFileContents,Cyclomatic complexity of the method is 11
Complex Method,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseFileContents,Cyclomatic complexity of the method is 11
Long Parameter List,MatterHackers.PolygonMesh.Csg,CsgPlane,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Csg\CsgPlane.cs,SplitPolygon,The method has 5 parameters. Parameters: polygon' coplanarFront' coplanarBack' front' back
Long Parameter List,MatterHackers.PolygonMesh,Face,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Face.cs,WrapQuadrantDelta,The method has 5 parameters. Parameters: delta' prevPosition' position' x' y
Long Parameter List,MatterHackers.PolygonMesh,Mesh,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,SplitFace,The method has 5 parameters. Parameters: faceToSplit' splitStartVertex' splitEndVertex' meshEdgeCreatedDuringSplit' faceCreatedDuringSplit
Long Parameter List,MatterHackers.PolygonMesh,Mesh,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,CreateVertex,The method has 5 parameters. Parameters: x' y' z' createOption' sortOption
Long Parameter List,MatterHackers.PolygonMesh,VertexXYZAxisWithRotation,C:\repos\MatterHackers_agg-sharp\PolygonMesh\VertexSorters\VertexXYZAxisWithRotation.cs,AddToListIfSameEnough,The method has 5 parameters. Parameters: vertices' position' findList' maxDistanceToConsiderVertexAsSameSquared' i
Long Parameter List,MatterHackers.PolygonMesh,VertexXAxisSorter,C:\repos\MatterHackers_agg-sharp\PolygonMesh\VertexSorters\VertexXAxisSorter.cs,AddToListIfSameEnough,The method has 5 parameters. Parameters: vertices' position' findList' maxDistanceToConsiderVertexAsSameSquared' i
Long Parameter List,MatterHackers.PolygonMesh.Rendering,OrthographicZProjection,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\OrthographicZProjection.cs,DrawTo,The method has 5 parameters. Parameters: graphics2D' meshToDraw' offset' scale' silhouetteColor
Long Identifier,MatterHackers.PolygonMesh,MeshEdge,C:\repos\MatterHackers_agg-sharp\PolygonMesh\MeshEdge.cs,RemoveFromMeshEdgeLinksOfVertex,The length of the parameter nextMeshEdgeConnectedToThisVertex is 33.
Long Identifier,MatterHackers.PolygonMesh,Mesh,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,CleanAndMergMesh,The length of the parameter maxDistanceToConsiderVertexAsSame is 33.
Long Identifier,MatterHackers.PolygonMesh,Mesh,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,UnsplitFace,The length of the parameter faceEdgeToDeleteOnFaceToDelete is 30.
Long Identifier,MatterHackers.PolygonMesh,Mesh,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,FindVertices,The length of the parameter maxDistanceToConsiderVertexAsSame is 33.
Long Identifier,MatterHackers.PolygonMesh,Mesh,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,CreateVertex,The length of the parameter maxDistanceToConsiderVertexAsSame is 33.
Long Identifier,MatterHackers.PolygonMesh,Mesh,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,MergeVertices,The length of the parameter maxDistanceToConsiderVertexAsSame is 33.
Long Identifier,MatterHackers.PolygonMesh,VertexCollecton,C:\repos\MatterHackers_agg-sharp\PolygonMesh\VertexCollection.cs,FindVertices,The length of the parameter maxDistanceToConsiderVertexAsSame is 33.
Long Identifier,MatterHackers.PolygonMesh,VertexSorterBase,C:\repos\MatterHackers_agg-sharp\PolygonMesh\VertexSorters\VertexSorterBase.cs,FindVertices,The length of the parameter maxDistanceToConsiderVertexAsSame is 33.
Long Identifier,MatterHackers.PolygonMesh,VertexXYZAxisWithRotation,C:\repos\MatterHackers_agg-sharp\PolygonMesh\VertexSorters\VertexXYZAxisWithRotation.cs,FindVertices,The length of the parameter maxDistanceToConsiderVertexAsSame is 33.
Long Identifier,MatterHackers.PolygonMesh,VertexXYZAxisWithRotation,C:\repos\MatterHackers_agg-sharp\PolygonMesh\VertexSorters\VertexXYZAxisWithRotation.cs,FindVertices,The length of the parameter maxDistanceToConsiderVertexAsSameSquared is 40.
Long Identifier,MatterHackers.PolygonMesh,VertexXYZAxisWithRotation,C:\repos\MatterHackers_agg-sharp\PolygonMesh\VertexSorters\VertexXYZAxisWithRotation.cs,AddToListIfSameEnough,The length of the parameter maxDistanceToConsiderVertexAsSameSquared is 40.
Long Identifier,MatterHackers.PolygonMesh,VertexDistanceFromPointSorter,C:\repos\MatterHackers_agg-sharp\PolygonMesh\VertexSorters\VertexDistanceFromPointSorter.cs,FindVertices,The length of the parameter maxDistanceToConsiderVertexAsSame is 33.
Long Identifier,MatterHackers.PolygonMesh,VertexXAxisSorter,C:\repos\MatterHackers_agg-sharp\PolygonMesh\VertexSorters\VertexXAxisSorter.cs,FindVertices,The length of the parameter maxDistanceToConsiderVertexAsSame is 33.
Long Identifier,MatterHackers.PolygonMesh,VertexXAxisSorter,C:\repos\MatterHackers_agg-sharp\PolygonMesh\VertexSorters\VertexXAxisSorter.cs,FindVertices,The length of the parameter maxDistanceToConsiderVertexAsSameSquared is 40.
Long Identifier,MatterHackers.PolygonMesh,VertexXAxisSorter,C:\repos\MatterHackers_agg-sharp\PolygonMesh\VertexSorters\VertexXAxisSorter.cs,AddToListIfSameEnough,The length of the parameter maxDistanceToConsiderVertexAsSameSquared is 40.
Long Statement,MatterHackers.PolygonMesh.Csg,CsgAcceleratedMesh,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Csg\CsgProcessing.cs,SplitOnAllEdgeIntersections,The length of the statement  "			AxisAlignedBoundingBox faceEdgeBoundsIntersection = AxisAlignedBoundingBox.Intersection(boundsForEdges' boundsForFaces); " is 120.
Long Statement,MatterHackers.PolygonMesh.Csg,CsgAcceleratedMesh,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Csg\CsgProcessing.cs,SplitOnAllEdgeIntersections,The length of the statement  "				AxisAlignedBoundingBox edgeBounds = new AxisAlignedBoundingBox(Vector3.ComponentMin(end0' end1)' Vector3.ComponentMax(end0' end1)); " is 131.
Long Statement,MatterHackers.PolygonMesh,MeshEdge,C:\repos\MatterHackers_agg-sharp\PolygonMesh\MeshEdge.cs,AddDebugInfo,The length of the statement  "			totalDebug.Append(new string('\t'' numTabs) + String.Format("Vertex1: {0}\n"' VertexOnEnd[0] != null ? VertexOnEnd[0].Data.ID.ToString() : "null")); " is 148.
Long Statement,MatterHackers.PolygonMesh,MeshEdge,C:\repos\MatterHackers_agg-sharp\PolygonMesh\MeshEdge.cs,AddDebugInfo,The length of the statement  "			totalDebug.Append(new string('\t'' numTabs) + String.Format("Vertex2: {0}\n"' VertexOnEnd[1] != null ? VertexOnEnd[1].Data.ID.ToString() : "null")); " is 148.
Long Statement,MatterHackers.PolygonMesh,MeshEdge,C:\repos\MatterHackers_agg-sharp\PolygonMesh\MeshEdge.cs,RemoveFromMeshEdgeLinksOfVertex,The length of the statement  "				MeshEdge nextMeshEdgeConnectedToThisVertex = vertexToRemoveFrom.firstMeshEdge.GetNextMeshEdgeConnectedTo(vertexToRemoveFrom); " is 125.
Long Statement,MatterHackers.PolygonMesh,MeshEdge,C:\repos\MatterHackers_agg-sharp\PolygonMesh\MeshEdge.cs,GetOppositeVertex,The length of the statement  "					throw new Exception("You must only ask to get the opposite vertex on a MeshEdge that is linked to the given vertexToGetOppositeFor."); " is 134.
Long Statement,MatterHackers.PolygonMesh,MeshEdge,C:\repos\MatterHackers_agg-sharp\PolygonMesh\MeshEdge.cs,GetOppositeMeshEdge,The length of the statement  "					throw new Exception("You must only ask to get the opposite vertex on a MeshEdge that is linked to the given vertexToGetOppositeFor."); " is 134.
Long Statement,MatterHackers.PolygonMesh,Face,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Face.cs,CalculateNormal,The length of the statement  "				collinear = Vector3.Collinear(faceEdge0.firstVertex.Position' faceEdge1.firstVertex.Position' faceEdge2.firstVertex.Position); " is 126.
Long Statement,MatterHackers.PolygonMesh,Mesh,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,Copy,The length of the statement  "					newMeshEdge.NextMeshEdgeFromEnd[0] = newMesh.MeshEdges[meshEdgeIndexDictionary[meshEdgeToCopy.NextMeshEdgeFromEnd[0].Data.ID]]; " is 127.
Long Statement,MatterHackers.PolygonMesh,Mesh,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,Copy,The length of the statement  "					newMeshEdge.NextMeshEdgeFromEnd[1] = newMesh.MeshEdges[meshEdgeIndexDictionary[meshEdgeToCopy.NextMeshEdgeFromEnd[1].Data.ID]]; " is 127.
Long Statement,MatterHackers.PolygonMesh,Mesh,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,Copy,The length of the statement  "					MeshEdge lastMeshEdgeFromCopy = verticesFromCopy[verticesFromCopy.Count - 1].GetMeshEdgeConnectedToVertex(verticesFromCopy[0]); " is 127.
Long Statement,MatterHackers.PolygonMesh,Mesh,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,Copy,The length of the statement  "						Vertex newVertex = newMesh.CreateVertex(faceEdgeToAdd.firstVertex.Position' CreateOption.CreateNew' SortOption.WillSortLater); " is 126.
Long Statement,MatterHackers.PolygonMesh,Mesh,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,CleanAndMergMesh,The length of the statement  "					MergeVertices(maxDistanceToConsiderVertexAsSame' (double progress0To1' string processingState' out bool continueProcessing) => " is 126.
Long Statement,MatterHackers.PolygonMesh,Mesh,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,UnsplitFace,The length of the statement  "			// validate the edgeToDelete is in both faces' edgeToDelete is only in these two faces' the two faces only share this one edge and no other edges " is 145.
Long Statement,MatterHackers.PolygonMesh,Mesh,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,UnsplitFace,The length of the statement  "			// if the face we are deleting is the one that the face to keep was looking at as its starting face edge' move it to the next face edge " is 135.
Long Statement,MatterHackers.PolygonMesh,Mesh,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,CreateMeshEdge,The length of the statement  "				throw new ArgumentException("the two vertices must be in the vertices list before a mesh edge can be made between them."); " is 122.
Long Statement,MatterHackers.PolygonMesh,Mesh,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,SplitMeshEdge,The length of the statement  "				vertexCreatedDuringSplit = CreateVertex((meshEdgeToSplit.VertexOnEnd[0].Position + meshEdgeToSplit.VertexOnEnd[1].Position) / 2); " is 129.
Long Statement,MatterHackers.PolygonMesh,Mesh,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,UnsplitMeshEdge,The length of the statement  "				throw new Exception("The edge that is being unsplit must be connected to only one other MeshEdge across the vertexToDelete."); " is 126.
Long Statement,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,CreateImage,The length of the statement  "				WriteStringAtPos(faceToRender.firstFaceEdge.Data.ID.ToString()' faceAverageCenter + new Vector2(0' -12)' faceEdgeColor); " is 120.
Long Statement,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,DrawFaceEdge,The length of the statement  "			WriteStringAtPos("{0}".FormatWith(faceEdge.radialNextFaceEdge.Data.ID)' start + new Vector2(0' 7) + normal * length * .90' faceEdgeColor); " is 138.
Long Statement,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,DrawFaceEdge,The length of the statement  "			WriteStringAtPos("{0}".FormatWith(faceEdge.radialPrevFaceEdge.Data.ID)' start + new Vector2(0' -7) + normal * length * .90' faceEdgeColor); " is 139.
Long Statement,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,DrawMeshEdge,The length of the statement  "				WriteStringAtPos("{0}".FormatWith(meshEdge.firstFaceEdge.Data.ID)' (start + end) / 2 + new Vector2(0' 12)' faceEdgeColor); " is 122.
Long Statement,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,DrawMeshEdge,The length of the statement  "			WriteStringAtPos("{0}".FormatWith(meshEdge.NextMeshEdgeFromEnd[0].Data.ID)' start + normal * length * .40' meshEdgeColor); " is 122.
Long Statement,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,DrawMeshEdge,The length of the statement  "			WriteStringAtPos("{0}".FormatWith(meshEdge.NextMeshEdgeFromEnd[1].Data.ID)' start + normal * length * .60' meshEdgeColor); " is 122.
Long Statement,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,DrawEdgeLine,The length of the statement  "			graphics.FillRectangle((end + start) / 2 - new Vector2(20' 7)' (end + start) / 2 + new Vector2(20' 7)' RGBA_Bytes.White); " is 121.
Long Statement,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,DrawRectangle,The length of the statement  "			RoundedRect rect = new RoundedRect(imagePosition.x - 20' imagePosition.y - 7' imagePosition.x + 20' imagePosition.y + 7' 3); " is 124.
Long Statement,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,WriteStringAtPos,The length of the statement  "			graphics.DrawString(stringToWrite' imagePosition.x' imagePosition.y' 10' justification: Justification.Center' baseline: Baseline.BoundsCenter' color: RGBA_Bytes.Black' backgroundColor: backgroundColor); " is 202.
Long Statement,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateTetrahedron,The length of the statement  "			tetrahedron.CreateFace(new Vertex[] { verts[0]' verts[2]' verts[1] }); // add reversed because we want to see the bottom. " is 121.
Long Statement,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The length of the statement  "				verts[i] = icosahedron.CreateVertex(new Vector3(icosahedronVertices[i * 3 + 0]' icosahedronVertices[i * 3 + 1]' icosahedronVertices[i * 3 + 2])); " is 145.
Long Statement,MatterHackers.PolygonMesh,VertexCollecton,C:\repos\MatterHackers_agg-sharp\PolygonMesh\VertexCollection.cs,FindVertices,The length of the statement  "				throw new Exception("You can't Find a vertex in an unsorted VertexCollection. Sort it first (or add the vertexes without preventing sorting)."); " is 144.
Long Statement,MatterHackers.PolygonMesh,VertexCollecton,C:\repos\MatterHackers_agg-sharp\PolygonMesh\VertexCollection.cs,ContainsAVertexAtPosition,The length of the statement  "				throw new Exception("You can't Find a vertex in an unsorted VertexCollection. Sort it first (or add the vertexes without preventing sorting)."); " is 144.
Long Statement,MatterHackers.PolygonMesh,VertexCollecton,C:\repos\MatterHackers_agg-sharp\PolygonMesh\VertexCollection.cs,ContainsVertex,The length of the statement  "				throw new Exception("You can't Find a vertex in an unsorted VertexCollection. Sort it first (or add the vertexes without preventing sorting)."); " is 144.
Long Statement,MatterHackers.PolygonMesh,VertexXYZAxisWithRotation,C:\repos\MatterHackers_agg-sharp\PolygonMesh\VertexSorters\VertexXYZAxisWithRotation.cs,FindVertices,The length of the statement  "			double maxDistanceToConsiderVertexAsSameSquared = maxDistanceToConsiderVertexAsSame * maxDistanceToConsiderVertexAsSame; " is 120.
Long Statement,MatterHackers.PolygonMesh,VertexXAxisSorter,C:\repos\MatterHackers_agg-sharp\PolygonMesh\VertexSorters\VertexXAxisSorter.cs,FindVertices,The length of the statement  "			double maxDistanceToConsiderVertexAsSameSquared = maxDistanceToConsiderVertexAsSame * maxDistanceToConsiderVertexAsSame; " is 120.
Long Statement,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,Save,The length of the statement  "										amfFile.WriteLine(Indent(5) + "<v2>{0}</v2>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[secondIndex]))); " is 126.
Long Statement,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,Save,The length of the statement  "										amfFile.WriteLine(Indent(5) + "<v3>{0}</v3>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[thirdIndex]))); " is 125.
Long Statement,MatterHackers.PolygonMesh.Processors,MeshFileIo,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\MeshFileIo.cs,DoMerge,The length of the statement  "									Vertex newVertex = allPolygons.CreateVertex(faceEdgeToAdd.firstVertex.Position' CreateOption.CreateNew' SortOption.WillSortLater); " is 130.
Long Statement,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,Save,The length of the statement  "								bw.Write((float)positionsCCW[secondIndex].x); bw.Write((float)positionsCCW[secondIndex].y); bw.Write((float)positionsCCW[secondIndex].z); " is 137.
Long Statement,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,Save,The length of the statement  "								bw.Write((float)positionsCCW[thirdIndex].x); bw.Write((float)positionsCCW[thirdIndex].y); bw.Write((float)positionsCCW[thirdIndex].z); " is 134.
Long Statement,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseFileContents,The length of the statement  "			if (first160Bytes[0] == ByteOredrMark[0] && first160Bytes[0] == ByteOredrMark[0] && first160Bytes[0] == ByteOredrMark[0]) " is 121.
Long Statement,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseFileContents,The length of the statement  "			string first160BytesOfSTLFile = System.Text.Encoding.UTF8.GetString(first160Bytes' startOfString' first160Bytes.Length - startOfString); " is 136.
Long Statement,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseFileContents,The length of the statement  "						reportProgress(stlStream.Position / (double)bytesInFile * parsingFileRatio' "Loading Polygons"' out continueProcessing); " is 120.
Long Statement,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,IsBinary,The length of the statement  "					if (first160Bytes[0] == ByteOredrMark[0] && first160Bytes[0] == ByteOredrMark[0] && first160Bytes[0] == ByteOredrMark[0]) " is 121.
Long Statement,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,IsBinary,The length of the statement  "					string first160BytesOfSTLFile = System.Text.Encoding.UTF8.GetString(first160Bytes' startOfString' first160Bytes.Length - startOfString); " is 136.
Complex Conditional,MatterHackers.PolygonMesh,Mesh,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,CreateFace,The conditional expression  "nonRepeatingSet.Count < 3  				|| (nonRepeatingSet.Count == 3  				&& (nonRepeatingSet[0].Position == nonRepeatingSet[1].Position  				|| nonRepeatingSet[1].Position == nonRepeatingSet[2].Position  				|| nonRepeatingSet[2].Position == nonRepeatingSet[0].Position))"  is complex.
Complex Conditional,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,ReadVolume,The conditional expression  "indices[0] != indices[1]  								&& indices[0] != indices[2]  								&& indices[1] != indices[2]  								&& vertices[indices[0]] != vertices[indices[1]]  								&& vertices[indices[1]] != vertices[indices[2]]  								&& vertices[indices[2]] != vertices[indices[0]]"  is complex.
Magic Number,MatterHackers.PolygonMesh.Csg,CsgPlane,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Csg\CsgPlane.cs,SplitPolygon,The following statement contains a magic number: double splitTolerance = 0.00001;
Magic Number,MatterHackers.PolygonMesh.Csg,CsgPlane,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Csg\CsgPlane.cs,SplitPolygon,The following statement contains a magic number: switch (polygonType)  			{  				case PolyType.COPLANAR:  					{  						if (Vector3.Dot(this.normal' polygon.plane.normal) > 0)  						{  							coplanarFront.Add(polygon);  						}  						else  						{  							coplanarBack.Add(polygon);  						}  						break;  					}  				case PolyType.FRONT:  					{  						front.Add(polygon);  						break;  					}  				case PolyType.BACK:  					{  						back.Add(polygon);  						break;  					}  				case PolyType.SPANNING:  					{  						List<Vertex> frontVertices = new List<Vertex>();  						List<Vertex> backVertices = new List<Vertex>();  						for (int firstVertexIndex = 0; firstVertexIndex < polygon.vertices.Count; firstVertexIndex++)  						{  							int nextVertexIndex = (firstVertexIndex + 1) % polygon.vertices.Count;  							PolyType firstPolyType = types[firstVertexIndex];  							PolyType nextPolyType = types[nextVertexIndex];  							Vertex firstVertex = polygon.vertices[firstVertexIndex];  							Vertex nextVertex = polygon.vertices[nextVertexIndex];  							if (firstPolyType != PolyType.BACK)  							{  								frontVertices.Add(firstVertex);  							}    							if (firstPolyType != PolyType.FRONT)  							{  								backVertices.Add(firstVertex);  							}    							if ((firstPolyType | nextPolyType) == PolyType.SPANNING)  							{  								double planDotFirstVertex = Vector3.Dot(this.normal' firstVertex.Position);  								double firstDistToPlane = this.w - planDotFirstVertex;  								Vector3 deltaFromFirstToNext = nextVertex.Position - firstVertex.Position;  								double t = firstDistToPlane / Vector3.Dot(this.normal' deltaFromFirstToNext);  								Vertex newVertex = firstVertex.CreateInterpolated(nextVertex' t);  								frontVertices.Add(newVertex);  								backVertices.Add(newVertex);  							}  						}    						if (frontVertices.Count >= 3)  						{  							front.Add(new CsgPolygon(frontVertices));  						}    						if (backVertices.Count >= 3)  						{  							back.Add(new CsgPolygon(backVertices));  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.PolygonMesh.Csg,CsgPlane,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Csg\CsgPlane.cs,SplitPolygon,The following statement contains a magic number: switch (polygonType)  			{  				case PolyType.COPLANAR:  					{  						if (Vector3.Dot(this.normal' polygon.plane.normal) > 0)  						{  							coplanarFront.Add(polygon);  						}  						else  						{  							coplanarBack.Add(polygon);  						}  						break;  					}  				case PolyType.FRONT:  					{  						front.Add(polygon);  						break;  					}  				case PolyType.BACK:  					{  						back.Add(polygon);  						break;  					}  				case PolyType.SPANNING:  					{  						List<Vertex> frontVertices = new List<Vertex>();  						List<Vertex> backVertices = new List<Vertex>();  						for (int firstVertexIndex = 0; firstVertexIndex < polygon.vertices.Count; firstVertexIndex++)  						{  							int nextVertexIndex = (firstVertexIndex + 1) % polygon.vertices.Count;  							PolyType firstPolyType = types[firstVertexIndex];  							PolyType nextPolyType = types[nextVertexIndex];  							Vertex firstVertex = polygon.vertices[firstVertexIndex];  							Vertex nextVertex = polygon.vertices[nextVertexIndex];  							if (firstPolyType != PolyType.BACK)  							{  								frontVertices.Add(firstVertex);  							}    							if (firstPolyType != PolyType.FRONT)  							{  								backVertices.Add(firstVertex);  							}    							if ((firstPolyType | nextPolyType) == PolyType.SPANNING)  							{  								double planDotFirstVertex = Vector3.Dot(this.normal' firstVertex.Position);  								double firstDistToPlane = this.w - planDotFirstVertex;  								Vector3 deltaFromFirstToNext = nextVertex.Position - firstVertex.Position;  								double t = firstDistToPlane / Vector3.Dot(this.normal' deltaFromFirstToNext);  								Vertex newVertex = firstVertex.CreateInterpolated(nextVertex' t);  								frontVertices.Add(newVertex);  								backVertices.Add(newVertex);  							}  						}    						if (frontVertices.Count >= 3)  						{  							front.Add(new CsgPolygon(frontVertices));  						}    						if (backVertices.Count >= 3)  						{  							back.Add(new CsgPolygon(backVertices));  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.PolygonMesh.Csg,CsgPolygon,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Csg\CsgPolygon.cs,CsgPolygon,The following statement contains a magic number: plane = new CsgPlane(vertices[0].Position' vertices[1].Position' vertices[2].Position);
Magic Number,MatterHackers.PolygonMesh.Csg,CsgAcceleratedMesh,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Csg\CsgProcessing.cs,ScaleAndMakeInteger,The following statement contains a magic number: for(int i=0; i<mesh.Vertices.Count; i++)  			{  				Vector3 intPosition = mesh.Vertices[i].Position;  				intPosition.x = (int)(mesh.Vertices[i].Position.x * scale + .5);  				intPosition.y = (int)(mesh.Vertices[i].Position.x * scale + .5);  				intPosition.z = (int)(mesh.Vertices[i].Position.x * scale + .5);  				mesh.Vertices[i].Position = intPosition;              }
Magic Number,MatterHackers.PolygonMesh.Csg,CsgAcceleratedMesh,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Csg\CsgProcessing.cs,ScaleAndMakeInteger,The following statement contains a magic number: for(int i=0; i<mesh.Vertices.Count; i++)  			{  				Vector3 intPosition = mesh.Vertices[i].Position;  				intPosition.x = (int)(mesh.Vertices[i].Position.x * scale + .5);  				intPosition.y = (int)(mesh.Vertices[i].Position.x * scale + .5);  				intPosition.z = (int)(mesh.Vertices[i].Position.x * scale + .5);  				mesh.Vertices[i].Position = intPosition;              }
Magic Number,MatterHackers.PolygonMesh.Csg,CsgAcceleratedMesh,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Csg\CsgProcessing.cs,ScaleAndMakeInteger,The following statement contains a magic number: for(int i=0; i<mesh.Vertices.Count; i++)  			{  				Vector3 intPosition = mesh.Vertices[i].Position;  				intPosition.x = (int)(mesh.Vertices[i].Position.x * scale + .5);  				intPosition.y = (int)(mesh.Vertices[i].Position.x * scale + .5);  				intPosition.z = (int)(mesh.Vertices[i].Position.x * scale + .5);  				mesh.Vertices[i].Position = intPosition;              }
Magic Number,MatterHackers.PolygonMesh.Csg,CsgOperations,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Csg\CsgOperations.cs,MeshFromPolygons,The following statement contains a magic number: for (int polygonIndex = 0; polygonIndex < polygons.Count; polygonIndex++)  			{  				CsgPolygon poly = polygons[polygonIndex];  				vertices.Clear();    				for (int vertexIndex = 0; vertexIndex < poly.vertices.Count; vertexIndex++)  				{  					vertices.Add(model.CreateVertex(poly.vertices[vertexIndex].Position));  				}    				if (vertices.Count > 2)  				{  					model.CreateFace(vertices.ToArray());  				}  			}
Magic Number,MatterHackers.PolygonMesh,Face,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Face.cs,WrapQuadrantDelta,The following statement contains a magic number: switch (delta)  			{  				// make quadrant deltas wrap around  				case 3:  					return -1;    				case -3:  					return 1;    				// check if went around point cw or ccw  				case 2:  				case -2:  					if (GetXIntersept(prevPosition' position' y) > x)  					{  						return -delta;  					}  					break;  			}
Magic Number,MatterHackers.PolygonMesh,Face,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Face.cs,WrapQuadrantDelta,The following statement contains a magic number: switch (delta)  			{  				// make quadrant deltas wrap around  				case 3:  					return -1;    				case -3:  					return 1;    				// check if went around point cw or ccw  				case 2:  				case -2:  					if (GetXIntersept(prevPosition' position' y) > x)  					{  						return -delta;  					}  					break;  			}
Magic Number,MatterHackers.PolygonMesh,Face,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Face.cs,WrapQuadrantDelta,The following statement contains a magic number: switch (delta)  			{  				// make quadrant deltas wrap around  				case 3:  					return -1;    				case -3:  					return 1;    				// check if went around point cw or ccw  				case 2:  				case -2:  					if (GetXIntersept(prevPosition' position' y) > x)  					{  						return -delta;  					}  					break;  			}
Magic Number,MatterHackers.PolygonMesh,Face,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Face.cs,WrapQuadrantDelta,The following statement contains a magic number: switch (delta)  			{  				// make quadrant deltas wrap around  				case 3:  					return -1;    				case -3:  					return 1;    				// check if went around point cw or ccw  				case 2:  				case -2:  					if (GetXIntersept(prevPosition' position' y) > x)  					{  						return -delta;  					}  					break;  			}
Magic Number,MatterHackers.PolygonMesh,Face,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Face.cs,GetQuadrant,The following statement contains a magic number: if (positionToGetQuadantFor.x > x)  			{  				if (positionToGetQuadantFor.y > y)  				{  					return 0;  				}  				else  				{  					return 3;  				}  			}  			else  			{  				if (positionToGetQuadantFor.y > y)  				{  					return 1;  				}  				else  				{  					return 2;  				}  			}
Magic Number,MatterHackers.PolygonMesh,Face,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Face.cs,GetQuadrant,The following statement contains a magic number: if (positionToGetQuadantFor.x > x)  			{  				if (positionToGetQuadantFor.y > y)  				{  					return 0;  				}  				else  				{  					return 3;  				}  			}  			else  			{  				if (positionToGetQuadantFor.y > y)  				{  					return 1;  				}  				else  				{  					return 2;  				}  			}
Magic Number,MatterHackers.PolygonMesh,Face,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Face.cs,GetMajorAxis,The following statement contains a magic number: return 2;
Magic Number,MatterHackers.PolygonMesh,Face,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Face.cs,PointInPoly,The following statement contains a magic number: if ((accumulatedQuadrantAngle == 4) || (accumulatedQuadrantAngle == -4))  			{  				return true;  			}
Magic Number,MatterHackers.PolygonMesh,Face,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Face.cs,PointInPoly,The following statement contains a magic number: if ((accumulatedQuadrantAngle == 4) || (accumulatedQuadrantAngle == -4))  			{  				return true;  			}
Magic Number,MatterHackers.PolygonMesh,Face,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Face.cs,GetAxisIndices,The following statement contains a magic number: if (axisOfProjection == 0) // x  			{  				xIndex = 1;  				yIndex = 2;  			}  			else if (axisOfProjection == 1) // y  			{  				xIndex = 0;  				yIndex = 2;  			}
Magic Number,MatterHackers.PolygonMesh,Face,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Face.cs,GetAxisIndices,The following statement contains a magic number: if (axisOfProjection == 0) // x  			{  				xIndex = 1;  				yIndex = 2;  			}  			else if (axisOfProjection == 1) // y  			{  				xIndex = 0;  				yIndex = 2;  			}
Magic Number,MatterHackers.PolygonMesh,Face,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Face.cs,GetCutLine,The following statement contains a magic number: foreach (FaceEdge faceEdge in FaceEdges())  			{  				if (first)  				{  					prevEdge = faceEdge;  					prevInFront = cutPlane.GetDistanceFromPlane(prevEdge.firstVertex.Position) > 0;  					first = false;  					firstEdge = prevEdge;  					firstInFront = prevInFront;  				}  				else  				{  					FaceEdge curEdge = faceEdge;  					bool curInFront = cutPlane.GetDistanceFromPlane(curEdge.firstVertex.Position) > 0;  					if (prevInFront != curInFront)  					{  						// we crossed over the cut line  						Vector3 directionNormal = (curEdge.firstVertex.Position - prevEdge.firstVertex.Position).GetNormal();  						Ray edgeRay = new Ray(prevEdge.firstVertex.Position' directionNormal);  						double distanceToHit;  						bool hitFrontOfPlane;  						if (cutPlane.RayHitPlane(edgeRay' out distanceToHit' out hitFrontOfPlane))  						{  							splitCount++;  							if (splitCount == 1)  							{  								start = edgeRay.origin + edgeRay.directionNormal * distanceToHit;  							}  							else  							{  								end = edgeRay.origin + edgeRay.directionNormal * distanceToHit;  							}  						}  					}    					prevEdge = curEdge;  					prevInFront = curInFront;  					if (splitCount == 2)  					{  						break;  					}  				}  			}
Magic Number,MatterHackers.PolygonMesh,Face,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Face.cs,GetCutLine,The following statement contains a magic number: if (splitCount == 2)  			{  				return true;  			}
Magic Number,MatterHackers.PolygonMesh,Mesh,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,CleanAndMergMesh,The following statement contains a magic number: if (reportProgress != null)  			{  #if AGRESSIVE_VALIDATING  				Validate();  #endif    				bool keepProcessing = true;  				SortVertices((double progress0To1' string processingState' out bool continueProcessing) =>  				{  					reportProgress(progress0To1 * .41' processingState' out continueProcessing);  					keepProcessing = continueProcessing;  #if AGRESSIVE_VALIDATING  					Validate();  #endif  				});  				if (keepProcessing)  				{  					MergeVertices(maxDistanceToConsiderVertexAsSame' (double progress0To1' string processingState' out bool continueProcessing) =>  					{  						reportProgress(progress0To1 * .23 + .41' processingState' out continueProcessing);  						keepProcessing = continueProcessing;  					});  				}  				if (keepProcessing)  				{  					MergeMeshEdges((double progress0To1' string processingState' out bool continueProcessing) =>  					{  						reportProgress(progress0To1 * .36 + .64' processingState' out continueProcessing);  						keepProcessing = continueProcessing;  					});  #if AGRESSIVE_VALIDATING  					Validate();  #endif  				}  			}  			else  			{  				SortVertices();  				MergeVertices(maxDistanceToConsiderVertexAsSame);  				MergeMeshEdges();  			}
Magic Number,MatterHackers.PolygonMesh,Mesh,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,CleanAndMergMesh,The following statement contains a magic number: if (reportProgress != null)  			{  #if AGRESSIVE_VALIDATING  				Validate();  #endif    				bool keepProcessing = true;  				SortVertices((double progress0To1' string processingState' out bool continueProcessing) =>  				{  					reportProgress(progress0To1 * .41' processingState' out continueProcessing);  					keepProcessing = continueProcessing;  #if AGRESSIVE_VALIDATING  					Validate();  #endif  				});  				if (keepProcessing)  				{  					MergeVertices(maxDistanceToConsiderVertexAsSame' (double progress0To1' string processingState' out bool continueProcessing) =>  					{  						reportProgress(progress0To1 * .23 + .41' processingState' out continueProcessing);  						keepProcessing = continueProcessing;  					});  				}  				if (keepProcessing)  				{  					MergeMeshEdges((double progress0To1' string processingState' out bool continueProcessing) =>  					{  						reportProgress(progress0To1 * .36 + .64' processingState' out continueProcessing);  						keepProcessing = continueProcessing;  					});  #if AGRESSIVE_VALIDATING  					Validate();  #endif  				}  			}  			else  			{  				SortVertices();  				MergeVertices(maxDistanceToConsiderVertexAsSame);  				MergeMeshEdges();  			}
Magic Number,MatterHackers.PolygonMesh,Mesh,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,CleanAndMergMesh,The following statement contains a magic number: if (reportProgress != null)  			{  #if AGRESSIVE_VALIDATING  				Validate();  #endif    				bool keepProcessing = true;  				SortVertices((double progress0To1' string processingState' out bool continueProcessing) =>  				{  					reportProgress(progress0To1 * .41' processingState' out continueProcessing);  					keepProcessing = continueProcessing;  #if AGRESSIVE_VALIDATING  					Validate();  #endif  				});  				if (keepProcessing)  				{  					MergeVertices(maxDistanceToConsiderVertexAsSame' (double progress0To1' string processingState' out bool continueProcessing) =>  					{  						reportProgress(progress0To1 * .23 + .41' processingState' out continueProcessing);  						keepProcessing = continueProcessing;  					});  				}  				if (keepProcessing)  				{  					MergeMeshEdges((double progress0To1' string processingState' out bool continueProcessing) =>  					{  						reportProgress(progress0To1 * .36 + .64' processingState' out continueProcessing);  						keepProcessing = continueProcessing;  					});  #if AGRESSIVE_VALIDATING  					Validate();  #endif  				}  			}  			else  			{  				SortVertices();  				MergeVertices(maxDistanceToConsiderVertexAsSame);  				MergeMeshEdges();  			}
Magic Number,MatterHackers.PolygonMesh,Mesh,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,CleanAndMergMesh,The following statement contains a magic number: if (reportProgress != null)  			{  #if AGRESSIVE_VALIDATING  				Validate();  #endif    				bool keepProcessing = true;  				SortVertices((double progress0To1' string processingState' out bool continueProcessing) =>  				{  					reportProgress(progress0To1 * .41' processingState' out continueProcessing);  					keepProcessing = continueProcessing;  #if AGRESSIVE_VALIDATING  					Validate();  #endif  				});  				if (keepProcessing)  				{  					MergeVertices(maxDistanceToConsiderVertexAsSame' (double progress0To1' string processingState' out bool continueProcessing) =>  					{  						reportProgress(progress0To1 * .23 + .41' processingState' out continueProcessing);  						keepProcessing = continueProcessing;  					});  				}  				if (keepProcessing)  				{  					MergeMeshEdges((double progress0To1' string processingState' out bool continueProcessing) =>  					{  						reportProgress(progress0To1 * .36 + .64' processingState' out continueProcessing);  						keepProcessing = continueProcessing;  					});  #if AGRESSIVE_VALIDATING  					Validate();  #endif  				}  			}  			else  			{  				SortVertices();  				MergeVertices(maxDistanceToConsiderVertexAsSame);  				MergeMeshEdges();  			}
Magic Number,MatterHackers.PolygonMesh,Mesh,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,CleanAndMergMesh,The following statement contains a magic number: if (reportProgress != null)  			{  #if AGRESSIVE_VALIDATING  				Validate();  #endif    				bool keepProcessing = true;  				SortVertices((double progress0To1' string processingState' out bool continueProcessing) =>  				{  					reportProgress(progress0To1 * .41' processingState' out continueProcessing);  					keepProcessing = continueProcessing;  #if AGRESSIVE_VALIDATING  					Validate();  #endif  				});  				if (keepProcessing)  				{  					MergeVertices(maxDistanceToConsiderVertexAsSame' (double progress0To1' string processingState' out bool continueProcessing) =>  					{  						reportProgress(progress0To1 * .23 + .41' processingState' out continueProcessing);  						keepProcessing = continueProcessing;  					});  				}  				if (keepProcessing)  				{  					MergeMeshEdges((double progress0To1' string processingState' out bool continueProcessing) =>  					{  						reportProgress(progress0To1 * .36 + .64' processingState' out continueProcessing);  						keepProcessing = continueProcessing;  					});  #if AGRESSIVE_VALIDATING  					Validate();  #endif  				}  			}  			else  			{  				SortVertices();  				MergeVertices(maxDistanceToConsiderVertexAsSame);  				MergeMeshEdges();  			}
Magic Number,MatterHackers.PolygonMesh,Mesh,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,GetConnectionInfoAsString,The following statement contains a magic number: foreach (Vertex vertex in Vertices)  			{  				totalDebug.Append(new string('\t'' 1) + String.Format("Vertex: {0}\n"' vertex.Data.ID));  				vertex.AddDebugInfo(totalDebug' 2);  			}
Magic Number,MatterHackers.PolygonMesh,Mesh,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,GetConnectionInfoAsString,The following statement contains a magic number: foreach (MeshEdge meshEdge in MeshEdges)  			{  				totalDebug.Append(new string('\t'' 1) + String.Format("MeshEdge: {0}\n"' meshEdge.Data.ID));  				meshEdge.AddDebugInfo(totalDebug' 2);  			}
Magic Number,MatterHackers.PolygonMesh,Mesh,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,GetConnectionInfoAsString,The following statement contains a magic number: foreach (Face face in Faces)  			{  				totalDebug.Append(new string('\t'' 1) + String.Format("Face: {0}\n"' face.Data.ID));  				face.AddDebugInfo(totalDebug' 2);  			}
Magic Number,MatterHackers.PolygonMesh,Mesh,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,SplitFace,The following statement contains a magic number: foreach (FaceEdge faceEdge in faceToSplit.FaceEdges())  			{  				if (faceEdge.firstVertex == splitStartVertex)  				{  					faceEdgeAfterSplitStart = faceEdge;  					count++;  				}  				else if (faceEdge.firstVertex == splitEndVertex)  				{  					faceEdgeAfterSplitEnd = faceEdge;  					count++;  				}  				if (count == 2)  				{  					break; // stop if we found both face edges  				}  			}
Magic Number,MatterHackers.PolygonMesh,Mesh,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,MergeVertices,The following statement contains a magic number: for (int i = 0; i < Vertices.Count; i++)  			{  				Vertex vertexToKeep = Vertices[i];  				if (!markedForDeletion.Contains(vertexToKeep))  				{  					List<Vertex> samePosition = Vertices.FindVertices(vertexToKeep.Position' maxDistanceToConsiderVertexAsSame);  					foreach (Vertex vertexToDelete in samePosition)  					{  						if (vertexToDelete != vertexToKeep)  						{  							if (!markedForDeletion.Contains(vertexToDelete))  							{  #if AGRESSIVE_VALIDATING  								Validate(markedForDeletion);  #endif  								MergeVertices(vertexToKeep' vertexToDelete' false);  								markedForDeletion.Add(vertexToDelete);  #if AGRESSIVE_VALIDATING  								Validate(markedForDeletion);  #endif  							}  						}  					}    					if (reportProgress != null)  					{  						if (maxProgressReport.ElapsedMilliseconds > 200)  						{  							bool continueProcessing;  							reportProgress(i / (double)Vertices.Count' "Merging Vertices"' out continueProcessing);  							if (!continueProcessing)  							{  								return;  							}  							maxProgressReport.Restart();  						}  					}  				}  			}
Magic Number,MatterHackers.PolygonMesh,Mesh,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,SplitMeshEdge,The following statement contains a magic number: {  				// make a new vertex between the existing ones    				// TODO: make this create an interpolated vertex' check if it exits and add it or use the right one.  				//vertexCreatedDuringSplit = meshEdgeToSplit.edgeEndVertex[0].CreateInterpolated(meshEdgeToSplit.edgeEndVertex[1]' .5);  				vertexCreatedDuringSplit = CreateVertex((meshEdgeToSplit.VertexOnEnd[0].Position + meshEdgeToSplit.VertexOnEnd[1].Position) / 2);  				// TODO: check if the mesh edge exits and use the existing one (or not)  				meshEdgeCreatedDuringSplit = new MeshEdge();  			}
Magic Number,MatterHackers.PolygonMesh,Mesh,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,MergeMeshEdges,The following statement contains a magic number: for (int i = 0; i < MeshEdges.Count; i++)  			{  				MeshEdge currentMeshEdge = MeshEdges[i];  				if (!markedForDeletion.Contains(currentMeshEdge))  				{  					Vertex vertex0 = currentMeshEdge.VertexOnEnd[0];  					Vertex vertex1 = currentMeshEdge.VertexOnEnd[1];    					// find out if there is another edge attached to the same vertexes  					List<MeshEdge> meshEdgesToDelete = FindMeshEdges(vertex0' vertex1);    					if (meshEdgesToDelete.Count > 1)  					{  						foreach (MeshEdge meshEdgeToDelete in meshEdgesToDelete)  						{  							if (meshEdgeToDelete != currentMeshEdge)  							{  								if (!markedForDeletion.Contains(meshEdgeToDelete))  								{  									MergeMeshEdges(currentMeshEdge' meshEdgeToDelete' false);  									markedForDeletion.Add(meshEdgeToDelete);  								}  							}  						}  					}  				}    				if (reportProgress != null)  				{  					if (maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(i / (double)MeshEdges.Count' "Merging Mesh Edges"' out continueProcessing);  						maxProgressReport.Restart();  						if (!continueProcessing)  						{  							return;  						}  					}  				}  			}
Magic Number,MatterHackers.PolygonMesh,Mesh,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,CreateFace,The following statement contains a magic number: if (nonRepeatingSet.Count < 3  				|| (nonRepeatingSet.Count == 3  				&& (nonRepeatingSet[0].Position == nonRepeatingSet[1].Position  				|| nonRepeatingSet[1].Position == nonRepeatingSet[2].Position  				|| nonRepeatingSet[2].Position == nonRepeatingSet[0].Position)))  			{  				return null;  			}
Magic Number,MatterHackers.PolygonMesh,Mesh,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,CreateFace,The following statement contains a magic number: if (nonRepeatingSet.Count < 3  				|| (nonRepeatingSet.Count == 3  				&& (nonRepeatingSet[0].Position == nonRepeatingSet[1].Position  				|| nonRepeatingSet[1].Position == nonRepeatingSet[2].Position  				|| nonRepeatingSet[2].Position == nonRepeatingSet[0].Position)))  			{  				return null;  			}
Magic Number,MatterHackers.PolygonMesh,Mesh,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,CreateFace,The following statement contains a magic number: if (nonRepeatingSet.Count < 3  				|| (nonRepeatingSet.Count == 3  				&& (nonRepeatingSet[0].Position == nonRepeatingSet[1].Position  				|| nonRepeatingSet[1].Position == nonRepeatingSet[2].Position  				|| nonRepeatingSet[2].Position == nonRepeatingSet[0].Position)))  			{  				return null;  			}
Magic Number,MatterHackers.PolygonMesh,Mesh,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,CreateFace,The following statement contains a magic number: if (nonRepeatingSet.Count < 3  				|| (nonRepeatingSet.Count == 3  				&& (nonRepeatingSet[0].Position == nonRepeatingSet[1].Position  				|| nonRepeatingSet[1].Position == nonRepeatingSet[2].Position  				|| nonRepeatingSet[2].Position == nonRepeatingSet[0].Position)))  			{  				return null;  			}
Magic Number,MatterHackers.PolygonMesh,Mesh,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,GetNonManifoldEdges,The following statement contains a magic number: foreach (MeshEdge meshEdge in MeshEdges)  			{  				int numFacesSharingEdge = meshEdge.GetNumFacesSharingEdge();  				if (numFacesSharingEdge != 2)  				{  					nonManifoldEdges.Add(meshEdge);  				}  			}
Magic Number,MatterHackers.PolygonMesh,Mesh,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,Triangulate,The following statement contains a magic number: foreach (Face face in tempFaceList)  			{  				if (face.NumVertices != 3)  				{  					List<Vertex> positionsCCW = new List<Vertex>();  					foreach (FaceEdge faceEdge in face.FaceEdges())  					{  						positionsCCW.Add(faceEdge.firstVertex);  					}    					for(int splitIndex = 2; splitIndex < positionsCCW.Count - 1; splitIndex++)  					{  						MeshEdge createdEdge;  						Face createdFace;  						this.SplitFace(face' positionsCCW[0]' positionsCCW[splitIndex]' out createdEdge' out createdFace);  					}  				}  			}
Magic Number,MatterHackers.PolygonMesh,Mesh,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Mesh.cs,Triangulate,The following statement contains a magic number: foreach (Face face in tempFaceList)  			{  				if (face.NumVertices != 3)  				{  					List<Vertex> positionsCCW = new List<Vertex>();  					foreach (FaceEdge faceEdge in face.FaceEdges())  					{  						positionsCCW.Add(faceEdge.firstVertex);  					}    					for(int splitIndex = 2; splitIndex < positionsCCW.Count - 1; splitIndex++)  					{  						MeshEdge createdEdge;  						Face createdFace;  						this.SplitFace(face' positionsCCW[0]' positionsCCW[splitIndex]' out createdEdge' out createdFace);  					}  				}  			}
Magic Number,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,DebugRenderToImage,The following statement contains a magic number: scale = Math.Min((image.Width - padding * 2) / (max.x - min.x)' (image.Height - padding * 2) / (max.y - min.y));
Magic Number,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,DebugRenderToImage,The following statement contains a magic number: scale = Math.Min((image.Width - padding * 2) / (max.x - min.x)' (image.Height - padding * 2) / (max.y - min.y));
Magic Number,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,CreateImage,The following statement contains a magic number: foreach (Face faceToRender in meshToRender.Faces)  			{  				Vector2 faceAverageCenter = new Vector2();  				int vertexCount = 0;  				// draw all the vertices  				foreach (Vertex vertex in faceToRender.Vertices())  				{  					Vector2 imagePosition = GetImagePosition(vertex.Position);  					faceAverageCenter += imagePosition;  					vertexCount++;  				}  				faceAverageCenter /= vertexCount;    				foreach (FaceEdge faceEdge in faceToRender.FaceEdges())  				{  					// draw the face edge  					DrawFaceEdge(faceEdge' faceAverageCenter);  				}    				WriteStringAtPos(faceToRender.Data.ID.ToString()' faceAverageCenter' faceColor);  				DrawRectangle(faceAverageCenter);  				WriteStringAtPos(faceToRender.firstFaceEdge.Data.ID.ToString()' faceAverageCenter + new Vector2(0' -12)' faceEdgeColor);  			}
Magic Number,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,DrawVertex,The following statement contains a magic number: WriteStringAtPos("{0}".FormatWith(vertex.firstMeshEdge.Data.ID)' imagePosition + new Vector2(0' -12)' meshEdgeColor);
Magic Number,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,DrawFaceEdge,The following statement contains a magic number: graphics.Circle(start' 3' RGBA_Bytes.Black);
Magic Number,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,DrawFaceEdge,The following statement contains a magic number: WriteStringAtPos("{0}".FormatWith(faceEdge.meshEdge.Data.ID)' (start + end) / 2 + new Vector2(0' -12)' meshEdgeColor);
Magic Number,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,DrawFaceEdge,The following statement contains a magic number: WriteStringAtPos("{0}".FormatWith(faceEdge.meshEdge.Data.ID)' (start + end) / 2 + new Vector2(0' -12)' meshEdgeColor);
Magic Number,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,DrawFaceEdge,The following statement contains a magic number: WriteStringAtPos("{0}".FormatWith(faceEdge.containingFace.Data.ID)' (start + end) / 2 + new Vector2(0' 12)' faceColor);
Magic Number,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,DrawFaceEdge,The following statement contains a magic number: WriteStringAtPos("{0}".FormatWith(faceEdge.containingFace.Data.ID)' (start + end) / 2 + new Vector2(0' 12)' faceColor);
Magic Number,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,DrawFaceEdge,The following statement contains a magic number: WriteStringAtPos("{0}".FormatWith(faceEdge.firstVertex.Data.ID)' start + normal * length * .10' vertexColor);
Magic Number,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,DrawFaceEdge,The following statement contains a magic number: WriteStringAtPos("{0}".FormatWith(faceEdge.nextFaceEdge.Data.ID)' start + normal * length * .60' faceEdgeColor);
Magic Number,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,DrawFaceEdge,The following statement contains a magic number: WriteStringAtPos("{0}".FormatWith(faceEdge.prevFaceEdge.Data.ID)' start + normal * length * .40' faceEdgeColor);
Magic Number,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,DrawFaceEdge,The following statement contains a magic number: WriteStringAtPos("{0}".FormatWith(faceEdge.radialNextFaceEdge.Data.ID)' start + new Vector2(0' 7) + normal * length * .90' faceEdgeColor);
Magic Number,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,DrawFaceEdge,The following statement contains a magic number: WriteStringAtPos("{0}".FormatWith(faceEdge.radialNextFaceEdge.Data.ID)' start + new Vector2(0' 7) + normal * length * .90' faceEdgeColor);
Magic Number,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,DrawFaceEdge,The following statement contains a magic number: WriteStringAtPos("{0}".FormatWith(faceEdge.radialPrevFaceEdge.Data.ID)' start + new Vector2(0' -7) + normal * length * .90' faceEdgeColor);
Magic Number,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,DrawFaceEdge,The following statement contains a magic number: WriteStringAtPos("{0}".FormatWith(faceEdge.radialPrevFaceEdge.Data.ID)' start + new Vector2(0' -7) + normal * length * .90' faceEdgeColor);
Magic Number,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,DrawMeshEdge,The following statement contains a magic number: if (meshEdge.firstFaceEdge != null)  			{  				WriteStringAtPos("{0}".FormatWith(meshEdge.firstFaceEdge.Data.ID)' (start + end) / 2 + new Vector2(0' 12)' faceEdgeColor);  			}  			else  			{  				WriteStringAtPos("null"' (start + end) / 2 + new Vector2(0' 12)' faceEdgeColor);  			}
Magic Number,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,DrawMeshEdge,The following statement contains a magic number: if (meshEdge.firstFaceEdge != null)  			{  				WriteStringAtPos("{0}".FormatWith(meshEdge.firstFaceEdge.Data.ID)' (start + end) / 2 + new Vector2(0' 12)' faceEdgeColor);  			}  			else  			{  				WriteStringAtPos("null"' (start + end) / 2 + new Vector2(0' 12)' faceEdgeColor);  			}
Magic Number,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,DrawMeshEdge,The following statement contains a magic number: if (meshEdge.firstFaceEdge != null)  			{  				WriteStringAtPos("{0}".FormatWith(meshEdge.firstFaceEdge.Data.ID)' (start + end) / 2 + new Vector2(0' 12)' faceEdgeColor);  			}  			else  			{  				WriteStringAtPos("null"' (start + end) / 2 + new Vector2(0' 12)' faceEdgeColor);  			}
Magic Number,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,DrawMeshEdge,The following statement contains a magic number: if (meshEdge.firstFaceEdge != null)  			{  				WriteStringAtPos("{0}".FormatWith(meshEdge.firstFaceEdge.Data.ID)' (start + end) / 2 + new Vector2(0' 12)' faceEdgeColor);  			}  			else  			{  				WriteStringAtPos("null"' (start + end) / 2 + new Vector2(0' 12)' faceEdgeColor);  			}
Magic Number,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,DrawMeshEdge,The following statement contains a magic number: WriteStringAtPos("{0}".FormatWith(meshEdge.NextMeshEdgeFromEnd[0].Data.ID)' start + normal * length * .40' meshEdgeColor);
Magic Number,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,DrawMeshEdge,The following statement contains a magic number: WriteStringAtPos("{0}".FormatWith(meshEdge.VertexOnEnd[0].Data.ID)' start + normal * length * .10' vertexColor);
Magic Number,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,DrawMeshEdge,The following statement contains a magic number: WriteStringAtPos("{0}".FormatWith(meshEdge.NextMeshEdgeFromEnd[1].Data.ID)' start + normal * length * .60' meshEdgeColor);
Magic Number,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,DrawMeshEdge,The following statement contains a magic number: WriteStringAtPos("{0}".FormatWith(meshEdge.VertexOnEnd[1].Data.ID)' start + normal * length * .90' vertexColor);
Magic Number,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,DrawEdgeLine,The following statement contains a magic number: Vector2 firstArrow = start + normal * length * .80;
Magic Number,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,DrawEdgeLine,The following statement contains a magic number: graphics.Line(firstArrow' firstArrow + left * 5 - normal * 5' RGBA_Bytes.Black);
Magic Number,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,DrawEdgeLine,The following statement contains a magic number: graphics.Line(firstArrow' firstArrow + left * 5 - normal * 5' RGBA_Bytes.Black);
Magic Number,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,DrawEdgeLine,The following statement contains a magic number: graphics.Line(firstArrow' firstArrow - left * 5 - normal * 5' RGBA_Bytes.Black);
Magic Number,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,DrawEdgeLine,The following statement contains a magic number: graphics.Line(firstArrow' firstArrow - left * 5 - normal * 5' RGBA_Bytes.Black);
Magic Number,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,DrawEdgeLine,The following statement contains a magic number: graphics.FillRectangle((end + start) / 2 - new Vector2(20' 7)' (end + start) / 2 + new Vector2(20' 7)' RGBA_Bytes.White);
Magic Number,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,DrawEdgeLine,The following statement contains a magic number: graphics.FillRectangle((end + start) / 2 - new Vector2(20' 7)' (end + start) / 2 + new Vector2(20' 7)' RGBA_Bytes.White);
Magic Number,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,DrawEdgeLine,The following statement contains a magic number: graphics.FillRectangle((end + start) / 2 - new Vector2(20' 7)' (end + start) / 2 + new Vector2(20' 7)' RGBA_Bytes.White);
Magic Number,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,DrawEdgeLine,The following statement contains a magic number: graphics.FillRectangle((end + start) / 2 - new Vector2(20' 7)' (end + start) / 2 + new Vector2(20' 7)' RGBA_Bytes.White);
Magic Number,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,DrawEdgeLine,The following statement contains a magic number: graphics.FillRectangle((end + start) / 2 - new Vector2(20' 7)' (end + start) / 2 + new Vector2(20' 7)' RGBA_Bytes.White);
Magic Number,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,DrawEdgeLine,The following statement contains a magic number: graphics.FillRectangle((end + start) / 2 - new Vector2(20' 7)' (end + start) / 2 + new Vector2(20' 7)' RGBA_Bytes.White);
Magic Number,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,DrawEdgeLine,The following statement contains a magic number: Vector2 stringCenter = new Vector2((end.x + start.x) / 2' (end.y + start.y) / 2);
Magic Number,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,DrawEdgeLine,The following statement contains a magic number: Vector2 stringCenter = new Vector2((end.x + start.x) / 2' (end.y + start.y) / 2);
Magic Number,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,MoveTowardsCenter,The following statement contains a magic number: delta *= .75;
Magic Number,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,DrawCircle,The following statement contains a magic number: Ellipse circle = new Ellipse(imagePosition' 14);
Magic Number,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,DrawRectangle,The following statement contains a magic number: RoundedRect rect = new RoundedRect(imagePosition.x - 20' imagePosition.y - 7' imagePosition.x + 20' imagePosition.y + 7' 3);
Magic Number,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,DrawRectangle,The following statement contains a magic number: RoundedRect rect = new RoundedRect(imagePosition.x - 20' imagePosition.y - 7' imagePosition.x + 20' imagePosition.y + 7' 3);
Magic Number,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,DrawRectangle,The following statement contains a magic number: RoundedRect rect = new RoundedRect(imagePosition.x - 20' imagePosition.y - 7' imagePosition.x + 20' imagePosition.y + 7' 3);
Magic Number,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,DrawRectangle,The following statement contains a magic number: RoundedRect rect = new RoundedRect(imagePosition.x - 20' imagePosition.y - 7' imagePosition.x + 20' imagePosition.y + 7' 3);
Magic Number,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,DrawRectangle,The following statement contains a magic number: RoundedRect rect = new RoundedRect(imagePosition.x - 20' imagePosition.y - 7' imagePosition.x + 20' imagePosition.y + 7' 3);
Magic Number,MatterHackers.PolygonMesh,DebugRenderToImage,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\DebugRenderToImage.cs,WriteStringAtPos,The following statement contains a magic number: graphics.DrawString(stringToWrite' imagePosition.x' imagePosition.y' 10' justification: Justification.Center' baseline: Baseline.BoundsCenter' color: RGBA_Bytes.Black' backgroundColor: backgroundColor);
Magic Number,MatterHackers.PolygonMesh,CommonShapes,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\CommonShapes.cs,CreatePlane,The following statement contains a magic number: Vector3 scale = new Vector3(scaleIn * .5);
Magic Number,MatterHackers.PolygonMesh,CommonShapes,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\CommonShapes.cs,CreatePlane,The following statement contains a magic number: Vertex[] verts = new Vertex[8];
Magic Number,MatterHackers.PolygonMesh,CommonShapes,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\CommonShapes.cs,CreatePlane,The following statement contains a magic number: verts[2] = plane.CreateVertex(new Vector3(1' 1' 0) * scale);
Magic Number,MatterHackers.PolygonMesh,CommonShapes,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\CommonShapes.cs,CreatePlane,The following statement contains a magic number: verts[3] = plane.CreateVertex(new Vector3(-1' 1' 0) * scale);
Magic Number,MatterHackers.PolygonMesh,CommonShapes,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\CommonShapes.cs,CreatePlane,The following statement contains a magic number: plane.CreateFace(new Vertex[] { verts[0]' verts[1]' verts[2]' verts[3] });
Magic Number,MatterHackers.PolygonMesh,CommonShapes,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\CommonShapes.cs,CreatePlane,The following statement contains a magic number: plane.CreateFace(new Vertex[] { verts[0]' verts[1]' verts[2]' verts[3] });
Magic Number,MatterHackers.PolygonMesh,CommonShapes,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\CommonShapes.cs,PlaceTextureOnFace,The following statement contains a magic number: foreach (FaceEdge faceEdge in face.FaceEdges())  			{  				FaceEdgeTextureUvData edgeUV = FaceEdgeTextureUvData.Get(faceEdge);  				switch (count++)  				{  					case 0:  						edgeUV.TextureUV.Add(new Vector2(0' 0));  						break;    					case 1:  						edgeUV.TextureUV.Add(new Vector2(1' 0));  						break;    					case 2:  						edgeUV.TextureUV.Add(new Vector2(1' 1));  						break;    					case 3:  						edgeUV.TextureUV.Add(new Vector2(0' 1));  						break;  				}  			}
Magic Number,MatterHackers.PolygonMesh,CommonShapes,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\CommonShapes.cs,PlaceTextureOnFace,The following statement contains a magic number: foreach (FaceEdge faceEdge in face.FaceEdges())  			{  				FaceEdgeTextureUvData edgeUV = FaceEdgeTextureUvData.Get(faceEdge);  				switch (count++)  				{  					case 0:  						edgeUV.TextureUV.Add(new Vector2(0' 0));  						break;    					case 1:  						edgeUV.TextureUV.Add(new Vector2(1' 0));  						break;    					case 2:  						edgeUV.TextureUV.Add(new Vector2(1' 1));  						break;    					case 3:  						edgeUV.TextureUV.Add(new Vector2(0' 1));  						break;  				}  			}
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateTetrahedron,The following statement contains a magic number: double baseOffsetZ = -Math.Sin(MathHelper.DegreesToRadians(30));
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateTetrahedron,The following statement contains a magic number: Vertex[] verts = new Vertex[4];
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateTetrahedron,The following statement contains a magic number: verts[1] = tetrahedron.CreateVertex(new Vector3(Vector2.Rotate(basePoint' MathHelper.Tau / 3)' baseOffsetZ));
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateTetrahedron,The following statement contains a magic number: verts[2] = tetrahedron.CreateVertex(new Vector3(Vector2.Rotate(basePoint' 2 * MathHelper.Tau / 3)' baseOffsetZ));
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateTetrahedron,The following statement contains a magic number: verts[2] = tetrahedron.CreateVertex(new Vector3(Vector2.Rotate(basePoint' 2 * MathHelper.Tau / 3)' baseOffsetZ));
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateTetrahedron,The following statement contains a magic number: verts[2] = tetrahedron.CreateVertex(new Vector3(Vector2.Rotate(basePoint' 2 * MathHelper.Tau / 3)' baseOffsetZ));
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateTetrahedron,The following statement contains a magic number: verts[3] = tetrahedron.CreateVertex(new Vector3(0' 0' 1));
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateTetrahedron,The following statement contains a magic number: tetrahedron.CreateFace(new Vertex[] { verts[0]' verts[2]' verts[1] });
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateTetrahedron,The following statement contains a magic number: tetrahedron.CreateFace(new Vertex[] { verts[0]' verts[1]' verts[3] });
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateTetrahedron,The following statement contains a magic number: tetrahedron.CreateFace(new Vertex[] { verts[1]' verts[2]' verts[3] });
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateTetrahedron,The following statement contains a magic number: tetrahedron.CreateFace(new Vertex[] { verts[1]' verts[2]' verts[3] });
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateTetrahedron,The following statement contains a magic number: tetrahedron.CreateFace(new Vertex[] { verts[2]' verts[0]' verts[3] });
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateTetrahedron,The following statement contains a magic number: tetrahedron.CreateFace(new Vertex[] { verts[2]' verts[0]' verts[3] });
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: scale *= .5;
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: Vertex[] verts = new Vertex[8];
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: verts[2] = cube.CreateVertex(new Vector3(1' 1' 1) * scale);
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: verts[3] = cube.CreateVertex(new Vector3(-1' 1' 1) * scale);
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: verts[4] = cube.CreateVertex(new Vector3(-1' -1' -1) * scale);
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: verts[5] = cube.CreateVertex(new Vector3(1' -1' -1) * scale);
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: verts[6] = cube.CreateVertex(new Vector3(1' 1' -1) * scale);
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: verts[7] = cube.CreateVertex(new Vector3(-1' 1' -1) * scale);
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: cube.CreateFace(new Vertex[] { verts[0]' verts[1]' verts[2]' verts[3] });
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: cube.CreateFace(new Vertex[] { verts[0]' verts[1]' verts[2]' verts[3] });
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: cube.CreateFace(new Vertex[] { verts[4]' verts[0]' verts[3]' verts[7] });
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: cube.CreateFace(new Vertex[] { verts[4]' verts[0]' verts[3]' verts[7] });
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: cube.CreateFace(new Vertex[] { verts[4]' verts[0]' verts[3]' verts[7] });
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: cube.CreateFace(new Vertex[] { verts[1]' verts[5]' verts[6]' verts[2] });
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: cube.CreateFace(new Vertex[] { verts[1]' verts[5]' verts[6]' verts[2] });
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: cube.CreateFace(new Vertex[] { verts[1]' verts[5]' verts[6]' verts[2] });
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: cube.CreateFace(new Vertex[] { verts[4]' verts[7]' verts[6]' verts[5] });
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: cube.CreateFace(new Vertex[] { verts[4]' verts[7]' verts[6]' verts[5] });
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: cube.CreateFace(new Vertex[] { verts[4]' verts[7]' verts[6]' verts[5] });
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: cube.CreateFace(new Vertex[] { verts[4]' verts[7]' verts[6]' verts[5] });
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: cube.CreateFace(new Vertex[] { verts[3]' verts[2]' verts[6]' verts[7] });
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: cube.CreateFace(new Vertex[] { verts[3]' verts[2]' verts[6]' verts[7] });
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: cube.CreateFace(new Vertex[] { verts[3]' verts[2]' verts[6]' verts[7] });
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: cube.CreateFace(new Vertex[] { verts[3]' verts[2]' verts[6]' verts[7] });
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: cube.CreateFace(new Vertex[] { verts[4]' verts[5]' verts[1]' verts[0] });
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateCube,The following statement contains a magic number: cube.CreateFace(new Vertex[] { verts[4]' verts[5]' verts[1]' verts[0] });
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: double[] icosahedronVertices =              {                  0' -0.525731' 0.850651'                  0.850651' 0' 0.525731'                  0.850651' 0' -0.525731'                  -0.850651' 0' -0.525731'                  -0.850651' 0' 0.525731'                  -0.525731' 0.850651' 0'                  0.525731' 0.850651' 0'                  0.525731' -0.850651' 0'                  -0.525731' -0.850651' 0'                  0' -0.525731' -0.850651'                  0' 0.525731' -0.850651'                  0' 0.525731' 0.850651              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: double[] icosahedronVertices =              {                  0' -0.525731' 0.850651'                  0.850651' 0' 0.525731'                  0.850651' 0' -0.525731'                  -0.850651' 0' -0.525731'                  -0.850651' 0' 0.525731'                  -0.525731' 0.850651' 0'                  0.525731' 0.850651' 0'                  0.525731' -0.850651' 0'                  -0.525731' -0.850651' 0'                  0' -0.525731' -0.850651'                  0' 0.525731' -0.850651'                  0' 0.525731' 0.850651              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: double[] icosahedronVertices =              {                  0' -0.525731' 0.850651'                  0.850651' 0' 0.525731'                  0.850651' 0' -0.525731'                  -0.850651' 0' -0.525731'                  -0.850651' 0' 0.525731'                  -0.525731' 0.850651' 0'                  0.525731' 0.850651' 0'                  0.525731' -0.850651' 0'                  -0.525731' -0.850651' 0'                  0' -0.525731' -0.850651'                  0' 0.525731' -0.850651'                  0' 0.525731' 0.850651              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: double[] icosahedronVertices =              {                  0' -0.525731' 0.850651'                  0.850651' 0' 0.525731'                  0.850651' 0' -0.525731'                  -0.850651' 0' -0.525731'                  -0.850651' 0' 0.525731'                  -0.525731' 0.850651' 0'                  0.525731' 0.850651' 0'                  0.525731' -0.850651' 0'                  -0.525731' -0.850651' 0'                  0' -0.525731' -0.850651'                  0' 0.525731' -0.850651'                  0' 0.525731' 0.850651              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: double[] icosahedronVertices =              {                  0' -0.525731' 0.850651'                  0.850651' 0' 0.525731'                  0.850651' 0' -0.525731'                  -0.850651' 0' -0.525731'                  -0.850651' 0' 0.525731'                  -0.525731' 0.850651' 0'                  0.525731' 0.850651' 0'                  0.525731' -0.850651' 0'                  -0.525731' -0.850651' 0'                  0' -0.525731' -0.850651'                  0' 0.525731' -0.850651'                  0' 0.525731' 0.850651              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: double[] icosahedronVertices =              {                  0' -0.525731' 0.850651'                  0.850651' 0' 0.525731'                  0.850651' 0' -0.525731'                  -0.850651' 0' -0.525731'                  -0.850651' 0' 0.525731'                  -0.525731' 0.850651' 0'                  0.525731' 0.850651' 0'                  0.525731' -0.850651' 0'                  -0.525731' -0.850651' 0'                  0' -0.525731' -0.850651'                  0' 0.525731' -0.850651'                  0' 0.525731' 0.850651              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: double[] icosahedronVertices =              {                  0' -0.525731' 0.850651'                  0.850651' 0' 0.525731'                  0.850651' 0' -0.525731'                  -0.850651' 0' -0.525731'                  -0.850651' 0' 0.525731'                  -0.525731' 0.850651' 0'                  0.525731' 0.850651' 0'                  0.525731' -0.850651' 0'                  -0.525731' -0.850651' 0'                  0' -0.525731' -0.850651'                  0' 0.525731' -0.850651'                  0' 0.525731' 0.850651              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: double[] icosahedronVertices =              {                  0' -0.525731' 0.850651'                  0.850651' 0' 0.525731'                  0.850651' 0' -0.525731'                  -0.850651' 0' -0.525731'                  -0.850651' 0' 0.525731'                  -0.525731' 0.850651' 0'                  0.525731' 0.850651' 0'                  0.525731' -0.850651' 0'                  -0.525731' -0.850651' 0'                  0' -0.525731' -0.850651'                  0' 0.525731' -0.850651'                  0' 0.525731' 0.850651              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: double[] icosahedronVertices =              {                  0' -0.525731' 0.850651'                  0.850651' 0' 0.525731'                  0.850651' 0' -0.525731'                  -0.850651' 0' -0.525731'                  -0.850651' 0' 0.525731'                  -0.525731' 0.850651' 0'                  0.525731' 0.850651' 0'                  0.525731' -0.850651' 0'                  -0.525731' -0.850651' 0'                  0' -0.525731' -0.850651'                  0' 0.525731' -0.850651'                  0' 0.525731' 0.850651              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: double[] icosahedronVertices =              {                  0' -0.525731' 0.850651'                  0.850651' 0' 0.525731'                  0.850651' 0' -0.525731'                  -0.850651' 0' -0.525731'                  -0.850651' 0' 0.525731'                  -0.525731' 0.850651' 0'                  0.525731' 0.850651' 0'                  0.525731' -0.850651' 0'                  -0.525731' -0.850651' 0'                  0' -0.525731' -0.850651'                  0' 0.525731' -0.850651'                  0' 0.525731' 0.850651              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: double[] icosahedronVertices =              {                  0' -0.525731' 0.850651'                  0.850651' 0' 0.525731'                  0.850651' 0' -0.525731'                  -0.850651' 0' -0.525731'                  -0.850651' 0' 0.525731'                  -0.525731' 0.850651' 0'                  0.525731' 0.850651' 0'                  0.525731' -0.850651' 0'                  -0.525731' -0.850651' 0'                  0' -0.525731' -0.850651'                  0' 0.525731' -0.850651'                  0' 0.525731' 0.850651              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: double[] icosahedronVertices =              {                  0' -0.525731' 0.850651'                  0.850651' 0' 0.525731'                  0.850651' 0' -0.525731'                  -0.850651' 0' -0.525731'                  -0.850651' 0' 0.525731'                  -0.525731' 0.850651' 0'                  0.525731' 0.850651' 0'                  0.525731' -0.850651' 0'                  -0.525731' -0.850651' 0'                  0' -0.525731' -0.850651'                  0' 0.525731' -0.850651'                  0' 0.525731' 0.850651              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: double[] icosahedronVertices =              {                  0' -0.525731' 0.850651'                  0.850651' 0' 0.525731'                  0.850651' 0' -0.525731'                  -0.850651' 0' -0.525731'                  -0.850651' 0' 0.525731'                  -0.525731' 0.850651' 0'                  0.525731' 0.850651' 0'                  0.525731' -0.850651' 0'                  -0.525731' -0.850651' 0'                  0' -0.525731' -0.850651'                  0' 0.525731' -0.850651'                  0' 0.525731' 0.850651              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: double[] icosahedronVertices =              {                  0' -0.525731' 0.850651'                  0.850651' 0' 0.525731'                  0.850651' 0' -0.525731'                  -0.850651' 0' -0.525731'                  -0.850651' 0' 0.525731'                  -0.525731' 0.850651' 0'                  0.525731' 0.850651' 0'                  0.525731' -0.850651' 0'                  -0.525731' -0.850651' 0'                  0' -0.525731' -0.850651'                  0' 0.525731' -0.850651'                  0' 0.525731' 0.850651              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: double[] icosahedronVertices =              {                  0' -0.525731' 0.850651'                  0.850651' 0' 0.525731'                  0.850651' 0' -0.525731'                  -0.850651' 0' -0.525731'                  -0.850651' 0' 0.525731'                  -0.525731' 0.850651' 0'                  0.525731' 0.850651' 0'                  0.525731' -0.850651' 0'                  -0.525731' -0.850651' 0'                  0' -0.525731' -0.850651'                  0' 0.525731' -0.850651'                  0' 0.525731' 0.850651              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: double[] icosahedronVertices =              {                  0' -0.525731' 0.850651'                  0.850651' 0' 0.525731'                  0.850651' 0' -0.525731'                  -0.850651' 0' -0.525731'                  -0.850651' 0' 0.525731'                  -0.525731' 0.850651' 0'                  0.525731' 0.850651' 0'                  0.525731' -0.850651' 0'                  -0.525731' -0.850651' 0'                  0' -0.525731' -0.850651'                  0' 0.525731' -0.850651'                  0' 0.525731' 0.850651              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: double[] icosahedronVertices =              {                  0' -0.525731' 0.850651'                  0.850651' 0' 0.525731'                  0.850651' 0' -0.525731'                  -0.850651' 0' -0.525731'                  -0.850651' 0' 0.525731'                  -0.525731' 0.850651' 0'                  0.525731' 0.850651' 0'                  0.525731' -0.850651' 0'                  -0.525731' -0.850651' 0'                  0' -0.525731' -0.850651'                  0' 0.525731' -0.850651'                  0' 0.525731' 0.850651              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: double[] icosahedronVertices =              {                  0' -0.525731' 0.850651'                  0.850651' 0' 0.525731'                  0.850651' 0' -0.525731'                  -0.850651' 0' -0.525731'                  -0.850651' 0' 0.525731'                  -0.525731' 0.850651' 0'                  0.525731' 0.850651' 0'                  0.525731' -0.850651' 0'                  -0.525731' -0.850651' 0'                  0' -0.525731' -0.850651'                  0' 0.525731' -0.850651'                  0' 0.525731' 0.850651              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: double[] icosahedronVertices =              {                  0' -0.525731' 0.850651'                  0.850651' 0' 0.525731'                  0.850651' 0' -0.525731'                  -0.850651' 0' -0.525731'                  -0.850651' 0' 0.525731'                  -0.525731' 0.850651' 0'                  0.525731' 0.850651' 0'                  0.525731' -0.850651' 0'                  -0.525731' -0.850651' 0'                  0' -0.525731' -0.850651'                  0' 0.525731' -0.850651'                  0' 0.525731' 0.850651              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: double[] icosahedronVertices =              {                  0' -0.525731' 0.850651'                  0.850651' 0' 0.525731'                  0.850651' 0' -0.525731'                  -0.850651' 0' -0.525731'                  -0.850651' 0' 0.525731'                  -0.525731' 0.850651' 0'                  0.525731' 0.850651' 0'                  0.525731' -0.850651' 0'                  -0.525731' -0.850651' 0'                  0' -0.525731' -0.850651'                  0' 0.525731' -0.850651'                  0' 0.525731' 0.850651              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: double[] icosahedronVertices =              {                  0' -0.525731' 0.850651'                  0.850651' 0' 0.525731'                  0.850651' 0' -0.525731'                  -0.850651' 0' -0.525731'                  -0.850651' 0' 0.525731'                  -0.525731' 0.850651' 0'                  0.525731' 0.850651' 0'                  0.525731' -0.850651' 0'                  -0.525731' -0.850651' 0'                  0' -0.525731' -0.850651'                  0' 0.525731' -0.850651'                  0' 0.525731' 0.850651              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: double[] icosahedronVertices =              {                  0' -0.525731' 0.850651'                  0.850651' 0' 0.525731'                  0.850651' 0' -0.525731'                  -0.850651' 0' -0.525731'                  -0.850651' 0' 0.525731'                  -0.525731' 0.850651' 0'                  0.525731' 0.850651' 0'                  0.525731' -0.850651' 0'                  -0.525731' -0.850651' 0'                  0' -0.525731' -0.850651'                  0' 0.525731' -0.850651'                  0' 0.525731' 0.850651              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: double[] icosahedronVertices =              {                  0' -0.525731' 0.850651'                  0.850651' 0' 0.525731'                  0.850651' 0' -0.525731'                  -0.850651' 0' -0.525731'                  -0.850651' 0' 0.525731'                  -0.525731' 0.850651' 0'                  0.525731' 0.850651' 0'                  0.525731' -0.850651' 0'                  -0.525731' -0.850651' 0'                  0' -0.525731' -0.850651'                  0' 0.525731' -0.850651'                  0' 0.525731' 0.850651              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: double[] icosahedronVertices =              {                  0' -0.525731' 0.850651'                  0.850651' 0' 0.525731'                  0.850651' 0' -0.525731'                  -0.850651' 0' -0.525731'                  -0.850651' 0' 0.525731'                  -0.525731' 0.850651' 0'                  0.525731' 0.850651' 0'                  0.525731' -0.850651' 0'                  -0.525731' -0.850651' 0'                  0' -0.525731' -0.850651'                  0' 0.525731' -0.850651'                  0' 0.525731' 0.850651              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: int[] icosahedronIndicies =              {                  1' 2' 6'                  1' 7' 2'                  3' 4' 5'                  4' 3' 8'                  6' 5' 11'                  5' 6' 10'                  9' 10' 2'                  10' 9' 3'                  7' 8' 9'                  8' 7' 0'                  11' 0' 1'                  0' 11' 4'                  6' 2' 10'                  1' 6' 11'                  3' 5' 10'                  5' 4' 11'                  2' 7' 9'                  7' 1' 0'                  3' 9' 8'                  4' 8' 0'              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: int[] icosahedronIndicies =              {                  1' 2' 6'                  1' 7' 2'                  3' 4' 5'                  4' 3' 8'                  6' 5' 11'                  5' 6' 10'                  9' 10' 2'                  10' 9' 3'                  7' 8' 9'                  8' 7' 0'                  11' 0' 1'                  0' 11' 4'                  6' 2' 10'                  1' 6' 11'                  3' 5' 10'                  5' 4' 11'                  2' 7' 9'                  7' 1' 0'                  3' 9' 8'                  4' 8' 0'              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: int[] icosahedronIndicies =              {                  1' 2' 6'                  1' 7' 2'                  3' 4' 5'                  4' 3' 8'                  6' 5' 11'                  5' 6' 10'                  9' 10' 2'                  10' 9' 3'                  7' 8' 9'                  8' 7' 0'                  11' 0' 1'                  0' 11' 4'                  6' 2' 10'                  1' 6' 11'                  3' 5' 10'                  5' 4' 11'                  2' 7' 9'                  7' 1' 0'                  3' 9' 8'                  4' 8' 0'              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: int[] icosahedronIndicies =              {                  1' 2' 6'                  1' 7' 2'                  3' 4' 5'                  4' 3' 8'                  6' 5' 11'                  5' 6' 10'                  9' 10' 2'                  10' 9' 3'                  7' 8' 9'                  8' 7' 0'                  11' 0' 1'                  0' 11' 4'                  6' 2' 10'                  1' 6' 11'                  3' 5' 10'                  5' 4' 11'                  2' 7' 9'                  7' 1' 0'                  3' 9' 8'                  4' 8' 0'              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: int[] icosahedronIndicies =              {                  1' 2' 6'                  1' 7' 2'                  3' 4' 5'                  4' 3' 8'                  6' 5' 11'                  5' 6' 10'                  9' 10' 2'                  10' 9' 3'                  7' 8' 9'                  8' 7' 0'                  11' 0' 1'                  0' 11' 4'                  6' 2' 10'                  1' 6' 11'                  3' 5' 10'                  5' 4' 11'                  2' 7' 9'                  7' 1' 0'                  3' 9' 8'                  4' 8' 0'              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: int[] icosahedronIndicies =              {                  1' 2' 6'                  1' 7' 2'                  3' 4' 5'                  4' 3' 8'                  6' 5' 11'                  5' 6' 10'                  9' 10' 2'                  10' 9' 3'                  7' 8' 9'                  8' 7' 0'                  11' 0' 1'                  0' 11' 4'                  6' 2' 10'                  1' 6' 11'                  3' 5' 10'                  5' 4' 11'                  2' 7' 9'                  7' 1' 0'                  3' 9' 8'                  4' 8' 0'              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: int[] icosahedronIndicies =              {                  1' 2' 6'                  1' 7' 2'                  3' 4' 5'                  4' 3' 8'                  6' 5' 11'                  5' 6' 10'                  9' 10' 2'                  10' 9' 3'                  7' 8' 9'                  8' 7' 0'                  11' 0' 1'                  0' 11' 4'                  6' 2' 10'                  1' 6' 11'                  3' 5' 10'                  5' 4' 11'                  2' 7' 9'                  7' 1' 0'                  3' 9' 8'                  4' 8' 0'              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: int[] icosahedronIndicies =              {                  1' 2' 6'                  1' 7' 2'                  3' 4' 5'                  4' 3' 8'                  6' 5' 11'                  5' 6' 10'                  9' 10' 2'                  10' 9' 3'                  7' 8' 9'                  8' 7' 0'                  11' 0' 1'                  0' 11' 4'                  6' 2' 10'                  1' 6' 11'                  3' 5' 10'                  5' 4' 11'                  2' 7' 9'                  7' 1' 0'                  3' 9' 8'                  4' 8' 0'              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: int[] icosahedronIndicies =              {                  1' 2' 6'                  1' 7' 2'                  3' 4' 5'                  4' 3' 8'                  6' 5' 11'                  5' 6' 10'                  9' 10' 2'                  10' 9' 3'                  7' 8' 9'                  8' 7' 0'                  11' 0' 1'                  0' 11' 4'                  6' 2' 10'                  1' 6' 11'                  3' 5' 10'                  5' 4' 11'                  2' 7' 9'                  7' 1' 0'                  3' 9' 8'                  4' 8' 0'              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: int[] icosahedronIndicies =              {                  1' 2' 6'                  1' 7' 2'                  3' 4' 5'                  4' 3' 8'                  6' 5' 11'                  5' 6' 10'                  9' 10' 2'                  10' 9' 3'                  7' 8' 9'                  8' 7' 0'                  11' 0' 1'                  0' 11' 4'                  6' 2' 10'                  1' 6' 11'                  3' 5' 10'                  5' 4' 11'                  2' 7' 9'                  7' 1' 0'                  3' 9' 8'                  4' 8' 0'              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: int[] icosahedronIndicies =              {                  1' 2' 6'                  1' 7' 2'                  3' 4' 5'                  4' 3' 8'                  6' 5' 11'                  5' 6' 10'                  9' 10' 2'                  10' 9' 3'                  7' 8' 9'                  8' 7' 0'                  11' 0' 1'                  0' 11' 4'                  6' 2' 10'                  1' 6' 11'                  3' 5' 10'                  5' 4' 11'                  2' 7' 9'                  7' 1' 0'                  3' 9' 8'                  4' 8' 0'              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: int[] icosahedronIndicies =              {                  1' 2' 6'                  1' 7' 2'                  3' 4' 5'                  4' 3' 8'                  6' 5' 11'                  5' 6' 10'                  9' 10' 2'                  10' 9' 3'                  7' 8' 9'                  8' 7' 0'                  11' 0' 1'                  0' 11' 4'                  6' 2' 10'                  1' 6' 11'                  3' 5' 10'                  5' 4' 11'                  2' 7' 9'                  7' 1' 0'                  3' 9' 8'                  4' 8' 0'              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: int[] icosahedronIndicies =              {                  1' 2' 6'                  1' 7' 2'                  3' 4' 5'                  4' 3' 8'                  6' 5' 11'                  5' 6' 10'                  9' 10' 2'                  10' 9' 3'                  7' 8' 9'                  8' 7' 0'                  11' 0' 1'                  0' 11' 4'                  6' 2' 10'                  1' 6' 11'                  3' 5' 10'                  5' 4' 11'                  2' 7' 9'                  7' 1' 0'                  3' 9' 8'                  4' 8' 0'              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: int[] icosahedronIndicies =              {                  1' 2' 6'                  1' 7' 2'                  3' 4' 5'                  4' 3' 8'                  6' 5' 11'                  5' 6' 10'                  9' 10' 2'                  10' 9' 3'                  7' 8' 9'                  8' 7' 0'                  11' 0' 1'                  0' 11' 4'                  6' 2' 10'                  1' 6' 11'                  3' 5' 10'                  5' 4' 11'                  2' 7' 9'                  7' 1' 0'                  3' 9' 8'                  4' 8' 0'              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: int[] icosahedronIndicies =              {                  1' 2' 6'                  1' 7' 2'                  3' 4' 5'                  4' 3' 8'                  6' 5' 11'                  5' 6' 10'                  9' 10' 2'                  10' 9' 3'                  7' 8' 9'                  8' 7' 0'                  11' 0' 1'                  0' 11' 4'                  6' 2' 10'                  1' 6' 11'                  3' 5' 10'                  5' 4' 11'                  2' 7' 9'                  7' 1' 0'                  3' 9' 8'                  4' 8' 0'              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: int[] icosahedronIndicies =              {                  1' 2' 6'                  1' 7' 2'                  3' 4' 5'                  4' 3' 8'                  6' 5' 11'                  5' 6' 10'                  9' 10' 2'                  10' 9' 3'                  7' 8' 9'                  8' 7' 0'                  11' 0' 1'                  0' 11' 4'                  6' 2' 10'                  1' 6' 11'                  3' 5' 10'                  5' 4' 11'                  2' 7' 9'                  7' 1' 0'                  3' 9' 8'                  4' 8' 0'              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: int[] icosahedronIndicies =              {                  1' 2' 6'                  1' 7' 2'                  3' 4' 5'                  4' 3' 8'                  6' 5' 11'                  5' 6' 10'                  9' 10' 2'                  10' 9' 3'                  7' 8' 9'                  8' 7' 0'                  11' 0' 1'                  0' 11' 4'                  6' 2' 10'                  1' 6' 11'                  3' 5' 10'                  5' 4' 11'                  2' 7' 9'                  7' 1' 0'                  3' 9' 8'                  4' 8' 0'              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: int[] icosahedronIndicies =              {                  1' 2' 6'                  1' 7' 2'                  3' 4' 5'                  4' 3' 8'                  6' 5' 11'                  5' 6' 10'                  9' 10' 2'                  10' 9' 3'                  7' 8' 9'                  8' 7' 0'                  11' 0' 1'                  0' 11' 4'                  6' 2' 10'                  1' 6' 11'                  3' 5' 10'                  5' 4' 11'                  2' 7' 9'                  7' 1' 0'                  3' 9' 8'                  4' 8' 0'              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: int[] icosahedronIndicies =              {                  1' 2' 6'                  1' 7' 2'                  3' 4' 5'                  4' 3' 8'                  6' 5' 11'                  5' 6' 10'                  9' 10' 2'                  10' 9' 3'                  7' 8' 9'                  8' 7' 0'                  11' 0' 1'                  0' 11' 4'                  6' 2' 10'                  1' 6' 11'                  3' 5' 10'                  5' 4' 11'                  2' 7' 9'                  7' 1' 0'                  3' 9' 8'                  4' 8' 0'              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: int[] icosahedronIndicies =              {                  1' 2' 6'                  1' 7' 2'                  3' 4' 5'                  4' 3' 8'                  6' 5' 11'                  5' 6' 10'                  9' 10' 2'                  10' 9' 3'                  7' 8' 9'                  8' 7' 0'                  11' 0' 1'                  0' 11' 4'                  6' 2' 10'                  1' 6' 11'                  3' 5' 10'                  5' 4' 11'                  2' 7' 9'                  7' 1' 0'                  3' 9' 8'                  4' 8' 0'              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: int[] icosahedronIndicies =              {                  1' 2' 6'                  1' 7' 2'                  3' 4' 5'                  4' 3' 8'                  6' 5' 11'                  5' 6' 10'                  9' 10' 2'                  10' 9' 3'                  7' 8' 9'                  8' 7' 0'                  11' 0' 1'                  0' 11' 4'                  6' 2' 10'                  1' 6' 11'                  3' 5' 10'                  5' 4' 11'                  2' 7' 9'                  7' 1' 0'                  3' 9' 8'                  4' 8' 0'              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: int[] icosahedronIndicies =              {                  1' 2' 6'                  1' 7' 2'                  3' 4' 5'                  4' 3' 8'                  6' 5' 11'                  5' 6' 10'                  9' 10' 2'                  10' 9' 3'                  7' 8' 9'                  8' 7' 0'                  11' 0' 1'                  0' 11' 4'                  6' 2' 10'                  1' 6' 11'                  3' 5' 10'                  5' 4' 11'                  2' 7' 9'                  7' 1' 0'                  3' 9' 8'                  4' 8' 0'              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: int[] icosahedronIndicies =              {                  1' 2' 6'                  1' 7' 2'                  3' 4' 5'                  4' 3' 8'                  6' 5' 11'                  5' 6' 10'                  9' 10' 2'                  10' 9' 3'                  7' 8' 9'                  8' 7' 0'                  11' 0' 1'                  0' 11' 4'                  6' 2' 10'                  1' 6' 11'                  3' 5' 10'                  5' 4' 11'                  2' 7' 9'                  7' 1' 0'                  3' 9' 8'                  4' 8' 0'              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: int[] icosahedronIndicies =              {                  1' 2' 6'                  1' 7' 2'                  3' 4' 5'                  4' 3' 8'                  6' 5' 11'                  5' 6' 10'                  9' 10' 2'                  10' 9' 3'                  7' 8' 9'                  8' 7' 0'                  11' 0' 1'                  0' 11' 4'                  6' 2' 10'                  1' 6' 11'                  3' 5' 10'                  5' 4' 11'                  2' 7' 9'                  7' 1' 0'                  3' 9' 8'                  4' 8' 0'              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: int[] icosahedronIndicies =              {                  1' 2' 6'                  1' 7' 2'                  3' 4' 5'                  4' 3' 8'                  6' 5' 11'                  5' 6' 10'                  9' 10' 2'                  10' 9' 3'                  7' 8' 9'                  8' 7' 0'                  11' 0' 1'                  0' 11' 4'                  6' 2' 10'                  1' 6' 11'                  3' 5' 10'                  5' 4' 11'                  2' 7' 9'                  7' 1' 0'                  3' 9' 8'                  4' 8' 0'              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: int[] icosahedronIndicies =              {                  1' 2' 6'                  1' 7' 2'                  3' 4' 5'                  4' 3' 8'                  6' 5' 11'                  5' 6' 10'                  9' 10' 2'                  10' 9' 3'                  7' 8' 9'                  8' 7' 0'                  11' 0' 1'                  0' 11' 4'                  6' 2' 10'                  1' 6' 11'                  3' 5' 10'                  5' 4' 11'                  2' 7' 9'                  7' 1' 0'                  3' 9' 8'                  4' 8' 0'              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: int[] icosahedronIndicies =              {                  1' 2' 6'                  1' 7' 2'                  3' 4' 5'                  4' 3' 8'                  6' 5' 11'                  5' 6' 10'                  9' 10' 2'                  10' 9' 3'                  7' 8' 9'                  8' 7' 0'                  11' 0' 1'                  0' 11' 4'                  6' 2' 10'                  1' 6' 11'                  3' 5' 10'                  5' 4' 11'                  2' 7' 9'                  7' 1' 0'                  3' 9' 8'                  4' 8' 0'              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: int[] icosahedronIndicies =              {                  1' 2' 6'                  1' 7' 2'                  3' 4' 5'                  4' 3' 8'                  6' 5' 11'                  5' 6' 10'                  9' 10' 2'                  10' 9' 3'                  7' 8' 9'                  8' 7' 0'                  11' 0' 1'                  0' 11' 4'                  6' 2' 10'                  1' 6' 11'                  3' 5' 10'                  5' 4' 11'                  2' 7' 9'                  7' 1' 0'                  3' 9' 8'                  4' 8' 0'              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: int[] icosahedronIndicies =              {                  1' 2' 6'                  1' 7' 2'                  3' 4' 5'                  4' 3' 8'                  6' 5' 11'                  5' 6' 10'                  9' 10' 2'                  10' 9' 3'                  7' 8' 9'                  8' 7' 0'                  11' 0' 1'                  0' 11' 4'                  6' 2' 10'                  1' 6' 11'                  3' 5' 10'                  5' 4' 11'                  2' 7' 9'                  7' 1' 0'                  3' 9' 8'                  4' 8' 0'              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: int[] icosahedronIndicies =              {                  1' 2' 6'                  1' 7' 2'                  3' 4' 5'                  4' 3' 8'                  6' 5' 11'                  5' 6' 10'                  9' 10' 2'                  10' 9' 3'                  7' 8' 9'                  8' 7' 0'                  11' 0' 1'                  0' 11' 4'                  6' 2' 10'                  1' 6' 11'                  3' 5' 10'                  5' 4' 11'                  2' 7' 9'                  7' 1' 0'                  3' 9' 8'                  4' 8' 0'              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: int[] icosahedronIndicies =              {                  1' 2' 6'                  1' 7' 2'                  3' 4' 5'                  4' 3' 8'                  6' 5' 11'                  5' 6' 10'                  9' 10' 2'                  10' 9' 3'                  7' 8' 9'                  8' 7' 0'                  11' 0' 1'                  0' 11' 4'                  6' 2' 10'                  1' 6' 11'                  3' 5' 10'                  5' 4' 11'                  2' 7' 9'                  7' 1' 0'                  3' 9' 8'                  4' 8' 0'              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: int[] icosahedronIndicies =              {                  1' 2' 6'                  1' 7' 2'                  3' 4' 5'                  4' 3' 8'                  6' 5' 11'                  5' 6' 10'                  9' 10' 2'                  10' 9' 3'                  7' 8' 9'                  8' 7' 0'                  11' 0' 1'                  0' 11' 4'                  6' 2' 10'                  1' 6' 11'                  3' 5' 10'                  5' 4' 11'                  2' 7' 9'                  7' 1' 0'                  3' 9' 8'                  4' 8' 0'              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: int[] icosahedronIndicies =              {                  1' 2' 6'                  1' 7' 2'                  3' 4' 5'                  4' 3' 8'                  6' 5' 11'                  5' 6' 10'                  9' 10' 2'                  10' 9' 3'                  7' 8' 9'                  8' 7' 0'                  11' 0' 1'                  0' 11' 4'                  6' 2' 10'                  1' 6' 11'                  3' 5' 10'                  5' 4' 11'                  2' 7' 9'                  7' 1' 0'                  3' 9' 8'                  4' 8' 0'              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: int[] icosahedronIndicies =              {                  1' 2' 6'                  1' 7' 2'                  3' 4' 5'                  4' 3' 8'                  6' 5' 11'                  5' 6' 10'                  9' 10' 2'                  10' 9' 3'                  7' 8' 9'                  8' 7' 0'                  11' 0' 1'                  0' 11' 4'                  6' 2' 10'                  1' 6' 11'                  3' 5' 10'                  5' 4' 11'                  2' 7' 9'                  7' 1' 0'                  3' 9' 8'                  4' 8' 0'              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: int[] icosahedronIndicies =              {                  1' 2' 6'                  1' 7' 2'                  3' 4' 5'                  4' 3' 8'                  6' 5' 11'                  5' 6' 10'                  9' 10' 2'                  10' 9' 3'                  7' 8' 9'                  8' 7' 0'                  11' 0' 1'                  0' 11' 4'                  6' 2' 10'                  1' 6' 11'                  3' 5' 10'                  5' 4' 11'                  2' 7' 9'                  7' 1' 0'                  3' 9' 8'                  4' 8' 0'              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: int[] icosahedronIndicies =              {                  1' 2' 6'                  1' 7' 2'                  3' 4' 5'                  4' 3' 8'                  6' 5' 11'                  5' 6' 10'                  9' 10' 2'                  10' 9' 3'                  7' 8' 9'                  8' 7' 0'                  11' 0' 1'                  0' 11' 4'                  6' 2' 10'                  1' 6' 11'                  3' 5' 10'                  5' 4' 11'                  2' 7' 9'                  7' 1' 0'                  3' 9' 8'                  4' 8' 0'              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: int[] icosahedronIndicies =              {                  1' 2' 6'                  1' 7' 2'                  3' 4' 5'                  4' 3' 8'                  6' 5' 11'                  5' 6' 10'                  9' 10' 2'                  10' 9' 3'                  7' 8' 9'                  8' 7' 0'                  11' 0' 1'                  0' 11' 4'                  6' 2' 10'                  1' 6' 11'                  3' 5' 10'                  5' 4' 11'                  2' 7' 9'                  7' 1' 0'                  3' 9' 8'                  4' 8' 0'              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: int[] icosahedronIndicies =              {                  1' 2' 6'                  1' 7' 2'                  3' 4' 5'                  4' 3' 8'                  6' 5' 11'                  5' 6' 10'                  9' 10' 2'                  10' 9' 3'                  7' 8' 9'                  8' 7' 0'                  11' 0' 1'                  0' 11' 4'                  6' 2' 10'                  1' 6' 11'                  3' 5' 10'                  5' 4' 11'                  2' 7' 9'                  7' 1' 0'                  3' 9' 8'                  4' 8' 0'              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: int[] icosahedronIndicies =              {                  1' 2' 6'                  1' 7' 2'                  3' 4' 5'                  4' 3' 8'                  6' 5' 11'                  5' 6' 10'                  9' 10' 2'                  10' 9' 3'                  7' 8' 9'                  8' 7' 0'                  11' 0' 1'                  0' 11' 4'                  6' 2' 10'                  1' 6' 11'                  3' 5' 10'                  5' 4' 11'                  2' 7' 9'                  7' 1' 0'                  3' 9' 8'                  4' 8' 0'              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: int[] icosahedronIndicies =              {                  1' 2' 6'                  1' 7' 2'                  3' 4' 5'                  4' 3' 8'                  6' 5' 11'                  5' 6' 10'                  9' 10' 2'                  10' 9' 3'                  7' 8' 9'                  8' 7' 0'                  11' 0' 1'                  0' 11' 4'                  6' 2' 10'                  1' 6' 11'                  3' 5' 10'                  5' 4' 11'                  2' 7' 9'                  7' 1' 0'                  3' 9' 8'                  4' 8' 0'              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: int[] icosahedronIndicies =              {                  1' 2' 6'                  1' 7' 2'                  3' 4' 5'                  4' 3' 8'                  6' 5' 11'                  5' 6' 10'                  9' 10' 2'                  10' 9' 3'                  7' 8' 9'                  8' 7' 0'                  11' 0' 1'                  0' 11' 4'                  6' 2' 10'                  1' 6' 11'                  3' 5' 10'                  5' 4' 11'                  2' 7' 9'                  7' 1' 0'                  3' 9' 8'                  4' 8' 0'              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: int[] icosahedronIndicies =              {                  1' 2' 6'                  1' 7' 2'                  3' 4' 5'                  4' 3' 8'                  6' 5' 11'                  5' 6' 10'                  9' 10' 2'                  10' 9' 3'                  7' 8' 9'                  8' 7' 0'                  11' 0' 1'                  0' 11' 4'                  6' 2' 10'                  1' 6' 11'                  3' 5' 10'                  5' 4' 11'                  2' 7' 9'                  7' 1' 0'                  3' 9' 8'                  4' 8' 0'              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: int[] icosahedronIndicies =              {                  1' 2' 6'                  1' 7' 2'                  3' 4' 5'                  4' 3' 8'                  6' 5' 11'                  5' 6' 10'                  9' 10' 2'                  10' 9' 3'                  7' 8' 9'                  8' 7' 0'                  11' 0' 1'                  0' 11' 4'                  6' 2' 10'                  1' 6' 11'                  3' 5' 10'                  5' 4' 11'                  2' 7' 9'                  7' 1' 0'                  3' 9' 8'                  4' 8' 0'              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: int[] icosahedronIndicies =              {                  1' 2' 6'                  1' 7' 2'                  3' 4' 5'                  4' 3' 8'                  6' 5' 11'                  5' 6' 10'                  9' 10' 2'                  10' 9' 3'                  7' 8' 9'                  8' 7' 0'                  11' 0' 1'                  0' 11' 4'                  6' 2' 10'                  1' 6' 11'                  3' 5' 10'                  5' 4' 11'                  2' 7' 9'                  7' 1' 0'                  3' 9' 8'                  4' 8' 0'              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: int[] icosahedronIndicies =              {                  1' 2' 6'                  1' 7' 2'                  3' 4' 5'                  4' 3' 8'                  6' 5' 11'                  5' 6' 10'                  9' 10' 2'                  10' 9' 3'                  7' 8' 9'                  8' 7' 0'                  11' 0' 1'                  0' 11' 4'                  6' 2' 10'                  1' 6' 11'                  3' 5' 10'                  5' 4' 11'                  2' 7' 9'                  7' 1' 0'                  3' 9' 8'                  4' 8' 0'              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: int[] icosahedronIndicies =              {                  1' 2' 6'                  1' 7' 2'                  3' 4' 5'                  4' 3' 8'                  6' 5' 11'                  5' 6' 10'                  9' 10' 2'                  10' 9' 3'                  7' 8' 9'                  8' 7' 0'                  11' 0' 1'                  0' 11' 4'                  6' 2' 10'                  1' 6' 11'                  3' 5' 10'                  5' 4' 11'                  2' 7' 9'                  7' 1' 0'                  3' 9' 8'                  4' 8' 0'              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: int[] icosahedronIndicies =              {                  1' 2' 6'                  1' 7' 2'                  3' 4' 5'                  4' 3' 8'                  6' 5' 11'                  5' 6' 10'                  9' 10' 2'                  10' 9' 3'                  7' 8' 9'                  8' 7' 0'                  11' 0' 1'                  0' 11' 4'                  6' 2' 10'                  1' 6' 11'                  3' 5' 10'                  5' 4' 11'                  2' 7' 9'                  7' 1' 0'                  3' 9' 8'                  4' 8' 0'              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: int[] icosahedronIndicies =              {                  1' 2' 6'                  1' 7' 2'                  3' 4' 5'                  4' 3' 8'                  6' 5' 11'                  5' 6' 10'                  9' 10' 2'                  10' 9' 3'                  7' 8' 9'                  8' 7' 0'                  11' 0' 1'                  0' 11' 4'                  6' 2' 10'                  1' 6' 11'                  3' 5' 10'                  5' 4' 11'                  2' 7' 9'                  7' 1' 0'                  3' 9' 8'                  4' 8' 0'              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: int[] icosahedronIndicies =              {                  1' 2' 6'                  1' 7' 2'                  3' 4' 5'                  4' 3' 8'                  6' 5' 11'                  5' 6' 10'                  9' 10' 2'                  10' 9' 3'                  7' 8' 9'                  8' 7' 0'                  11' 0' 1'                  0' 11' 4'                  6' 2' 10'                  1' 6' 11'                  3' 5' 10'                  5' 4' 11'                  2' 7' 9'                  7' 1' 0'                  3' 9' 8'                  4' 8' 0'              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: int[] icosahedronIndicies =              {                  1' 2' 6'                  1' 7' 2'                  3' 4' 5'                  4' 3' 8'                  6' 5' 11'                  5' 6' 10'                  9' 10' 2'                  10' 9' 3'                  7' 8' 9'                  8' 7' 0'                  11' 0' 1'                  0' 11' 4'                  6' 2' 10'                  1' 6' 11'                  3' 5' 10'                  5' 4' 11'                  2' 7' 9'                  7' 1' 0'                  3' 9' 8'                  4' 8' 0'              };
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: Vertex[] verts = new Vertex[icosahedronVertices.Length / 3];
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: for (int i = 0; i < icosahedronVertices.Length / 3; i++)  			{  				verts[i] = icosahedron.CreateVertex(new Vector3(icosahedronVertices[i * 3 + 0]' icosahedronVertices[i * 3 + 1]' icosahedronVertices[i * 3 + 2]));  			}
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: for (int i = 0; i < icosahedronVertices.Length / 3; i++)  			{  				verts[i] = icosahedron.CreateVertex(new Vector3(icosahedronVertices[i * 3 + 0]' icosahedronVertices[i * 3 + 1]' icosahedronVertices[i * 3 + 2]));  			}
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: for (int i = 0; i < icosahedronVertices.Length / 3; i++)  			{  				verts[i] = icosahedron.CreateVertex(new Vector3(icosahedronVertices[i * 3 + 0]' icosahedronVertices[i * 3 + 1]' icosahedronVertices[i * 3 + 2]));  			}
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: for (int i = 0; i < icosahedronVertices.Length / 3; i++)  			{  				verts[i] = icosahedron.CreateVertex(new Vector3(icosahedronVertices[i * 3 + 0]' icosahedronVertices[i * 3 + 1]' icosahedronVertices[i * 3 + 2]));  			}
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: for (int i = 0; i < icosahedronVertices.Length / 3; i++)  			{  				verts[i] = icosahedron.CreateVertex(new Vector3(icosahedronVertices[i * 3 + 0]' icosahedronVertices[i * 3 + 1]' icosahedronVertices[i * 3 + 2]));  			}
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: for (int i = 0; i < icosahedronIndicies.Length / 3; i++)  			{  				Vertex[] triangleVertices = new Vertex[]                  {                      verts[icosahedronIndicies[i * 3 + 0]]'                      verts[icosahedronIndicies[i * 3 + 1]]'                      verts[icosahedronIndicies[i * 3 + 2]]'                  };  				icosahedron.CreateFace(triangleVertices);  			}
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: for (int i = 0; i < icosahedronIndicies.Length / 3; i++)  			{  				Vertex[] triangleVertices = new Vertex[]                  {                      verts[icosahedronIndicies[i * 3 + 0]]'                      verts[icosahedronIndicies[i * 3 + 1]]'                      verts[icosahedronIndicies[i * 3 + 2]]'                  };  				icosahedron.CreateFace(triangleVertices);  			}
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: for (int i = 0; i < icosahedronIndicies.Length / 3; i++)  			{  				Vertex[] triangleVertices = new Vertex[]                  {                      verts[icosahedronIndicies[i * 3 + 0]]'                      verts[icosahedronIndicies[i * 3 + 1]]'                      verts[icosahedronIndicies[i * 3 + 2]]'                  };  				icosahedron.CreateFace(triangleVertices);  			}
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: for (int i = 0; i < icosahedronIndicies.Length / 3; i++)  			{  				Vertex[] triangleVertices = new Vertex[]                  {                      verts[icosahedronIndicies[i * 3 + 0]]'                      verts[icosahedronIndicies[i * 3 + 1]]'                      verts[icosahedronIndicies[i * 3 + 2]]'                  };  				icosahedron.CreateFace(triangleVertices);  			}
Magic Number,MatterHackers.PolygonMesh,PlatonicSolids,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\PlatonicSolids.cs,CreateIcosahedron,The following statement contains a magic number: for (int i = 0; i < icosahedronIndicies.Length / 3; i++)  			{  				Vertex[] triangleVertices = new Vertex[]                  {                      verts[icosahedronIndicies[i * 3 + 0]]'                      verts[icosahedronIndicies[i * 3 + 1]]'                      verts[icosahedronIndicies[i * 3 + 2]]'                  };  				icosahedron.CreateFace(triangleVertices);  			}
Magic Number,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,Indent,The following statement contains a magic number: return new String(' '' index * 2);
Magic Number,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,Save,The following statement contains a magic number: {  				int objectId = 1;    				bool continueProcessing;    				int totalMeshes = 0;  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						totalMeshes++;  					}  				}    				double ratioPerMesh = 1d / totalMeshes;  				double currentRation = 0;  				for(int meshGroupIndex = 0; meshGroupIndex < meshToSave.Count; meshGroupIndex++)  				{  					MeshGroup meshGroup = meshToSave[meshGroupIndex];  					amfFile.WriteLine(Indent(1) + "<object id=\"{0}\">".FormatWith(objectId++));  					{  						int vertexCount = 0;  						List<int> meshVertexStart = new List<int>();  						amfFile.WriteLine(Indent(2) + "<mesh>");  						{  							amfFile.WriteLine(Indent(3) + "<vertices>");  							{  								for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  								{  									Mesh mesh = meshGroup.Meshes[meshIndex];  									double vertCount = (double)mesh.Vertices.Count;    									meshVertexStart.Add(vertexCount);  									for (int vertexIndex = 0; vertexIndex < mesh.Vertices.Count; vertexIndex++)  									{  										Vertex vertex = mesh.Vertices[vertexIndex];  										if (outputInfo.ReportProgress != null)  										{  											outputInfo.ReportProgress(currentRation + vertexIndex / vertCount * ratioPerMesh * .5' ""' out continueProcessing);  										}    										Vector3 position = vertex.Position;  										amfFile.WriteLine(Indent(4) + "<vertex>");  										{  											amfFile.WriteLine(Indent(5) + "<coordinates>");  											amfFile.WriteLine(Indent(6) + "<x>{0}</x>".FormatWith(position.x));  											amfFile.WriteLine(Indent(6) + "<y>{0}</y>".FormatWith(position.y));  											amfFile.WriteLine(Indent(6) + "<z>{0}</z>".FormatWith(position.z));  											amfFile.WriteLine(Indent(5) + "</coordinates>");  										}  										amfFile.WriteLine(Indent(4) + "</vertex>");  										vertexCount++;  									}  									currentRation += ratioPerMesh * .5;  								}  							}    							amfFile.WriteLine(Indent(3) + "</vertices>");  							for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  							{  								Mesh mesh = meshGroup.Meshes[meshIndex];  								int firstVertexIndex = meshVertexStart[meshIndex];  								MeshMaterialData material = MeshMaterialData.Get(mesh);  								if (material.MaterialIndex == -1)  								{  									amfFile.WriteLine(Indent(3) + "<volume>");  								}  								else  								{  									amfFile.WriteLine(Indent(3) + "<volume materialid=\"{0}\">".FormatWith(material.MaterialIndex));  								}    								double faceCount = (double)mesh.Faces.Count;  								for (int faceIndex = 0; faceIndex < mesh.Faces.Count; faceIndex++)  								{  									if (outputInfo.ReportProgress != null)  									{  										outputInfo.ReportProgress(currentRation + faceIndex / faceCount * ratioPerMesh * .5' ""' out continueProcessing);  									}    									Face face = mesh.Faces[faceIndex];  									List<Vertex> positionsCCW = new List<Vertex>();  									foreach (FaceEdge faceEdge in face.FaceEdges())  									{  										positionsCCW.Add(faceEdge.firstVertex);  									}    									int numPolys = positionsCCW.Count - 2;  									int secondIndex = 1;  									int thirdIndex = 2;  									for (int polyIndex = 0; polyIndex < numPolys; polyIndex++)  									{  										amfFile.WriteLine(Indent(4) + "<triangle>");  										amfFile.WriteLine(Indent(5) + "<v1>{0}</v1>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[0])));  										amfFile.WriteLine(Indent(5) + "<v2>{0}</v2>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[secondIndex])));  										amfFile.WriteLine(Indent(5) + "<v3>{0}</v3>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[thirdIndex])));  										amfFile.WriteLine(Indent(4) + "</triangle>");    										secondIndex = thirdIndex;  										thirdIndex++;  									}  								}    								currentRation += ratioPerMesh * .5;  								amfFile.WriteLine(Indent(3) + "</volume>");  							}  						}  						amfFile.WriteLine(Indent(2) + "</mesh>");  					}  					amfFile.WriteLine(Indent(1) + "</object>");  				}    				HashSet<int> materials = new HashSet<int>();  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						MeshMaterialData material = MeshMaterialData.Get(mesh);  						if (material.MaterialIndex != -1)  						{  							materials.Add(material.MaterialIndex);  						}  					}  				}    				foreach (int material in materials)  				{  					amfFile.WriteLine(Indent(1) + "<material id=\"{0}\">".FormatWith(material));  					amfFile.WriteLine(Indent(2) + "<metadata type=\"Name\">Material {0}</metadata>".FormatWith(material));  					amfFile.WriteLine(Indent(1) + "</material>");  				}  			}
Magic Number,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,Save,The following statement contains a magic number: {  				int objectId = 1;    				bool continueProcessing;    				int totalMeshes = 0;  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						totalMeshes++;  					}  				}    				double ratioPerMesh = 1d / totalMeshes;  				double currentRation = 0;  				for(int meshGroupIndex = 0; meshGroupIndex < meshToSave.Count; meshGroupIndex++)  				{  					MeshGroup meshGroup = meshToSave[meshGroupIndex];  					amfFile.WriteLine(Indent(1) + "<object id=\"{0}\">".FormatWith(objectId++));  					{  						int vertexCount = 0;  						List<int> meshVertexStart = new List<int>();  						amfFile.WriteLine(Indent(2) + "<mesh>");  						{  							amfFile.WriteLine(Indent(3) + "<vertices>");  							{  								for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  								{  									Mesh mesh = meshGroup.Meshes[meshIndex];  									double vertCount = (double)mesh.Vertices.Count;    									meshVertexStart.Add(vertexCount);  									for (int vertexIndex = 0; vertexIndex < mesh.Vertices.Count; vertexIndex++)  									{  										Vertex vertex = mesh.Vertices[vertexIndex];  										if (outputInfo.ReportProgress != null)  										{  											outputInfo.ReportProgress(currentRation + vertexIndex / vertCount * ratioPerMesh * .5' ""' out continueProcessing);  										}    										Vector3 position = vertex.Position;  										amfFile.WriteLine(Indent(4) + "<vertex>");  										{  											amfFile.WriteLine(Indent(5) + "<coordinates>");  											amfFile.WriteLine(Indent(6) + "<x>{0}</x>".FormatWith(position.x));  											amfFile.WriteLine(Indent(6) + "<y>{0}</y>".FormatWith(position.y));  											amfFile.WriteLine(Indent(6) + "<z>{0}</z>".FormatWith(position.z));  											amfFile.WriteLine(Indent(5) + "</coordinates>");  										}  										amfFile.WriteLine(Indent(4) + "</vertex>");  										vertexCount++;  									}  									currentRation += ratioPerMesh * .5;  								}  							}    							amfFile.WriteLine(Indent(3) + "</vertices>");  							for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  							{  								Mesh mesh = meshGroup.Meshes[meshIndex];  								int firstVertexIndex = meshVertexStart[meshIndex];  								MeshMaterialData material = MeshMaterialData.Get(mesh);  								if (material.MaterialIndex == -1)  								{  									amfFile.WriteLine(Indent(3) + "<volume>");  								}  								else  								{  									amfFile.WriteLine(Indent(3) + "<volume materialid=\"{0}\">".FormatWith(material.MaterialIndex));  								}    								double faceCount = (double)mesh.Faces.Count;  								for (int faceIndex = 0; faceIndex < mesh.Faces.Count; faceIndex++)  								{  									if (outputInfo.ReportProgress != null)  									{  										outputInfo.ReportProgress(currentRation + faceIndex / faceCount * ratioPerMesh * .5' ""' out continueProcessing);  									}    									Face face = mesh.Faces[faceIndex];  									List<Vertex> positionsCCW = new List<Vertex>();  									foreach (FaceEdge faceEdge in face.FaceEdges())  									{  										positionsCCW.Add(faceEdge.firstVertex);  									}    									int numPolys = positionsCCW.Count - 2;  									int secondIndex = 1;  									int thirdIndex = 2;  									for (int polyIndex = 0; polyIndex < numPolys; polyIndex++)  									{  										amfFile.WriteLine(Indent(4) + "<triangle>");  										amfFile.WriteLine(Indent(5) + "<v1>{0}</v1>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[0])));  										amfFile.WriteLine(Indent(5) + "<v2>{0}</v2>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[secondIndex])));  										amfFile.WriteLine(Indent(5) + "<v3>{0}</v3>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[thirdIndex])));  										amfFile.WriteLine(Indent(4) + "</triangle>");    										secondIndex = thirdIndex;  										thirdIndex++;  									}  								}    								currentRation += ratioPerMesh * .5;  								amfFile.WriteLine(Indent(3) + "</volume>");  							}  						}  						amfFile.WriteLine(Indent(2) + "</mesh>");  					}  					amfFile.WriteLine(Indent(1) + "</object>");  				}    				HashSet<int> materials = new HashSet<int>();  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						MeshMaterialData material = MeshMaterialData.Get(mesh);  						if (material.MaterialIndex != -1)  						{  							materials.Add(material.MaterialIndex);  						}  					}  				}    				foreach (int material in materials)  				{  					amfFile.WriteLine(Indent(1) + "<material id=\"{0}\">".FormatWith(material));  					amfFile.WriteLine(Indent(2) + "<metadata type=\"Name\">Material {0}</metadata>".FormatWith(material));  					amfFile.WriteLine(Indent(1) + "</material>");  				}  			}
Magic Number,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,Save,The following statement contains a magic number: {  				int objectId = 1;    				bool continueProcessing;    				int totalMeshes = 0;  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						totalMeshes++;  					}  				}    				double ratioPerMesh = 1d / totalMeshes;  				double currentRation = 0;  				for(int meshGroupIndex = 0; meshGroupIndex < meshToSave.Count; meshGroupIndex++)  				{  					MeshGroup meshGroup = meshToSave[meshGroupIndex];  					amfFile.WriteLine(Indent(1) + "<object id=\"{0}\">".FormatWith(objectId++));  					{  						int vertexCount = 0;  						List<int> meshVertexStart = new List<int>();  						amfFile.WriteLine(Indent(2) + "<mesh>");  						{  							amfFile.WriteLine(Indent(3) + "<vertices>");  							{  								for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  								{  									Mesh mesh = meshGroup.Meshes[meshIndex];  									double vertCount = (double)mesh.Vertices.Count;    									meshVertexStart.Add(vertexCount);  									for (int vertexIndex = 0; vertexIndex < mesh.Vertices.Count; vertexIndex++)  									{  										Vertex vertex = mesh.Vertices[vertexIndex];  										if (outputInfo.ReportProgress != null)  										{  											outputInfo.ReportProgress(currentRation + vertexIndex / vertCount * ratioPerMesh * .5' ""' out continueProcessing);  										}    										Vector3 position = vertex.Position;  										amfFile.WriteLine(Indent(4) + "<vertex>");  										{  											amfFile.WriteLine(Indent(5) + "<coordinates>");  											amfFile.WriteLine(Indent(6) + "<x>{0}</x>".FormatWith(position.x));  											amfFile.WriteLine(Indent(6) + "<y>{0}</y>".FormatWith(position.y));  											amfFile.WriteLine(Indent(6) + "<z>{0}</z>".FormatWith(position.z));  											amfFile.WriteLine(Indent(5) + "</coordinates>");  										}  										amfFile.WriteLine(Indent(4) + "</vertex>");  										vertexCount++;  									}  									currentRation += ratioPerMesh * .5;  								}  							}    							amfFile.WriteLine(Indent(3) + "</vertices>");  							for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  							{  								Mesh mesh = meshGroup.Meshes[meshIndex];  								int firstVertexIndex = meshVertexStart[meshIndex];  								MeshMaterialData material = MeshMaterialData.Get(mesh);  								if (material.MaterialIndex == -1)  								{  									amfFile.WriteLine(Indent(3) + "<volume>");  								}  								else  								{  									amfFile.WriteLine(Indent(3) + "<volume materialid=\"{0}\">".FormatWith(material.MaterialIndex));  								}    								double faceCount = (double)mesh.Faces.Count;  								for (int faceIndex = 0; faceIndex < mesh.Faces.Count; faceIndex++)  								{  									if (outputInfo.ReportProgress != null)  									{  										outputInfo.ReportProgress(currentRation + faceIndex / faceCount * ratioPerMesh * .5' ""' out continueProcessing);  									}    									Face face = mesh.Faces[faceIndex];  									List<Vertex> positionsCCW = new List<Vertex>();  									foreach (FaceEdge faceEdge in face.FaceEdges())  									{  										positionsCCW.Add(faceEdge.firstVertex);  									}    									int numPolys = positionsCCW.Count - 2;  									int secondIndex = 1;  									int thirdIndex = 2;  									for (int polyIndex = 0; polyIndex < numPolys; polyIndex++)  									{  										amfFile.WriteLine(Indent(4) + "<triangle>");  										amfFile.WriteLine(Indent(5) + "<v1>{0}</v1>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[0])));  										amfFile.WriteLine(Indent(5) + "<v2>{0}</v2>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[secondIndex])));  										amfFile.WriteLine(Indent(5) + "<v3>{0}</v3>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[thirdIndex])));  										amfFile.WriteLine(Indent(4) + "</triangle>");    										secondIndex = thirdIndex;  										thirdIndex++;  									}  								}    								currentRation += ratioPerMesh * .5;  								amfFile.WriteLine(Indent(3) + "</volume>");  							}  						}  						amfFile.WriteLine(Indent(2) + "</mesh>");  					}  					amfFile.WriteLine(Indent(1) + "</object>");  				}    				HashSet<int> materials = new HashSet<int>();  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						MeshMaterialData material = MeshMaterialData.Get(mesh);  						if (material.MaterialIndex != -1)  						{  							materials.Add(material.MaterialIndex);  						}  					}  				}    				foreach (int material in materials)  				{  					amfFile.WriteLine(Indent(1) + "<material id=\"{0}\">".FormatWith(material));  					amfFile.WriteLine(Indent(2) + "<metadata type=\"Name\">Material {0}</metadata>".FormatWith(material));  					amfFile.WriteLine(Indent(1) + "</material>");  				}  			}
Magic Number,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,Save,The following statement contains a magic number: {  				int objectId = 1;    				bool continueProcessing;    				int totalMeshes = 0;  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						totalMeshes++;  					}  				}    				double ratioPerMesh = 1d / totalMeshes;  				double currentRation = 0;  				for(int meshGroupIndex = 0; meshGroupIndex < meshToSave.Count; meshGroupIndex++)  				{  					MeshGroup meshGroup = meshToSave[meshGroupIndex];  					amfFile.WriteLine(Indent(1) + "<object id=\"{0}\">".FormatWith(objectId++));  					{  						int vertexCount = 0;  						List<int> meshVertexStart = new List<int>();  						amfFile.WriteLine(Indent(2) + "<mesh>");  						{  							amfFile.WriteLine(Indent(3) + "<vertices>");  							{  								for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  								{  									Mesh mesh = meshGroup.Meshes[meshIndex];  									double vertCount = (double)mesh.Vertices.Count;    									meshVertexStart.Add(vertexCount);  									for (int vertexIndex = 0; vertexIndex < mesh.Vertices.Count; vertexIndex++)  									{  										Vertex vertex = mesh.Vertices[vertexIndex];  										if (outputInfo.ReportProgress != null)  										{  											outputInfo.ReportProgress(currentRation + vertexIndex / vertCount * ratioPerMesh * .5' ""' out continueProcessing);  										}    										Vector3 position = vertex.Position;  										amfFile.WriteLine(Indent(4) + "<vertex>");  										{  											amfFile.WriteLine(Indent(5) + "<coordinates>");  											amfFile.WriteLine(Indent(6) + "<x>{0}</x>".FormatWith(position.x));  											amfFile.WriteLine(Indent(6) + "<y>{0}</y>".FormatWith(position.y));  											amfFile.WriteLine(Indent(6) + "<z>{0}</z>".FormatWith(position.z));  											amfFile.WriteLine(Indent(5) + "</coordinates>");  										}  										amfFile.WriteLine(Indent(4) + "</vertex>");  										vertexCount++;  									}  									currentRation += ratioPerMesh * .5;  								}  							}    							amfFile.WriteLine(Indent(3) + "</vertices>");  							for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  							{  								Mesh mesh = meshGroup.Meshes[meshIndex];  								int firstVertexIndex = meshVertexStart[meshIndex];  								MeshMaterialData material = MeshMaterialData.Get(mesh);  								if (material.MaterialIndex == -1)  								{  									amfFile.WriteLine(Indent(3) + "<volume>");  								}  								else  								{  									amfFile.WriteLine(Indent(3) + "<volume materialid=\"{0}\">".FormatWith(material.MaterialIndex));  								}    								double faceCount = (double)mesh.Faces.Count;  								for (int faceIndex = 0; faceIndex < mesh.Faces.Count; faceIndex++)  								{  									if (outputInfo.ReportProgress != null)  									{  										outputInfo.ReportProgress(currentRation + faceIndex / faceCount * ratioPerMesh * .5' ""' out continueProcessing);  									}    									Face face = mesh.Faces[faceIndex];  									List<Vertex> positionsCCW = new List<Vertex>();  									foreach (FaceEdge faceEdge in face.FaceEdges())  									{  										positionsCCW.Add(faceEdge.firstVertex);  									}    									int numPolys = positionsCCW.Count - 2;  									int secondIndex = 1;  									int thirdIndex = 2;  									for (int polyIndex = 0; polyIndex < numPolys; polyIndex++)  									{  										amfFile.WriteLine(Indent(4) + "<triangle>");  										amfFile.WriteLine(Indent(5) + "<v1>{0}</v1>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[0])));  										amfFile.WriteLine(Indent(5) + "<v2>{0}</v2>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[secondIndex])));  										amfFile.WriteLine(Indent(5) + "<v3>{0}</v3>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[thirdIndex])));  										amfFile.WriteLine(Indent(4) + "</triangle>");    										secondIndex = thirdIndex;  										thirdIndex++;  									}  								}    								currentRation += ratioPerMesh * .5;  								amfFile.WriteLine(Indent(3) + "</volume>");  							}  						}  						amfFile.WriteLine(Indent(2) + "</mesh>");  					}  					amfFile.WriteLine(Indent(1) + "</object>");  				}    				HashSet<int> materials = new HashSet<int>();  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						MeshMaterialData material = MeshMaterialData.Get(mesh);  						if (material.MaterialIndex != -1)  						{  							materials.Add(material.MaterialIndex);  						}  					}  				}    				foreach (int material in materials)  				{  					amfFile.WriteLine(Indent(1) + "<material id=\"{0}\">".FormatWith(material));  					amfFile.WriteLine(Indent(2) + "<metadata type=\"Name\">Material {0}</metadata>".FormatWith(material));  					amfFile.WriteLine(Indent(1) + "</material>");  				}  			}
Magic Number,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,Save,The following statement contains a magic number: {  				int objectId = 1;    				bool continueProcessing;    				int totalMeshes = 0;  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						totalMeshes++;  					}  				}    				double ratioPerMesh = 1d / totalMeshes;  				double currentRation = 0;  				for(int meshGroupIndex = 0; meshGroupIndex < meshToSave.Count; meshGroupIndex++)  				{  					MeshGroup meshGroup = meshToSave[meshGroupIndex];  					amfFile.WriteLine(Indent(1) + "<object id=\"{0}\">".FormatWith(objectId++));  					{  						int vertexCount = 0;  						List<int> meshVertexStart = new List<int>();  						amfFile.WriteLine(Indent(2) + "<mesh>");  						{  							amfFile.WriteLine(Indent(3) + "<vertices>");  							{  								for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  								{  									Mesh mesh = meshGroup.Meshes[meshIndex];  									double vertCount = (double)mesh.Vertices.Count;    									meshVertexStart.Add(vertexCount);  									for (int vertexIndex = 0; vertexIndex < mesh.Vertices.Count; vertexIndex++)  									{  										Vertex vertex = mesh.Vertices[vertexIndex];  										if (outputInfo.ReportProgress != null)  										{  											outputInfo.ReportProgress(currentRation + vertexIndex / vertCount * ratioPerMesh * .5' ""' out continueProcessing);  										}    										Vector3 position = vertex.Position;  										amfFile.WriteLine(Indent(4) + "<vertex>");  										{  											amfFile.WriteLine(Indent(5) + "<coordinates>");  											amfFile.WriteLine(Indent(6) + "<x>{0}</x>".FormatWith(position.x));  											amfFile.WriteLine(Indent(6) + "<y>{0}</y>".FormatWith(position.y));  											amfFile.WriteLine(Indent(6) + "<z>{0}</z>".FormatWith(position.z));  											amfFile.WriteLine(Indent(5) + "</coordinates>");  										}  										amfFile.WriteLine(Indent(4) + "</vertex>");  										vertexCount++;  									}  									currentRation += ratioPerMesh * .5;  								}  							}    							amfFile.WriteLine(Indent(3) + "</vertices>");  							for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  							{  								Mesh mesh = meshGroup.Meshes[meshIndex];  								int firstVertexIndex = meshVertexStart[meshIndex];  								MeshMaterialData material = MeshMaterialData.Get(mesh);  								if (material.MaterialIndex == -1)  								{  									amfFile.WriteLine(Indent(3) + "<volume>");  								}  								else  								{  									amfFile.WriteLine(Indent(3) + "<volume materialid=\"{0}\">".FormatWith(material.MaterialIndex));  								}    								double faceCount = (double)mesh.Faces.Count;  								for (int faceIndex = 0; faceIndex < mesh.Faces.Count; faceIndex++)  								{  									if (outputInfo.ReportProgress != null)  									{  										outputInfo.ReportProgress(currentRation + faceIndex / faceCount * ratioPerMesh * .5' ""' out continueProcessing);  									}    									Face face = mesh.Faces[faceIndex];  									List<Vertex> positionsCCW = new List<Vertex>();  									foreach (FaceEdge faceEdge in face.FaceEdges())  									{  										positionsCCW.Add(faceEdge.firstVertex);  									}    									int numPolys = positionsCCW.Count - 2;  									int secondIndex = 1;  									int thirdIndex = 2;  									for (int polyIndex = 0; polyIndex < numPolys; polyIndex++)  									{  										amfFile.WriteLine(Indent(4) + "<triangle>");  										amfFile.WriteLine(Indent(5) + "<v1>{0}</v1>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[0])));  										amfFile.WriteLine(Indent(5) + "<v2>{0}</v2>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[secondIndex])));  										amfFile.WriteLine(Indent(5) + "<v3>{0}</v3>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[thirdIndex])));  										amfFile.WriteLine(Indent(4) + "</triangle>");    										secondIndex = thirdIndex;  										thirdIndex++;  									}  								}    								currentRation += ratioPerMesh * .5;  								amfFile.WriteLine(Indent(3) + "</volume>");  							}  						}  						amfFile.WriteLine(Indent(2) + "</mesh>");  					}  					amfFile.WriteLine(Indent(1) + "</object>");  				}    				HashSet<int> materials = new HashSet<int>();  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						MeshMaterialData material = MeshMaterialData.Get(mesh);  						if (material.MaterialIndex != -1)  						{  							materials.Add(material.MaterialIndex);  						}  					}  				}    				foreach (int material in materials)  				{  					amfFile.WriteLine(Indent(1) + "<material id=\"{0}\">".FormatWith(material));  					amfFile.WriteLine(Indent(2) + "<metadata type=\"Name\">Material {0}</metadata>".FormatWith(material));  					amfFile.WriteLine(Indent(1) + "</material>");  				}  			}
Magic Number,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,Save,The following statement contains a magic number: {  				int objectId = 1;    				bool continueProcessing;    				int totalMeshes = 0;  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						totalMeshes++;  					}  				}    				double ratioPerMesh = 1d / totalMeshes;  				double currentRation = 0;  				for(int meshGroupIndex = 0; meshGroupIndex < meshToSave.Count; meshGroupIndex++)  				{  					MeshGroup meshGroup = meshToSave[meshGroupIndex];  					amfFile.WriteLine(Indent(1) + "<object id=\"{0}\">".FormatWith(objectId++));  					{  						int vertexCount = 0;  						List<int> meshVertexStart = new List<int>();  						amfFile.WriteLine(Indent(2) + "<mesh>");  						{  							amfFile.WriteLine(Indent(3) + "<vertices>");  							{  								for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  								{  									Mesh mesh = meshGroup.Meshes[meshIndex];  									double vertCount = (double)mesh.Vertices.Count;    									meshVertexStart.Add(vertexCount);  									for (int vertexIndex = 0; vertexIndex < mesh.Vertices.Count; vertexIndex++)  									{  										Vertex vertex = mesh.Vertices[vertexIndex];  										if (outputInfo.ReportProgress != null)  										{  											outputInfo.ReportProgress(currentRation + vertexIndex / vertCount * ratioPerMesh * .5' ""' out continueProcessing);  										}    										Vector3 position = vertex.Position;  										amfFile.WriteLine(Indent(4) + "<vertex>");  										{  											amfFile.WriteLine(Indent(5) + "<coordinates>");  											amfFile.WriteLine(Indent(6) + "<x>{0}</x>".FormatWith(position.x));  											amfFile.WriteLine(Indent(6) + "<y>{0}</y>".FormatWith(position.y));  											amfFile.WriteLine(Indent(6) + "<z>{0}</z>".FormatWith(position.z));  											amfFile.WriteLine(Indent(5) + "</coordinates>");  										}  										amfFile.WriteLine(Indent(4) + "</vertex>");  										vertexCount++;  									}  									currentRation += ratioPerMesh * .5;  								}  							}    							amfFile.WriteLine(Indent(3) + "</vertices>");  							for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  							{  								Mesh mesh = meshGroup.Meshes[meshIndex];  								int firstVertexIndex = meshVertexStart[meshIndex];  								MeshMaterialData material = MeshMaterialData.Get(mesh);  								if (material.MaterialIndex == -1)  								{  									amfFile.WriteLine(Indent(3) + "<volume>");  								}  								else  								{  									amfFile.WriteLine(Indent(3) + "<volume materialid=\"{0}\">".FormatWith(material.MaterialIndex));  								}    								double faceCount = (double)mesh.Faces.Count;  								for (int faceIndex = 0; faceIndex < mesh.Faces.Count; faceIndex++)  								{  									if (outputInfo.ReportProgress != null)  									{  										outputInfo.ReportProgress(currentRation + faceIndex / faceCount * ratioPerMesh * .5' ""' out continueProcessing);  									}    									Face face = mesh.Faces[faceIndex];  									List<Vertex> positionsCCW = new List<Vertex>();  									foreach (FaceEdge faceEdge in face.FaceEdges())  									{  										positionsCCW.Add(faceEdge.firstVertex);  									}    									int numPolys = positionsCCW.Count - 2;  									int secondIndex = 1;  									int thirdIndex = 2;  									for (int polyIndex = 0; polyIndex < numPolys; polyIndex++)  									{  										amfFile.WriteLine(Indent(4) + "<triangle>");  										amfFile.WriteLine(Indent(5) + "<v1>{0}</v1>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[0])));  										amfFile.WriteLine(Indent(5) + "<v2>{0}</v2>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[secondIndex])));  										amfFile.WriteLine(Indent(5) + "<v3>{0}</v3>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[thirdIndex])));  										amfFile.WriteLine(Indent(4) + "</triangle>");    										secondIndex = thirdIndex;  										thirdIndex++;  									}  								}    								currentRation += ratioPerMesh * .5;  								amfFile.WriteLine(Indent(3) + "</volume>");  							}  						}  						amfFile.WriteLine(Indent(2) + "</mesh>");  					}  					amfFile.WriteLine(Indent(1) + "</object>");  				}    				HashSet<int> materials = new HashSet<int>();  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						MeshMaterialData material = MeshMaterialData.Get(mesh);  						if (material.MaterialIndex != -1)  						{  							materials.Add(material.MaterialIndex);  						}  					}  				}    				foreach (int material in materials)  				{  					amfFile.WriteLine(Indent(1) + "<material id=\"{0}\">".FormatWith(material));  					amfFile.WriteLine(Indent(2) + "<metadata type=\"Name\">Material {0}</metadata>".FormatWith(material));  					amfFile.WriteLine(Indent(1) + "</material>");  				}  			}
Magic Number,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,Save,The following statement contains a magic number: {  				int objectId = 1;    				bool continueProcessing;    				int totalMeshes = 0;  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						totalMeshes++;  					}  				}    				double ratioPerMesh = 1d / totalMeshes;  				double currentRation = 0;  				for(int meshGroupIndex = 0; meshGroupIndex < meshToSave.Count; meshGroupIndex++)  				{  					MeshGroup meshGroup = meshToSave[meshGroupIndex];  					amfFile.WriteLine(Indent(1) + "<object id=\"{0}\">".FormatWith(objectId++));  					{  						int vertexCount = 0;  						List<int> meshVertexStart = new List<int>();  						amfFile.WriteLine(Indent(2) + "<mesh>");  						{  							amfFile.WriteLine(Indent(3) + "<vertices>");  							{  								for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  								{  									Mesh mesh = meshGroup.Meshes[meshIndex];  									double vertCount = (double)mesh.Vertices.Count;    									meshVertexStart.Add(vertexCount);  									for (int vertexIndex = 0; vertexIndex < mesh.Vertices.Count; vertexIndex++)  									{  										Vertex vertex = mesh.Vertices[vertexIndex];  										if (outputInfo.ReportProgress != null)  										{  											outputInfo.ReportProgress(currentRation + vertexIndex / vertCount * ratioPerMesh * .5' ""' out continueProcessing);  										}    										Vector3 position = vertex.Position;  										amfFile.WriteLine(Indent(4) + "<vertex>");  										{  											amfFile.WriteLine(Indent(5) + "<coordinates>");  											amfFile.WriteLine(Indent(6) + "<x>{0}</x>".FormatWith(position.x));  											amfFile.WriteLine(Indent(6) + "<y>{0}</y>".FormatWith(position.y));  											amfFile.WriteLine(Indent(6) + "<z>{0}</z>".FormatWith(position.z));  											amfFile.WriteLine(Indent(5) + "</coordinates>");  										}  										amfFile.WriteLine(Indent(4) + "</vertex>");  										vertexCount++;  									}  									currentRation += ratioPerMesh * .5;  								}  							}    							amfFile.WriteLine(Indent(3) + "</vertices>");  							for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  							{  								Mesh mesh = meshGroup.Meshes[meshIndex];  								int firstVertexIndex = meshVertexStart[meshIndex];  								MeshMaterialData material = MeshMaterialData.Get(mesh);  								if (material.MaterialIndex == -1)  								{  									amfFile.WriteLine(Indent(3) + "<volume>");  								}  								else  								{  									amfFile.WriteLine(Indent(3) + "<volume materialid=\"{0}\">".FormatWith(material.MaterialIndex));  								}    								double faceCount = (double)mesh.Faces.Count;  								for (int faceIndex = 0; faceIndex < mesh.Faces.Count; faceIndex++)  								{  									if (outputInfo.ReportProgress != null)  									{  										outputInfo.ReportProgress(currentRation + faceIndex / faceCount * ratioPerMesh * .5' ""' out continueProcessing);  									}    									Face face = mesh.Faces[faceIndex];  									List<Vertex> positionsCCW = new List<Vertex>();  									foreach (FaceEdge faceEdge in face.FaceEdges())  									{  										positionsCCW.Add(faceEdge.firstVertex);  									}    									int numPolys = positionsCCW.Count - 2;  									int secondIndex = 1;  									int thirdIndex = 2;  									for (int polyIndex = 0; polyIndex < numPolys; polyIndex++)  									{  										amfFile.WriteLine(Indent(4) + "<triangle>");  										amfFile.WriteLine(Indent(5) + "<v1>{0}</v1>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[0])));  										amfFile.WriteLine(Indent(5) + "<v2>{0}</v2>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[secondIndex])));  										amfFile.WriteLine(Indent(5) + "<v3>{0}</v3>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[thirdIndex])));  										amfFile.WriteLine(Indent(4) + "</triangle>");    										secondIndex = thirdIndex;  										thirdIndex++;  									}  								}    								currentRation += ratioPerMesh * .5;  								amfFile.WriteLine(Indent(3) + "</volume>");  							}  						}  						amfFile.WriteLine(Indent(2) + "</mesh>");  					}  					amfFile.WriteLine(Indent(1) + "</object>");  				}    				HashSet<int> materials = new HashSet<int>();  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						MeshMaterialData material = MeshMaterialData.Get(mesh);  						if (material.MaterialIndex != -1)  						{  							materials.Add(material.MaterialIndex);  						}  					}  				}    				foreach (int material in materials)  				{  					amfFile.WriteLine(Indent(1) + "<material id=\"{0}\">".FormatWith(material));  					amfFile.WriteLine(Indent(2) + "<metadata type=\"Name\">Material {0}</metadata>".FormatWith(material));  					amfFile.WriteLine(Indent(1) + "</material>");  				}  			}
Magic Number,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,Save,The following statement contains a magic number: {  				int objectId = 1;    				bool continueProcessing;    				int totalMeshes = 0;  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						totalMeshes++;  					}  				}    				double ratioPerMesh = 1d / totalMeshes;  				double currentRation = 0;  				for(int meshGroupIndex = 0; meshGroupIndex < meshToSave.Count; meshGroupIndex++)  				{  					MeshGroup meshGroup = meshToSave[meshGroupIndex];  					amfFile.WriteLine(Indent(1) + "<object id=\"{0}\">".FormatWith(objectId++));  					{  						int vertexCount = 0;  						List<int> meshVertexStart = new List<int>();  						amfFile.WriteLine(Indent(2) + "<mesh>");  						{  							amfFile.WriteLine(Indent(3) + "<vertices>");  							{  								for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  								{  									Mesh mesh = meshGroup.Meshes[meshIndex];  									double vertCount = (double)mesh.Vertices.Count;    									meshVertexStart.Add(vertexCount);  									for (int vertexIndex = 0; vertexIndex < mesh.Vertices.Count; vertexIndex++)  									{  										Vertex vertex = mesh.Vertices[vertexIndex];  										if (outputInfo.ReportProgress != null)  										{  											outputInfo.ReportProgress(currentRation + vertexIndex / vertCount * ratioPerMesh * .5' ""' out continueProcessing);  										}    										Vector3 position = vertex.Position;  										amfFile.WriteLine(Indent(4) + "<vertex>");  										{  											amfFile.WriteLine(Indent(5) + "<coordinates>");  											amfFile.WriteLine(Indent(6) + "<x>{0}</x>".FormatWith(position.x));  											amfFile.WriteLine(Indent(6) + "<y>{0}</y>".FormatWith(position.y));  											amfFile.WriteLine(Indent(6) + "<z>{0}</z>".FormatWith(position.z));  											amfFile.WriteLine(Indent(5) + "</coordinates>");  										}  										amfFile.WriteLine(Indent(4) + "</vertex>");  										vertexCount++;  									}  									currentRation += ratioPerMesh * .5;  								}  							}    							amfFile.WriteLine(Indent(3) + "</vertices>");  							for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  							{  								Mesh mesh = meshGroup.Meshes[meshIndex];  								int firstVertexIndex = meshVertexStart[meshIndex];  								MeshMaterialData material = MeshMaterialData.Get(mesh);  								if (material.MaterialIndex == -1)  								{  									amfFile.WriteLine(Indent(3) + "<volume>");  								}  								else  								{  									amfFile.WriteLine(Indent(3) + "<volume materialid=\"{0}\">".FormatWith(material.MaterialIndex));  								}    								double faceCount = (double)mesh.Faces.Count;  								for (int faceIndex = 0; faceIndex < mesh.Faces.Count; faceIndex++)  								{  									if (outputInfo.ReportProgress != null)  									{  										outputInfo.ReportProgress(currentRation + faceIndex / faceCount * ratioPerMesh * .5' ""' out continueProcessing);  									}    									Face face = mesh.Faces[faceIndex];  									List<Vertex> positionsCCW = new List<Vertex>();  									foreach (FaceEdge faceEdge in face.FaceEdges())  									{  										positionsCCW.Add(faceEdge.firstVertex);  									}    									int numPolys = positionsCCW.Count - 2;  									int secondIndex = 1;  									int thirdIndex = 2;  									for (int polyIndex = 0; polyIndex < numPolys; polyIndex++)  									{  										amfFile.WriteLine(Indent(4) + "<triangle>");  										amfFile.WriteLine(Indent(5) + "<v1>{0}</v1>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[0])));  										amfFile.WriteLine(Indent(5) + "<v2>{0}</v2>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[secondIndex])));  										amfFile.WriteLine(Indent(5) + "<v3>{0}</v3>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[thirdIndex])));  										amfFile.WriteLine(Indent(4) + "</triangle>");    										secondIndex = thirdIndex;  										thirdIndex++;  									}  								}    								currentRation += ratioPerMesh * .5;  								amfFile.WriteLine(Indent(3) + "</volume>");  							}  						}  						amfFile.WriteLine(Indent(2) + "</mesh>");  					}  					amfFile.WriteLine(Indent(1) + "</object>");  				}    				HashSet<int> materials = new HashSet<int>();  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						MeshMaterialData material = MeshMaterialData.Get(mesh);  						if (material.MaterialIndex != -1)  						{  							materials.Add(material.MaterialIndex);  						}  					}  				}    				foreach (int material in materials)  				{  					amfFile.WriteLine(Indent(1) + "<material id=\"{0}\">".FormatWith(material));  					amfFile.WriteLine(Indent(2) + "<metadata type=\"Name\">Material {0}</metadata>".FormatWith(material));  					amfFile.WriteLine(Indent(1) + "</material>");  				}  			}
Magic Number,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,Save,The following statement contains a magic number: {  				int objectId = 1;    				bool continueProcessing;    				int totalMeshes = 0;  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						totalMeshes++;  					}  				}    				double ratioPerMesh = 1d / totalMeshes;  				double currentRation = 0;  				for(int meshGroupIndex = 0; meshGroupIndex < meshToSave.Count; meshGroupIndex++)  				{  					MeshGroup meshGroup = meshToSave[meshGroupIndex];  					amfFile.WriteLine(Indent(1) + "<object id=\"{0}\">".FormatWith(objectId++));  					{  						int vertexCount = 0;  						List<int> meshVertexStart = new List<int>();  						amfFile.WriteLine(Indent(2) + "<mesh>");  						{  							amfFile.WriteLine(Indent(3) + "<vertices>");  							{  								for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  								{  									Mesh mesh = meshGroup.Meshes[meshIndex];  									double vertCount = (double)mesh.Vertices.Count;    									meshVertexStart.Add(vertexCount);  									for (int vertexIndex = 0; vertexIndex < mesh.Vertices.Count; vertexIndex++)  									{  										Vertex vertex = mesh.Vertices[vertexIndex];  										if (outputInfo.ReportProgress != null)  										{  											outputInfo.ReportProgress(currentRation + vertexIndex / vertCount * ratioPerMesh * .5' ""' out continueProcessing);  										}    										Vector3 position = vertex.Position;  										amfFile.WriteLine(Indent(4) + "<vertex>");  										{  											amfFile.WriteLine(Indent(5) + "<coordinates>");  											amfFile.WriteLine(Indent(6) + "<x>{0}</x>".FormatWith(position.x));  											amfFile.WriteLine(Indent(6) + "<y>{0}</y>".FormatWith(position.y));  											amfFile.WriteLine(Indent(6) + "<z>{0}</z>".FormatWith(position.z));  											amfFile.WriteLine(Indent(5) + "</coordinates>");  										}  										amfFile.WriteLine(Indent(4) + "</vertex>");  										vertexCount++;  									}  									currentRation += ratioPerMesh * .5;  								}  							}    							amfFile.WriteLine(Indent(3) + "</vertices>");  							for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  							{  								Mesh mesh = meshGroup.Meshes[meshIndex];  								int firstVertexIndex = meshVertexStart[meshIndex];  								MeshMaterialData material = MeshMaterialData.Get(mesh);  								if (material.MaterialIndex == -1)  								{  									amfFile.WriteLine(Indent(3) + "<volume>");  								}  								else  								{  									amfFile.WriteLine(Indent(3) + "<volume materialid=\"{0}\">".FormatWith(material.MaterialIndex));  								}    								double faceCount = (double)mesh.Faces.Count;  								for (int faceIndex = 0; faceIndex < mesh.Faces.Count; faceIndex++)  								{  									if (outputInfo.ReportProgress != null)  									{  										outputInfo.ReportProgress(currentRation + faceIndex / faceCount * ratioPerMesh * .5' ""' out continueProcessing);  									}    									Face face = mesh.Faces[faceIndex];  									List<Vertex> positionsCCW = new List<Vertex>();  									foreach (FaceEdge faceEdge in face.FaceEdges())  									{  										positionsCCW.Add(faceEdge.firstVertex);  									}    									int numPolys = positionsCCW.Count - 2;  									int secondIndex = 1;  									int thirdIndex = 2;  									for (int polyIndex = 0; polyIndex < numPolys; polyIndex++)  									{  										amfFile.WriteLine(Indent(4) + "<triangle>");  										amfFile.WriteLine(Indent(5) + "<v1>{0}</v1>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[0])));  										amfFile.WriteLine(Indent(5) + "<v2>{0}</v2>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[secondIndex])));  										amfFile.WriteLine(Indent(5) + "<v3>{0}</v3>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[thirdIndex])));  										amfFile.WriteLine(Indent(4) + "</triangle>");    										secondIndex = thirdIndex;  										thirdIndex++;  									}  								}    								currentRation += ratioPerMesh * .5;  								amfFile.WriteLine(Indent(3) + "</volume>");  							}  						}  						amfFile.WriteLine(Indent(2) + "</mesh>");  					}  					amfFile.WriteLine(Indent(1) + "</object>");  				}    				HashSet<int> materials = new HashSet<int>();  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						MeshMaterialData material = MeshMaterialData.Get(mesh);  						if (material.MaterialIndex != -1)  						{  							materials.Add(material.MaterialIndex);  						}  					}  				}    				foreach (int material in materials)  				{  					amfFile.WriteLine(Indent(1) + "<material id=\"{0}\">".FormatWith(material));  					amfFile.WriteLine(Indent(2) + "<metadata type=\"Name\">Material {0}</metadata>".FormatWith(material));  					amfFile.WriteLine(Indent(1) + "</material>");  				}  			}
Magic Number,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,Save,The following statement contains a magic number: {  				int objectId = 1;    				bool continueProcessing;    				int totalMeshes = 0;  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						totalMeshes++;  					}  				}    				double ratioPerMesh = 1d / totalMeshes;  				double currentRation = 0;  				for(int meshGroupIndex = 0; meshGroupIndex < meshToSave.Count; meshGroupIndex++)  				{  					MeshGroup meshGroup = meshToSave[meshGroupIndex];  					amfFile.WriteLine(Indent(1) + "<object id=\"{0}\">".FormatWith(objectId++));  					{  						int vertexCount = 0;  						List<int> meshVertexStart = new List<int>();  						amfFile.WriteLine(Indent(2) + "<mesh>");  						{  							amfFile.WriteLine(Indent(3) + "<vertices>");  							{  								for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  								{  									Mesh mesh = meshGroup.Meshes[meshIndex];  									double vertCount = (double)mesh.Vertices.Count;    									meshVertexStart.Add(vertexCount);  									for (int vertexIndex = 0; vertexIndex < mesh.Vertices.Count; vertexIndex++)  									{  										Vertex vertex = mesh.Vertices[vertexIndex];  										if (outputInfo.ReportProgress != null)  										{  											outputInfo.ReportProgress(currentRation + vertexIndex / vertCount * ratioPerMesh * .5' ""' out continueProcessing);  										}    										Vector3 position = vertex.Position;  										amfFile.WriteLine(Indent(4) + "<vertex>");  										{  											amfFile.WriteLine(Indent(5) + "<coordinates>");  											amfFile.WriteLine(Indent(6) + "<x>{0}</x>".FormatWith(position.x));  											amfFile.WriteLine(Indent(6) + "<y>{0}</y>".FormatWith(position.y));  											amfFile.WriteLine(Indent(6) + "<z>{0}</z>".FormatWith(position.z));  											amfFile.WriteLine(Indent(5) + "</coordinates>");  										}  										amfFile.WriteLine(Indent(4) + "</vertex>");  										vertexCount++;  									}  									currentRation += ratioPerMesh * .5;  								}  							}    							amfFile.WriteLine(Indent(3) + "</vertices>");  							for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  							{  								Mesh mesh = meshGroup.Meshes[meshIndex];  								int firstVertexIndex = meshVertexStart[meshIndex];  								MeshMaterialData material = MeshMaterialData.Get(mesh);  								if (material.MaterialIndex == -1)  								{  									amfFile.WriteLine(Indent(3) + "<volume>");  								}  								else  								{  									amfFile.WriteLine(Indent(3) + "<volume materialid=\"{0}\">".FormatWith(material.MaterialIndex));  								}    								double faceCount = (double)mesh.Faces.Count;  								for (int faceIndex = 0; faceIndex < mesh.Faces.Count; faceIndex++)  								{  									if (outputInfo.ReportProgress != null)  									{  										outputInfo.ReportProgress(currentRation + faceIndex / faceCount * ratioPerMesh * .5' ""' out continueProcessing);  									}    									Face face = mesh.Faces[faceIndex];  									List<Vertex> positionsCCW = new List<Vertex>();  									foreach (FaceEdge faceEdge in face.FaceEdges())  									{  										positionsCCW.Add(faceEdge.firstVertex);  									}    									int numPolys = positionsCCW.Count - 2;  									int secondIndex = 1;  									int thirdIndex = 2;  									for (int polyIndex = 0; polyIndex < numPolys; polyIndex++)  									{  										amfFile.WriteLine(Indent(4) + "<triangle>");  										amfFile.WriteLine(Indent(5) + "<v1>{0}</v1>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[0])));  										amfFile.WriteLine(Indent(5) + "<v2>{0}</v2>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[secondIndex])));  										amfFile.WriteLine(Indent(5) + "<v3>{0}</v3>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[thirdIndex])));  										amfFile.WriteLine(Indent(4) + "</triangle>");    										secondIndex = thirdIndex;  										thirdIndex++;  									}  								}    								currentRation += ratioPerMesh * .5;  								amfFile.WriteLine(Indent(3) + "</volume>");  							}  						}  						amfFile.WriteLine(Indent(2) + "</mesh>");  					}  					amfFile.WriteLine(Indent(1) + "</object>");  				}    				HashSet<int> materials = new HashSet<int>();  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						MeshMaterialData material = MeshMaterialData.Get(mesh);  						if (material.MaterialIndex != -1)  						{  							materials.Add(material.MaterialIndex);  						}  					}  				}    				foreach (int material in materials)  				{  					amfFile.WriteLine(Indent(1) + "<material id=\"{0}\">".FormatWith(material));  					amfFile.WriteLine(Indent(2) + "<metadata type=\"Name\">Material {0}</metadata>".FormatWith(material));  					amfFile.WriteLine(Indent(1) + "</material>");  				}  			}
Magic Number,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,Save,The following statement contains a magic number: {  				int objectId = 1;    				bool continueProcessing;    				int totalMeshes = 0;  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						totalMeshes++;  					}  				}    				double ratioPerMesh = 1d / totalMeshes;  				double currentRation = 0;  				for(int meshGroupIndex = 0; meshGroupIndex < meshToSave.Count; meshGroupIndex++)  				{  					MeshGroup meshGroup = meshToSave[meshGroupIndex];  					amfFile.WriteLine(Indent(1) + "<object id=\"{0}\">".FormatWith(objectId++));  					{  						int vertexCount = 0;  						List<int> meshVertexStart = new List<int>();  						amfFile.WriteLine(Indent(2) + "<mesh>");  						{  							amfFile.WriteLine(Indent(3) + "<vertices>");  							{  								for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  								{  									Mesh mesh = meshGroup.Meshes[meshIndex];  									double vertCount = (double)mesh.Vertices.Count;    									meshVertexStart.Add(vertexCount);  									for (int vertexIndex = 0; vertexIndex < mesh.Vertices.Count; vertexIndex++)  									{  										Vertex vertex = mesh.Vertices[vertexIndex];  										if (outputInfo.ReportProgress != null)  										{  											outputInfo.ReportProgress(currentRation + vertexIndex / vertCount * ratioPerMesh * .5' ""' out continueProcessing);  										}    										Vector3 position = vertex.Position;  										amfFile.WriteLine(Indent(4) + "<vertex>");  										{  											amfFile.WriteLine(Indent(5) + "<coordinates>");  											amfFile.WriteLine(Indent(6) + "<x>{0}</x>".FormatWith(position.x));  											amfFile.WriteLine(Indent(6) + "<y>{0}</y>".FormatWith(position.y));  											amfFile.WriteLine(Indent(6) + "<z>{0}</z>".FormatWith(position.z));  											amfFile.WriteLine(Indent(5) + "</coordinates>");  										}  										amfFile.WriteLine(Indent(4) + "</vertex>");  										vertexCount++;  									}  									currentRation += ratioPerMesh * .5;  								}  							}    							amfFile.WriteLine(Indent(3) + "</vertices>");  							for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  							{  								Mesh mesh = meshGroup.Meshes[meshIndex];  								int firstVertexIndex = meshVertexStart[meshIndex];  								MeshMaterialData material = MeshMaterialData.Get(mesh);  								if (material.MaterialIndex == -1)  								{  									amfFile.WriteLine(Indent(3) + "<volume>");  								}  								else  								{  									amfFile.WriteLine(Indent(3) + "<volume materialid=\"{0}\">".FormatWith(material.MaterialIndex));  								}    								double faceCount = (double)mesh.Faces.Count;  								for (int faceIndex = 0; faceIndex < mesh.Faces.Count; faceIndex++)  								{  									if (outputInfo.ReportProgress != null)  									{  										outputInfo.ReportProgress(currentRation + faceIndex / faceCount * ratioPerMesh * .5' ""' out continueProcessing);  									}    									Face face = mesh.Faces[faceIndex];  									List<Vertex> positionsCCW = new List<Vertex>();  									foreach (FaceEdge faceEdge in face.FaceEdges())  									{  										positionsCCW.Add(faceEdge.firstVertex);  									}    									int numPolys = positionsCCW.Count - 2;  									int secondIndex = 1;  									int thirdIndex = 2;  									for (int polyIndex = 0; polyIndex < numPolys; polyIndex++)  									{  										amfFile.WriteLine(Indent(4) + "<triangle>");  										amfFile.WriteLine(Indent(5) + "<v1>{0}</v1>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[0])));  										amfFile.WriteLine(Indent(5) + "<v2>{0}</v2>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[secondIndex])));  										amfFile.WriteLine(Indent(5) + "<v3>{0}</v3>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[thirdIndex])));  										amfFile.WriteLine(Indent(4) + "</triangle>");    										secondIndex = thirdIndex;  										thirdIndex++;  									}  								}    								currentRation += ratioPerMesh * .5;  								amfFile.WriteLine(Indent(3) + "</volume>");  							}  						}  						amfFile.WriteLine(Indent(2) + "</mesh>");  					}  					amfFile.WriteLine(Indent(1) + "</object>");  				}    				HashSet<int> materials = new HashSet<int>();  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						MeshMaterialData material = MeshMaterialData.Get(mesh);  						if (material.MaterialIndex != -1)  						{  							materials.Add(material.MaterialIndex);  						}  					}  				}    				foreach (int material in materials)  				{  					amfFile.WriteLine(Indent(1) + "<material id=\"{0}\">".FormatWith(material));  					amfFile.WriteLine(Indent(2) + "<metadata type=\"Name\">Material {0}</metadata>".FormatWith(material));  					amfFile.WriteLine(Indent(1) + "</material>");  				}  			}
Magic Number,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,Save,The following statement contains a magic number: {  				int objectId = 1;    				bool continueProcessing;    				int totalMeshes = 0;  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						totalMeshes++;  					}  				}    				double ratioPerMesh = 1d / totalMeshes;  				double currentRation = 0;  				for(int meshGroupIndex = 0; meshGroupIndex < meshToSave.Count; meshGroupIndex++)  				{  					MeshGroup meshGroup = meshToSave[meshGroupIndex];  					amfFile.WriteLine(Indent(1) + "<object id=\"{0}\">".FormatWith(objectId++));  					{  						int vertexCount = 0;  						List<int> meshVertexStart = new List<int>();  						amfFile.WriteLine(Indent(2) + "<mesh>");  						{  							amfFile.WriteLine(Indent(3) + "<vertices>");  							{  								for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  								{  									Mesh mesh = meshGroup.Meshes[meshIndex];  									double vertCount = (double)mesh.Vertices.Count;    									meshVertexStart.Add(vertexCount);  									for (int vertexIndex = 0; vertexIndex < mesh.Vertices.Count; vertexIndex++)  									{  										Vertex vertex = mesh.Vertices[vertexIndex];  										if (outputInfo.ReportProgress != null)  										{  											outputInfo.ReportProgress(currentRation + vertexIndex / vertCount * ratioPerMesh * .5' ""' out continueProcessing);  										}    										Vector3 position = vertex.Position;  										amfFile.WriteLine(Indent(4) + "<vertex>");  										{  											amfFile.WriteLine(Indent(5) + "<coordinates>");  											amfFile.WriteLine(Indent(6) + "<x>{0}</x>".FormatWith(position.x));  											amfFile.WriteLine(Indent(6) + "<y>{0}</y>".FormatWith(position.y));  											amfFile.WriteLine(Indent(6) + "<z>{0}</z>".FormatWith(position.z));  											amfFile.WriteLine(Indent(5) + "</coordinates>");  										}  										amfFile.WriteLine(Indent(4) + "</vertex>");  										vertexCount++;  									}  									currentRation += ratioPerMesh * .5;  								}  							}    							amfFile.WriteLine(Indent(3) + "</vertices>");  							for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  							{  								Mesh mesh = meshGroup.Meshes[meshIndex];  								int firstVertexIndex = meshVertexStart[meshIndex];  								MeshMaterialData material = MeshMaterialData.Get(mesh);  								if (material.MaterialIndex == -1)  								{  									amfFile.WriteLine(Indent(3) + "<volume>");  								}  								else  								{  									amfFile.WriteLine(Indent(3) + "<volume materialid=\"{0}\">".FormatWith(material.MaterialIndex));  								}    								double faceCount = (double)mesh.Faces.Count;  								for (int faceIndex = 0; faceIndex < mesh.Faces.Count; faceIndex++)  								{  									if (outputInfo.ReportProgress != null)  									{  										outputInfo.ReportProgress(currentRation + faceIndex / faceCount * ratioPerMesh * .5' ""' out continueProcessing);  									}    									Face face = mesh.Faces[faceIndex];  									List<Vertex> positionsCCW = new List<Vertex>();  									foreach (FaceEdge faceEdge in face.FaceEdges())  									{  										positionsCCW.Add(faceEdge.firstVertex);  									}    									int numPolys = positionsCCW.Count - 2;  									int secondIndex = 1;  									int thirdIndex = 2;  									for (int polyIndex = 0; polyIndex < numPolys; polyIndex++)  									{  										amfFile.WriteLine(Indent(4) + "<triangle>");  										amfFile.WriteLine(Indent(5) + "<v1>{0}</v1>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[0])));  										amfFile.WriteLine(Indent(5) + "<v2>{0}</v2>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[secondIndex])));  										amfFile.WriteLine(Indent(5) + "<v3>{0}</v3>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[thirdIndex])));  										amfFile.WriteLine(Indent(4) + "</triangle>");    										secondIndex = thirdIndex;  										thirdIndex++;  									}  								}    								currentRation += ratioPerMesh * .5;  								amfFile.WriteLine(Indent(3) + "</volume>");  							}  						}  						amfFile.WriteLine(Indent(2) + "</mesh>");  					}  					amfFile.WriteLine(Indent(1) + "</object>");  				}    				HashSet<int> materials = new HashSet<int>();  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						MeshMaterialData material = MeshMaterialData.Get(mesh);  						if (material.MaterialIndex != -1)  						{  							materials.Add(material.MaterialIndex);  						}  					}  				}    				foreach (int material in materials)  				{  					amfFile.WriteLine(Indent(1) + "<material id=\"{0}\">".FormatWith(material));  					amfFile.WriteLine(Indent(2) + "<metadata type=\"Name\">Material {0}</metadata>".FormatWith(material));  					amfFile.WriteLine(Indent(1) + "</material>");  				}  			}
Magic Number,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,Save,The following statement contains a magic number: {  				int objectId = 1;    				bool continueProcessing;    				int totalMeshes = 0;  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						totalMeshes++;  					}  				}    				double ratioPerMesh = 1d / totalMeshes;  				double currentRation = 0;  				for(int meshGroupIndex = 0; meshGroupIndex < meshToSave.Count; meshGroupIndex++)  				{  					MeshGroup meshGroup = meshToSave[meshGroupIndex];  					amfFile.WriteLine(Indent(1) + "<object id=\"{0}\">".FormatWith(objectId++));  					{  						int vertexCount = 0;  						List<int> meshVertexStart = new List<int>();  						amfFile.WriteLine(Indent(2) + "<mesh>");  						{  							amfFile.WriteLine(Indent(3) + "<vertices>");  							{  								for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  								{  									Mesh mesh = meshGroup.Meshes[meshIndex];  									double vertCount = (double)mesh.Vertices.Count;    									meshVertexStart.Add(vertexCount);  									for (int vertexIndex = 0; vertexIndex < mesh.Vertices.Count; vertexIndex++)  									{  										Vertex vertex = mesh.Vertices[vertexIndex];  										if (outputInfo.ReportProgress != null)  										{  											outputInfo.ReportProgress(currentRation + vertexIndex / vertCount * ratioPerMesh * .5' ""' out continueProcessing);  										}    										Vector3 position = vertex.Position;  										amfFile.WriteLine(Indent(4) + "<vertex>");  										{  											amfFile.WriteLine(Indent(5) + "<coordinates>");  											amfFile.WriteLine(Indent(6) + "<x>{0}</x>".FormatWith(position.x));  											amfFile.WriteLine(Indent(6) + "<y>{0}</y>".FormatWith(position.y));  											amfFile.WriteLine(Indent(6) + "<z>{0}</z>".FormatWith(position.z));  											amfFile.WriteLine(Indent(5) + "</coordinates>");  										}  										amfFile.WriteLine(Indent(4) + "</vertex>");  										vertexCount++;  									}  									currentRation += ratioPerMesh * .5;  								}  							}    							amfFile.WriteLine(Indent(3) + "</vertices>");  							for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  							{  								Mesh mesh = meshGroup.Meshes[meshIndex];  								int firstVertexIndex = meshVertexStart[meshIndex];  								MeshMaterialData material = MeshMaterialData.Get(mesh);  								if (material.MaterialIndex == -1)  								{  									amfFile.WriteLine(Indent(3) + "<volume>");  								}  								else  								{  									amfFile.WriteLine(Indent(3) + "<volume materialid=\"{0}\">".FormatWith(material.MaterialIndex));  								}    								double faceCount = (double)mesh.Faces.Count;  								for (int faceIndex = 0; faceIndex < mesh.Faces.Count; faceIndex++)  								{  									if (outputInfo.ReportProgress != null)  									{  										outputInfo.ReportProgress(currentRation + faceIndex / faceCount * ratioPerMesh * .5' ""' out continueProcessing);  									}    									Face face = mesh.Faces[faceIndex];  									List<Vertex> positionsCCW = new List<Vertex>();  									foreach (FaceEdge faceEdge in face.FaceEdges())  									{  										positionsCCW.Add(faceEdge.firstVertex);  									}    									int numPolys = positionsCCW.Count - 2;  									int secondIndex = 1;  									int thirdIndex = 2;  									for (int polyIndex = 0; polyIndex < numPolys; polyIndex++)  									{  										amfFile.WriteLine(Indent(4) + "<triangle>");  										amfFile.WriteLine(Indent(5) + "<v1>{0}</v1>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[0])));  										amfFile.WriteLine(Indent(5) + "<v2>{0}</v2>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[secondIndex])));  										amfFile.WriteLine(Indent(5) + "<v3>{0}</v3>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[thirdIndex])));  										amfFile.WriteLine(Indent(4) + "</triangle>");    										secondIndex = thirdIndex;  										thirdIndex++;  									}  								}    								currentRation += ratioPerMesh * .5;  								amfFile.WriteLine(Indent(3) + "</volume>");  							}  						}  						amfFile.WriteLine(Indent(2) + "</mesh>");  					}  					amfFile.WriteLine(Indent(1) + "</object>");  				}    				HashSet<int> materials = new HashSet<int>();  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						MeshMaterialData material = MeshMaterialData.Get(mesh);  						if (material.MaterialIndex != -1)  						{  							materials.Add(material.MaterialIndex);  						}  					}  				}    				foreach (int material in materials)  				{  					amfFile.WriteLine(Indent(1) + "<material id=\"{0}\">".FormatWith(material));  					amfFile.WriteLine(Indent(2) + "<metadata type=\"Name\">Material {0}</metadata>".FormatWith(material));  					amfFile.WriteLine(Indent(1) + "</material>");  				}  			}
Magic Number,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,Save,The following statement contains a magic number: {  				int objectId = 1;    				bool continueProcessing;    				int totalMeshes = 0;  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						totalMeshes++;  					}  				}    				double ratioPerMesh = 1d / totalMeshes;  				double currentRation = 0;  				for(int meshGroupIndex = 0; meshGroupIndex < meshToSave.Count; meshGroupIndex++)  				{  					MeshGroup meshGroup = meshToSave[meshGroupIndex];  					amfFile.WriteLine(Indent(1) + "<object id=\"{0}\">".FormatWith(objectId++));  					{  						int vertexCount = 0;  						List<int> meshVertexStart = new List<int>();  						amfFile.WriteLine(Indent(2) + "<mesh>");  						{  							amfFile.WriteLine(Indent(3) + "<vertices>");  							{  								for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  								{  									Mesh mesh = meshGroup.Meshes[meshIndex];  									double vertCount = (double)mesh.Vertices.Count;    									meshVertexStart.Add(vertexCount);  									for (int vertexIndex = 0; vertexIndex < mesh.Vertices.Count; vertexIndex++)  									{  										Vertex vertex = mesh.Vertices[vertexIndex];  										if (outputInfo.ReportProgress != null)  										{  											outputInfo.ReportProgress(currentRation + vertexIndex / vertCount * ratioPerMesh * .5' ""' out continueProcessing);  										}    										Vector3 position = vertex.Position;  										amfFile.WriteLine(Indent(4) + "<vertex>");  										{  											amfFile.WriteLine(Indent(5) + "<coordinates>");  											amfFile.WriteLine(Indent(6) + "<x>{0}</x>".FormatWith(position.x));  											amfFile.WriteLine(Indent(6) + "<y>{0}</y>".FormatWith(position.y));  											amfFile.WriteLine(Indent(6) + "<z>{0}</z>".FormatWith(position.z));  											amfFile.WriteLine(Indent(5) + "</coordinates>");  										}  										amfFile.WriteLine(Indent(4) + "</vertex>");  										vertexCount++;  									}  									currentRation += ratioPerMesh * .5;  								}  							}    							amfFile.WriteLine(Indent(3) + "</vertices>");  							for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  							{  								Mesh mesh = meshGroup.Meshes[meshIndex];  								int firstVertexIndex = meshVertexStart[meshIndex];  								MeshMaterialData material = MeshMaterialData.Get(mesh);  								if (material.MaterialIndex == -1)  								{  									amfFile.WriteLine(Indent(3) + "<volume>");  								}  								else  								{  									amfFile.WriteLine(Indent(3) + "<volume materialid=\"{0}\">".FormatWith(material.MaterialIndex));  								}    								double faceCount = (double)mesh.Faces.Count;  								for (int faceIndex = 0; faceIndex < mesh.Faces.Count; faceIndex++)  								{  									if (outputInfo.ReportProgress != null)  									{  										outputInfo.ReportProgress(currentRation + faceIndex / faceCount * ratioPerMesh * .5' ""' out continueProcessing);  									}    									Face face = mesh.Faces[faceIndex];  									List<Vertex> positionsCCW = new List<Vertex>();  									foreach (FaceEdge faceEdge in face.FaceEdges())  									{  										positionsCCW.Add(faceEdge.firstVertex);  									}    									int numPolys = positionsCCW.Count - 2;  									int secondIndex = 1;  									int thirdIndex = 2;  									for (int polyIndex = 0; polyIndex < numPolys; polyIndex++)  									{  										amfFile.WriteLine(Indent(4) + "<triangle>");  										amfFile.WriteLine(Indent(5) + "<v1>{0}</v1>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[0])));  										amfFile.WriteLine(Indent(5) + "<v2>{0}</v2>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[secondIndex])));  										amfFile.WriteLine(Indent(5) + "<v3>{0}</v3>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[thirdIndex])));  										amfFile.WriteLine(Indent(4) + "</triangle>");    										secondIndex = thirdIndex;  										thirdIndex++;  									}  								}    								currentRation += ratioPerMesh * .5;  								amfFile.WriteLine(Indent(3) + "</volume>");  							}  						}  						amfFile.WriteLine(Indent(2) + "</mesh>");  					}  					amfFile.WriteLine(Indent(1) + "</object>");  				}    				HashSet<int> materials = new HashSet<int>();  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						MeshMaterialData material = MeshMaterialData.Get(mesh);  						if (material.MaterialIndex != -1)  						{  							materials.Add(material.MaterialIndex);  						}  					}  				}    				foreach (int material in materials)  				{  					amfFile.WriteLine(Indent(1) + "<material id=\"{0}\">".FormatWith(material));  					amfFile.WriteLine(Indent(2) + "<metadata type=\"Name\">Material {0}</metadata>".FormatWith(material));  					amfFile.WriteLine(Indent(1) + "</material>");  				}  			}
Magic Number,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,Save,The following statement contains a magic number: {  				int objectId = 1;    				bool continueProcessing;    				int totalMeshes = 0;  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						totalMeshes++;  					}  				}    				double ratioPerMesh = 1d / totalMeshes;  				double currentRation = 0;  				for(int meshGroupIndex = 0; meshGroupIndex < meshToSave.Count; meshGroupIndex++)  				{  					MeshGroup meshGroup = meshToSave[meshGroupIndex];  					amfFile.WriteLine(Indent(1) + "<object id=\"{0}\">".FormatWith(objectId++));  					{  						int vertexCount = 0;  						List<int> meshVertexStart = new List<int>();  						amfFile.WriteLine(Indent(2) + "<mesh>");  						{  							amfFile.WriteLine(Indent(3) + "<vertices>");  							{  								for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  								{  									Mesh mesh = meshGroup.Meshes[meshIndex];  									double vertCount = (double)mesh.Vertices.Count;    									meshVertexStart.Add(vertexCount);  									for (int vertexIndex = 0; vertexIndex < mesh.Vertices.Count; vertexIndex++)  									{  										Vertex vertex = mesh.Vertices[vertexIndex];  										if (outputInfo.ReportProgress != null)  										{  											outputInfo.ReportProgress(currentRation + vertexIndex / vertCount * ratioPerMesh * .5' ""' out continueProcessing);  										}    										Vector3 position = vertex.Position;  										amfFile.WriteLine(Indent(4) + "<vertex>");  										{  											amfFile.WriteLine(Indent(5) + "<coordinates>");  											amfFile.WriteLine(Indent(6) + "<x>{0}</x>".FormatWith(position.x));  											amfFile.WriteLine(Indent(6) + "<y>{0}</y>".FormatWith(position.y));  											amfFile.WriteLine(Indent(6) + "<z>{0}</z>".FormatWith(position.z));  											amfFile.WriteLine(Indent(5) + "</coordinates>");  										}  										amfFile.WriteLine(Indent(4) + "</vertex>");  										vertexCount++;  									}  									currentRation += ratioPerMesh * .5;  								}  							}    							amfFile.WriteLine(Indent(3) + "</vertices>");  							for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  							{  								Mesh mesh = meshGroup.Meshes[meshIndex];  								int firstVertexIndex = meshVertexStart[meshIndex];  								MeshMaterialData material = MeshMaterialData.Get(mesh);  								if (material.MaterialIndex == -1)  								{  									amfFile.WriteLine(Indent(3) + "<volume>");  								}  								else  								{  									amfFile.WriteLine(Indent(3) + "<volume materialid=\"{0}\">".FormatWith(material.MaterialIndex));  								}    								double faceCount = (double)mesh.Faces.Count;  								for (int faceIndex = 0; faceIndex < mesh.Faces.Count; faceIndex++)  								{  									if (outputInfo.ReportProgress != null)  									{  										outputInfo.ReportProgress(currentRation + faceIndex / faceCount * ratioPerMesh * .5' ""' out continueProcessing);  									}    									Face face = mesh.Faces[faceIndex];  									List<Vertex> positionsCCW = new List<Vertex>();  									foreach (FaceEdge faceEdge in face.FaceEdges())  									{  										positionsCCW.Add(faceEdge.firstVertex);  									}    									int numPolys = positionsCCW.Count - 2;  									int secondIndex = 1;  									int thirdIndex = 2;  									for (int polyIndex = 0; polyIndex < numPolys; polyIndex++)  									{  										amfFile.WriteLine(Indent(4) + "<triangle>");  										amfFile.WriteLine(Indent(5) + "<v1>{0}</v1>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[0])));  										amfFile.WriteLine(Indent(5) + "<v2>{0}</v2>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[secondIndex])));  										amfFile.WriteLine(Indent(5) + "<v3>{0}</v3>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[thirdIndex])));  										amfFile.WriteLine(Indent(4) + "</triangle>");    										secondIndex = thirdIndex;  										thirdIndex++;  									}  								}    								currentRation += ratioPerMesh * .5;  								amfFile.WriteLine(Indent(3) + "</volume>");  							}  						}  						amfFile.WriteLine(Indent(2) + "</mesh>");  					}  					amfFile.WriteLine(Indent(1) + "</object>");  				}    				HashSet<int> materials = new HashSet<int>();  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						MeshMaterialData material = MeshMaterialData.Get(mesh);  						if (material.MaterialIndex != -1)  						{  							materials.Add(material.MaterialIndex);  						}  					}  				}    				foreach (int material in materials)  				{  					amfFile.WriteLine(Indent(1) + "<material id=\"{0}\">".FormatWith(material));  					amfFile.WriteLine(Indent(2) + "<metadata type=\"Name\">Material {0}</metadata>".FormatWith(material));  					amfFile.WriteLine(Indent(1) + "</material>");  				}  			}
Magic Number,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,Save,The following statement contains a magic number: {  				int objectId = 1;    				bool continueProcessing;    				int totalMeshes = 0;  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						totalMeshes++;  					}  				}    				double ratioPerMesh = 1d / totalMeshes;  				double currentRation = 0;  				for(int meshGroupIndex = 0; meshGroupIndex < meshToSave.Count; meshGroupIndex++)  				{  					MeshGroup meshGroup = meshToSave[meshGroupIndex];  					amfFile.WriteLine(Indent(1) + "<object id=\"{0}\">".FormatWith(objectId++));  					{  						int vertexCount = 0;  						List<int> meshVertexStart = new List<int>();  						amfFile.WriteLine(Indent(2) + "<mesh>");  						{  							amfFile.WriteLine(Indent(3) + "<vertices>");  							{  								for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  								{  									Mesh mesh = meshGroup.Meshes[meshIndex];  									double vertCount = (double)mesh.Vertices.Count;    									meshVertexStart.Add(vertexCount);  									for (int vertexIndex = 0; vertexIndex < mesh.Vertices.Count; vertexIndex++)  									{  										Vertex vertex = mesh.Vertices[vertexIndex];  										if (outputInfo.ReportProgress != null)  										{  											outputInfo.ReportProgress(currentRation + vertexIndex / vertCount * ratioPerMesh * .5' ""' out continueProcessing);  										}    										Vector3 position = vertex.Position;  										amfFile.WriteLine(Indent(4) + "<vertex>");  										{  											amfFile.WriteLine(Indent(5) + "<coordinates>");  											amfFile.WriteLine(Indent(6) + "<x>{0}</x>".FormatWith(position.x));  											amfFile.WriteLine(Indent(6) + "<y>{0}</y>".FormatWith(position.y));  											amfFile.WriteLine(Indent(6) + "<z>{0}</z>".FormatWith(position.z));  											amfFile.WriteLine(Indent(5) + "</coordinates>");  										}  										amfFile.WriteLine(Indent(4) + "</vertex>");  										vertexCount++;  									}  									currentRation += ratioPerMesh * .5;  								}  							}    							amfFile.WriteLine(Indent(3) + "</vertices>");  							for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  							{  								Mesh mesh = meshGroup.Meshes[meshIndex];  								int firstVertexIndex = meshVertexStart[meshIndex];  								MeshMaterialData material = MeshMaterialData.Get(mesh);  								if (material.MaterialIndex == -1)  								{  									amfFile.WriteLine(Indent(3) + "<volume>");  								}  								else  								{  									amfFile.WriteLine(Indent(3) + "<volume materialid=\"{0}\">".FormatWith(material.MaterialIndex));  								}    								double faceCount = (double)mesh.Faces.Count;  								for (int faceIndex = 0; faceIndex < mesh.Faces.Count; faceIndex++)  								{  									if (outputInfo.ReportProgress != null)  									{  										outputInfo.ReportProgress(currentRation + faceIndex / faceCount * ratioPerMesh * .5' ""' out continueProcessing);  									}    									Face face = mesh.Faces[faceIndex];  									List<Vertex> positionsCCW = new List<Vertex>();  									foreach (FaceEdge faceEdge in face.FaceEdges())  									{  										positionsCCW.Add(faceEdge.firstVertex);  									}    									int numPolys = positionsCCW.Count - 2;  									int secondIndex = 1;  									int thirdIndex = 2;  									for (int polyIndex = 0; polyIndex < numPolys; polyIndex++)  									{  										amfFile.WriteLine(Indent(4) + "<triangle>");  										amfFile.WriteLine(Indent(5) + "<v1>{0}</v1>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[0])));  										amfFile.WriteLine(Indent(5) + "<v2>{0}</v2>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[secondIndex])));  										amfFile.WriteLine(Indent(5) + "<v3>{0}</v3>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[thirdIndex])));  										amfFile.WriteLine(Indent(4) + "</triangle>");    										secondIndex = thirdIndex;  										thirdIndex++;  									}  								}    								currentRation += ratioPerMesh * .5;  								amfFile.WriteLine(Indent(3) + "</volume>");  							}  						}  						amfFile.WriteLine(Indent(2) + "</mesh>");  					}  					amfFile.WriteLine(Indent(1) + "</object>");  				}    				HashSet<int> materials = new HashSet<int>();  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						MeshMaterialData material = MeshMaterialData.Get(mesh);  						if (material.MaterialIndex != -1)  						{  							materials.Add(material.MaterialIndex);  						}  					}  				}    				foreach (int material in materials)  				{  					amfFile.WriteLine(Indent(1) + "<material id=\"{0}\">".FormatWith(material));  					amfFile.WriteLine(Indent(2) + "<metadata type=\"Name\">Material {0}</metadata>".FormatWith(material));  					amfFile.WriteLine(Indent(1) + "</material>");  				}  			}
Magic Number,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,Save,The following statement contains a magic number: {  				int objectId = 1;    				bool continueProcessing;    				int totalMeshes = 0;  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						totalMeshes++;  					}  				}    				double ratioPerMesh = 1d / totalMeshes;  				double currentRation = 0;  				for(int meshGroupIndex = 0; meshGroupIndex < meshToSave.Count; meshGroupIndex++)  				{  					MeshGroup meshGroup = meshToSave[meshGroupIndex];  					amfFile.WriteLine(Indent(1) + "<object id=\"{0}\">".FormatWith(objectId++));  					{  						int vertexCount = 0;  						List<int> meshVertexStart = new List<int>();  						amfFile.WriteLine(Indent(2) + "<mesh>");  						{  							amfFile.WriteLine(Indent(3) + "<vertices>");  							{  								for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  								{  									Mesh mesh = meshGroup.Meshes[meshIndex];  									double vertCount = (double)mesh.Vertices.Count;    									meshVertexStart.Add(vertexCount);  									for (int vertexIndex = 0; vertexIndex < mesh.Vertices.Count; vertexIndex++)  									{  										Vertex vertex = mesh.Vertices[vertexIndex];  										if (outputInfo.ReportProgress != null)  										{  											outputInfo.ReportProgress(currentRation + vertexIndex / vertCount * ratioPerMesh * .5' ""' out continueProcessing);  										}    										Vector3 position = vertex.Position;  										amfFile.WriteLine(Indent(4) + "<vertex>");  										{  											amfFile.WriteLine(Indent(5) + "<coordinates>");  											amfFile.WriteLine(Indent(6) + "<x>{0}</x>".FormatWith(position.x));  											amfFile.WriteLine(Indent(6) + "<y>{0}</y>".FormatWith(position.y));  											amfFile.WriteLine(Indent(6) + "<z>{0}</z>".FormatWith(position.z));  											amfFile.WriteLine(Indent(5) + "</coordinates>");  										}  										amfFile.WriteLine(Indent(4) + "</vertex>");  										vertexCount++;  									}  									currentRation += ratioPerMesh * .5;  								}  							}    							amfFile.WriteLine(Indent(3) + "</vertices>");  							for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  							{  								Mesh mesh = meshGroup.Meshes[meshIndex];  								int firstVertexIndex = meshVertexStart[meshIndex];  								MeshMaterialData material = MeshMaterialData.Get(mesh);  								if (material.MaterialIndex == -1)  								{  									amfFile.WriteLine(Indent(3) + "<volume>");  								}  								else  								{  									amfFile.WriteLine(Indent(3) + "<volume materialid=\"{0}\">".FormatWith(material.MaterialIndex));  								}    								double faceCount = (double)mesh.Faces.Count;  								for (int faceIndex = 0; faceIndex < mesh.Faces.Count; faceIndex++)  								{  									if (outputInfo.ReportProgress != null)  									{  										outputInfo.ReportProgress(currentRation + faceIndex / faceCount * ratioPerMesh * .5' ""' out continueProcessing);  									}    									Face face = mesh.Faces[faceIndex];  									List<Vertex> positionsCCW = new List<Vertex>();  									foreach (FaceEdge faceEdge in face.FaceEdges())  									{  										positionsCCW.Add(faceEdge.firstVertex);  									}    									int numPolys = positionsCCW.Count - 2;  									int secondIndex = 1;  									int thirdIndex = 2;  									for (int polyIndex = 0; polyIndex < numPolys; polyIndex++)  									{  										amfFile.WriteLine(Indent(4) + "<triangle>");  										amfFile.WriteLine(Indent(5) + "<v1>{0}</v1>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[0])));  										amfFile.WriteLine(Indent(5) + "<v2>{0}</v2>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[secondIndex])));  										amfFile.WriteLine(Indent(5) + "<v3>{0}</v3>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[thirdIndex])));  										amfFile.WriteLine(Indent(4) + "</triangle>");    										secondIndex = thirdIndex;  										thirdIndex++;  									}  								}    								currentRation += ratioPerMesh * .5;  								amfFile.WriteLine(Indent(3) + "</volume>");  							}  						}  						amfFile.WriteLine(Indent(2) + "</mesh>");  					}  					amfFile.WriteLine(Indent(1) + "</object>");  				}    				HashSet<int> materials = new HashSet<int>();  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						MeshMaterialData material = MeshMaterialData.Get(mesh);  						if (material.MaterialIndex != -1)  						{  							materials.Add(material.MaterialIndex);  						}  					}  				}    				foreach (int material in materials)  				{  					amfFile.WriteLine(Indent(1) + "<material id=\"{0}\">".FormatWith(material));  					amfFile.WriteLine(Indent(2) + "<metadata type=\"Name\">Material {0}</metadata>".FormatWith(material));  					amfFile.WriteLine(Indent(1) + "</material>");  				}  			}
Magic Number,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,Save,The following statement contains a magic number: {  				int objectId = 1;    				bool continueProcessing;    				int totalMeshes = 0;  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						totalMeshes++;  					}  				}    				double ratioPerMesh = 1d / totalMeshes;  				double currentRation = 0;  				for(int meshGroupIndex = 0; meshGroupIndex < meshToSave.Count; meshGroupIndex++)  				{  					MeshGroup meshGroup = meshToSave[meshGroupIndex];  					amfFile.WriteLine(Indent(1) + "<object id=\"{0}\">".FormatWith(objectId++));  					{  						int vertexCount = 0;  						List<int> meshVertexStart = new List<int>();  						amfFile.WriteLine(Indent(2) + "<mesh>");  						{  							amfFile.WriteLine(Indent(3) + "<vertices>");  							{  								for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  								{  									Mesh mesh = meshGroup.Meshes[meshIndex];  									double vertCount = (double)mesh.Vertices.Count;    									meshVertexStart.Add(vertexCount);  									for (int vertexIndex = 0; vertexIndex < mesh.Vertices.Count; vertexIndex++)  									{  										Vertex vertex = mesh.Vertices[vertexIndex];  										if (outputInfo.ReportProgress != null)  										{  											outputInfo.ReportProgress(currentRation + vertexIndex / vertCount * ratioPerMesh * .5' ""' out continueProcessing);  										}    										Vector3 position = vertex.Position;  										amfFile.WriteLine(Indent(4) + "<vertex>");  										{  											amfFile.WriteLine(Indent(5) + "<coordinates>");  											amfFile.WriteLine(Indent(6) + "<x>{0}</x>".FormatWith(position.x));  											amfFile.WriteLine(Indent(6) + "<y>{0}</y>".FormatWith(position.y));  											amfFile.WriteLine(Indent(6) + "<z>{0}</z>".FormatWith(position.z));  											amfFile.WriteLine(Indent(5) + "</coordinates>");  										}  										amfFile.WriteLine(Indent(4) + "</vertex>");  										vertexCount++;  									}  									currentRation += ratioPerMesh * .5;  								}  							}    							amfFile.WriteLine(Indent(3) + "</vertices>");  							for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  							{  								Mesh mesh = meshGroup.Meshes[meshIndex];  								int firstVertexIndex = meshVertexStart[meshIndex];  								MeshMaterialData material = MeshMaterialData.Get(mesh);  								if (material.MaterialIndex == -1)  								{  									amfFile.WriteLine(Indent(3) + "<volume>");  								}  								else  								{  									amfFile.WriteLine(Indent(3) + "<volume materialid=\"{0}\">".FormatWith(material.MaterialIndex));  								}    								double faceCount = (double)mesh.Faces.Count;  								for (int faceIndex = 0; faceIndex < mesh.Faces.Count; faceIndex++)  								{  									if (outputInfo.ReportProgress != null)  									{  										outputInfo.ReportProgress(currentRation + faceIndex / faceCount * ratioPerMesh * .5' ""' out continueProcessing);  									}    									Face face = mesh.Faces[faceIndex];  									List<Vertex> positionsCCW = new List<Vertex>();  									foreach (FaceEdge faceEdge in face.FaceEdges())  									{  										positionsCCW.Add(faceEdge.firstVertex);  									}    									int numPolys = positionsCCW.Count - 2;  									int secondIndex = 1;  									int thirdIndex = 2;  									for (int polyIndex = 0; polyIndex < numPolys; polyIndex++)  									{  										amfFile.WriteLine(Indent(4) + "<triangle>");  										amfFile.WriteLine(Indent(5) + "<v1>{0}</v1>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[0])));  										amfFile.WriteLine(Indent(5) + "<v2>{0}</v2>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[secondIndex])));  										amfFile.WriteLine(Indent(5) + "<v3>{0}</v3>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[thirdIndex])));  										amfFile.WriteLine(Indent(4) + "</triangle>");    										secondIndex = thirdIndex;  										thirdIndex++;  									}  								}    								currentRation += ratioPerMesh * .5;  								amfFile.WriteLine(Indent(3) + "</volume>");  							}  						}  						amfFile.WriteLine(Indent(2) + "</mesh>");  					}  					amfFile.WriteLine(Indent(1) + "</object>");  				}    				HashSet<int> materials = new HashSet<int>();  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						MeshMaterialData material = MeshMaterialData.Get(mesh);  						if (material.MaterialIndex != -1)  						{  							materials.Add(material.MaterialIndex);  						}  					}  				}    				foreach (int material in materials)  				{  					amfFile.WriteLine(Indent(1) + "<material id=\"{0}\">".FormatWith(material));  					amfFile.WriteLine(Indent(2) + "<metadata type=\"Name\">Material {0}</metadata>".FormatWith(material));  					amfFile.WriteLine(Indent(1) + "</material>");  				}  			}
Magic Number,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,Save,The following statement contains a magic number: {  				int objectId = 1;    				bool continueProcessing;    				int totalMeshes = 0;  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						totalMeshes++;  					}  				}    				double ratioPerMesh = 1d / totalMeshes;  				double currentRation = 0;  				for(int meshGroupIndex = 0; meshGroupIndex < meshToSave.Count; meshGroupIndex++)  				{  					MeshGroup meshGroup = meshToSave[meshGroupIndex];  					amfFile.WriteLine(Indent(1) + "<object id=\"{0}\">".FormatWith(objectId++));  					{  						int vertexCount = 0;  						List<int> meshVertexStart = new List<int>();  						amfFile.WriteLine(Indent(2) + "<mesh>");  						{  							amfFile.WriteLine(Indent(3) + "<vertices>");  							{  								for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  								{  									Mesh mesh = meshGroup.Meshes[meshIndex];  									double vertCount = (double)mesh.Vertices.Count;    									meshVertexStart.Add(vertexCount);  									for (int vertexIndex = 0; vertexIndex < mesh.Vertices.Count; vertexIndex++)  									{  										Vertex vertex = mesh.Vertices[vertexIndex];  										if (outputInfo.ReportProgress != null)  										{  											outputInfo.ReportProgress(currentRation + vertexIndex / vertCount * ratioPerMesh * .5' ""' out continueProcessing);  										}    										Vector3 position = vertex.Position;  										amfFile.WriteLine(Indent(4) + "<vertex>");  										{  											amfFile.WriteLine(Indent(5) + "<coordinates>");  											amfFile.WriteLine(Indent(6) + "<x>{0}</x>".FormatWith(position.x));  											amfFile.WriteLine(Indent(6) + "<y>{0}</y>".FormatWith(position.y));  											amfFile.WriteLine(Indent(6) + "<z>{0}</z>".FormatWith(position.z));  											amfFile.WriteLine(Indent(5) + "</coordinates>");  										}  										amfFile.WriteLine(Indent(4) + "</vertex>");  										vertexCount++;  									}  									currentRation += ratioPerMesh * .5;  								}  							}    							amfFile.WriteLine(Indent(3) + "</vertices>");  							for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  							{  								Mesh mesh = meshGroup.Meshes[meshIndex];  								int firstVertexIndex = meshVertexStart[meshIndex];  								MeshMaterialData material = MeshMaterialData.Get(mesh);  								if (material.MaterialIndex == -1)  								{  									amfFile.WriteLine(Indent(3) + "<volume>");  								}  								else  								{  									amfFile.WriteLine(Indent(3) + "<volume materialid=\"{0}\">".FormatWith(material.MaterialIndex));  								}    								double faceCount = (double)mesh.Faces.Count;  								for (int faceIndex = 0; faceIndex < mesh.Faces.Count; faceIndex++)  								{  									if (outputInfo.ReportProgress != null)  									{  										outputInfo.ReportProgress(currentRation + faceIndex / faceCount * ratioPerMesh * .5' ""' out continueProcessing);  									}    									Face face = mesh.Faces[faceIndex];  									List<Vertex> positionsCCW = new List<Vertex>();  									foreach (FaceEdge faceEdge in face.FaceEdges())  									{  										positionsCCW.Add(faceEdge.firstVertex);  									}    									int numPolys = positionsCCW.Count - 2;  									int secondIndex = 1;  									int thirdIndex = 2;  									for (int polyIndex = 0; polyIndex < numPolys; polyIndex++)  									{  										amfFile.WriteLine(Indent(4) + "<triangle>");  										amfFile.WriteLine(Indent(5) + "<v1>{0}</v1>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[0])));  										amfFile.WriteLine(Indent(5) + "<v2>{0}</v2>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[secondIndex])));  										amfFile.WriteLine(Indent(5) + "<v3>{0}</v3>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[thirdIndex])));  										amfFile.WriteLine(Indent(4) + "</triangle>");    										secondIndex = thirdIndex;  										thirdIndex++;  									}  								}    								currentRation += ratioPerMesh * .5;  								amfFile.WriteLine(Indent(3) + "</volume>");  							}  						}  						amfFile.WriteLine(Indent(2) + "</mesh>");  					}  					amfFile.WriteLine(Indent(1) + "</object>");  				}    				HashSet<int> materials = new HashSet<int>();  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						MeshMaterialData material = MeshMaterialData.Get(mesh);  						if (material.MaterialIndex != -1)  						{  							materials.Add(material.MaterialIndex);  						}  					}  				}    				foreach (int material in materials)  				{  					amfFile.WriteLine(Indent(1) + "<material id=\"{0}\">".FormatWith(material));  					amfFile.WriteLine(Indent(2) + "<metadata type=\"Name\">Material {0}</metadata>".FormatWith(material));  					amfFile.WriteLine(Indent(1) + "</material>");  				}  			}
Magic Number,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,Save,The following statement contains a magic number: {  				int objectId = 1;    				bool continueProcessing;    				int totalMeshes = 0;  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						totalMeshes++;  					}  				}    				double ratioPerMesh = 1d / totalMeshes;  				double currentRation = 0;  				for(int meshGroupIndex = 0; meshGroupIndex < meshToSave.Count; meshGroupIndex++)  				{  					MeshGroup meshGroup = meshToSave[meshGroupIndex];  					amfFile.WriteLine(Indent(1) + "<object id=\"{0}\">".FormatWith(objectId++));  					{  						int vertexCount = 0;  						List<int> meshVertexStart = new List<int>();  						amfFile.WriteLine(Indent(2) + "<mesh>");  						{  							amfFile.WriteLine(Indent(3) + "<vertices>");  							{  								for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  								{  									Mesh mesh = meshGroup.Meshes[meshIndex];  									double vertCount = (double)mesh.Vertices.Count;    									meshVertexStart.Add(vertexCount);  									for (int vertexIndex = 0; vertexIndex < mesh.Vertices.Count; vertexIndex++)  									{  										Vertex vertex = mesh.Vertices[vertexIndex];  										if (outputInfo.ReportProgress != null)  										{  											outputInfo.ReportProgress(currentRation + vertexIndex / vertCount * ratioPerMesh * .5' ""' out continueProcessing);  										}    										Vector3 position = vertex.Position;  										amfFile.WriteLine(Indent(4) + "<vertex>");  										{  											amfFile.WriteLine(Indent(5) + "<coordinates>");  											amfFile.WriteLine(Indent(6) + "<x>{0}</x>".FormatWith(position.x));  											amfFile.WriteLine(Indent(6) + "<y>{0}</y>".FormatWith(position.y));  											amfFile.WriteLine(Indent(6) + "<z>{0}</z>".FormatWith(position.z));  											amfFile.WriteLine(Indent(5) + "</coordinates>");  										}  										amfFile.WriteLine(Indent(4) + "</vertex>");  										vertexCount++;  									}  									currentRation += ratioPerMesh * .5;  								}  							}    							amfFile.WriteLine(Indent(3) + "</vertices>");  							for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  							{  								Mesh mesh = meshGroup.Meshes[meshIndex];  								int firstVertexIndex = meshVertexStart[meshIndex];  								MeshMaterialData material = MeshMaterialData.Get(mesh);  								if (material.MaterialIndex == -1)  								{  									amfFile.WriteLine(Indent(3) + "<volume>");  								}  								else  								{  									amfFile.WriteLine(Indent(3) + "<volume materialid=\"{0}\">".FormatWith(material.MaterialIndex));  								}    								double faceCount = (double)mesh.Faces.Count;  								for (int faceIndex = 0; faceIndex < mesh.Faces.Count; faceIndex++)  								{  									if (outputInfo.ReportProgress != null)  									{  										outputInfo.ReportProgress(currentRation + faceIndex / faceCount * ratioPerMesh * .5' ""' out continueProcessing);  									}    									Face face = mesh.Faces[faceIndex];  									List<Vertex> positionsCCW = new List<Vertex>();  									foreach (FaceEdge faceEdge in face.FaceEdges())  									{  										positionsCCW.Add(faceEdge.firstVertex);  									}    									int numPolys = positionsCCW.Count - 2;  									int secondIndex = 1;  									int thirdIndex = 2;  									for (int polyIndex = 0; polyIndex < numPolys; polyIndex++)  									{  										amfFile.WriteLine(Indent(4) + "<triangle>");  										amfFile.WriteLine(Indent(5) + "<v1>{0}</v1>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[0])));  										amfFile.WriteLine(Indent(5) + "<v2>{0}</v2>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[secondIndex])));  										amfFile.WriteLine(Indent(5) + "<v3>{0}</v3>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[thirdIndex])));  										amfFile.WriteLine(Indent(4) + "</triangle>");    										secondIndex = thirdIndex;  										thirdIndex++;  									}  								}    								currentRation += ratioPerMesh * .5;  								amfFile.WriteLine(Indent(3) + "</volume>");  							}  						}  						amfFile.WriteLine(Indent(2) + "</mesh>");  					}  					amfFile.WriteLine(Indent(1) + "</object>");  				}    				HashSet<int> materials = new HashSet<int>();  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						MeshMaterialData material = MeshMaterialData.Get(mesh);  						if (material.MaterialIndex != -1)  						{  							materials.Add(material.MaterialIndex);  						}  					}  				}    				foreach (int material in materials)  				{  					amfFile.WriteLine(Indent(1) + "<material id=\"{0}\">".FormatWith(material));  					amfFile.WriteLine(Indent(2) + "<metadata type=\"Name\">Material {0}</metadata>".FormatWith(material));  					amfFile.WriteLine(Indent(1) + "</material>");  				}  			}
Magic Number,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,Save,The following statement contains a magic number: {  				int objectId = 1;    				bool continueProcessing;    				int totalMeshes = 0;  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						totalMeshes++;  					}  				}    				double ratioPerMesh = 1d / totalMeshes;  				double currentRation = 0;  				for(int meshGroupIndex = 0; meshGroupIndex < meshToSave.Count; meshGroupIndex++)  				{  					MeshGroup meshGroup = meshToSave[meshGroupIndex];  					amfFile.WriteLine(Indent(1) + "<object id=\"{0}\">".FormatWith(objectId++));  					{  						int vertexCount = 0;  						List<int> meshVertexStart = new List<int>();  						amfFile.WriteLine(Indent(2) + "<mesh>");  						{  							amfFile.WriteLine(Indent(3) + "<vertices>");  							{  								for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  								{  									Mesh mesh = meshGroup.Meshes[meshIndex];  									double vertCount = (double)mesh.Vertices.Count;    									meshVertexStart.Add(vertexCount);  									for (int vertexIndex = 0; vertexIndex < mesh.Vertices.Count; vertexIndex++)  									{  										Vertex vertex = mesh.Vertices[vertexIndex];  										if (outputInfo.ReportProgress != null)  										{  											outputInfo.ReportProgress(currentRation + vertexIndex / vertCount * ratioPerMesh * .5' ""' out continueProcessing);  										}    										Vector3 position = vertex.Position;  										amfFile.WriteLine(Indent(4) + "<vertex>");  										{  											amfFile.WriteLine(Indent(5) + "<coordinates>");  											amfFile.WriteLine(Indent(6) + "<x>{0}</x>".FormatWith(position.x));  											amfFile.WriteLine(Indent(6) + "<y>{0}</y>".FormatWith(position.y));  											amfFile.WriteLine(Indent(6) + "<z>{0}</z>".FormatWith(position.z));  											amfFile.WriteLine(Indent(5) + "</coordinates>");  										}  										amfFile.WriteLine(Indent(4) + "</vertex>");  										vertexCount++;  									}  									currentRation += ratioPerMesh * .5;  								}  							}    							amfFile.WriteLine(Indent(3) + "</vertices>");  							for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  							{  								Mesh mesh = meshGroup.Meshes[meshIndex];  								int firstVertexIndex = meshVertexStart[meshIndex];  								MeshMaterialData material = MeshMaterialData.Get(mesh);  								if (material.MaterialIndex == -1)  								{  									amfFile.WriteLine(Indent(3) + "<volume>");  								}  								else  								{  									amfFile.WriteLine(Indent(3) + "<volume materialid=\"{0}\">".FormatWith(material.MaterialIndex));  								}    								double faceCount = (double)mesh.Faces.Count;  								for (int faceIndex = 0; faceIndex < mesh.Faces.Count; faceIndex++)  								{  									if (outputInfo.ReportProgress != null)  									{  										outputInfo.ReportProgress(currentRation + faceIndex / faceCount * ratioPerMesh * .5' ""' out continueProcessing);  									}    									Face face = mesh.Faces[faceIndex];  									List<Vertex> positionsCCW = new List<Vertex>();  									foreach (FaceEdge faceEdge in face.FaceEdges())  									{  										positionsCCW.Add(faceEdge.firstVertex);  									}    									int numPolys = positionsCCW.Count - 2;  									int secondIndex = 1;  									int thirdIndex = 2;  									for (int polyIndex = 0; polyIndex < numPolys; polyIndex++)  									{  										amfFile.WriteLine(Indent(4) + "<triangle>");  										amfFile.WriteLine(Indent(5) + "<v1>{0}</v1>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[0])));  										amfFile.WriteLine(Indent(5) + "<v2>{0}</v2>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[secondIndex])));  										amfFile.WriteLine(Indent(5) + "<v3>{0}</v3>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[thirdIndex])));  										amfFile.WriteLine(Indent(4) + "</triangle>");    										secondIndex = thirdIndex;  										thirdIndex++;  									}  								}    								currentRation += ratioPerMesh * .5;  								amfFile.WriteLine(Indent(3) + "</volume>");  							}  						}  						amfFile.WriteLine(Indent(2) + "</mesh>");  					}  					amfFile.WriteLine(Indent(1) + "</object>");  				}    				HashSet<int> materials = new HashSet<int>();  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						MeshMaterialData material = MeshMaterialData.Get(mesh);  						if (material.MaterialIndex != -1)  						{  							materials.Add(material.MaterialIndex);  						}  					}  				}    				foreach (int material in materials)  				{  					amfFile.WriteLine(Indent(1) + "<material id=\"{0}\">".FormatWith(material));  					amfFile.WriteLine(Indent(2) + "<metadata type=\"Name\">Material {0}</metadata>".FormatWith(material));  					amfFile.WriteLine(Indent(1) + "</material>");  				}  			}
Magic Number,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,Save,The following statement contains a magic number: {  				int objectId = 1;    				bool continueProcessing;    				int totalMeshes = 0;  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						totalMeshes++;  					}  				}    				double ratioPerMesh = 1d / totalMeshes;  				double currentRation = 0;  				for(int meshGroupIndex = 0; meshGroupIndex < meshToSave.Count; meshGroupIndex++)  				{  					MeshGroup meshGroup = meshToSave[meshGroupIndex];  					amfFile.WriteLine(Indent(1) + "<object id=\"{0}\">".FormatWith(objectId++));  					{  						int vertexCount = 0;  						List<int> meshVertexStart = new List<int>();  						amfFile.WriteLine(Indent(2) + "<mesh>");  						{  							amfFile.WriteLine(Indent(3) + "<vertices>");  							{  								for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  								{  									Mesh mesh = meshGroup.Meshes[meshIndex];  									double vertCount = (double)mesh.Vertices.Count;    									meshVertexStart.Add(vertexCount);  									for (int vertexIndex = 0; vertexIndex < mesh.Vertices.Count; vertexIndex++)  									{  										Vertex vertex = mesh.Vertices[vertexIndex];  										if (outputInfo.ReportProgress != null)  										{  											outputInfo.ReportProgress(currentRation + vertexIndex / vertCount * ratioPerMesh * .5' ""' out continueProcessing);  										}    										Vector3 position = vertex.Position;  										amfFile.WriteLine(Indent(4) + "<vertex>");  										{  											amfFile.WriteLine(Indent(5) + "<coordinates>");  											amfFile.WriteLine(Indent(6) + "<x>{0}</x>".FormatWith(position.x));  											amfFile.WriteLine(Indent(6) + "<y>{0}</y>".FormatWith(position.y));  											amfFile.WriteLine(Indent(6) + "<z>{0}</z>".FormatWith(position.z));  											amfFile.WriteLine(Indent(5) + "</coordinates>");  										}  										amfFile.WriteLine(Indent(4) + "</vertex>");  										vertexCount++;  									}  									currentRation += ratioPerMesh * .5;  								}  							}    							amfFile.WriteLine(Indent(3) + "</vertices>");  							for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  							{  								Mesh mesh = meshGroup.Meshes[meshIndex];  								int firstVertexIndex = meshVertexStart[meshIndex];  								MeshMaterialData material = MeshMaterialData.Get(mesh);  								if (material.MaterialIndex == -1)  								{  									amfFile.WriteLine(Indent(3) + "<volume>");  								}  								else  								{  									amfFile.WriteLine(Indent(3) + "<volume materialid=\"{0}\">".FormatWith(material.MaterialIndex));  								}    								double faceCount = (double)mesh.Faces.Count;  								for (int faceIndex = 0; faceIndex < mesh.Faces.Count; faceIndex++)  								{  									if (outputInfo.ReportProgress != null)  									{  										outputInfo.ReportProgress(currentRation + faceIndex / faceCount * ratioPerMesh * .5' ""' out continueProcessing);  									}    									Face face = mesh.Faces[faceIndex];  									List<Vertex> positionsCCW = new List<Vertex>();  									foreach (FaceEdge faceEdge in face.FaceEdges())  									{  										positionsCCW.Add(faceEdge.firstVertex);  									}    									int numPolys = positionsCCW.Count - 2;  									int secondIndex = 1;  									int thirdIndex = 2;  									for (int polyIndex = 0; polyIndex < numPolys; polyIndex++)  									{  										amfFile.WriteLine(Indent(4) + "<triangle>");  										amfFile.WriteLine(Indent(5) + "<v1>{0}</v1>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[0])));  										amfFile.WriteLine(Indent(5) + "<v2>{0}</v2>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[secondIndex])));  										amfFile.WriteLine(Indent(5) + "<v3>{0}</v3>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[thirdIndex])));  										amfFile.WriteLine(Indent(4) + "</triangle>");    										secondIndex = thirdIndex;  										thirdIndex++;  									}  								}    								currentRation += ratioPerMesh * .5;  								amfFile.WriteLine(Indent(3) + "</volume>");  							}  						}  						amfFile.WriteLine(Indent(2) + "</mesh>");  					}  					amfFile.WriteLine(Indent(1) + "</object>");  				}    				HashSet<int> materials = new HashSet<int>();  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						MeshMaterialData material = MeshMaterialData.Get(mesh);  						if (material.MaterialIndex != -1)  						{  							materials.Add(material.MaterialIndex);  						}  					}  				}    				foreach (int material in materials)  				{  					amfFile.WriteLine(Indent(1) + "<material id=\"{0}\">".FormatWith(material));  					amfFile.WriteLine(Indent(2) + "<metadata type=\"Name\">Material {0}</metadata>".FormatWith(material));  					amfFile.WriteLine(Indent(1) + "</material>");  				}  			}
Magic Number,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,Save,The following statement contains a magic number: {  				int objectId = 1;    				bool continueProcessing;    				int totalMeshes = 0;  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						totalMeshes++;  					}  				}    				double ratioPerMesh = 1d / totalMeshes;  				double currentRation = 0;  				for(int meshGroupIndex = 0; meshGroupIndex < meshToSave.Count; meshGroupIndex++)  				{  					MeshGroup meshGroup = meshToSave[meshGroupIndex];  					amfFile.WriteLine(Indent(1) + "<object id=\"{0}\">".FormatWith(objectId++));  					{  						int vertexCount = 0;  						List<int> meshVertexStart = new List<int>();  						amfFile.WriteLine(Indent(2) + "<mesh>");  						{  							amfFile.WriteLine(Indent(3) + "<vertices>");  							{  								for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  								{  									Mesh mesh = meshGroup.Meshes[meshIndex];  									double vertCount = (double)mesh.Vertices.Count;    									meshVertexStart.Add(vertexCount);  									for (int vertexIndex = 0; vertexIndex < mesh.Vertices.Count; vertexIndex++)  									{  										Vertex vertex = mesh.Vertices[vertexIndex];  										if (outputInfo.ReportProgress != null)  										{  											outputInfo.ReportProgress(currentRation + vertexIndex / vertCount * ratioPerMesh * .5' ""' out continueProcessing);  										}    										Vector3 position = vertex.Position;  										amfFile.WriteLine(Indent(4) + "<vertex>");  										{  											amfFile.WriteLine(Indent(5) + "<coordinates>");  											amfFile.WriteLine(Indent(6) + "<x>{0}</x>".FormatWith(position.x));  											amfFile.WriteLine(Indent(6) + "<y>{0}</y>".FormatWith(position.y));  											amfFile.WriteLine(Indent(6) + "<z>{0}</z>".FormatWith(position.z));  											amfFile.WriteLine(Indent(5) + "</coordinates>");  										}  										amfFile.WriteLine(Indent(4) + "</vertex>");  										vertexCount++;  									}  									currentRation += ratioPerMesh * .5;  								}  							}    							amfFile.WriteLine(Indent(3) + "</vertices>");  							for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  							{  								Mesh mesh = meshGroup.Meshes[meshIndex];  								int firstVertexIndex = meshVertexStart[meshIndex];  								MeshMaterialData material = MeshMaterialData.Get(mesh);  								if (material.MaterialIndex == -1)  								{  									amfFile.WriteLine(Indent(3) + "<volume>");  								}  								else  								{  									amfFile.WriteLine(Indent(3) + "<volume materialid=\"{0}\">".FormatWith(material.MaterialIndex));  								}    								double faceCount = (double)mesh.Faces.Count;  								for (int faceIndex = 0; faceIndex < mesh.Faces.Count; faceIndex++)  								{  									if (outputInfo.ReportProgress != null)  									{  										outputInfo.ReportProgress(currentRation + faceIndex / faceCount * ratioPerMesh * .5' ""' out continueProcessing);  									}    									Face face = mesh.Faces[faceIndex];  									List<Vertex> positionsCCW = new List<Vertex>();  									foreach (FaceEdge faceEdge in face.FaceEdges())  									{  										positionsCCW.Add(faceEdge.firstVertex);  									}    									int numPolys = positionsCCW.Count - 2;  									int secondIndex = 1;  									int thirdIndex = 2;  									for (int polyIndex = 0; polyIndex < numPolys; polyIndex++)  									{  										amfFile.WriteLine(Indent(4) + "<triangle>");  										amfFile.WriteLine(Indent(5) + "<v1>{0}</v1>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[0])));  										amfFile.WriteLine(Indent(5) + "<v2>{0}</v2>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[secondIndex])));  										amfFile.WriteLine(Indent(5) + "<v3>{0}</v3>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[thirdIndex])));  										amfFile.WriteLine(Indent(4) + "</triangle>");    										secondIndex = thirdIndex;  										thirdIndex++;  									}  								}    								currentRation += ratioPerMesh * .5;  								amfFile.WriteLine(Indent(3) + "</volume>");  							}  						}  						amfFile.WriteLine(Indent(2) + "</mesh>");  					}  					amfFile.WriteLine(Indent(1) + "</object>");  				}    				HashSet<int> materials = new HashSet<int>();  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						MeshMaterialData material = MeshMaterialData.Get(mesh);  						if (material.MaterialIndex != -1)  						{  							materials.Add(material.MaterialIndex);  						}  					}  				}    				foreach (int material in materials)  				{  					amfFile.WriteLine(Indent(1) + "<material id=\"{0}\">".FormatWith(material));  					amfFile.WriteLine(Indent(2) + "<metadata type=\"Name\">Material {0}</metadata>".FormatWith(material));  					amfFile.WriteLine(Indent(1) + "</material>");  				}  			}
Magic Number,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,Save,The following statement contains a magic number: {  				int objectId = 1;    				bool continueProcessing;    				int totalMeshes = 0;  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						totalMeshes++;  					}  				}    				double ratioPerMesh = 1d / totalMeshes;  				double currentRation = 0;  				for(int meshGroupIndex = 0; meshGroupIndex < meshToSave.Count; meshGroupIndex++)  				{  					MeshGroup meshGroup = meshToSave[meshGroupIndex];  					amfFile.WriteLine(Indent(1) + "<object id=\"{0}\">".FormatWith(objectId++));  					{  						int vertexCount = 0;  						List<int> meshVertexStart = new List<int>();  						amfFile.WriteLine(Indent(2) + "<mesh>");  						{  							amfFile.WriteLine(Indent(3) + "<vertices>");  							{  								for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  								{  									Mesh mesh = meshGroup.Meshes[meshIndex];  									double vertCount = (double)mesh.Vertices.Count;    									meshVertexStart.Add(vertexCount);  									for (int vertexIndex = 0; vertexIndex < mesh.Vertices.Count; vertexIndex++)  									{  										Vertex vertex = mesh.Vertices[vertexIndex];  										if (outputInfo.ReportProgress != null)  										{  											outputInfo.ReportProgress(currentRation + vertexIndex / vertCount * ratioPerMesh * .5' ""' out continueProcessing);  										}    										Vector3 position = vertex.Position;  										amfFile.WriteLine(Indent(4) + "<vertex>");  										{  											amfFile.WriteLine(Indent(5) + "<coordinates>");  											amfFile.WriteLine(Indent(6) + "<x>{0}</x>".FormatWith(position.x));  											amfFile.WriteLine(Indent(6) + "<y>{0}</y>".FormatWith(position.y));  											amfFile.WriteLine(Indent(6) + "<z>{0}</z>".FormatWith(position.z));  											amfFile.WriteLine(Indent(5) + "</coordinates>");  										}  										amfFile.WriteLine(Indent(4) + "</vertex>");  										vertexCount++;  									}  									currentRation += ratioPerMesh * .5;  								}  							}    							amfFile.WriteLine(Indent(3) + "</vertices>");  							for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  							{  								Mesh mesh = meshGroup.Meshes[meshIndex];  								int firstVertexIndex = meshVertexStart[meshIndex];  								MeshMaterialData material = MeshMaterialData.Get(mesh);  								if (material.MaterialIndex == -1)  								{  									amfFile.WriteLine(Indent(3) + "<volume>");  								}  								else  								{  									amfFile.WriteLine(Indent(3) + "<volume materialid=\"{0}\">".FormatWith(material.MaterialIndex));  								}    								double faceCount = (double)mesh.Faces.Count;  								for (int faceIndex = 0; faceIndex < mesh.Faces.Count; faceIndex++)  								{  									if (outputInfo.ReportProgress != null)  									{  										outputInfo.ReportProgress(currentRation + faceIndex / faceCount * ratioPerMesh * .5' ""' out continueProcessing);  									}    									Face face = mesh.Faces[faceIndex];  									List<Vertex> positionsCCW = new List<Vertex>();  									foreach (FaceEdge faceEdge in face.FaceEdges())  									{  										positionsCCW.Add(faceEdge.firstVertex);  									}    									int numPolys = positionsCCW.Count - 2;  									int secondIndex = 1;  									int thirdIndex = 2;  									for (int polyIndex = 0; polyIndex < numPolys; polyIndex++)  									{  										amfFile.WriteLine(Indent(4) + "<triangle>");  										amfFile.WriteLine(Indent(5) + "<v1>{0}</v1>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[0])));  										amfFile.WriteLine(Indent(5) + "<v2>{0}</v2>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[secondIndex])));  										amfFile.WriteLine(Indent(5) + "<v3>{0}</v3>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[thirdIndex])));  										amfFile.WriteLine(Indent(4) + "</triangle>");    										secondIndex = thirdIndex;  										thirdIndex++;  									}  								}    								currentRation += ratioPerMesh * .5;  								amfFile.WriteLine(Indent(3) + "</volume>");  							}  						}  						amfFile.WriteLine(Indent(2) + "</mesh>");  					}  					amfFile.WriteLine(Indent(1) + "</object>");  				}    				HashSet<int> materials = new HashSet<int>();  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						MeshMaterialData material = MeshMaterialData.Get(mesh);  						if (material.MaterialIndex != -1)  						{  							materials.Add(material.MaterialIndex);  						}  					}  				}    				foreach (int material in materials)  				{  					amfFile.WriteLine(Indent(1) + "<material id=\"{0}\">".FormatWith(material));  					amfFile.WriteLine(Indent(2) + "<metadata type=\"Name\">Material {0}</metadata>".FormatWith(material));  					amfFile.WriteLine(Indent(1) + "</material>");  				}  			}
Magic Number,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,Save,The following statement contains a magic number: {  				int objectId = 1;    				bool continueProcessing;    				int totalMeshes = 0;  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						totalMeshes++;  					}  				}    				double ratioPerMesh = 1d / totalMeshes;  				double currentRation = 0;  				for(int meshGroupIndex = 0; meshGroupIndex < meshToSave.Count; meshGroupIndex++)  				{  					MeshGroup meshGroup = meshToSave[meshGroupIndex];  					amfFile.WriteLine(Indent(1) + "<object id=\"{0}\">".FormatWith(objectId++));  					{  						int vertexCount = 0;  						List<int> meshVertexStart = new List<int>();  						amfFile.WriteLine(Indent(2) + "<mesh>");  						{  							amfFile.WriteLine(Indent(3) + "<vertices>");  							{  								for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  								{  									Mesh mesh = meshGroup.Meshes[meshIndex];  									double vertCount = (double)mesh.Vertices.Count;    									meshVertexStart.Add(vertexCount);  									for (int vertexIndex = 0; vertexIndex < mesh.Vertices.Count; vertexIndex++)  									{  										Vertex vertex = mesh.Vertices[vertexIndex];  										if (outputInfo.ReportProgress != null)  										{  											outputInfo.ReportProgress(currentRation + vertexIndex / vertCount * ratioPerMesh * .5' ""' out continueProcessing);  										}    										Vector3 position = vertex.Position;  										amfFile.WriteLine(Indent(4) + "<vertex>");  										{  											amfFile.WriteLine(Indent(5) + "<coordinates>");  											amfFile.WriteLine(Indent(6) + "<x>{0}</x>".FormatWith(position.x));  											amfFile.WriteLine(Indent(6) + "<y>{0}</y>".FormatWith(position.y));  											amfFile.WriteLine(Indent(6) + "<z>{0}</z>".FormatWith(position.z));  											amfFile.WriteLine(Indent(5) + "</coordinates>");  										}  										amfFile.WriteLine(Indent(4) + "</vertex>");  										vertexCount++;  									}  									currentRation += ratioPerMesh * .5;  								}  							}    							amfFile.WriteLine(Indent(3) + "</vertices>");  							for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  							{  								Mesh mesh = meshGroup.Meshes[meshIndex];  								int firstVertexIndex = meshVertexStart[meshIndex];  								MeshMaterialData material = MeshMaterialData.Get(mesh);  								if (material.MaterialIndex == -1)  								{  									amfFile.WriteLine(Indent(3) + "<volume>");  								}  								else  								{  									amfFile.WriteLine(Indent(3) + "<volume materialid=\"{0}\">".FormatWith(material.MaterialIndex));  								}    								double faceCount = (double)mesh.Faces.Count;  								for (int faceIndex = 0; faceIndex < mesh.Faces.Count; faceIndex++)  								{  									if (outputInfo.ReportProgress != null)  									{  										outputInfo.ReportProgress(currentRation + faceIndex / faceCount * ratioPerMesh * .5' ""' out continueProcessing);  									}    									Face face = mesh.Faces[faceIndex];  									List<Vertex> positionsCCW = new List<Vertex>();  									foreach (FaceEdge faceEdge in face.FaceEdges())  									{  										positionsCCW.Add(faceEdge.firstVertex);  									}    									int numPolys = positionsCCW.Count - 2;  									int secondIndex = 1;  									int thirdIndex = 2;  									for (int polyIndex = 0; polyIndex < numPolys; polyIndex++)  									{  										amfFile.WriteLine(Indent(4) + "<triangle>");  										amfFile.WriteLine(Indent(5) + "<v1>{0}</v1>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[0])));  										amfFile.WriteLine(Indent(5) + "<v2>{0}</v2>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[secondIndex])));  										amfFile.WriteLine(Indent(5) + "<v3>{0}</v3>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[thirdIndex])));  										amfFile.WriteLine(Indent(4) + "</triangle>");    										secondIndex = thirdIndex;  										thirdIndex++;  									}  								}    								currentRation += ratioPerMesh * .5;  								amfFile.WriteLine(Indent(3) + "</volume>");  							}  						}  						amfFile.WriteLine(Indent(2) + "</mesh>");  					}  					amfFile.WriteLine(Indent(1) + "</object>");  				}    				HashSet<int> materials = new HashSet<int>();  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						MeshMaterialData material = MeshMaterialData.Get(mesh);  						if (material.MaterialIndex != -1)  						{  							materials.Add(material.MaterialIndex);  						}  					}  				}    				foreach (int material in materials)  				{  					amfFile.WriteLine(Indent(1) + "<material id=\"{0}\">".FormatWith(material));  					amfFile.WriteLine(Indent(2) + "<metadata type=\"Name\">Material {0}</metadata>".FormatWith(material));  					amfFile.WriteLine(Indent(1) + "</material>");  				}  			}
Magic Number,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,Save,The following statement contains a magic number: {  				int objectId = 1;    				bool continueProcessing;    				int totalMeshes = 0;  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						totalMeshes++;  					}  				}    				double ratioPerMesh = 1d / totalMeshes;  				double currentRation = 0;  				for(int meshGroupIndex = 0; meshGroupIndex < meshToSave.Count; meshGroupIndex++)  				{  					MeshGroup meshGroup = meshToSave[meshGroupIndex];  					amfFile.WriteLine(Indent(1) + "<object id=\"{0}\">".FormatWith(objectId++));  					{  						int vertexCount = 0;  						List<int> meshVertexStart = new List<int>();  						amfFile.WriteLine(Indent(2) + "<mesh>");  						{  							amfFile.WriteLine(Indent(3) + "<vertices>");  							{  								for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  								{  									Mesh mesh = meshGroup.Meshes[meshIndex];  									double vertCount = (double)mesh.Vertices.Count;    									meshVertexStart.Add(vertexCount);  									for (int vertexIndex = 0; vertexIndex < mesh.Vertices.Count; vertexIndex++)  									{  										Vertex vertex = mesh.Vertices[vertexIndex];  										if (outputInfo.ReportProgress != null)  										{  											outputInfo.ReportProgress(currentRation + vertexIndex / vertCount * ratioPerMesh * .5' ""' out continueProcessing);  										}    										Vector3 position = vertex.Position;  										amfFile.WriteLine(Indent(4) + "<vertex>");  										{  											amfFile.WriteLine(Indent(5) + "<coordinates>");  											amfFile.WriteLine(Indent(6) + "<x>{0}</x>".FormatWith(position.x));  											amfFile.WriteLine(Indent(6) + "<y>{0}</y>".FormatWith(position.y));  											amfFile.WriteLine(Indent(6) + "<z>{0}</z>".FormatWith(position.z));  											amfFile.WriteLine(Indent(5) + "</coordinates>");  										}  										amfFile.WriteLine(Indent(4) + "</vertex>");  										vertexCount++;  									}  									currentRation += ratioPerMesh * .5;  								}  							}    							amfFile.WriteLine(Indent(3) + "</vertices>");  							for (int meshIndex = 0; meshIndex < meshGroup.Meshes.Count; meshIndex++)  							{  								Mesh mesh = meshGroup.Meshes[meshIndex];  								int firstVertexIndex = meshVertexStart[meshIndex];  								MeshMaterialData material = MeshMaterialData.Get(mesh);  								if (material.MaterialIndex == -1)  								{  									amfFile.WriteLine(Indent(3) + "<volume>");  								}  								else  								{  									amfFile.WriteLine(Indent(3) + "<volume materialid=\"{0}\">".FormatWith(material.MaterialIndex));  								}    								double faceCount = (double)mesh.Faces.Count;  								for (int faceIndex = 0; faceIndex < mesh.Faces.Count; faceIndex++)  								{  									if (outputInfo.ReportProgress != null)  									{  										outputInfo.ReportProgress(currentRation + faceIndex / faceCount * ratioPerMesh * .5' ""' out continueProcessing);  									}    									Face face = mesh.Faces[faceIndex];  									List<Vertex> positionsCCW = new List<Vertex>();  									foreach (FaceEdge faceEdge in face.FaceEdges())  									{  										positionsCCW.Add(faceEdge.firstVertex);  									}    									int numPolys = positionsCCW.Count - 2;  									int secondIndex = 1;  									int thirdIndex = 2;  									for (int polyIndex = 0; polyIndex < numPolys; polyIndex++)  									{  										amfFile.WriteLine(Indent(4) + "<triangle>");  										amfFile.WriteLine(Indent(5) + "<v1>{0}</v1>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[0])));  										amfFile.WriteLine(Indent(5) + "<v2>{0}</v2>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[secondIndex])));  										amfFile.WriteLine(Indent(5) + "<v3>{0}</v3>".FormatWith(firstVertexIndex + mesh.Vertices.IndexOf(positionsCCW[thirdIndex])));  										amfFile.WriteLine(Indent(4) + "</triangle>");    										secondIndex = thirdIndex;  										thirdIndex++;  									}  								}    								currentRation += ratioPerMesh * .5;  								amfFile.WriteLine(Indent(3) + "</volume>");  							}  						}  						amfFile.WriteLine(Indent(2) + "</mesh>");  					}  					amfFile.WriteLine(Indent(1) + "</object>");  				}    				HashSet<int> materials = new HashSet<int>();  				foreach (MeshGroup meshGroup in meshToSave)  				{  					foreach (Mesh mesh in meshGroup.Meshes)  					{  						MeshMaterialData material = MeshMaterialData.Get(mesh);  						if (material.MaterialIndex != -1)  						{  							materials.Add(material.MaterialIndex);  						}  					}  				}    				foreach (int material in materials)  				{  					amfFile.WriteLine(Indent(1) + "<material id=\"{0}\">".FormatWith(material));  					amfFile.WriteLine(Indent(2) + "<metadata type=\"Name\">Material {0}</metadata>".FormatWith(material));  					amfFile.WriteLine(Indent(1) + "</material>");  				}  			}
Magic Number,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,IsZipFile,The following statement contains a magic number: int elements = 4;
Magic Number,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,ParseFileContents,The following statement contains a magic number: double parsingFileRatio = .5;
Magic Number,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,ReadVolume,The following statement contains a magic number: while (xmlTree.Read())  			{  				if (xmlTree.Name == "triangle")  				{  					using (XmlReader triangleTree = xmlTree.ReadSubtree())  					{  						while (triangleTree.Read())  						{  							int[] indices = new int[3];  							while (triangleTree.Read())  							{  								switch (triangleTree.Name)  								{  									case "v1":  										string v1 = triangleTree.ReadString();  										indices[0] = int.Parse(v1);  										break;    									case "v2":  										string v2 = triangleTree.ReadString();  										indices[1] = int.Parse(v2);  										break;    									case "v3":  										string v3 = triangleTree.ReadString();  										indices[2] = int.Parse(v3);  										break;    									case "map":  										using (XmlReader mapTree = triangleTree.ReadSubtree())  										{  										}  										// a texture map' has u1...un and v1...vn  										break;    									default:  										break;  								}  							}  							if (indices[0] != indices[1]  								&& indices[0] != indices[2]  								&& indices[1] != indices[2]  								&& vertices[indices[0]] != vertices[indices[1]]  								&& vertices[indices[1]] != vertices[indices[2]]  								&& vertices[indices[2]] != vertices[indices[0]])  							{  								Vertex[] triangle = new Vertex[]                                  {                                      newMesh.CreateVertex(vertices[indices[0]]' CreateOption.CreateNew' SortOption.WillSortLater)'                                      newMesh.CreateVertex(vertices[indices[1]]' CreateOption.CreateNew' SortOption.WillSortLater)'                                      newMesh.CreateVertex(vertices[indices[2]]' CreateOption.CreateNew' SortOption.WillSortLater)'                                  };  								newMesh.CreateFace(triangle' CreateOption.CreateNew);  							}    							bool continueProcessing;  							progressData.ReportProgress0To50(out continueProcessing);  							if (!continueProcessing)  							{  								// this is what we should do but it requires a bit more debugging.  								return null;  							}  						}  					}  				}  			}
Magic Number,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,ReadVolume,The following statement contains a magic number: while (xmlTree.Read())  			{  				if (xmlTree.Name == "triangle")  				{  					using (XmlReader triangleTree = xmlTree.ReadSubtree())  					{  						while (triangleTree.Read())  						{  							int[] indices = new int[3];  							while (triangleTree.Read())  							{  								switch (triangleTree.Name)  								{  									case "v1":  										string v1 = triangleTree.ReadString();  										indices[0] = int.Parse(v1);  										break;    									case "v2":  										string v2 = triangleTree.ReadString();  										indices[1] = int.Parse(v2);  										break;    									case "v3":  										string v3 = triangleTree.ReadString();  										indices[2] = int.Parse(v3);  										break;    									case "map":  										using (XmlReader mapTree = triangleTree.ReadSubtree())  										{  										}  										// a texture map' has u1...un and v1...vn  										break;    									default:  										break;  								}  							}  							if (indices[0] != indices[1]  								&& indices[0] != indices[2]  								&& indices[1] != indices[2]  								&& vertices[indices[0]] != vertices[indices[1]]  								&& vertices[indices[1]] != vertices[indices[2]]  								&& vertices[indices[2]] != vertices[indices[0]])  							{  								Vertex[] triangle = new Vertex[]                                  {                                      newMesh.CreateVertex(vertices[indices[0]]' CreateOption.CreateNew' SortOption.WillSortLater)'                                      newMesh.CreateVertex(vertices[indices[1]]' CreateOption.CreateNew' SortOption.WillSortLater)'                                      newMesh.CreateVertex(vertices[indices[2]]' CreateOption.CreateNew' SortOption.WillSortLater)'                                  };  								newMesh.CreateFace(triangle' CreateOption.CreateNew);  							}    							bool continueProcessing;  							progressData.ReportProgress0To50(out continueProcessing);  							if (!continueProcessing)  							{  								// this is what we should do but it requires a bit more debugging.  								return null;  							}  						}  					}  				}  			}
Magic Number,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,ReadVolume,The following statement contains a magic number: while (xmlTree.Read())  			{  				if (xmlTree.Name == "triangle")  				{  					using (XmlReader triangleTree = xmlTree.ReadSubtree())  					{  						while (triangleTree.Read())  						{  							int[] indices = new int[3];  							while (triangleTree.Read())  							{  								switch (triangleTree.Name)  								{  									case "v1":  										string v1 = triangleTree.ReadString();  										indices[0] = int.Parse(v1);  										break;    									case "v2":  										string v2 = triangleTree.ReadString();  										indices[1] = int.Parse(v2);  										break;    									case "v3":  										string v3 = triangleTree.ReadString();  										indices[2] = int.Parse(v3);  										break;    									case "map":  										using (XmlReader mapTree = triangleTree.ReadSubtree())  										{  										}  										// a texture map' has u1...un and v1...vn  										break;    									default:  										break;  								}  							}  							if (indices[0] != indices[1]  								&& indices[0] != indices[2]  								&& indices[1] != indices[2]  								&& vertices[indices[0]] != vertices[indices[1]]  								&& vertices[indices[1]] != vertices[indices[2]]  								&& vertices[indices[2]] != vertices[indices[0]])  							{  								Vertex[] triangle = new Vertex[]                                  {                                      newMesh.CreateVertex(vertices[indices[0]]' CreateOption.CreateNew' SortOption.WillSortLater)'                                      newMesh.CreateVertex(vertices[indices[1]]' CreateOption.CreateNew' SortOption.WillSortLater)'                                      newMesh.CreateVertex(vertices[indices[2]]' CreateOption.CreateNew' SortOption.WillSortLater)'                                  };  								newMesh.CreateFace(triangle' CreateOption.CreateNew);  							}    							bool continueProcessing;  							progressData.ReportProgress0To50(out continueProcessing);  							if (!continueProcessing)  							{  								// this is what we should do but it requires a bit more debugging.  								return null;  							}  						}  					}  				}  			}
Magic Number,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,ReadVolume,The following statement contains a magic number: while (xmlTree.Read())  			{  				if (xmlTree.Name == "triangle")  				{  					using (XmlReader triangleTree = xmlTree.ReadSubtree())  					{  						while (triangleTree.Read())  						{  							int[] indices = new int[3];  							while (triangleTree.Read())  							{  								switch (triangleTree.Name)  								{  									case "v1":  										string v1 = triangleTree.ReadString();  										indices[0] = int.Parse(v1);  										break;    									case "v2":  										string v2 = triangleTree.ReadString();  										indices[1] = int.Parse(v2);  										break;    									case "v3":  										string v3 = triangleTree.ReadString();  										indices[2] = int.Parse(v3);  										break;    									case "map":  										using (XmlReader mapTree = triangleTree.ReadSubtree())  										{  										}  										// a texture map' has u1...un and v1...vn  										break;    									default:  										break;  								}  							}  							if (indices[0] != indices[1]  								&& indices[0] != indices[2]  								&& indices[1] != indices[2]  								&& vertices[indices[0]] != vertices[indices[1]]  								&& vertices[indices[1]] != vertices[indices[2]]  								&& vertices[indices[2]] != vertices[indices[0]])  							{  								Vertex[] triangle = new Vertex[]                                  {                                      newMesh.CreateVertex(vertices[indices[0]]' CreateOption.CreateNew' SortOption.WillSortLater)'                                      newMesh.CreateVertex(vertices[indices[1]]' CreateOption.CreateNew' SortOption.WillSortLater)'                                      newMesh.CreateVertex(vertices[indices[2]]' CreateOption.CreateNew' SortOption.WillSortLater)'                                  };  								newMesh.CreateFace(triangle' CreateOption.CreateNew);  							}    							bool continueProcessing;  							progressData.ReportProgress0To50(out continueProcessing);  							if (!continueProcessing)  							{  								// this is what we should do but it requires a bit more debugging.  								return null;  							}  						}  					}  				}  			}
Magic Number,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,ReadVolume,The following statement contains a magic number: while (xmlTree.Read())  			{  				if (xmlTree.Name == "triangle")  				{  					using (XmlReader triangleTree = xmlTree.ReadSubtree())  					{  						while (triangleTree.Read())  						{  							int[] indices = new int[3];  							while (triangleTree.Read())  							{  								switch (triangleTree.Name)  								{  									case "v1":  										string v1 = triangleTree.ReadString();  										indices[0] = int.Parse(v1);  										break;    									case "v2":  										string v2 = triangleTree.ReadString();  										indices[1] = int.Parse(v2);  										break;    									case "v3":  										string v3 = triangleTree.ReadString();  										indices[2] = int.Parse(v3);  										break;    									case "map":  										using (XmlReader mapTree = triangleTree.ReadSubtree())  										{  										}  										// a texture map' has u1...un and v1...vn  										break;    									default:  										break;  								}  							}  							if (indices[0] != indices[1]  								&& indices[0] != indices[2]  								&& indices[1] != indices[2]  								&& vertices[indices[0]] != vertices[indices[1]]  								&& vertices[indices[1]] != vertices[indices[2]]  								&& vertices[indices[2]] != vertices[indices[0]])  							{  								Vertex[] triangle = new Vertex[]                                  {                                      newMesh.CreateVertex(vertices[indices[0]]' CreateOption.CreateNew' SortOption.WillSortLater)'                                      newMesh.CreateVertex(vertices[indices[1]]' CreateOption.CreateNew' SortOption.WillSortLater)'                                      newMesh.CreateVertex(vertices[indices[2]]' CreateOption.CreateNew' SortOption.WillSortLater)'                                  };  								newMesh.CreateFace(triangle' CreateOption.CreateNew);  							}    							bool continueProcessing;  							progressData.ReportProgress0To50(out continueProcessing);  							if (!continueProcessing)  							{  								// this is what we should do but it requires a bit more debugging.  								return null;  							}  						}  					}  				}  			}
Magic Number,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,ReadVolume,The following statement contains a magic number: while (xmlTree.Read())  			{  				if (xmlTree.Name == "triangle")  				{  					using (XmlReader triangleTree = xmlTree.ReadSubtree())  					{  						while (triangleTree.Read())  						{  							int[] indices = new int[3];  							while (triangleTree.Read())  							{  								switch (triangleTree.Name)  								{  									case "v1":  										string v1 = triangleTree.ReadString();  										indices[0] = int.Parse(v1);  										break;    									case "v2":  										string v2 = triangleTree.ReadString();  										indices[1] = int.Parse(v2);  										break;    									case "v3":  										string v3 = triangleTree.ReadString();  										indices[2] = int.Parse(v3);  										break;    									case "map":  										using (XmlReader mapTree = triangleTree.ReadSubtree())  										{  										}  										// a texture map' has u1...un and v1...vn  										break;    									default:  										break;  								}  							}  							if (indices[0] != indices[1]  								&& indices[0] != indices[2]  								&& indices[1] != indices[2]  								&& vertices[indices[0]] != vertices[indices[1]]  								&& vertices[indices[1]] != vertices[indices[2]]  								&& vertices[indices[2]] != vertices[indices[0]])  							{  								Vertex[] triangle = new Vertex[]                                  {                                      newMesh.CreateVertex(vertices[indices[0]]' CreateOption.CreateNew' SortOption.WillSortLater)'                                      newMesh.CreateVertex(vertices[indices[1]]' CreateOption.CreateNew' SortOption.WillSortLater)'                                      newMesh.CreateVertex(vertices[indices[2]]' CreateOption.CreateNew' SortOption.WillSortLater)'                                  };  								newMesh.CreateFace(triangle' CreateOption.CreateNew);  							}    							bool continueProcessing;  							progressData.ReportProgress0To50(out continueProcessing);  							if (!continueProcessing)  							{  								// this is what we should do but it requires a bit more debugging.  								return null;  							}  						}  					}  				}  			}
Magic Number,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,ReadVolume,The following statement contains a magic number: while (xmlTree.Read())  			{  				if (xmlTree.Name == "triangle")  				{  					using (XmlReader triangleTree = xmlTree.ReadSubtree())  					{  						while (triangleTree.Read())  						{  							int[] indices = new int[3];  							while (triangleTree.Read())  							{  								switch (triangleTree.Name)  								{  									case "v1":  										string v1 = triangleTree.ReadString();  										indices[0] = int.Parse(v1);  										break;    									case "v2":  										string v2 = triangleTree.ReadString();  										indices[1] = int.Parse(v2);  										break;    									case "v3":  										string v3 = triangleTree.ReadString();  										indices[2] = int.Parse(v3);  										break;    									case "map":  										using (XmlReader mapTree = triangleTree.ReadSubtree())  										{  										}  										// a texture map' has u1...un and v1...vn  										break;    									default:  										break;  								}  							}  							if (indices[0] != indices[1]  								&& indices[0] != indices[2]  								&& indices[1] != indices[2]  								&& vertices[indices[0]] != vertices[indices[1]]  								&& vertices[indices[1]] != vertices[indices[2]]  								&& vertices[indices[2]] != vertices[indices[0]])  							{  								Vertex[] triangle = new Vertex[]                                  {                                      newMesh.CreateVertex(vertices[indices[0]]' CreateOption.CreateNew' SortOption.WillSortLater)'                                      newMesh.CreateVertex(vertices[indices[1]]' CreateOption.CreateNew' SortOption.WillSortLater)'                                      newMesh.CreateVertex(vertices[indices[2]]' CreateOption.CreateNew' SortOption.WillSortLater)'                                  };  								newMesh.CreateFace(triangle' CreateOption.CreateNew);  							}    							bool continueProcessing;  							progressData.ReportProgress0To50(out continueProcessing);  							if (!continueProcessing)  							{  								// this is what we should do but it requires a bit more debugging.  								return null;  							}  						}  					}  				}  			}
Magic Number,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,GetScaling,The following statement contains a magic number: switch (units.ToLower())  			{  				case "millimeter":  					return 1;    				case "centimeter":  					return 10;    				case "meter":  					return 1000;    				case "inch":  					return 25.4;    				case "feet":  					return 304.8;    				case "micron":  					return 0.001;    				default:  #if DEBUG  					throw new NotImplementedException();  #else                  return 1;  #endif  			}
Magic Number,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,GetScaling,The following statement contains a magic number: switch (units.ToLower())  			{  				case "millimeter":  					return 1;    				case "centimeter":  					return 10;    				case "meter":  					return 1000;    				case "inch":  					return 25.4;    				case "feet":  					return 304.8;    				case "micron":  					return 0.001;    				default:  #if DEBUG  					throw new NotImplementedException();  #else                  return 1;  #endif  			}
Magic Number,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,GetScaling,The following statement contains a magic number: switch (units.ToLower())  			{  				case "millimeter":  					return 1;    				case "centimeter":  					return 10;    				case "meter":  					return 1000;    				case "inch":  					return 25.4;    				case "feet":  					return 304.8;    				case "micron":  					return 0.001;    				default:  #if DEBUG  					throw new NotImplementedException();  #else                  return 1;  #endif  			}
Magic Number,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,GetScaling,The following statement contains a magic number: switch (units.ToLower())  			{  				case "millimeter":  					return 1;    				case "centimeter":  					return 10;    				case "meter":  					return 1000;    				case "inch":  					return 25.4;    				case "feet":  					return 304.8;    				case "micron":  					return 0.001;    				default:  #if DEBUG  					throw new NotImplementedException();  #else                  return 1;  #endif  			}
Magic Number,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,GetScaling,The following statement contains a magic number: switch (units.ToLower())  			{  				case "millimeter":  					return 1;    				case "centimeter":  					return 10;    				case "meter":  					return 1000;    				case "inch":  					return 25.4;    				case "feet":  					return 304.8;    				case "micron":  					return 0.001;    				default:  #if DEBUG  					throw new NotImplementedException();  #else                  return 1;  #endif  			}
Magic Number,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,GetEstimatedMemoryUse,The following statement contains a magic number: try  			{  				using (Stream stream = new FileStream(fileLocation' FileMode.Open' FileAccess.Read' FileShare.Read))  				{  					if (IsZipFile(stream))  					{  						return (long)(stream.Length * 57);  					}  					else  					{  						return (long)(stream.Length * 3.7);  					}  				}  			}  			catch (Exception e)  			{  				Debug.Print(e.Message);  				BreakInDebugger();  				return 0;  			}
Magic Number,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,GetEstimatedMemoryUse,The following statement contains a magic number: try  			{  				using (Stream stream = new FileStream(fileLocation' FileMode.Open' FileAccess.Read' FileShare.Read))  				{  					if (IsZipFile(stream))  					{  						return (long)(stream.Length * 57);  					}  					else  					{  						return (long)(stream.Length * 3.7);  					}  				}  			}  			catch (Exception e)  			{  				Debug.Print(e.Message);  				BreakInDebugger();  				return 0;  			}
Magic Number,MatterHackers.PolygonMesh.Processors,ProgressData,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,ReportProgress0To50,The following statement contains a magic number: if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  				{  					reportProgress(positionStream.Position / (double)bytesInFile * .5' "Loading Mesh"' out continueProcessing);  					if (!continueProcessing)  					{  						loadCanceled = true;  					}  					maxProgressReport.Restart();  				}  				else  				{  					continueProcessing = true;  				}
Magic Number,MatterHackers.PolygonMesh.Processors,ProgressData,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,ReportProgress0To50,The following statement contains a magic number: if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  				{  					reportProgress(positionStream.Position / (double)bytesInFile * .5' "Loading Mesh"' out continueProcessing);  					if (!continueProcessing)  					{  						loadCanceled = true;  					}  					maxProgressReport.Restart();  				}  				else  				{  					continueProcessing = true;  				}
Magic Number,MatterHackers.PolygonMesh.Processors,MeshOutputSettings,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\MeshFileIo.cs,MeshOutputSettings,The following statement contains a magic number: if (metaDataKeyValuePairs != null)  			{  				for (int i = 0; i < metaDataKeyValuePairs.Length / 2; i++)  				{  					MetaDataKeyValue.Add(metaDataKeyValuePairs[i * 2]' metaDataKeyValuePairs[i * 2 + 1]);  				}  			}
Magic Number,MatterHackers.PolygonMesh.Processors,MeshOutputSettings,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\MeshFileIo.cs,MeshOutputSettings,The following statement contains a magic number: if (metaDataKeyValuePairs != null)  			{  				for (int i = 0; i < metaDataKeyValuePairs.Length / 2; i++)  				{  					MetaDataKeyValue.Add(metaDataKeyValuePairs[i * 2]' metaDataKeyValuePairs[i * 2 + 1]);  				}  			}
Magic Number,MatterHackers.PolygonMesh.Processors,MeshOutputSettings,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\MeshFileIo.cs,MeshOutputSettings,The following statement contains a magic number: if (metaDataKeyValuePairs != null)  			{  				for (int i = 0; i < metaDataKeyValuePairs.Length / 2; i++)  				{  					MetaDataKeyValue.Add(metaDataKeyValuePairs[i * 2]' metaDataKeyValuePairs[i * 2 + 1]);  				}  			}
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,Save,The following statement contains a magic number: switch (outputInfo.OutputTypeSetting)  			{  				case MeshOutputSettings.OutputType.Ascii:  					{  						StreamWriter streamWriter = new StreamWriter(stream);    						streamWriter.WriteLine("solid Default");    						foreach (Face face in meshToSave.Faces)  						{  							List<Vector3> positionsCCW = new List<Vector3>();  							foreach (FaceEdge faceEdge in face.FaceEdges())  							{  								positionsCCW.Add(faceEdge.firstVertex.Position);  							}    							int numPolys = positionsCCW.Count - 2;  							int secondIndex = 1;  							int thirdIndex = 2;  							for (int polyIndex = 0; polyIndex < numPolys; polyIndex++)  							{  								streamWriter.WriteLine("  facet normal " + FormatForStl(face.normal));  								streamWriter.WriteLine("    outer loop");  								streamWriter.WriteLine("      vertex " + FormatForStl(positionsCCW[0]));  								streamWriter.WriteLine("      vertex " + FormatForStl(positionsCCW[secondIndex]));  								streamWriter.WriteLine("      vertex " + FormatForStl(positionsCCW[thirdIndex]));  								streamWriter.WriteLine("    endloop");  								streamWriter.WriteLine("  endfacet");    								secondIndex = thirdIndex;  								thirdIndex++;  							}  						}    						streamWriter.WriteLine("endsolid Default");    						streamWriter.Close();  					}  					break;    				case MeshOutputSettings.OutputType.Binary:  					using (BinaryWriter bw = new BinaryWriter(stream))  					{  						// 80 bytes of nothing  						bw.Write(new Byte[80]);  						// the number of tranigles  						bw.Write(meshToSave.Faces.Count);  						int binaryPolyCount = 0;  						foreach (Face face in meshToSave.Faces)  						{  							List<Vector3> positionsCCW = new List<Vector3>();  							foreach (FaceEdge faceEdge in face.FaceEdges())  							{  								positionsCCW.Add(faceEdge.firstVertex.Position);  							}    							int numPolys = positionsCCW.Count - 2;  							int secondIndex = 1;  							int thirdIndex = 2;  							for (int polyIndex = 0; polyIndex < numPolys; polyIndex++)  							{  								binaryPolyCount++;  								// save the normal (all 0 so it can compress better)  								bw.Write((float)0);  								bw.Write((float)0);  								bw.Write((float)0);  								// save the position  								bw.Write((float)positionsCCW[0].x); bw.Write((float)positionsCCW[0].y); bw.Write((float)positionsCCW[0].z);  								bw.Write((float)positionsCCW[secondIndex].x); bw.Write((float)positionsCCW[secondIndex].y); bw.Write((float)positionsCCW[secondIndex].z);  								bw.Write((float)positionsCCW[thirdIndex].x); bw.Write((float)positionsCCW[thirdIndex].y); bw.Write((float)positionsCCW[thirdIndex].z);    								// and the attribute  								bw.Write((ushort)0);    								secondIndex = thirdIndex;  								thirdIndex++;  							}  						}  						bw.BaseStream.Position = 80;  						// the number of tranigles  						bw.Write(binaryPolyCount);  					}  					break;  			}
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,Save,The following statement contains a magic number: switch (outputInfo.OutputTypeSetting)  			{  				case MeshOutputSettings.OutputType.Ascii:  					{  						StreamWriter streamWriter = new StreamWriter(stream);    						streamWriter.WriteLine("solid Default");    						foreach (Face face in meshToSave.Faces)  						{  							List<Vector3> positionsCCW = new List<Vector3>();  							foreach (FaceEdge faceEdge in face.FaceEdges())  							{  								positionsCCW.Add(faceEdge.firstVertex.Position);  							}    							int numPolys = positionsCCW.Count - 2;  							int secondIndex = 1;  							int thirdIndex = 2;  							for (int polyIndex = 0; polyIndex < numPolys; polyIndex++)  							{  								streamWriter.WriteLine("  facet normal " + FormatForStl(face.normal));  								streamWriter.WriteLine("    outer loop");  								streamWriter.WriteLine("      vertex " + FormatForStl(positionsCCW[0]));  								streamWriter.WriteLine("      vertex " + FormatForStl(positionsCCW[secondIndex]));  								streamWriter.WriteLine("      vertex " + FormatForStl(positionsCCW[thirdIndex]));  								streamWriter.WriteLine("    endloop");  								streamWriter.WriteLine("  endfacet");    								secondIndex = thirdIndex;  								thirdIndex++;  							}  						}    						streamWriter.WriteLine("endsolid Default");    						streamWriter.Close();  					}  					break;    				case MeshOutputSettings.OutputType.Binary:  					using (BinaryWriter bw = new BinaryWriter(stream))  					{  						// 80 bytes of nothing  						bw.Write(new Byte[80]);  						// the number of tranigles  						bw.Write(meshToSave.Faces.Count);  						int binaryPolyCount = 0;  						foreach (Face face in meshToSave.Faces)  						{  							List<Vector3> positionsCCW = new List<Vector3>();  							foreach (FaceEdge faceEdge in face.FaceEdges())  							{  								positionsCCW.Add(faceEdge.firstVertex.Position);  							}    							int numPolys = positionsCCW.Count - 2;  							int secondIndex = 1;  							int thirdIndex = 2;  							for (int polyIndex = 0; polyIndex < numPolys; polyIndex++)  							{  								binaryPolyCount++;  								// save the normal (all 0 so it can compress better)  								bw.Write((float)0);  								bw.Write((float)0);  								bw.Write((float)0);  								// save the position  								bw.Write((float)positionsCCW[0].x); bw.Write((float)positionsCCW[0].y); bw.Write((float)positionsCCW[0].z);  								bw.Write((float)positionsCCW[secondIndex].x); bw.Write((float)positionsCCW[secondIndex].y); bw.Write((float)positionsCCW[secondIndex].z);  								bw.Write((float)positionsCCW[thirdIndex].x); bw.Write((float)positionsCCW[thirdIndex].y); bw.Write((float)positionsCCW[thirdIndex].z);    								// and the attribute  								bw.Write((ushort)0);    								secondIndex = thirdIndex;  								thirdIndex++;  							}  						}  						bw.BaseStream.Position = 80;  						// the number of tranigles  						bw.Write(binaryPolyCount);  					}  					break;  			}
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,Save,The following statement contains a magic number: switch (outputInfo.OutputTypeSetting)  			{  				case MeshOutputSettings.OutputType.Ascii:  					{  						StreamWriter streamWriter = new StreamWriter(stream);    						streamWriter.WriteLine("solid Default");    						foreach (Face face in meshToSave.Faces)  						{  							List<Vector3> positionsCCW = new List<Vector3>();  							foreach (FaceEdge faceEdge in face.FaceEdges())  							{  								positionsCCW.Add(faceEdge.firstVertex.Position);  							}    							int numPolys = positionsCCW.Count - 2;  							int secondIndex = 1;  							int thirdIndex = 2;  							for (int polyIndex = 0; polyIndex < numPolys; polyIndex++)  							{  								streamWriter.WriteLine("  facet normal " + FormatForStl(face.normal));  								streamWriter.WriteLine("    outer loop");  								streamWriter.WriteLine("      vertex " + FormatForStl(positionsCCW[0]));  								streamWriter.WriteLine("      vertex " + FormatForStl(positionsCCW[secondIndex]));  								streamWriter.WriteLine("      vertex " + FormatForStl(positionsCCW[thirdIndex]));  								streamWriter.WriteLine("    endloop");  								streamWriter.WriteLine("  endfacet");    								secondIndex = thirdIndex;  								thirdIndex++;  							}  						}    						streamWriter.WriteLine("endsolid Default");    						streamWriter.Close();  					}  					break;    				case MeshOutputSettings.OutputType.Binary:  					using (BinaryWriter bw = new BinaryWriter(stream))  					{  						// 80 bytes of nothing  						bw.Write(new Byte[80]);  						// the number of tranigles  						bw.Write(meshToSave.Faces.Count);  						int binaryPolyCount = 0;  						foreach (Face face in meshToSave.Faces)  						{  							List<Vector3> positionsCCW = new List<Vector3>();  							foreach (FaceEdge faceEdge in face.FaceEdges())  							{  								positionsCCW.Add(faceEdge.firstVertex.Position);  							}    							int numPolys = positionsCCW.Count - 2;  							int secondIndex = 1;  							int thirdIndex = 2;  							for (int polyIndex = 0; polyIndex < numPolys; polyIndex++)  							{  								binaryPolyCount++;  								// save the normal (all 0 so it can compress better)  								bw.Write((float)0);  								bw.Write((float)0);  								bw.Write((float)0);  								// save the position  								bw.Write((float)positionsCCW[0].x); bw.Write((float)positionsCCW[0].y); bw.Write((float)positionsCCW[0].z);  								bw.Write((float)positionsCCW[secondIndex].x); bw.Write((float)positionsCCW[secondIndex].y); bw.Write((float)positionsCCW[secondIndex].z);  								bw.Write((float)positionsCCW[thirdIndex].x); bw.Write((float)positionsCCW[thirdIndex].y); bw.Write((float)positionsCCW[thirdIndex].z);    								// and the attribute  								bw.Write((ushort)0);    								secondIndex = thirdIndex;  								thirdIndex++;  							}  						}  						bw.BaseStream.Position = 80;  						// the number of tranigles  						bw.Write(binaryPolyCount);  					}  					break;  			}
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,Save,The following statement contains a magic number: switch (outputInfo.OutputTypeSetting)  			{  				case MeshOutputSettings.OutputType.Ascii:  					{  						StreamWriter streamWriter = new StreamWriter(stream);    						streamWriter.WriteLine("solid Default");    						foreach (Face face in meshToSave.Faces)  						{  							List<Vector3> positionsCCW = new List<Vector3>();  							foreach (FaceEdge faceEdge in face.FaceEdges())  							{  								positionsCCW.Add(faceEdge.firstVertex.Position);  							}    							int numPolys = positionsCCW.Count - 2;  							int secondIndex = 1;  							int thirdIndex = 2;  							for (int polyIndex = 0; polyIndex < numPolys; polyIndex++)  							{  								streamWriter.WriteLine("  facet normal " + FormatForStl(face.normal));  								streamWriter.WriteLine("    outer loop");  								streamWriter.WriteLine("      vertex " + FormatForStl(positionsCCW[0]));  								streamWriter.WriteLine("      vertex " + FormatForStl(positionsCCW[secondIndex]));  								streamWriter.WriteLine("      vertex " + FormatForStl(positionsCCW[thirdIndex]));  								streamWriter.WriteLine("    endloop");  								streamWriter.WriteLine("  endfacet");    								secondIndex = thirdIndex;  								thirdIndex++;  							}  						}    						streamWriter.WriteLine("endsolid Default");    						streamWriter.Close();  					}  					break;    				case MeshOutputSettings.OutputType.Binary:  					using (BinaryWriter bw = new BinaryWriter(stream))  					{  						// 80 bytes of nothing  						bw.Write(new Byte[80]);  						// the number of tranigles  						bw.Write(meshToSave.Faces.Count);  						int binaryPolyCount = 0;  						foreach (Face face in meshToSave.Faces)  						{  							List<Vector3> positionsCCW = new List<Vector3>();  							foreach (FaceEdge faceEdge in face.FaceEdges())  							{  								positionsCCW.Add(faceEdge.firstVertex.Position);  							}    							int numPolys = positionsCCW.Count - 2;  							int secondIndex = 1;  							int thirdIndex = 2;  							for (int polyIndex = 0; polyIndex < numPolys; polyIndex++)  							{  								binaryPolyCount++;  								// save the normal (all 0 so it can compress better)  								bw.Write((float)0);  								bw.Write((float)0);  								bw.Write((float)0);  								// save the position  								bw.Write((float)positionsCCW[0].x); bw.Write((float)positionsCCW[0].y); bw.Write((float)positionsCCW[0].z);  								bw.Write((float)positionsCCW[secondIndex].x); bw.Write((float)positionsCCW[secondIndex].y); bw.Write((float)positionsCCW[secondIndex].z);  								bw.Write((float)positionsCCW[thirdIndex].x); bw.Write((float)positionsCCW[thirdIndex].y); bw.Write((float)positionsCCW[thirdIndex].z);    								// and the attribute  								bw.Write((ushort)0);    								secondIndex = thirdIndex;  								thirdIndex++;  							}  						}  						bw.BaseStream.Position = 80;  						// the number of tranigles  						bw.Write(binaryPolyCount);  					}  					break;  			}
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,Save,The following statement contains a magic number: switch (outputInfo.OutputTypeSetting)  			{  				case MeshOutputSettings.OutputType.Ascii:  					{  						StreamWriter streamWriter = new StreamWriter(stream);    						streamWriter.WriteLine("solid Default");    						foreach (Face face in meshToSave.Faces)  						{  							List<Vector3> positionsCCW = new List<Vector3>();  							foreach (FaceEdge faceEdge in face.FaceEdges())  							{  								positionsCCW.Add(faceEdge.firstVertex.Position);  							}    							int numPolys = positionsCCW.Count - 2;  							int secondIndex = 1;  							int thirdIndex = 2;  							for (int polyIndex = 0; polyIndex < numPolys; polyIndex++)  							{  								streamWriter.WriteLine("  facet normal " + FormatForStl(face.normal));  								streamWriter.WriteLine("    outer loop");  								streamWriter.WriteLine("      vertex " + FormatForStl(positionsCCW[0]));  								streamWriter.WriteLine("      vertex " + FormatForStl(positionsCCW[secondIndex]));  								streamWriter.WriteLine("      vertex " + FormatForStl(positionsCCW[thirdIndex]));  								streamWriter.WriteLine("    endloop");  								streamWriter.WriteLine("  endfacet");    								secondIndex = thirdIndex;  								thirdIndex++;  							}  						}    						streamWriter.WriteLine("endsolid Default");    						streamWriter.Close();  					}  					break;    				case MeshOutputSettings.OutputType.Binary:  					using (BinaryWriter bw = new BinaryWriter(stream))  					{  						// 80 bytes of nothing  						bw.Write(new Byte[80]);  						// the number of tranigles  						bw.Write(meshToSave.Faces.Count);  						int binaryPolyCount = 0;  						foreach (Face face in meshToSave.Faces)  						{  							List<Vector3> positionsCCW = new List<Vector3>();  							foreach (FaceEdge faceEdge in face.FaceEdges())  							{  								positionsCCW.Add(faceEdge.firstVertex.Position);  							}    							int numPolys = positionsCCW.Count - 2;  							int secondIndex = 1;  							int thirdIndex = 2;  							for (int polyIndex = 0; polyIndex < numPolys; polyIndex++)  							{  								binaryPolyCount++;  								// save the normal (all 0 so it can compress better)  								bw.Write((float)0);  								bw.Write((float)0);  								bw.Write((float)0);  								// save the position  								bw.Write((float)positionsCCW[0].x); bw.Write((float)positionsCCW[0].y); bw.Write((float)positionsCCW[0].z);  								bw.Write((float)positionsCCW[secondIndex].x); bw.Write((float)positionsCCW[secondIndex].y); bw.Write((float)positionsCCW[secondIndex].z);  								bw.Write((float)positionsCCW[thirdIndex].x); bw.Write((float)positionsCCW[thirdIndex].y); bw.Write((float)positionsCCW[thirdIndex].z);    								// and the attribute  								bw.Write((ushort)0);    								secondIndex = thirdIndex;  								thirdIndex++;  							}  						}  						bw.BaseStream.Position = 80;  						// the number of tranigles  						bw.Write(binaryPolyCount);  					}  					break;  			}
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,Save,The following statement contains a magic number: switch (outputInfo.OutputTypeSetting)  			{  				case MeshOutputSettings.OutputType.Ascii:  					{  						StreamWriter streamWriter = new StreamWriter(stream);    						streamWriter.WriteLine("solid Default");    						foreach (Face face in meshToSave.Faces)  						{  							List<Vector3> positionsCCW = new List<Vector3>();  							foreach (FaceEdge faceEdge in face.FaceEdges())  							{  								positionsCCW.Add(faceEdge.firstVertex.Position);  							}    							int numPolys = positionsCCW.Count - 2;  							int secondIndex = 1;  							int thirdIndex = 2;  							for (int polyIndex = 0; polyIndex < numPolys; polyIndex++)  							{  								streamWriter.WriteLine("  facet normal " + FormatForStl(face.normal));  								streamWriter.WriteLine("    outer loop");  								streamWriter.WriteLine("      vertex " + FormatForStl(positionsCCW[0]));  								streamWriter.WriteLine("      vertex " + FormatForStl(positionsCCW[secondIndex]));  								streamWriter.WriteLine("      vertex " + FormatForStl(positionsCCW[thirdIndex]));  								streamWriter.WriteLine("    endloop");  								streamWriter.WriteLine("  endfacet");    								secondIndex = thirdIndex;  								thirdIndex++;  							}  						}    						streamWriter.WriteLine("endsolid Default");    						streamWriter.Close();  					}  					break;    				case MeshOutputSettings.OutputType.Binary:  					using (BinaryWriter bw = new BinaryWriter(stream))  					{  						// 80 bytes of nothing  						bw.Write(new Byte[80]);  						// the number of tranigles  						bw.Write(meshToSave.Faces.Count);  						int binaryPolyCount = 0;  						foreach (Face face in meshToSave.Faces)  						{  							List<Vector3> positionsCCW = new List<Vector3>();  							foreach (FaceEdge faceEdge in face.FaceEdges())  							{  								positionsCCW.Add(faceEdge.firstVertex.Position);  							}    							int numPolys = positionsCCW.Count - 2;  							int secondIndex = 1;  							int thirdIndex = 2;  							for (int polyIndex = 0; polyIndex < numPolys; polyIndex++)  							{  								binaryPolyCount++;  								// save the normal (all 0 so it can compress better)  								bw.Write((float)0);  								bw.Write((float)0);  								bw.Write((float)0);  								// save the position  								bw.Write((float)positionsCCW[0].x); bw.Write((float)positionsCCW[0].y); bw.Write((float)positionsCCW[0].z);  								bw.Write((float)positionsCCW[secondIndex].x); bw.Write((float)positionsCCW[secondIndex].y); bw.Write((float)positionsCCW[secondIndex].z);  								bw.Write((float)positionsCCW[thirdIndex].x); bw.Write((float)positionsCCW[thirdIndex].y); bw.Write((float)positionsCCW[thirdIndex].z);    								// and the attribute  								bw.Write((ushort)0);    								secondIndex = thirdIndex;  								thirdIndex++;  							}  						}  						bw.BaseStream.Position = 80;  						// the number of tranigles  						bw.Write(binaryPolyCount);  					}  					break;  			}
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseFileContents,The following statement contains a magic number: double parsingFileRatio = .5;
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseFileContents,The following statement contains a magic number: if (bytesInFile <= 80)  			{  				return null;  			}
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseFileContents,The following statement contains a magic number: byte[] first160Bytes = new byte[160];
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseFileContents,The following statement contains a magic number: stlStream.Read(first160Bytes' 0' 160);
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseFileContents,The following statement contains a magic number: if (first160Bytes[0] == ByteOredrMark[0] && first160Bytes[0] == ByteOredrMark[0] && first160Bytes[0] == ByteOredrMark[0])  			{  				startOfString = 3;  			}
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseFileContents,The following statement contains a magic number: if (first160BytesOfSTLFile.StartsWith("solid") && first160BytesOfSTLFile.Contains("facet"))  			{  				stlStream.Position = 0;  				StreamReader stlReader = new StreamReader(stlStream);  				int vectorIndex = 0;  				Vector3 vector0 = new Vector3(0' 0' 0);  				Vector3 vector1 = new Vector3(0' 0' 0);  				Vector3 vector2 = new Vector3(0' 0' 0);  				string line = stlReader.ReadLine();    				while (line != null)  				{  					line = line.Trim();  					if (line.StartsWith("vertex"))  					{  						vectorIndex++;  						switch (vectorIndex)  						{  							case 1:  								vector0 = Convert(line);  								break;    							case 2:  								vector1 = Convert(line);  								break;    							case 3:  								vector2 = Convert(line);  								if (!Vector3.Collinear(vector0' vector1' vector2))  								{  									Vertex vertex1 = meshFromStlFile.CreateVertex(vector0' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex2 = meshFromStlFile.CreateVertex(vector1' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex3 = meshFromStlFile.CreateVertex(vector2' CreateOption.CreateNew' SortOption.WillSortLater);  									meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  								}  								vectorIndex = 0;  								break;  						}  					}  					line = stlReader.ReadLine();    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(stlStream.Position / (double)bytesInFile * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}  				}  			}  			else  			{  				// load it as a binary stl  				// skip the first 80 bytes  				// read in the number of triangles  				stlStream.Position = 0;  				BinaryReader br = new BinaryReader(stlStream);  				byte[] fileContents = br.ReadBytes((int)stlStream.Length);  				int currentPosition = 80;  				uint numTriangles = System.BitConverter.ToUInt32(fileContents' currentPosition);  				long bytesForNormals = numTriangles * 3 * 4;  				long bytesForVertices = numTriangles * 3 * 4 * 3;  				long bytesForAttributs = numTriangles * 2;  				currentPosition += 4;  				long numBytesRequiredForVertexData = currentPosition + bytesForNormals + bytesForVertices + bytesForAttributs;  				if (fileContents.Length < numBytesRequiredForVertexData || numTriangles < 4)  				{  					stlStream.Close();  					return null;  				}  				Vector3[] vector = new Vector3[3];  				for (int i = 0; i < numTriangles; i++)  				{  					// skip the normal  					currentPosition += 3 * 4;  					for (int j = 0; j < 3; j++)  					{  						vector[j] = new Vector3(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4));  						currentPosition += 3 * 4;  					}  					currentPosition += 2; // skip the attribute    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(i / (double)numTriangles * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}    					if (!Vector3.Collinear(vector[0]' vector[1]' vector[2]))  					{  						Vertex vertex1 = meshFromStlFile.CreateVertex(vector[0]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex2 = meshFromStlFile.CreateVertex(vector[1]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex3 = meshFromStlFile.CreateVertex(vector[2]' CreateOption.CreateNew' SortOption.WillSortLater);  						meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  					}  				}  				//uint numTriangles = System.BitConverter.ToSingle(fileContents' 80);  			}
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseFileContents,The following statement contains a magic number: if (first160BytesOfSTLFile.StartsWith("solid") && first160BytesOfSTLFile.Contains("facet"))  			{  				stlStream.Position = 0;  				StreamReader stlReader = new StreamReader(stlStream);  				int vectorIndex = 0;  				Vector3 vector0 = new Vector3(0' 0' 0);  				Vector3 vector1 = new Vector3(0' 0' 0);  				Vector3 vector2 = new Vector3(0' 0' 0);  				string line = stlReader.ReadLine();    				while (line != null)  				{  					line = line.Trim();  					if (line.StartsWith("vertex"))  					{  						vectorIndex++;  						switch (vectorIndex)  						{  							case 1:  								vector0 = Convert(line);  								break;    							case 2:  								vector1 = Convert(line);  								break;    							case 3:  								vector2 = Convert(line);  								if (!Vector3.Collinear(vector0' vector1' vector2))  								{  									Vertex vertex1 = meshFromStlFile.CreateVertex(vector0' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex2 = meshFromStlFile.CreateVertex(vector1' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex3 = meshFromStlFile.CreateVertex(vector2' CreateOption.CreateNew' SortOption.WillSortLater);  									meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  								}  								vectorIndex = 0;  								break;  						}  					}  					line = stlReader.ReadLine();    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(stlStream.Position / (double)bytesInFile * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}  				}  			}  			else  			{  				// load it as a binary stl  				// skip the first 80 bytes  				// read in the number of triangles  				stlStream.Position = 0;  				BinaryReader br = new BinaryReader(stlStream);  				byte[] fileContents = br.ReadBytes((int)stlStream.Length);  				int currentPosition = 80;  				uint numTriangles = System.BitConverter.ToUInt32(fileContents' currentPosition);  				long bytesForNormals = numTriangles * 3 * 4;  				long bytesForVertices = numTriangles * 3 * 4 * 3;  				long bytesForAttributs = numTriangles * 2;  				currentPosition += 4;  				long numBytesRequiredForVertexData = currentPosition + bytesForNormals + bytesForVertices + bytesForAttributs;  				if (fileContents.Length < numBytesRequiredForVertexData || numTriangles < 4)  				{  					stlStream.Close();  					return null;  				}  				Vector3[] vector = new Vector3[3];  				for (int i = 0; i < numTriangles; i++)  				{  					// skip the normal  					currentPosition += 3 * 4;  					for (int j = 0; j < 3; j++)  					{  						vector[j] = new Vector3(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4));  						currentPosition += 3 * 4;  					}  					currentPosition += 2; // skip the attribute    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(i / (double)numTriangles * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}    					if (!Vector3.Collinear(vector[0]' vector[1]' vector[2]))  					{  						Vertex vertex1 = meshFromStlFile.CreateVertex(vector[0]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex2 = meshFromStlFile.CreateVertex(vector[1]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex3 = meshFromStlFile.CreateVertex(vector[2]' CreateOption.CreateNew' SortOption.WillSortLater);  						meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  					}  				}  				//uint numTriangles = System.BitConverter.ToSingle(fileContents' 80);  			}
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseFileContents,The following statement contains a magic number: if (first160BytesOfSTLFile.StartsWith("solid") && first160BytesOfSTLFile.Contains("facet"))  			{  				stlStream.Position = 0;  				StreamReader stlReader = new StreamReader(stlStream);  				int vectorIndex = 0;  				Vector3 vector0 = new Vector3(0' 0' 0);  				Vector3 vector1 = new Vector3(0' 0' 0);  				Vector3 vector2 = new Vector3(0' 0' 0);  				string line = stlReader.ReadLine();    				while (line != null)  				{  					line = line.Trim();  					if (line.StartsWith("vertex"))  					{  						vectorIndex++;  						switch (vectorIndex)  						{  							case 1:  								vector0 = Convert(line);  								break;    							case 2:  								vector1 = Convert(line);  								break;    							case 3:  								vector2 = Convert(line);  								if (!Vector3.Collinear(vector0' vector1' vector2))  								{  									Vertex vertex1 = meshFromStlFile.CreateVertex(vector0' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex2 = meshFromStlFile.CreateVertex(vector1' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex3 = meshFromStlFile.CreateVertex(vector2' CreateOption.CreateNew' SortOption.WillSortLater);  									meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  								}  								vectorIndex = 0;  								break;  						}  					}  					line = stlReader.ReadLine();    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(stlStream.Position / (double)bytesInFile * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}  				}  			}  			else  			{  				// load it as a binary stl  				// skip the first 80 bytes  				// read in the number of triangles  				stlStream.Position = 0;  				BinaryReader br = new BinaryReader(stlStream);  				byte[] fileContents = br.ReadBytes((int)stlStream.Length);  				int currentPosition = 80;  				uint numTriangles = System.BitConverter.ToUInt32(fileContents' currentPosition);  				long bytesForNormals = numTriangles * 3 * 4;  				long bytesForVertices = numTriangles * 3 * 4 * 3;  				long bytesForAttributs = numTriangles * 2;  				currentPosition += 4;  				long numBytesRequiredForVertexData = currentPosition + bytesForNormals + bytesForVertices + bytesForAttributs;  				if (fileContents.Length < numBytesRequiredForVertexData || numTriangles < 4)  				{  					stlStream.Close();  					return null;  				}  				Vector3[] vector = new Vector3[3];  				for (int i = 0; i < numTriangles; i++)  				{  					// skip the normal  					currentPosition += 3 * 4;  					for (int j = 0; j < 3; j++)  					{  						vector[j] = new Vector3(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4));  						currentPosition += 3 * 4;  					}  					currentPosition += 2; // skip the attribute    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(i / (double)numTriangles * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}    					if (!Vector3.Collinear(vector[0]' vector[1]' vector[2]))  					{  						Vertex vertex1 = meshFromStlFile.CreateVertex(vector[0]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex2 = meshFromStlFile.CreateVertex(vector[1]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex3 = meshFromStlFile.CreateVertex(vector[2]' CreateOption.CreateNew' SortOption.WillSortLater);  						meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  					}  				}  				//uint numTriangles = System.BitConverter.ToSingle(fileContents' 80);  			}
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseFileContents,The following statement contains a magic number: if (first160BytesOfSTLFile.StartsWith("solid") && first160BytesOfSTLFile.Contains("facet"))  			{  				stlStream.Position = 0;  				StreamReader stlReader = new StreamReader(stlStream);  				int vectorIndex = 0;  				Vector3 vector0 = new Vector3(0' 0' 0);  				Vector3 vector1 = new Vector3(0' 0' 0);  				Vector3 vector2 = new Vector3(0' 0' 0);  				string line = stlReader.ReadLine();    				while (line != null)  				{  					line = line.Trim();  					if (line.StartsWith("vertex"))  					{  						vectorIndex++;  						switch (vectorIndex)  						{  							case 1:  								vector0 = Convert(line);  								break;    							case 2:  								vector1 = Convert(line);  								break;    							case 3:  								vector2 = Convert(line);  								if (!Vector3.Collinear(vector0' vector1' vector2))  								{  									Vertex vertex1 = meshFromStlFile.CreateVertex(vector0' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex2 = meshFromStlFile.CreateVertex(vector1' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex3 = meshFromStlFile.CreateVertex(vector2' CreateOption.CreateNew' SortOption.WillSortLater);  									meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  								}  								vectorIndex = 0;  								break;  						}  					}  					line = stlReader.ReadLine();    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(stlStream.Position / (double)bytesInFile * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}  				}  			}  			else  			{  				// load it as a binary stl  				// skip the first 80 bytes  				// read in the number of triangles  				stlStream.Position = 0;  				BinaryReader br = new BinaryReader(stlStream);  				byte[] fileContents = br.ReadBytes((int)stlStream.Length);  				int currentPosition = 80;  				uint numTriangles = System.BitConverter.ToUInt32(fileContents' currentPosition);  				long bytesForNormals = numTriangles * 3 * 4;  				long bytesForVertices = numTriangles * 3 * 4 * 3;  				long bytesForAttributs = numTriangles * 2;  				currentPosition += 4;  				long numBytesRequiredForVertexData = currentPosition + bytesForNormals + bytesForVertices + bytesForAttributs;  				if (fileContents.Length < numBytesRequiredForVertexData || numTriangles < 4)  				{  					stlStream.Close();  					return null;  				}  				Vector3[] vector = new Vector3[3];  				for (int i = 0; i < numTriangles; i++)  				{  					// skip the normal  					currentPosition += 3 * 4;  					for (int j = 0; j < 3; j++)  					{  						vector[j] = new Vector3(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4));  						currentPosition += 3 * 4;  					}  					currentPosition += 2; // skip the attribute    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(i / (double)numTriangles * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}    					if (!Vector3.Collinear(vector[0]' vector[1]' vector[2]))  					{  						Vertex vertex1 = meshFromStlFile.CreateVertex(vector[0]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex2 = meshFromStlFile.CreateVertex(vector[1]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex3 = meshFromStlFile.CreateVertex(vector[2]' CreateOption.CreateNew' SortOption.WillSortLater);  						meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  					}  				}  				//uint numTriangles = System.BitConverter.ToSingle(fileContents' 80);  			}
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseFileContents,The following statement contains a magic number: if (first160BytesOfSTLFile.StartsWith("solid") && first160BytesOfSTLFile.Contains("facet"))  			{  				stlStream.Position = 0;  				StreamReader stlReader = new StreamReader(stlStream);  				int vectorIndex = 0;  				Vector3 vector0 = new Vector3(0' 0' 0);  				Vector3 vector1 = new Vector3(0' 0' 0);  				Vector3 vector2 = new Vector3(0' 0' 0);  				string line = stlReader.ReadLine();    				while (line != null)  				{  					line = line.Trim();  					if (line.StartsWith("vertex"))  					{  						vectorIndex++;  						switch (vectorIndex)  						{  							case 1:  								vector0 = Convert(line);  								break;    							case 2:  								vector1 = Convert(line);  								break;    							case 3:  								vector2 = Convert(line);  								if (!Vector3.Collinear(vector0' vector1' vector2))  								{  									Vertex vertex1 = meshFromStlFile.CreateVertex(vector0' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex2 = meshFromStlFile.CreateVertex(vector1' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex3 = meshFromStlFile.CreateVertex(vector2' CreateOption.CreateNew' SortOption.WillSortLater);  									meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  								}  								vectorIndex = 0;  								break;  						}  					}  					line = stlReader.ReadLine();    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(stlStream.Position / (double)bytesInFile * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}  				}  			}  			else  			{  				// load it as a binary stl  				// skip the first 80 bytes  				// read in the number of triangles  				stlStream.Position = 0;  				BinaryReader br = new BinaryReader(stlStream);  				byte[] fileContents = br.ReadBytes((int)stlStream.Length);  				int currentPosition = 80;  				uint numTriangles = System.BitConverter.ToUInt32(fileContents' currentPosition);  				long bytesForNormals = numTriangles * 3 * 4;  				long bytesForVertices = numTriangles * 3 * 4 * 3;  				long bytesForAttributs = numTriangles * 2;  				currentPosition += 4;  				long numBytesRequiredForVertexData = currentPosition + bytesForNormals + bytesForVertices + bytesForAttributs;  				if (fileContents.Length < numBytesRequiredForVertexData || numTriangles < 4)  				{  					stlStream.Close();  					return null;  				}  				Vector3[] vector = new Vector3[3];  				for (int i = 0; i < numTriangles; i++)  				{  					// skip the normal  					currentPosition += 3 * 4;  					for (int j = 0; j < 3; j++)  					{  						vector[j] = new Vector3(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4));  						currentPosition += 3 * 4;  					}  					currentPosition += 2; // skip the attribute    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(i / (double)numTriangles * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}    					if (!Vector3.Collinear(vector[0]' vector[1]' vector[2]))  					{  						Vertex vertex1 = meshFromStlFile.CreateVertex(vector[0]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex2 = meshFromStlFile.CreateVertex(vector[1]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex3 = meshFromStlFile.CreateVertex(vector[2]' CreateOption.CreateNew' SortOption.WillSortLater);  						meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  					}  				}  				//uint numTriangles = System.BitConverter.ToSingle(fileContents' 80);  			}
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseFileContents,The following statement contains a magic number: if (first160BytesOfSTLFile.StartsWith("solid") && first160BytesOfSTLFile.Contains("facet"))  			{  				stlStream.Position = 0;  				StreamReader stlReader = new StreamReader(stlStream);  				int vectorIndex = 0;  				Vector3 vector0 = new Vector3(0' 0' 0);  				Vector3 vector1 = new Vector3(0' 0' 0);  				Vector3 vector2 = new Vector3(0' 0' 0);  				string line = stlReader.ReadLine();    				while (line != null)  				{  					line = line.Trim();  					if (line.StartsWith("vertex"))  					{  						vectorIndex++;  						switch (vectorIndex)  						{  							case 1:  								vector0 = Convert(line);  								break;    							case 2:  								vector1 = Convert(line);  								break;    							case 3:  								vector2 = Convert(line);  								if (!Vector3.Collinear(vector0' vector1' vector2))  								{  									Vertex vertex1 = meshFromStlFile.CreateVertex(vector0' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex2 = meshFromStlFile.CreateVertex(vector1' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex3 = meshFromStlFile.CreateVertex(vector2' CreateOption.CreateNew' SortOption.WillSortLater);  									meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  								}  								vectorIndex = 0;  								break;  						}  					}  					line = stlReader.ReadLine();    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(stlStream.Position / (double)bytesInFile * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}  				}  			}  			else  			{  				// load it as a binary stl  				// skip the first 80 bytes  				// read in the number of triangles  				stlStream.Position = 0;  				BinaryReader br = new BinaryReader(stlStream);  				byte[] fileContents = br.ReadBytes((int)stlStream.Length);  				int currentPosition = 80;  				uint numTriangles = System.BitConverter.ToUInt32(fileContents' currentPosition);  				long bytesForNormals = numTriangles * 3 * 4;  				long bytesForVertices = numTriangles * 3 * 4 * 3;  				long bytesForAttributs = numTriangles * 2;  				currentPosition += 4;  				long numBytesRequiredForVertexData = currentPosition + bytesForNormals + bytesForVertices + bytesForAttributs;  				if (fileContents.Length < numBytesRequiredForVertexData || numTriangles < 4)  				{  					stlStream.Close();  					return null;  				}  				Vector3[] vector = new Vector3[3];  				for (int i = 0; i < numTriangles; i++)  				{  					// skip the normal  					currentPosition += 3 * 4;  					for (int j = 0; j < 3; j++)  					{  						vector[j] = new Vector3(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4));  						currentPosition += 3 * 4;  					}  					currentPosition += 2; // skip the attribute    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(i / (double)numTriangles * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}    					if (!Vector3.Collinear(vector[0]' vector[1]' vector[2]))  					{  						Vertex vertex1 = meshFromStlFile.CreateVertex(vector[0]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex2 = meshFromStlFile.CreateVertex(vector[1]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex3 = meshFromStlFile.CreateVertex(vector[2]' CreateOption.CreateNew' SortOption.WillSortLater);  						meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  					}  				}  				//uint numTriangles = System.BitConverter.ToSingle(fileContents' 80);  			}
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseFileContents,The following statement contains a magic number: if (first160BytesOfSTLFile.StartsWith("solid") && first160BytesOfSTLFile.Contains("facet"))  			{  				stlStream.Position = 0;  				StreamReader stlReader = new StreamReader(stlStream);  				int vectorIndex = 0;  				Vector3 vector0 = new Vector3(0' 0' 0);  				Vector3 vector1 = new Vector3(0' 0' 0);  				Vector3 vector2 = new Vector3(0' 0' 0);  				string line = stlReader.ReadLine();    				while (line != null)  				{  					line = line.Trim();  					if (line.StartsWith("vertex"))  					{  						vectorIndex++;  						switch (vectorIndex)  						{  							case 1:  								vector0 = Convert(line);  								break;    							case 2:  								vector1 = Convert(line);  								break;    							case 3:  								vector2 = Convert(line);  								if (!Vector3.Collinear(vector0' vector1' vector2))  								{  									Vertex vertex1 = meshFromStlFile.CreateVertex(vector0' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex2 = meshFromStlFile.CreateVertex(vector1' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex3 = meshFromStlFile.CreateVertex(vector2' CreateOption.CreateNew' SortOption.WillSortLater);  									meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  								}  								vectorIndex = 0;  								break;  						}  					}  					line = stlReader.ReadLine();    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(stlStream.Position / (double)bytesInFile * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}  				}  			}  			else  			{  				// load it as a binary stl  				// skip the first 80 bytes  				// read in the number of triangles  				stlStream.Position = 0;  				BinaryReader br = new BinaryReader(stlStream);  				byte[] fileContents = br.ReadBytes((int)stlStream.Length);  				int currentPosition = 80;  				uint numTriangles = System.BitConverter.ToUInt32(fileContents' currentPosition);  				long bytesForNormals = numTriangles * 3 * 4;  				long bytesForVertices = numTriangles * 3 * 4 * 3;  				long bytesForAttributs = numTriangles * 2;  				currentPosition += 4;  				long numBytesRequiredForVertexData = currentPosition + bytesForNormals + bytesForVertices + bytesForAttributs;  				if (fileContents.Length < numBytesRequiredForVertexData || numTriangles < 4)  				{  					stlStream.Close();  					return null;  				}  				Vector3[] vector = new Vector3[3];  				for (int i = 0; i < numTriangles; i++)  				{  					// skip the normal  					currentPosition += 3 * 4;  					for (int j = 0; j < 3; j++)  					{  						vector[j] = new Vector3(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4));  						currentPosition += 3 * 4;  					}  					currentPosition += 2; // skip the attribute    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(i / (double)numTriangles * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}    					if (!Vector3.Collinear(vector[0]' vector[1]' vector[2]))  					{  						Vertex vertex1 = meshFromStlFile.CreateVertex(vector[0]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex2 = meshFromStlFile.CreateVertex(vector[1]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex3 = meshFromStlFile.CreateVertex(vector[2]' CreateOption.CreateNew' SortOption.WillSortLater);  						meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  					}  				}  				//uint numTriangles = System.BitConverter.ToSingle(fileContents' 80);  			}
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseFileContents,The following statement contains a magic number: if (first160BytesOfSTLFile.StartsWith("solid") && first160BytesOfSTLFile.Contains("facet"))  			{  				stlStream.Position = 0;  				StreamReader stlReader = new StreamReader(stlStream);  				int vectorIndex = 0;  				Vector3 vector0 = new Vector3(0' 0' 0);  				Vector3 vector1 = new Vector3(0' 0' 0);  				Vector3 vector2 = new Vector3(0' 0' 0);  				string line = stlReader.ReadLine();    				while (line != null)  				{  					line = line.Trim();  					if (line.StartsWith("vertex"))  					{  						vectorIndex++;  						switch (vectorIndex)  						{  							case 1:  								vector0 = Convert(line);  								break;    							case 2:  								vector1 = Convert(line);  								break;    							case 3:  								vector2 = Convert(line);  								if (!Vector3.Collinear(vector0' vector1' vector2))  								{  									Vertex vertex1 = meshFromStlFile.CreateVertex(vector0' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex2 = meshFromStlFile.CreateVertex(vector1' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex3 = meshFromStlFile.CreateVertex(vector2' CreateOption.CreateNew' SortOption.WillSortLater);  									meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  								}  								vectorIndex = 0;  								break;  						}  					}  					line = stlReader.ReadLine();    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(stlStream.Position / (double)bytesInFile * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}  				}  			}  			else  			{  				// load it as a binary stl  				// skip the first 80 bytes  				// read in the number of triangles  				stlStream.Position = 0;  				BinaryReader br = new BinaryReader(stlStream);  				byte[] fileContents = br.ReadBytes((int)stlStream.Length);  				int currentPosition = 80;  				uint numTriangles = System.BitConverter.ToUInt32(fileContents' currentPosition);  				long bytesForNormals = numTriangles * 3 * 4;  				long bytesForVertices = numTriangles * 3 * 4 * 3;  				long bytesForAttributs = numTriangles * 2;  				currentPosition += 4;  				long numBytesRequiredForVertexData = currentPosition + bytesForNormals + bytesForVertices + bytesForAttributs;  				if (fileContents.Length < numBytesRequiredForVertexData || numTriangles < 4)  				{  					stlStream.Close();  					return null;  				}  				Vector3[] vector = new Vector3[3];  				for (int i = 0; i < numTriangles; i++)  				{  					// skip the normal  					currentPosition += 3 * 4;  					for (int j = 0; j < 3; j++)  					{  						vector[j] = new Vector3(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4));  						currentPosition += 3 * 4;  					}  					currentPosition += 2; // skip the attribute    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(i / (double)numTriangles * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}    					if (!Vector3.Collinear(vector[0]' vector[1]' vector[2]))  					{  						Vertex vertex1 = meshFromStlFile.CreateVertex(vector[0]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex2 = meshFromStlFile.CreateVertex(vector[1]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex3 = meshFromStlFile.CreateVertex(vector[2]' CreateOption.CreateNew' SortOption.WillSortLater);  						meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  					}  				}  				//uint numTriangles = System.BitConverter.ToSingle(fileContents' 80);  			}
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseFileContents,The following statement contains a magic number: if (first160BytesOfSTLFile.StartsWith("solid") && first160BytesOfSTLFile.Contains("facet"))  			{  				stlStream.Position = 0;  				StreamReader stlReader = new StreamReader(stlStream);  				int vectorIndex = 0;  				Vector3 vector0 = new Vector3(0' 0' 0);  				Vector3 vector1 = new Vector3(0' 0' 0);  				Vector3 vector2 = new Vector3(0' 0' 0);  				string line = stlReader.ReadLine();    				while (line != null)  				{  					line = line.Trim();  					if (line.StartsWith("vertex"))  					{  						vectorIndex++;  						switch (vectorIndex)  						{  							case 1:  								vector0 = Convert(line);  								break;    							case 2:  								vector1 = Convert(line);  								break;    							case 3:  								vector2 = Convert(line);  								if (!Vector3.Collinear(vector0' vector1' vector2))  								{  									Vertex vertex1 = meshFromStlFile.CreateVertex(vector0' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex2 = meshFromStlFile.CreateVertex(vector1' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex3 = meshFromStlFile.CreateVertex(vector2' CreateOption.CreateNew' SortOption.WillSortLater);  									meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  								}  								vectorIndex = 0;  								break;  						}  					}  					line = stlReader.ReadLine();    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(stlStream.Position / (double)bytesInFile * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}  				}  			}  			else  			{  				// load it as a binary stl  				// skip the first 80 bytes  				// read in the number of triangles  				stlStream.Position = 0;  				BinaryReader br = new BinaryReader(stlStream);  				byte[] fileContents = br.ReadBytes((int)stlStream.Length);  				int currentPosition = 80;  				uint numTriangles = System.BitConverter.ToUInt32(fileContents' currentPosition);  				long bytesForNormals = numTriangles * 3 * 4;  				long bytesForVertices = numTriangles * 3 * 4 * 3;  				long bytesForAttributs = numTriangles * 2;  				currentPosition += 4;  				long numBytesRequiredForVertexData = currentPosition + bytesForNormals + bytesForVertices + bytesForAttributs;  				if (fileContents.Length < numBytesRequiredForVertexData || numTriangles < 4)  				{  					stlStream.Close();  					return null;  				}  				Vector3[] vector = new Vector3[3];  				for (int i = 0; i < numTriangles; i++)  				{  					// skip the normal  					currentPosition += 3 * 4;  					for (int j = 0; j < 3; j++)  					{  						vector[j] = new Vector3(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4));  						currentPosition += 3 * 4;  					}  					currentPosition += 2; // skip the attribute    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(i / (double)numTriangles * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}    					if (!Vector3.Collinear(vector[0]' vector[1]' vector[2]))  					{  						Vertex vertex1 = meshFromStlFile.CreateVertex(vector[0]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex2 = meshFromStlFile.CreateVertex(vector[1]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex3 = meshFromStlFile.CreateVertex(vector[2]' CreateOption.CreateNew' SortOption.WillSortLater);  						meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  					}  				}  				//uint numTriangles = System.BitConverter.ToSingle(fileContents' 80);  			}
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseFileContents,The following statement contains a magic number: if (first160BytesOfSTLFile.StartsWith("solid") && first160BytesOfSTLFile.Contains("facet"))  			{  				stlStream.Position = 0;  				StreamReader stlReader = new StreamReader(stlStream);  				int vectorIndex = 0;  				Vector3 vector0 = new Vector3(0' 0' 0);  				Vector3 vector1 = new Vector3(0' 0' 0);  				Vector3 vector2 = new Vector3(0' 0' 0);  				string line = stlReader.ReadLine();    				while (line != null)  				{  					line = line.Trim();  					if (line.StartsWith("vertex"))  					{  						vectorIndex++;  						switch (vectorIndex)  						{  							case 1:  								vector0 = Convert(line);  								break;    							case 2:  								vector1 = Convert(line);  								break;    							case 3:  								vector2 = Convert(line);  								if (!Vector3.Collinear(vector0' vector1' vector2))  								{  									Vertex vertex1 = meshFromStlFile.CreateVertex(vector0' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex2 = meshFromStlFile.CreateVertex(vector1' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex3 = meshFromStlFile.CreateVertex(vector2' CreateOption.CreateNew' SortOption.WillSortLater);  									meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  								}  								vectorIndex = 0;  								break;  						}  					}  					line = stlReader.ReadLine();    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(stlStream.Position / (double)bytesInFile * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}  				}  			}  			else  			{  				// load it as a binary stl  				// skip the first 80 bytes  				// read in the number of triangles  				stlStream.Position = 0;  				BinaryReader br = new BinaryReader(stlStream);  				byte[] fileContents = br.ReadBytes((int)stlStream.Length);  				int currentPosition = 80;  				uint numTriangles = System.BitConverter.ToUInt32(fileContents' currentPosition);  				long bytesForNormals = numTriangles * 3 * 4;  				long bytesForVertices = numTriangles * 3 * 4 * 3;  				long bytesForAttributs = numTriangles * 2;  				currentPosition += 4;  				long numBytesRequiredForVertexData = currentPosition + bytesForNormals + bytesForVertices + bytesForAttributs;  				if (fileContents.Length < numBytesRequiredForVertexData || numTriangles < 4)  				{  					stlStream.Close();  					return null;  				}  				Vector3[] vector = new Vector3[3];  				for (int i = 0; i < numTriangles; i++)  				{  					// skip the normal  					currentPosition += 3 * 4;  					for (int j = 0; j < 3; j++)  					{  						vector[j] = new Vector3(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4));  						currentPosition += 3 * 4;  					}  					currentPosition += 2; // skip the attribute    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(i / (double)numTriangles * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}    					if (!Vector3.Collinear(vector[0]' vector[1]' vector[2]))  					{  						Vertex vertex1 = meshFromStlFile.CreateVertex(vector[0]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex2 = meshFromStlFile.CreateVertex(vector[1]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex3 = meshFromStlFile.CreateVertex(vector[2]' CreateOption.CreateNew' SortOption.WillSortLater);  						meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  					}  				}  				//uint numTriangles = System.BitConverter.ToSingle(fileContents' 80);  			}
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseFileContents,The following statement contains a magic number: if (first160BytesOfSTLFile.StartsWith("solid") && first160BytesOfSTLFile.Contains("facet"))  			{  				stlStream.Position = 0;  				StreamReader stlReader = new StreamReader(stlStream);  				int vectorIndex = 0;  				Vector3 vector0 = new Vector3(0' 0' 0);  				Vector3 vector1 = new Vector3(0' 0' 0);  				Vector3 vector2 = new Vector3(0' 0' 0);  				string line = stlReader.ReadLine();    				while (line != null)  				{  					line = line.Trim();  					if (line.StartsWith("vertex"))  					{  						vectorIndex++;  						switch (vectorIndex)  						{  							case 1:  								vector0 = Convert(line);  								break;    							case 2:  								vector1 = Convert(line);  								break;    							case 3:  								vector2 = Convert(line);  								if (!Vector3.Collinear(vector0' vector1' vector2))  								{  									Vertex vertex1 = meshFromStlFile.CreateVertex(vector0' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex2 = meshFromStlFile.CreateVertex(vector1' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex3 = meshFromStlFile.CreateVertex(vector2' CreateOption.CreateNew' SortOption.WillSortLater);  									meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  								}  								vectorIndex = 0;  								break;  						}  					}  					line = stlReader.ReadLine();    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(stlStream.Position / (double)bytesInFile * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}  				}  			}  			else  			{  				// load it as a binary stl  				// skip the first 80 bytes  				// read in the number of triangles  				stlStream.Position = 0;  				BinaryReader br = new BinaryReader(stlStream);  				byte[] fileContents = br.ReadBytes((int)stlStream.Length);  				int currentPosition = 80;  				uint numTriangles = System.BitConverter.ToUInt32(fileContents' currentPosition);  				long bytesForNormals = numTriangles * 3 * 4;  				long bytesForVertices = numTriangles * 3 * 4 * 3;  				long bytesForAttributs = numTriangles * 2;  				currentPosition += 4;  				long numBytesRequiredForVertexData = currentPosition + bytesForNormals + bytesForVertices + bytesForAttributs;  				if (fileContents.Length < numBytesRequiredForVertexData || numTriangles < 4)  				{  					stlStream.Close();  					return null;  				}  				Vector3[] vector = new Vector3[3];  				for (int i = 0; i < numTriangles; i++)  				{  					// skip the normal  					currentPosition += 3 * 4;  					for (int j = 0; j < 3; j++)  					{  						vector[j] = new Vector3(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4));  						currentPosition += 3 * 4;  					}  					currentPosition += 2; // skip the attribute    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(i / (double)numTriangles * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}    					if (!Vector3.Collinear(vector[0]' vector[1]' vector[2]))  					{  						Vertex vertex1 = meshFromStlFile.CreateVertex(vector[0]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex2 = meshFromStlFile.CreateVertex(vector[1]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex3 = meshFromStlFile.CreateVertex(vector[2]' CreateOption.CreateNew' SortOption.WillSortLater);  						meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  					}  				}  				//uint numTriangles = System.BitConverter.ToSingle(fileContents' 80);  			}
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseFileContents,The following statement contains a magic number: if (first160BytesOfSTLFile.StartsWith("solid") && first160BytesOfSTLFile.Contains("facet"))  			{  				stlStream.Position = 0;  				StreamReader stlReader = new StreamReader(stlStream);  				int vectorIndex = 0;  				Vector3 vector0 = new Vector3(0' 0' 0);  				Vector3 vector1 = new Vector3(0' 0' 0);  				Vector3 vector2 = new Vector3(0' 0' 0);  				string line = stlReader.ReadLine();    				while (line != null)  				{  					line = line.Trim();  					if (line.StartsWith("vertex"))  					{  						vectorIndex++;  						switch (vectorIndex)  						{  							case 1:  								vector0 = Convert(line);  								break;    							case 2:  								vector1 = Convert(line);  								break;    							case 3:  								vector2 = Convert(line);  								if (!Vector3.Collinear(vector0' vector1' vector2))  								{  									Vertex vertex1 = meshFromStlFile.CreateVertex(vector0' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex2 = meshFromStlFile.CreateVertex(vector1' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex3 = meshFromStlFile.CreateVertex(vector2' CreateOption.CreateNew' SortOption.WillSortLater);  									meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  								}  								vectorIndex = 0;  								break;  						}  					}  					line = stlReader.ReadLine();    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(stlStream.Position / (double)bytesInFile * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}  				}  			}  			else  			{  				// load it as a binary stl  				// skip the first 80 bytes  				// read in the number of triangles  				stlStream.Position = 0;  				BinaryReader br = new BinaryReader(stlStream);  				byte[] fileContents = br.ReadBytes((int)stlStream.Length);  				int currentPosition = 80;  				uint numTriangles = System.BitConverter.ToUInt32(fileContents' currentPosition);  				long bytesForNormals = numTriangles * 3 * 4;  				long bytesForVertices = numTriangles * 3 * 4 * 3;  				long bytesForAttributs = numTriangles * 2;  				currentPosition += 4;  				long numBytesRequiredForVertexData = currentPosition + bytesForNormals + bytesForVertices + bytesForAttributs;  				if (fileContents.Length < numBytesRequiredForVertexData || numTriangles < 4)  				{  					stlStream.Close();  					return null;  				}  				Vector3[] vector = new Vector3[3];  				for (int i = 0; i < numTriangles; i++)  				{  					// skip the normal  					currentPosition += 3 * 4;  					for (int j = 0; j < 3; j++)  					{  						vector[j] = new Vector3(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4));  						currentPosition += 3 * 4;  					}  					currentPosition += 2; // skip the attribute    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(i / (double)numTriangles * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}    					if (!Vector3.Collinear(vector[0]' vector[1]' vector[2]))  					{  						Vertex vertex1 = meshFromStlFile.CreateVertex(vector[0]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex2 = meshFromStlFile.CreateVertex(vector[1]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex3 = meshFromStlFile.CreateVertex(vector[2]' CreateOption.CreateNew' SortOption.WillSortLater);  						meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  					}  				}  				//uint numTriangles = System.BitConverter.ToSingle(fileContents' 80);  			}
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseFileContents,The following statement contains a magic number: if (first160BytesOfSTLFile.StartsWith("solid") && first160BytesOfSTLFile.Contains("facet"))  			{  				stlStream.Position = 0;  				StreamReader stlReader = new StreamReader(stlStream);  				int vectorIndex = 0;  				Vector3 vector0 = new Vector3(0' 0' 0);  				Vector3 vector1 = new Vector3(0' 0' 0);  				Vector3 vector2 = new Vector3(0' 0' 0);  				string line = stlReader.ReadLine();    				while (line != null)  				{  					line = line.Trim();  					if (line.StartsWith("vertex"))  					{  						vectorIndex++;  						switch (vectorIndex)  						{  							case 1:  								vector0 = Convert(line);  								break;    							case 2:  								vector1 = Convert(line);  								break;    							case 3:  								vector2 = Convert(line);  								if (!Vector3.Collinear(vector0' vector1' vector2))  								{  									Vertex vertex1 = meshFromStlFile.CreateVertex(vector0' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex2 = meshFromStlFile.CreateVertex(vector1' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex3 = meshFromStlFile.CreateVertex(vector2' CreateOption.CreateNew' SortOption.WillSortLater);  									meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  								}  								vectorIndex = 0;  								break;  						}  					}  					line = stlReader.ReadLine();    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(stlStream.Position / (double)bytesInFile * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}  				}  			}  			else  			{  				// load it as a binary stl  				// skip the first 80 bytes  				// read in the number of triangles  				stlStream.Position = 0;  				BinaryReader br = new BinaryReader(stlStream);  				byte[] fileContents = br.ReadBytes((int)stlStream.Length);  				int currentPosition = 80;  				uint numTriangles = System.BitConverter.ToUInt32(fileContents' currentPosition);  				long bytesForNormals = numTriangles * 3 * 4;  				long bytesForVertices = numTriangles * 3 * 4 * 3;  				long bytesForAttributs = numTriangles * 2;  				currentPosition += 4;  				long numBytesRequiredForVertexData = currentPosition + bytesForNormals + bytesForVertices + bytesForAttributs;  				if (fileContents.Length < numBytesRequiredForVertexData || numTriangles < 4)  				{  					stlStream.Close();  					return null;  				}  				Vector3[] vector = new Vector3[3];  				for (int i = 0; i < numTriangles; i++)  				{  					// skip the normal  					currentPosition += 3 * 4;  					for (int j = 0; j < 3; j++)  					{  						vector[j] = new Vector3(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4));  						currentPosition += 3 * 4;  					}  					currentPosition += 2; // skip the attribute    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(i / (double)numTriangles * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}    					if (!Vector3.Collinear(vector[0]' vector[1]' vector[2]))  					{  						Vertex vertex1 = meshFromStlFile.CreateVertex(vector[0]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex2 = meshFromStlFile.CreateVertex(vector[1]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex3 = meshFromStlFile.CreateVertex(vector[2]' CreateOption.CreateNew' SortOption.WillSortLater);  						meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  					}  				}  				//uint numTriangles = System.BitConverter.ToSingle(fileContents' 80);  			}
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseFileContents,The following statement contains a magic number: if (first160BytesOfSTLFile.StartsWith("solid") && first160BytesOfSTLFile.Contains("facet"))  			{  				stlStream.Position = 0;  				StreamReader stlReader = new StreamReader(stlStream);  				int vectorIndex = 0;  				Vector3 vector0 = new Vector3(0' 0' 0);  				Vector3 vector1 = new Vector3(0' 0' 0);  				Vector3 vector2 = new Vector3(0' 0' 0);  				string line = stlReader.ReadLine();    				while (line != null)  				{  					line = line.Trim();  					if (line.StartsWith("vertex"))  					{  						vectorIndex++;  						switch (vectorIndex)  						{  							case 1:  								vector0 = Convert(line);  								break;    							case 2:  								vector1 = Convert(line);  								break;    							case 3:  								vector2 = Convert(line);  								if (!Vector3.Collinear(vector0' vector1' vector2))  								{  									Vertex vertex1 = meshFromStlFile.CreateVertex(vector0' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex2 = meshFromStlFile.CreateVertex(vector1' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex3 = meshFromStlFile.CreateVertex(vector2' CreateOption.CreateNew' SortOption.WillSortLater);  									meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  								}  								vectorIndex = 0;  								break;  						}  					}  					line = stlReader.ReadLine();    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(stlStream.Position / (double)bytesInFile * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}  				}  			}  			else  			{  				// load it as a binary stl  				// skip the first 80 bytes  				// read in the number of triangles  				stlStream.Position = 0;  				BinaryReader br = new BinaryReader(stlStream);  				byte[] fileContents = br.ReadBytes((int)stlStream.Length);  				int currentPosition = 80;  				uint numTriangles = System.BitConverter.ToUInt32(fileContents' currentPosition);  				long bytesForNormals = numTriangles * 3 * 4;  				long bytesForVertices = numTriangles * 3 * 4 * 3;  				long bytesForAttributs = numTriangles * 2;  				currentPosition += 4;  				long numBytesRequiredForVertexData = currentPosition + bytesForNormals + bytesForVertices + bytesForAttributs;  				if (fileContents.Length < numBytesRequiredForVertexData || numTriangles < 4)  				{  					stlStream.Close();  					return null;  				}  				Vector3[] vector = new Vector3[3];  				for (int i = 0; i < numTriangles; i++)  				{  					// skip the normal  					currentPosition += 3 * 4;  					for (int j = 0; j < 3; j++)  					{  						vector[j] = new Vector3(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4));  						currentPosition += 3 * 4;  					}  					currentPosition += 2; // skip the attribute    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(i / (double)numTriangles * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}    					if (!Vector3.Collinear(vector[0]' vector[1]' vector[2]))  					{  						Vertex vertex1 = meshFromStlFile.CreateVertex(vector[0]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex2 = meshFromStlFile.CreateVertex(vector[1]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex3 = meshFromStlFile.CreateVertex(vector[2]' CreateOption.CreateNew' SortOption.WillSortLater);  						meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  					}  				}  				//uint numTriangles = System.BitConverter.ToSingle(fileContents' 80);  			}
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseFileContents,The following statement contains a magic number: if (first160BytesOfSTLFile.StartsWith("solid") && first160BytesOfSTLFile.Contains("facet"))  			{  				stlStream.Position = 0;  				StreamReader stlReader = new StreamReader(stlStream);  				int vectorIndex = 0;  				Vector3 vector0 = new Vector3(0' 0' 0);  				Vector3 vector1 = new Vector3(0' 0' 0);  				Vector3 vector2 = new Vector3(0' 0' 0);  				string line = stlReader.ReadLine();    				while (line != null)  				{  					line = line.Trim();  					if (line.StartsWith("vertex"))  					{  						vectorIndex++;  						switch (vectorIndex)  						{  							case 1:  								vector0 = Convert(line);  								break;    							case 2:  								vector1 = Convert(line);  								break;    							case 3:  								vector2 = Convert(line);  								if (!Vector3.Collinear(vector0' vector1' vector2))  								{  									Vertex vertex1 = meshFromStlFile.CreateVertex(vector0' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex2 = meshFromStlFile.CreateVertex(vector1' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex3 = meshFromStlFile.CreateVertex(vector2' CreateOption.CreateNew' SortOption.WillSortLater);  									meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  								}  								vectorIndex = 0;  								break;  						}  					}  					line = stlReader.ReadLine();    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(stlStream.Position / (double)bytesInFile * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}  				}  			}  			else  			{  				// load it as a binary stl  				// skip the first 80 bytes  				// read in the number of triangles  				stlStream.Position = 0;  				BinaryReader br = new BinaryReader(stlStream);  				byte[] fileContents = br.ReadBytes((int)stlStream.Length);  				int currentPosition = 80;  				uint numTriangles = System.BitConverter.ToUInt32(fileContents' currentPosition);  				long bytesForNormals = numTriangles * 3 * 4;  				long bytesForVertices = numTriangles * 3 * 4 * 3;  				long bytesForAttributs = numTriangles * 2;  				currentPosition += 4;  				long numBytesRequiredForVertexData = currentPosition + bytesForNormals + bytesForVertices + bytesForAttributs;  				if (fileContents.Length < numBytesRequiredForVertexData || numTriangles < 4)  				{  					stlStream.Close();  					return null;  				}  				Vector3[] vector = new Vector3[3];  				for (int i = 0; i < numTriangles; i++)  				{  					// skip the normal  					currentPosition += 3 * 4;  					for (int j = 0; j < 3; j++)  					{  						vector[j] = new Vector3(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4));  						currentPosition += 3 * 4;  					}  					currentPosition += 2; // skip the attribute    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(i / (double)numTriangles * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}    					if (!Vector3.Collinear(vector[0]' vector[1]' vector[2]))  					{  						Vertex vertex1 = meshFromStlFile.CreateVertex(vector[0]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex2 = meshFromStlFile.CreateVertex(vector[1]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex3 = meshFromStlFile.CreateVertex(vector[2]' CreateOption.CreateNew' SortOption.WillSortLater);  						meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  					}  				}  				//uint numTriangles = System.BitConverter.ToSingle(fileContents' 80);  			}
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseFileContents,The following statement contains a magic number: if (first160BytesOfSTLFile.StartsWith("solid") && first160BytesOfSTLFile.Contains("facet"))  			{  				stlStream.Position = 0;  				StreamReader stlReader = new StreamReader(stlStream);  				int vectorIndex = 0;  				Vector3 vector0 = new Vector3(0' 0' 0);  				Vector3 vector1 = new Vector3(0' 0' 0);  				Vector3 vector2 = new Vector3(0' 0' 0);  				string line = stlReader.ReadLine();    				while (line != null)  				{  					line = line.Trim();  					if (line.StartsWith("vertex"))  					{  						vectorIndex++;  						switch (vectorIndex)  						{  							case 1:  								vector0 = Convert(line);  								break;    							case 2:  								vector1 = Convert(line);  								break;    							case 3:  								vector2 = Convert(line);  								if (!Vector3.Collinear(vector0' vector1' vector2))  								{  									Vertex vertex1 = meshFromStlFile.CreateVertex(vector0' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex2 = meshFromStlFile.CreateVertex(vector1' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex3 = meshFromStlFile.CreateVertex(vector2' CreateOption.CreateNew' SortOption.WillSortLater);  									meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  								}  								vectorIndex = 0;  								break;  						}  					}  					line = stlReader.ReadLine();    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(stlStream.Position / (double)bytesInFile * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}  				}  			}  			else  			{  				// load it as a binary stl  				// skip the first 80 bytes  				// read in the number of triangles  				stlStream.Position = 0;  				BinaryReader br = new BinaryReader(stlStream);  				byte[] fileContents = br.ReadBytes((int)stlStream.Length);  				int currentPosition = 80;  				uint numTriangles = System.BitConverter.ToUInt32(fileContents' currentPosition);  				long bytesForNormals = numTriangles * 3 * 4;  				long bytesForVertices = numTriangles * 3 * 4 * 3;  				long bytesForAttributs = numTriangles * 2;  				currentPosition += 4;  				long numBytesRequiredForVertexData = currentPosition + bytesForNormals + bytesForVertices + bytesForAttributs;  				if (fileContents.Length < numBytesRequiredForVertexData || numTriangles < 4)  				{  					stlStream.Close();  					return null;  				}  				Vector3[] vector = new Vector3[3];  				for (int i = 0; i < numTriangles; i++)  				{  					// skip the normal  					currentPosition += 3 * 4;  					for (int j = 0; j < 3; j++)  					{  						vector[j] = new Vector3(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4));  						currentPosition += 3 * 4;  					}  					currentPosition += 2; // skip the attribute    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(i / (double)numTriangles * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}    					if (!Vector3.Collinear(vector[0]' vector[1]' vector[2]))  					{  						Vertex vertex1 = meshFromStlFile.CreateVertex(vector[0]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex2 = meshFromStlFile.CreateVertex(vector[1]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex3 = meshFromStlFile.CreateVertex(vector[2]' CreateOption.CreateNew' SortOption.WillSortLater);  						meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  					}  				}  				//uint numTriangles = System.BitConverter.ToSingle(fileContents' 80);  			}
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseFileContents,The following statement contains a magic number: if (first160BytesOfSTLFile.StartsWith("solid") && first160BytesOfSTLFile.Contains("facet"))  			{  				stlStream.Position = 0;  				StreamReader stlReader = new StreamReader(stlStream);  				int vectorIndex = 0;  				Vector3 vector0 = new Vector3(0' 0' 0);  				Vector3 vector1 = new Vector3(0' 0' 0);  				Vector3 vector2 = new Vector3(0' 0' 0);  				string line = stlReader.ReadLine();    				while (line != null)  				{  					line = line.Trim();  					if (line.StartsWith("vertex"))  					{  						vectorIndex++;  						switch (vectorIndex)  						{  							case 1:  								vector0 = Convert(line);  								break;    							case 2:  								vector1 = Convert(line);  								break;    							case 3:  								vector2 = Convert(line);  								if (!Vector3.Collinear(vector0' vector1' vector2))  								{  									Vertex vertex1 = meshFromStlFile.CreateVertex(vector0' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex2 = meshFromStlFile.CreateVertex(vector1' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex3 = meshFromStlFile.CreateVertex(vector2' CreateOption.CreateNew' SortOption.WillSortLater);  									meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  								}  								vectorIndex = 0;  								break;  						}  					}  					line = stlReader.ReadLine();    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(stlStream.Position / (double)bytesInFile * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}  				}  			}  			else  			{  				// load it as a binary stl  				// skip the first 80 bytes  				// read in the number of triangles  				stlStream.Position = 0;  				BinaryReader br = new BinaryReader(stlStream);  				byte[] fileContents = br.ReadBytes((int)stlStream.Length);  				int currentPosition = 80;  				uint numTriangles = System.BitConverter.ToUInt32(fileContents' currentPosition);  				long bytesForNormals = numTriangles * 3 * 4;  				long bytesForVertices = numTriangles * 3 * 4 * 3;  				long bytesForAttributs = numTriangles * 2;  				currentPosition += 4;  				long numBytesRequiredForVertexData = currentPosition + bytesForNormals + bytesForVertices + bytesForAttributs;  				if (fileContents.Length < numBytesRequiredForVertexData || numTriangles < 4)  				{  					stlStream.Close();  					return null;  				}  				Vector3[] vector = new Vector3[3];  				for (int i = 0; i < numTriangles; i++)  				{  					// skip the normal  					currentPosition += 3 * 4;  					for (int j = 0; j < 3; j++)  					{  						vector[j] = new Vector3(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4));  						currentPosition += 3 * 4;  					}  					currentPosition += 2; // skip the attribute    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(i / (double)numTriangles * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}    					if (!Vector3.Collinear(vector[0]' vector[1]' vector[2]))  					{  						Vertex vertex1 = meshFromStlFile.CreateVertex(vector[0]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex2 = meshFromStlFile.CreateVertex(vector[1]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex3 = meshFromStlFile.CreateVertex(vector[2]' CreateOption.CreateNew' SortOption.WillSortLater);  						meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  					}  				}  				//uint numTriangles = System.BitConverter.ToSingle(fileContents' 80);  			}
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseFileContents,The following statement contains a magic number: if (first160BytesOfSTLFile.StartsWith("solid") && first160BytesOfSTLFile.Contains("facet"))  			{  				stlStream.Position = 0;  				StreamReader stlReader = new StreamReader(stlStream);  				int vectorIndex = 0;  				Vector3 vector0 = new Vector3(0' 0' 0);  				Vector3 vector1 = new Vector3(0' 0' 0);  				Vector3 vector2 = new Vector3(0' 0' 0);  				string line = stlReader.ReadLine();    				while (line != null)  				{  					line = line.Trim();  					if (line.StartsWith("vertex"))  					{  						vectorIndex++;  						switch (vectorIndex)  						{  							case 1:  								vector0 = Convert(line);  								break;    							case 2:  								vector1 = Convert(line);  								break;    							case 3:  								vector2 = Convert(line);  								if (!Vector3.Collinear(vector0' vector1' vector2))  								{  									Vertex vertex1 = meshFromStlFile.CreateVertex(vector0' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex2 = meshFromStlFile.CreateVertex(vector1' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex3 = meshFromStlFile.CreateVertex(vector2' CreateOption.CreateNew' SortOption.WillSortLater);  									meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  								}  								vectorIndex = 0;  								break;  						}  					}  					line = stlReader.ReadLine();    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(stlStream.Position / (double)bytesInFile * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}  				}  			}  			else  			{  				// load it as a binary stl  				// skip the first 80 bytes  				// read in the number of triangles  				stlStream.Position = 0;  				BinaryReader br = new BinaryReader(stlStream);  				byte[] fileContents = br.ReadBytes((int)stlStream.Length);  				int currentPosition = 80;  				uint numTriangles = System.BitConverter.ToUInt32(fileContents' currentPosition);  				long bytesForNormals = numTriangles * 3 * 4;  				long bytesForVertices = numTriangles * 3 * 4 * 3;  				long bytesForAttributs = numTriangles * 2;  				currentPosition += 4;  				long numBytesRequiredForVertexData = currentPosition + bytesForNormals + bytesForVertices + bytesForAttributs;  				if (fileContents.Length < numBytesRequiredForVertexData || numTriangles < 4)  				{  					stlStream.Close();  					return null;  				}  				Vector3[] vector = new Vector3[3];  				for (int i = 0; i < numTriangles; i++)  				{  					// skip the normal  					currentPosition += 3 * 4;  					for (int j = 0; j < 3; j++)  					{  						vector[j] = new Vector3(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4));  						currentPosition += 3 * 4;  					}  					currentPosition += 2; // skip the attribute    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(i / (double)numTriangles * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}    					if (!Vector3.Collinear(vector[0]' vector[1]' vector[2]))  					{  						Vertex vertex1 = meshFromStlFile.CreateVertex(vector[0]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex2 = meshFromStlFile.CreateVertex(vector[1]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex3 = meshFromStlFile.CreateVertex(vector[2]' CreateOption.CreateNew' SortOption.WillSortLater);  						meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  					}  				}  				//uint numTriangles = System.BitConverter.ToSingle(fileContents' 80);  			}
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseFileContents,The following statement contains a magic number: if (first160BytesOfSTLFile.StartsWith("solid") && first160BytesOfSTLFile.Contains("facet"))  			{  				stlStream.Position = 0;  				StreamReader stlReader = new StreamReader(stlStream);  				int vectorIndex = 0;  				Vector3 vector0 = new Vector3(0' 0' 0);  				Vector3 vector1 = new Vector3(0' 0' 0);  				Vector3 vector2 = new Vector3(0' 0' 0);  				string line = stlReader.ReadLine();    				while (line != null)  				{  					line = line.Trim();  					if (line.StartsWith("vertex"))  					{  						vectorIndex++;  						switch (vectorIndex)  						{  							case 1:  								vector0 = Convert(line);  								break;    							case 2:  								vector1 = Convert(line);  								break;    							case 3:  								vector2 = Convert(line);  								if (!Vector3.Collinear(vector0' vector1' vector2))  								{  									Vertex vertex1 = meshFromStlFile.CreateVertex(vector0' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex2 = meshFromStlFile.CreateVertex(vector1' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex3 = meshFromStlFile.CreateVertex(vector2' CreateOption.CreateNew' SortOption.WillSortLater);  									meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  								}  								vectorIndex = 0;  								break;  						}  					}  					line = stlReader.ReadLine();    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(stlStream.Position / (double)bytesInFile * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}  				}  			}  			else  			{  				// load it as a binary stl  				// skip the first 80 bytes  				// read in the number of triangles  				stlStream.Position = 0;  				BinaryReader br = new BinaryReader(stlStream);  				byte[] fileContents = br.ReadBytes((int)stlStream.Length);  				int currentPosition = 80;  				uint numTriangles = System.BitConverter.ToUInt32(fileContents' currentPosition);  				long bytesForNormals = numTriangles * 3 * 4;  				long bytesForVertices = numTriangles * 3 * 4 * 3;  				long bytesForAttributs = numTriangles * 2;  				currentPosition += 4;  				long numBytesRequiredForVertexData = currentPosition + bytesForNormals + bytesForVertices + bytesForAttributs;  				if (fileContents.Length < numBytesRequiredForVertexData || numTriangles < 4)  				{  					stlStream.Close();  					return null;  				}  				Vector3[] vector = new Vector3[3];  				for (int i = 0; i < numTriangles; i++)  				{  					// skip the normal  					currentPosition += 3 * 4;  					for (int j = 0; j < 3; j++)  					{  						vector[j] = new Vector3(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4));  						currentPosition += 3 * 4;  					}  					currentPosition += 2; // skip the attribute    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(i / (double)numTriangles * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}    					if (!Vector3.Collinear(vector[0]' vector[1]' vector[2]))  					{  						Vertex vertex1 = meshFromStlFile.CreateVertex(vector[0]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex2 = meshFromStlFile.CreateVertex(vector[1]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex3 = meshFromStlFile.CreateVertex(vector[2]' CreateOption.CreateNew' SortOption.WillSortLater);  						meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  					}  				}  				//uint numTriangles = System.BitConverter.ToSingle(fileContents' 80);  			}
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseFileContents,The following statement contains a magic number: if (first160BytesOfSTLFile.StartsWith("solid") && first160BytesOfSTLFile.Contains("facet"))  			{  				stlStream.Position = 0;  				StreamReader stlReader = new StreamReader(stlStream);  				int vectorIndex = 0;  				Vector3 vector0 = new Vector3(0' 0' 0);  				Vector3 vector1 = new Vector3(0' 0' 0);  				Vector3 vector2 = new Vector3(0' 0' 0);  				string line = stlReader.ReadLine();    				while (line != null)  				{  					line = line.Trim();  					if (line.StartsWith("vertex"))  					{  						vectorIndex++;  						switch (vectorIndex)  						{  							case 1:  								vector0 = Convert(line);  								break;    							case 2:  								vector1 = Convert(line);  								break;    							case 3:  								vector2 = Convert(line);  								if (!Vector3.Collinear(vector0' vector1' vector2))  								{  									Vertex vertex1 = meshFromStlFile.CreateVertex(vector0' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex2 = meshFromStlFile.CreateVertex(vector1' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex3 = meshFromStlFile.CreateVertex(vector2' CreateOption.CreateNew' SortOption.WillSortLater);  									meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  								}  								vectorIndex = 0;  								break;  						}  					}  					line = stlReader.ReadLine();    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(stlStream.Position / (double)bytesInFile * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}  				}  			}  			else  			{  				// load it as a binary stl  				// skip the first 80 bytes  				// read in the number of triangles  				stlStream.Position = 0;  				BinaryReader br = new BinaryReader(stlStream);  				byte[] fileContents = br.ReadBytes((int)stlStream.Length);  				int currentPosition = 80;  				uint numTriangles = System.BitConverter.ToUInt32(fileContents' currentPosition);  				long bytesForNormals = numTriangles * 3 * 4;  				long bytesForVertices = numTriangles * 3 * 4 * 3;  				long bytesForAttributs = numTriangles * 2;  				currentPosition += 4;  				long numBytesRequiredForVertexData = currentPosition + bytesForNormals + bytesForVertices + bytesForAttributs;  				if (fileContents.Length < numBytesRequiredForVertexData || numTriangles < 4)  				{  					stlStream.Close();  					return null;  				}  				Vector3[] vector = new Vector3[3];  				for (int i = 0; i < numTriangles; i++)  				{  					// skip the normal  					currentPosition += 3 * 4;  					for (int j = 0; j < 3; j++)  					{  						vector[j] = new Vector3(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4));  						currentPosition += 3 * 4;  					}  					currentPosition += 2; // skip the attribute    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(i / (double)numTriangles * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}    					if (!Vector3.Collinear(vector[0]' vector[1]' vector[2]))  					{  						Vertex vertex1 = meshFromStlFile.CreateVertex(vector[0]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex2 = meshFromStlFile.CreateVertex(vector[1]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex3 = meshFromStlFile.CreateVertex(vector[2]' CreateOption.CreateNew' SortOption.WillSortLater);  						meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  					}  				}  				//uint numTriangles = System.BitConverter.ToSingle(fileContents' 80);  			}
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseFileContents,The following statement contains a magic number: if (first160BytesOfSTLFile.StartsWith("solid") && first160BytesOfSTLFile.Contains("facet"))  			{  				stlStream.Position = 0;  				StreamReader stlReader = new StreamReader(stlStream);  				int vectorIndex = 0;  				Vector3 vector0 = new Vector3(0' 0' 0);  				Vector3 vector1 = new Vector3(0' 0' 0);  				Vector3 vector2 = new Vector3(0' 0' 0);  				string line = stlReader.ReadLine();    				while (line != null)  				{  					line = line.Trim();  					if (line.StartsWith("vertex"))  					{  						vectorIndex++;  						switch (vectorIndex)  						{  							case 1:  								vector0 = Convert(line);  								break;    							case 2:  								vector1 = Convert(line);  								break;    							case 3:  								vector2 = Convert(line);  								if (!Vector3.Collinear(vector0' vector1' vector2))  								{  									Vertex vertex1 = meshFromStlFile.CreateVertex(vector0' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex2 = meshFromStlFile.CreateVertex(vector1' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex3 = meshFromStlFile.CreateVertex(vector2' CreateOption.CreateNew' SortOption.WillSortLater);  									meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  								}  								vectorIndex = 0;  								break;  						}  					}  					line = stlReader.ReadLine();    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(stlStream.Position / (double)bytesInFile * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}  				}  			}  			else  			{  				// load it as a binary stl  				// skip the first 80 bytes  				// read in the number of triangles  				stlStream.Position = 0;  				BinaryReader br = new BinaryReader(stlStream);  				byte[] fileContents = br.ReadBytes((int)stlStream.Length);  				int currentPosition = 80;  				uint numTriangles = System.BitConverter.ToUInt32(fileContents' currentPosition);  				long bytesForNormals = numTriangles * 3 * 4;  				long bytesForVertices = numTriangles * 3 * 4 * 3;  				long bytesForAttributs = numTriangles * 2;  				currentPosition += 4;  				long numBytesRequiredForVertexData = currentPosition + bytesForNormals + bytesForVertices + bytesForAttributs;  				if (fileContents.Length < numBytesRequiredForVertexData || numTriangles < 4)  				{  					stlStream.Close();  					return null;  				}  				Vector3[] vector = new Vector3[3];  				for (int i = 0; i < numTriangles; i++)  				{  					// skip the normal  					currentPosition += 3 * 4;  					for (int j = 0; j < 3; j++)  					{  						vector[j] = new Vector3(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4));  						currentPosition += 3 * 4;  					}  					currentPosition += 2; // skip the attribute    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(i / (double)numTriangles * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}    					if (!Vector3.Collinear(vector[0]' vector[1]' vector[2]))  					{  						Vertex vertex1 = meshFromStlFile.CreateVertex(vector[0]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex2 = meshFromStlFile.CreateVertex(vector[1]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex3 = meshFromStlFile.CreateVertex(vector[2]' CreateOption.CreateNew' SortOption.WillSortLater);  						meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  					}  				}  				//uint numTriangles = System.BitConverter.ToSingle(fileContents' 80);  			}
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseFileContents,The following statement contains a magic number: if (first160BytesOfSTLFile.StartsWith("solid") && first160BytesOfSTLFile.Contains("facet"))  			{  				stlStream.Position = 0;  				StreamReader stlReader = new StreamReader(stlStream);  				int vectorIndex = 0;  				Vector3 vector0 = new Vector3(0' 0' 0);  				Vector3 vector1 = new Vector3(0' 0' 0);  				Vector3 vector2 = new Vector3(0' 0' 0);  				string line = stlReader.ReadLine();    				while (line != null)  				{  					line = line.Trim();  					if (line.StartsWith("vertex"))  					{  						vectorIndex++;  						switch (vectorIndex)  						{  							case 1:  								vector0 = Convert(line);  								break;    							case 2:  								vector1 = Convert(line);  								break;    							case 3:  								vector2 = Convert(line);  								if (!Vector3.Collinear(vector0' vector1' vector2))  								{  									Vertex vertex1 = meshFromStlFile.CreateVertex(vector0' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex2 = meshFromStlFile.CreateVertex(vector1' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex3 = meshFromStlFile.CreateVertex(vector2' CreateOption.CreateNew' SortOption.WillSortLater);  									meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  								}  								vectorIndex = 0;  								break;  						}  					}  					line = stlReader.ReadLine();    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(stlStream.Position / (double)bytesInFile * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}  				}  			}  			else  			{  				// load it as a binary stl  				// skip the first 80 bytes  				// read in the number of triangles  				stlStream.Position = 0;  				BinaryReader br = new BinaryReader(stlStream);  				byte[] fileContents = br.ReadBytes((int)stlStream.Length);  				int currentPosition = 80;  				uint numTriangles = System.BitConverter.ToUInt32(fileContents' currentPosition);  				long bytesForNormals = numTriangles * 3 * 4;  				long bytesForVertices = numTriangles * 3 * 4 * 3;  				long bytesForAttributs = numTriangles * 2;  				currentPosition += 4;  				long numBytesRequiredForVertexData = currentPosition + bytesForNormals + bytesForVertices + bytesForAttributs;  				if (fileContents.Length < numBytesRequiredForVertexData || numTriangles < 4)  				{  					stlStream.Close();  					return null;  				}  				Vector3[] vector = new Vector3[3];  				for (int i = 0; i < numTriangles; i++)  				{  					// skip the normal  					currentPosition += 3 * 4;  					for (int j = 0; j < 3; j++)  					{  						vector[j] = new Vector3(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4));  						currentPosition += 3 * 4;  					}  					currentPosition += 2; // skip the attribute    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(i / (double)numTriangles * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}    					if (!Vector3.Collinear(vector[0]' vector[1]' vector[2]))  					{  						Vertex vertex1 = meshFromStlFile.CreateVertex(vector[0]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex2 = meshFromStlFile.CreateVertex(vector[1]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex3 = meshFromStlFile.CreateVertex(vector[2]' CreateOption.CreateNew' SortOption.WillSortLater);  						meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  					}  				}  				//uint numTriangles = System.BitConverter.ToSingle(fileContents' 80);  			}
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseFileContents,The following statement contains a magic number: if (first160BytesOfSTLFile.StartsWith("solid") && first160BytesOfSTLFile.Contains("facet"))  			{  				stlStream.Position = 0;  				StreamReader stlReader = new StreamReader(stlStream);  				int vectorIndex = 0;  				Vector3 vector0 = new Vector3(0' 0' 0);  				Vector3 vector1 = new Vector3(0' 0' 0);  				Vector3 vector2 = new Vector3(0' 0' 0);  				string line = stlReader.ReadLine();    				while (line != null)  				{  					line = line.Trim();  					if (line.StartsWith("vertex"))  					{  						vectorIndex++;  						switch (vectorIndex)  						{  							case 1:  								vector0 = Convert(line);  								break;    							case 2:  								vector1 = Convert(line);  								break;    							case 3:  								vector2 = Convert(line);  								if (!Vector3.Collinear(vector0' vector1' vector2))  								{  									Vertex vertex1 = meshFromStlFile.CreateVertex(vector0' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex2 = meshFromStlFile.CreateVertex(vector1' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex3 = meshFromStlFile.CreateVertex(vector2' CreateOption.CreateNew' SortOption.WillSortLater);  									meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  								}  								vectorIndex = 0;  								break;  						}  					}  					line = stlReader.ReadLine();    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(stlStream.Position / (double)bytesInFile * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}  				}  			}  			else  			{  				// load it as a binary stl  				// skip the first 80 bytes  				// read in the number of triangles  				stlStream.Position = 0;  				BinaryReader br = new BinaryReader(stlStream);  				byte[] fileContents = br.ReadBytes((int)stlStream.Length);  				int currentPosition = 80;  				uint numTriangles = System.BitConverter.ToUInt32(fileContents' currentPosition);  				long bytesForNormals = numTriangles * 3 * 4;  				long bytesForVertices = numTriangles * 3 * 4 * 3;  				long bytesForAttributs = numTriangles * 2;  				currentPosition += 4;  				long numBytesRequiredForVertexData = currentPosition + bytesForNormals + bytesForVertices + bytesForAttributs;  				if (fileContents.Length < numBytesRequiredForVertexData || numTriangles < 4)  				{  					stlStream.Close();  					return null;  				}  				Vector3[] vector = new Vector3[3];  				for (int i = 0; i < numTriangles; i++)  				{  					// skip the normal  					currentPosition += 3 * 4;  					for (int j = 0; j < 3; j++)  					{  						vector[j] = new Vector3(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4));  						currentPosition += 3 * 4;  					}  					currentPosition += 2; // skip the attribute    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(i / (double)numTriangles * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}    					if (!Vector3.Collinear(vector[0]' vector[1]' vector[2]))  					{  						Vertex vertex1 = meshFromStlFile.CreateVertex(vector[0]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex2 = meshFromStlFile.CreateVertex(vector[1]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex3 = meshFromStlFile.CreateVertex(vector[2]' CreateOption.CreateNew' SortOption.WillSortLater);  						meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  					}  				}  				//uint numTriangles = System.BitConverter.ToSingle(fileContents' 80);  			}
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseFileContents,The following statement contains a magic number: if (first160BytesOfSTLFile.StartsWith("solid") && first160BytesOfSTLFile.Contains("facet"))  			{  				stlStream.Position = 0;  				StreamReader stlReader = new StreamReader(stlStream);  				int vectorIndex = 0;  				Vector3 vector0 = new Vector3(0' 0' 0);  				Vector3 vector1 = new Vector3(0' 0' 0);  				Vector3 vector2 = new Vector3(0' 0' 0);  				string line = stlReader.ReadLine();    				while (line != null)  				{  					line = line.Trim();  					if (line.StartsWith("vertex"))  					{  						vectorIndex++;  						switch (vectorIndex)  						{  							case 1:  								vector0 = Convert(line);  								break;    							case 2:  								vector1 = Convert(line);  								break;    							case 3:  								vector2 = Convert(line);  								if (!Vector3.Collinear(vector0' vector1' vector2))  								{  									Vertex vertex1 = meshFromStlFile.CreateVertex(vector0' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex2 = meshFromStlFile.CreateVertex(vector1' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex3 = meshFromStlFile.CreateVertex(vector2' CreateOption.CreateNew' SortOption.WillSortLater);  									meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  								}  								vectorIndex = 0;  								break;  						}  					}  					line = stlReader.ReadLine();    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(stlStream.Position / (double)bytesInFile * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}  				}  			}  			else  			{  				// load it as a binary stl  				// skip the first 80 bytes  				// read in the number of triangles  				stlStream.Position = 0;  				BinaryReader br = new BinaryReader(stlStream);  				byte[] fileContents = br.ReadBytes((int)stlStream.Length);  				int currentPosition = 80;  				uint numTriangles = System.BitConverter.ToUInt32(fileContents' currentPosition);  				long bytesForNormals = numTriangles * 3 * 4;  				long bytesForVertices = numTriangles * 3 * 4 * 3;  				long bytesForAttributs = numTriangles * 2;  				currentPosition += 4;  				long numBytesRequiredForVertexData = currentPosition + bytesForNormals + bytesForVertices + bytesForAttributs;  				if (fileContents.Length < numBytesRequiredForVertexData || numTriangles < 4)  				{  					stlStream.Close();  					return null;  				}  				Vector3[] vector = new Vector3[3];  				for (int i = 0; i < numTriangles; i++)  				{  					// skip the normal  					currentPosition += 3 * 4;  					for (int j = 0; j < 3; j++)  					{  						vector[j] = new Vector3(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4));  						currentPosition += 3 * 4;  					}  					currentPosition += 2; // skip the attribute    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(i / (double)numTriangles * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}    					if (!Vector3.Collinear(vector[0]' vector[1]' vector[2]))  					{  						Vertex vertex1 = meshFromStlFile.CreateVertex(vector[0]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex2 = meshFromStlFile.CreateVertex(vector[1]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex3 = meshFromStlFile.CreateVertex(vector[2]' CreateOption.CreateNew' SortOption.WillSortLater);  						meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  					}  				}  				//uint numTriangles = System.BitConverter.ToSingle(fileContents' 80);  			}
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseFileContents,The following statement contains a magic number: if (first160BytesOfSTLFile.StartsWith("solid") && first160BytesOfSTLFile.Contains("facet"))  			{  				stlStream.Position = 0;  				StreamReader stlReader = new StreamReader(stlStream);  				int vectorIndex = 0;  				Vector3 vector0 = new Vector3(0' 0' 0);  				Vector3 vector1 = new Vector3(0' 0' 0);  				Vector3 vector2 = new Vector3(0' 0' 0);  				string line = stlReader.ReadLine();    				while (line != null)  				{  					line = line.Trim();  					if (line.StartsWith("vertex"))  					{  						vectorIndex++;  						switch (vectorIndex)  						{  							case 1:  								vector0 = Convert(line);  								break;    							case 2:  								vector1 = Convert(line);  								break;    							case 3:  								vector2 = Convert(line);  								if (!Vector3.Collinear(vector0' vector1' vector2))  								{  									Vertex vertex1 = meshFromStlFile.CreateVertex(vector0' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex2 = meshFromStlFile.CreateVertex(vector1' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex3 = meshFromStlFile.CreateVertex(vector2' CreateOption.CreateNew' SortOption.WillSortLater);  									meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  								}  								vectorIndex = 0;  								break;  						}  					}  					line = stlReader.ReadLine();    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(stlStream.Position / (double)bytesInFile * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}  				}  			}  			else  			{  				// load it as a binary stl  				// skip the first 80 bytes  				// read in the number of triangles  				stlStream.Position = 0;  				BinaryReader br = new BinaryReader(stlStream);  				byte[] fileContents = br.ReadBytes((int)stlStream.Length);  				int currentPosition = 80;  				uint numTriangles = System.BitConverter.ToUInt32(fileContents' currentPosition);  				long bytesForNormals = numTriangles * 3 * 4;  				long bytesForVertices = numTriangles * 3 * 4 * 3;  				long bytesForAttributs = numTriangles * 2;  				currentPosition += 4;  				long numBytesRequiredForVertexData = currentPosition + bytesForNormals + bytesForVertices + bytesForAttributs;  				if (fileContents.Length < numBytesRequiredForVertexData || numTriangles < 4)  				{  					stlStream.Close();  					return null;  				}  				Vector3[] vector = new Vector3[3];  				for (int i = 0; i < numTriangles; i++)  				{  					// skip the normal  					currentPosition += 3 * 4;  					for (int j = 0; j < 3; j++)  					{  						vector[j] = new Vector3(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4));  						currentPosition += 3 * 4;  					}  					currentPosition += 2; // skip the attribute    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(i / (double)numTriangles * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}    					if (!Vector3.Collinear(vector[0]' vector[1]' vector[2]))  					{  						Vertex vertex1 = meshFromStlFile.CreateVertex(vector[0]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex2 = meshFromStlFile.CreateVertex(vector[1]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex3 = meshFromStlFile.CreateVertex(vector[2]' CreateOption.CreateNew' SortOption.WillSortLater);  						meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  					}  				}  				//uint numTriangles = System.BitConverter.ToSingle(fileContents' 80);  			}
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseFileContents,The following statement contains a magic number: if (first160BytesOfSTLFile.StartsWith("solid") && first160BytesOfSTLFile.Contains("facet"))  			{  				stlStream.Position = 0;  				StreamReader stlReader = new StreamReader(stlStream);  				int vectorIndex = 0;  				Vector3 vector0 = new Vector3(0' 0' 0);  				Vector3 vector1 = new Vector3(0' 0' 0);  				Vector3 vector2 = new Vector3(0' 0' 0);  				string line = stlReader.ReadLine();    				while (line != null)  				{  					line = line.Trim();  					if (line.StartsWith("vertex"))  					{  						vectorIndex++;  						switch (vectorIndex)  						{  							case 1:  								vector0 = Convert(line);  								break;    							case 2:  								vector1 = Convert(line);  								break;    							case 3:  								vector2 = Convert(line);  								if (!Vector3.Collinear(vector0' vector1' vector2))  								{  									Vertex vertex1 = meshFromStlFile.CreateVertex(vector0' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex2 = meshFromStlFile.CreateVertex(vector1' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex3 = meshFromStlFile.CreateVertex(vector2' CreateOption.CreateNew' SortOption.WillSortLater);  									meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  								}  								vectorIndex = 0;  								break;  						}  					}  					line = stlReader.ReadLine();    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(stlStream.Position / (double)bytesInFile * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}  				}  			}  			else  			{  				// load it as a binary stl  				// skip the first 80 bytes  				// read in the number of triangles  				stlStream.Position = 0;  				BinaryReader br = new BinaryReader(stlStream);  				byte[] fileContents = br.ReadBytes((int)stlStream.Length);  				int currentPosition = 80;  				uint numTriangles = System.BitConverter.ToUInt32(fileContents' currentPosition);  				long bytesForNormals = numTriangles * 3 * 4;  				long bytesForVertices = numTriangles * 3 * 4 * 3;  				long bytesForAttributs = numTriangles * 2;  				currentPosition += 4;  				long numBytesRequiredForVertexData = currentPosition + bytesForNormals + bytesForVertices + bytesForAttributs;  				if (fileContents.Length < numBytesRequiredForVertexData || numTriangles < 4)  				{  					stlStream.Close();  					return null;  				}  				Vector3[] vector = new Vector3[3];  				for (int i = 0; i < numTriangles; i++)  				{  					// skip the normal  					currentPosition += 3 * 4;  					for (int j = 0; j < 3; j++)  					{  						vector[j] = new Vector3(  							System.BitConverter.ToSingle(fileContents' currentPosition + 0 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 1 * 4)'  							System.BitConverter.ToSingle(fileContents' currentPosition + 2 * 4));  						currentPosition += 3 * 4;  					}  					currentPosition += 2; // skip the attribute    					if (reportProgress != null && maxProgressReport.ElapsedMilliseconds > 200)  					{  						bool continueProcessing;  						reportProgress(i / (double)numTriangles * parsingFileRatio' "Loading Polygons"' out continueProcessing);  						if (!continueProcessing)  						{  							stlStream.Close();  							return null;  						}  						maxProgressReport.Restart();  					}    					if (!Vector3.Collinear(vector[0]' vector[1]' vector[2]))  					{  						Vertex vertex1 = meshFromStlFile.CreateVertex(vector[0]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex2 = meshFromStlFile.CreateVertex(vector[1]' CreateOption.CreateNew' SortOption.WillSortLater);  						Vertex vertex3 = meshFromStlFile.CreateVertex(vector[2]' CreateOption.CreateNew' SortOption.WillSortLater);  						meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  					}  				}  				//uint numTriangles = System.BitConverter.ToSingle(fileContents' 80);  			}
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseLine,The following statement contains a magic number: goodParse &= double.TryParse(splitOnSpace[2]' out vertexPosition.y);
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseLine,The following statement contains a magic number: goodParse &= double.TryParse(splitOnSpace[3]' out vertexPosition.z);
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,IsBinary,The following statement contains a magic number: try  			{  				using (Stream stlStream = new FileStream(fileName' FileMode.Open' FileAccess.Read))  				{  					long bytesInFile = stlStream.Length;  					if (bytesInFile <= 80)  					{  						return false;  					}    					byte[] first160Bytes = new byte[160];  					stlStream.Read(first160Bytes' 0' 160);  					byte[] ByteOredrMark = new byte[] { 0xEF' 0xBB' 0xBF };  					int startOfString = 0;  					if (first160Bytes[0] == ByteOredrMark[0] && first160Bytes[0] == ByteOredrMark[0] && first160Bytes[0] == ByteOredrMark[0])  					{  						startOfString = 3;  					}  					string first160BytesOfSTLFile = System.Text.Encoding.UTF8.GetString(first160Bytes' startOfString' first160Bytes.Length - startOfString);  					if (first160BytesOfSTLFile.StartsWith("solid") && first160BytesOfSTLFile.Contains("facet"))  					{  						return false;  					}  				}  			}  			catch (Exception e)   			{  				Debug.Print(e.Message);  				BreakInDebugger();  			}
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,IsBinary,The following statement contains a magic number: try  			{  				using (Stream stlStream = new FileStream(fileName' FileMode.Open' FileAccess.Read))  				{  					long bytesInFile = stlStream.Length;  					if (bytesInFile <= 80)  					{  						return false;  					}    					byte[] first160Bytes = new byte[160];  					stlStream.Read(first160Bytes' 0' 160);  					byte[] ByteOredrMark = new byte[] { 0xEF' 0xBB' 0xBF };  					int startOfString = 0;  					if (first160Bytes[0] == ByteOredrMark[0] && first160Bytes[0] == ByteOredrMark[0] && first160Bytes[0] == ByteOredrMark[0])  					{  						startOfString = 3;  					}  					string first160BytesOfSTLFile = System.Text.Encoding.UTF8.GetString(first160Bytes' startOfString' first160Bytes.Length - startOfString);  					if (first160BytesOfSTLFile.StartsWith("solid") && first160BytesOfSTLFile.Contains("facet"))  					{  						return false;  					}  				}  			}  			catch (Exception e)   			{  				Debug.Print(e.Message);  				BreakInDebugger();  			}
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,IsBinary,The following statement contains a magic number: try  			{  				using (Stream stlStream = new FileStream(fileName' FileMode.Open' FileAccess.Read))  				{  					long bytesInFile = stlStream.Length;  					if (bytesInFile <= 80)  					{  						return false;  					}    					byte[] first160Bytes = new byte[160];  					stlStream.Read(first160Bytes' 0' 160);  					byte[] ByteOredrMark = new byte[] { 0xEF' 0xBB' 0xBF };  					int startOfString = 0;  					if (first160Bytes[0] == ByteOredrMark[0] && first160Bytes[0] == ByteOredrMark[0] && first160Bytes[0] == ByteOredrMark[0])  					{  						startOfString = 3;  					}  					string first160BytesOfSTLFile = System.Text.Encoding.UTF8.GetString(first160Bytes' startOfString' first160Bytes.Length - startOfString);  					if (first160BytesOfSTLFile.StartsWith("solid") && first160BytesOfSTLFile.Contains("facet"))  					{  						return false;  					}  				}  			}  			catch (Exception e)   			{  				Debug.Print(e.Message);  				BreakInDebugger();  			}
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,IsBinary,The following statement contains a magic number: try  			{  				using (Stream stlStream = new FileStream(fileName' FileMode.Open' FileAccess.Read))  				{  					long bytesInFile = stlStream.Length;  					if (bytesInFile <= 80)  					{  						return false;  					}    					byte[] first160Bytes = new byte[160];  					stlStream.Read(first160Bytes' 0' 160);  					byte[] ByteOredrMark = new byte[] { 0xEF' 0xBB' 0xBF };  					int startOfString = 0;  					if (first160Bytes[0] == ByteOredrMark[0] && first160Bytes[0] == ByteOredrMark[0] && first160Bytes[0] == ByteOredrMark[0])  					{  						startOfString = 3;  					}  					string first160BytesOfSTLFile = System.Text.Encoding.UTF8.GetString(first160Bytes' startOfString' first160Bytes.Length - startOfString);  					if (first160BytesOfSTLFile.StartsWith("solid") && first160BytesOfSTLFile.Contains("facet"))  					{  						return false;  					}  				}  			}  			catch (Exception e)   			{  				Debug.Print(e.Message);  				BreakInDebugger();  			}
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,GetEstimatedMemoryUse,The following statement contains a magic number: try  			{  				using (Stream stream = new FileStream(fileLocation' FileMode.Open' FileAccess.Read))  				{  					if (IsBinary(fileLocation))  					{  						return (long)(stream.Length * 13.5);  					}  					else  					{  						return (long)(stream.Length * 2.5);  					}  				}  			}  			catch (Exception e)  			{  				Debug.Print(e.Message);  				BreakInDebugger();  				return 0;  			}
Magic Number,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,GetEstimatedMemoryUse,The following statement contains a magic number: try  			{  				using (Stream stream = new FileStream(fileLocation' FileMode.Open' FileAccess.Read))  				{  					if (IsBinary(fileLocation))  					{  						return (long)(stream.Length * 13.5);  					}  					else  					{  						return (long)(stream.Length * 2.5);  					}  				}  			}  			catch (Exception e)  			{  				Debug.Print(e.Message);  				BreakInDebugger();  				return 0;  			}
Magic Number,MatterHackers.PolygonMesh.Rendering,OrthographicZProjection,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Rendering\OrthographicZProjection.cs,DrawTo,The following statement contains a magic number: graphics2D.Rasterizer.gamma(new gamma_power(.3));
Missing Default,MatterHackers.PolygonMesh.Csg,CsgAcceleratedMesh,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Csg\CsgProcessing.cs,SplitOnAllEdgeIntersections,The following switch statement is missing a default case: switch (face.Intersection(ray' out intersectionPosition))  					{  						case FaceHelper.IntersectionType.Vertex:  							break;    						case FaceHelper.IntersectionType.MeshEdge:  							{  								SplitMeshEdge(meshEdge' intersectionPosition);  								// split the face at intersectionPosition  								SplitMeshEdgeAtPosition(face' intersectionPosition);  							}  							break;    						case FaceHelper.IntersectionType.Face:  							{  								SplitMeshEdge(meshEdge' intersectionPosition);  								// split the face at intersectionPosition  								SplitFaceAtPosition(face' intersectionPosition);  							}  							break;  					}
Missing Default,MatterHackers.PolygonMesh,Face,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Face.cs,WrapQuadrantDelta,The following switch statement is missing a default case: switch (delta)  			{  				// make quadrant deltas wrap around  				case 3:  					return -1;    				case -3:  					return 1;    				// check if went around point cw or ccw  				case 2:  				case -2:  					if (GetXIntersept(prevPosition' position' y) > x)  					{  						return -delta;  					}  					break;  			}
Missing Default,MatterHackers.PolygonMesh,CommonShapes,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Solids\CommonShapes.cs,PlaceTextureOnFace,The following switch statement is missing a default case: switch (count++)  				{  					case 0:  						edgeUV.TextureUV.Add(new Vector2(0' 0));  						break;    					case 1:  						edgeUV.TextureUV.Add(new Vector2(1' 0));  						break;    					case 2:  						edgeUV.TextureUV.Add(new Vector2(1' 1));  						break;    					case 3:  						edgeUV.TextureUV.Add(new Vector2(0' 1));  						break;  				}
Missing Default,MatterHackers.PolygonMesh.Processors,AmfProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\AmfProcessing.cs,ReadMesh,The following switch statement is missing a default case: switch (xmlTree.Name)  				{  					case "vertices":  						using (XmlReader verticesTree = xmlTree.ReadSubtree())  						{  							ReadVertices(verticesTree' vertices' scale' progressData);  							if (progressData.LoadCanceled)  							{  								return;  							}  						}  						break;    					case "volume":  						string materialId = xmlTree["materialid"];  						Mesh loadedMesh = null;  						using (XmlReader volumeTree = xmlTree.ReadSubtree())  						{  							loadedMesh = ReadVolume(volumeTree' vertices' progressData);  							if (progressData.LoadCanceled)  							{  								return;  							}  							meshGroup.Meshes.Add(loadedMesh);  						}  						if (loadedMesh != null && materialId != null)  						{  							MeshMaterialData material = MeshMaterialData.Get(loadedMesh);  							material.MaterialIndex = int.Parse(materialId);  						}  						break;  				}
Missing Default,MatterHackers.PolygonMesh.Processors,MeshFileIo,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\MeshFileIo.cs,GetEstimatedMemoryUse,The following switch statement is missing a default case: switch (Path.GetExtension(fileLocation).ToUpper())  			{  				case ".STL":  					return StlProcessing.GetEstimatedMemoryUse(fileLocation);    				case ".AMF":  					return AmfProcessing.GetEstimatedMemoryUse(fileLocation);  			}
Missing Default,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,Save,The following switch statement is missing a default case: switch (outputInfo.OutputTypeSetting)  			{  				case MeshOutputSettings.OutputType.Ascii:  					{  						StreamWriter streamWriter = new StreamWriter(stream);    						streamWriter.WriteLine("solid Default");    						foreach (Face face in meshToSave.Faces)  						{  							List<Vector3> positionsCCW = new List<Vector3>();  							foreach (FaceEdge faceEdge in face.FaceEdges())  							{  								positionsCCW.Add(faceEdge.firstVertex.Position);  							}    							int numPolys = positionsCCW.Count - 2;  							int secondIndex = 1;  							int thirdIndex = 2;  							for (int polyIndex = 0; polyIndex < numPolys; polyIndex++)  							{  								streamWriter.WriteLine("  facet normal " + FormatForStl(face.normal));  								streamWriter.WriteLine("    outer loop");  								streamWriter.WriteLine("      vertex " + FormatForStl(positionsCCW[0]));  								streamWriter.WriteLine("      vertex " + FormatForStl(positionsCCW[secondIndex]));  								streamWriter.WriteLine("      vertex " + FormatForStl(positionsCCW[thirdIndex]));  								streamWriter.WriteLine("    endloop");  								streamWriter.WriteLine("  endfacet");    								secondIndex = thirdIndex;  								thirdIndex++;  							}  						}    						streamWriter.WriteLine("endsolid Default");    						streamWriter.Close();  					}  					break;    				case MeshOutputSettings.OutputType.Binary:  					using (BinaryWriter bw = new BinaryWriter(stream))  					{  						// 80 bytes of nothing  						bw.Write(new Byte[80]);  						// the number of tranigles  						bw.Write(meshToSave.Faces.Count);  						int binaryPolyCount = 0;  						foreach (Face face in meshToSave.Faces)  						{  							List<Vector3> positionsCCW = new List<Vector3>();  							foreach (FaceEdge faceEdge in face.FaceEdges())  							{  								positionsCCW.Add(faceEdge.firstVertex.Position);  							}    							int numPolys = positionsCCW.Count - 2;  							int secondIndex = 1;  							int thirdIndex = 2;  							for (int polyIndex = 0; polyIndex < numPolys; polyIndex++)  							{  								binaryPolyCount++;  								// save the normal (all 0 so it can compress better)  								bw.Write((float)0);  								bw.Write((float)0);  								bw.Write((float)0);  								// save the position  								bw.Write((float)positionsCCW[0].x); bw.Write((float)positionsCCW[0].y); bw.Write((float)positionsCCW[0].z);  								bw.Write((float)positionsCCW[secondIndex].x); bw.Write((float)positionsCCW[secondIndex].y); bw.Write((float)positionsCCW[secondIndex].z);  								bw.Write((float)positionsCCW[thirdIndex].x); bw.Write((float)positionsCCW[thirdIndex].y); bw.Write((float)positionsCCW[thirdIndex].z);    								// and the attribute  								bw.Write((ushort)0);    								secondIndex = thirdIndex;  								thirdIndex++;  							}  						}  						bw.BaseStream.Position = 80;  						// the number of tranigles  						bw.Write(binaryPolyCount);  					}  					break;  			}
Missing Default,MatterHackers.PolygonMesh.Processors,StlProcessing,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Processors\StlProcessing.cs,ParseFileContents,The following switch statement is missing a default case: switch (vectorIndex)  						{  							case 1:  								vector0 = Convert(line);  								break;    							case 2:  								vector1 = Convert(line);  								break;    							case 3:  								vector2 = Convert(line);  								if (!Vector3.Collinear(vector0' vector1' vector2))  								{  									Vertex vertex1 = meshFromStlFile.CreateVertex(vector0' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex2 = meshFromStlFile.CreateVertex(vector1' CreateOption.CreateNew' SortOption.WillSortLater);  									Vertex vertex3 = meshFromStlFile.CreateVertex(vector2' CreateOption.CreateNew' SortOption.WillSortLater);  									meshFromStlFile.CreateFace(new Vertex[] { vertex1' vertex2' vertex3 }' CreateOption.CreateNew);  								}  								vectorIndex = 0;  								break;  						}
