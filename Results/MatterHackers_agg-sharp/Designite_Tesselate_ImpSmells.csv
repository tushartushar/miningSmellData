Implementation smell,Namespace,Class,File,Method,Description
Long Method,Tesselate,ActiveRegion,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\ActiveRegion.cs,CheckForIntersect,The method has 175 lines of code.
Long Method,Tesselate,Mesh,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\mesh.cs,CheckMesh,The method has 122 lines of code.
Complex Method,Tesselate,ActiveRegion,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\ActiveRegion.cs,AddRightEdges,Cyclomatic complexity of the method is 8
Complex Method,Tesselate,ActiveRegion,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\ActiveRegion.cs,EdgeIntersect,Cyclomatic complexity of the method is 15
Complex Method,Tesselate,ActiveRegion,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\ActiveRegion.cs,CheckForIntersect,Cyclomatic complexity of the method is 23
Complex Method,Tesselate,ActiveRegion,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\ActiveRegion.cs,WalkDirtyRegions,Cyclomatic complexity of the method is 13
Complex Method,Tesselate,Face,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\Face.cs,TessellateMonoRegion,Cyclomatic complexity of the method is 10
Complex Method,Tesselate,Mesh,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\mesh.cs,CheckMesh,Cyclomatic complexity of the method is 16
Complex Method,Tesselate,Tesselator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\Tesselator.cs,EndPolygon,Cyclomatic complexity of the method is 8
Complex Method,Tesselate,Tesselator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\Tesselator.cs,RenderCache,Cyclomatic complexity of the method is 12
Complex Method,Tesselate,Tesselator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\Tesselator.cs,RenderMaximumFaceGroup,Cyclomatic complexity of the method is 8
Long Parameter List,Tesselate,ActiveRegion,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\ActiveRegion.cs,AddRightEdges,The method has 6 parameters. Parameters: tess' regUp' eFirst' eLast' eTopLeft' cleanUp
Long Parameter List,Tesselate,ActiveRegion,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\ActiveRegion.cs,CallCombine,The method has 5 parameters. Parameters: tess' intersectionVertex' vertexIndexArray' vertexWeights' needed
Long Parameter List,Tesselate,ActiveRegion,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\ActiveRegion.cs,VertexWeights,The method has 5 parameters. Parameters: isect' org' dst' weights0' weights1
Long Parameter List,Tesselate,ActiveRegion,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\ActiveRegion.cs,GetIntersectData,The method has 6 parameters. Parameters: tess' isect' orgUp' dstUp' orgLo' dstLo
Long Parameter List,Tesselate,ActiveRegion,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\ActiveRegion.cs,EdgeIntersect,The method has 5 parameters. Parameters: o1' d1' o2' d2' v
Long Statement,Tesselate,ActiveRegion,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\ActiveRegion.cs,RemoveDegenerateEdges,The length of the statement  "					if (currentEdge == nextHalfEdge || currentEdge == nextHalfEdge.otherHalfOfThisEdge) { nextHalfEdge = nextHalfEdge.nextHalfEdge; } " is 129.
Complex Conditional,Tesselate,ActiveRegion,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\ActiveRegion.cs,CheckForIntersect,The conditional expression  "(!dstUp.VertEq(tess.CurrentSweepVertex)  				&& ContourVertex.EdgeSign(dstUp' tess.CurrentSweepVertex' isect) >= 0)  				|| (!dstLo.VertEq(tess.CurrentSweepVertex)  				&& ContourVertex.EdgeSign(dstLo' tess.CurrentSweepVertex' isect) <= 0)"  is complex.
Complex Conditional,Tesselate,ActiveRegion,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\ActiveRegion.cs,WalkDirtyRegions,The conditional expression  "eUp.directionVertex != eLo.directionVertex  					&& !regUp.fixUpperEdge && !regLo.fixUpperEdge  					&& (eUp.directionVertex == tess.CurrentSweepVertex || eLo.directionVertex == tess.CurrentSweepVertex)"  is complex.
Complex Conditional,Tesselate,Mesh,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\mesh.cs,CheckMesh,The conditional expression  "e.otherHalfOfThisEdge.nextHalfEdge != ePrev.otherHalfOfThisEdge  				|| e.otherHalfOfThisEdge != this.otherHalfOfThisEdgeHead  				|| e.otherHalfOfThisEdge.otherHalfOfThisEdge != e  				|| e.originVertex != null || e.directionVertex != null  				|| e.leftFace != null || e.rightFace != null"  is complex.
Complex Conditional,Tesselate,Tesselator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\Tesselator.cs,EndPolygon,The conditional expression  "this.callBegin != null || this.callEnd != null  				|| this.callVertex != null || this.callEdgeFlag != null"  is complex.
Magic Number,Tesselate,ActiveRegion,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\ActiveRegion.cs,CallCombine,The following statement contains a magic number: double[] coords = new double[3];
Magic Number,Tesselate,ActiveRegion,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\ActiveRegion.cs,CallCombine,The following statement contains a magic number: coords[2] = intersectionVertex.coords[2];
Magic Number,Tesselate,ActiveRegion,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\ActiveRegion.cs,CallCombine,The following statement contains a magic number: coords[2] = intersectionVertex.coords[2];
Magic Number,Tesselate,ActiveRegion,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\ActiveRegion.cs,SpliceMergeVertices,The following statement contains a magic number: int[] data4 = new int[4];
Magic Number,Tesselate,ActiveRegion,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\ActiveRegion.cs,SpliceMergeVertices,The following statement contains a magic number: double[] weights4 = new double[] { 0.5f' 0.5f' 0' 0 };
Magic Number,Tesselate,ActiveRegion,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\ActiveRegion.cs,SpliceMergeVertices,The following statement contains a magic number: double[] weights4 = new double[] { 0.5f' 0.5f' 0' 0 };
Magic Number,Tesselate,ActiveRegion,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\ActiveRegion.cs,VertexWeights,The following statement contains a magic number: weights0 = 0.5 * t2 / (t1 + t2);
Magic Number,Tesselate,ActiveRegion,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\ActiveRegion.cs,VertexWeights,The following statement contains a magic number: weights1 = 0.5 * t1 / (t1 + t2);
Magic Number,Tesselate,ActiveRegion,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\ActiveRegion.cs,VertexWeights,The following statement contains a magic number: isect.coords[2] += weights0 * org.coords[2] + weights1 * dst.coords[2];
Magic Number,Tesselate,ActiveRegion,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\ActiveRegion.cs,VertexWeights,The following statement contains a magic number: isect.coords[2] += weights0 * org.coords[2] + weights1 * dst.coords[2];
Magic Number,Tesselate,ActiveRegion,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\ActiveRegion.cs,VertexWeights,The following statement contains a magic number: isect.coords[2] += weights0 * org.coords[2] + weights1 * dst.coords[2];
Magic Number,Tesselate,ActiveRegion,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\ActiveRegion.cs,GetIntersectData,The following statement contains a magic number: int[] data4 = new int[4];
Magic Number,Tesselate,ActiveRegion,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\ActiveRegion.cs,GetIntersectData,The following statement contains a magic number: double[] weights4 = new double[4];
Magic Number,Tesselate,ActiveRegion,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\ActiveRegion.cs,GetIntersectData,The following statement contains a magic number: data4[2] = orgLo.ClientIndex;
Magic Number,Tesselate,ActiveRegion,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\ActiveRegion.cs,GetIntersectData,The following statement contains a magic number: data4[3] = dstLo.ClientIndex;
Magic Number,Tesselate,ActiveRegion,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\ActiveRegion.cs,GetIntersectData,The following statement contains a magic number: isect.coords[0] = isect.coords[1] = isect.coords[2] = 0;
Magic Number,Tesselate,ActiveRegion,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\ActiveRegion.cs,GetIntersectData,The following statement contains a magic number: VertexWeights(isect' orgLo' dstLo' out weights4[2]' out weights4[3]);
Magic Number,Tesselate,ActiveRegion,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\ActiveRegion.cs,GetIntersectData,The following statement contains a magic number: VertexWeights(isect' orgLo' dstLo' out weights4[2]' out weights4[3]);
Magic Number,Tesselate,ActiveRegion,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\ActiveRegion.cs,Interpolate,The following statement contains a magic number: return (x + y) / 2;
Magic Number,Tesselate,ActiveRegion,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\ActiveRegion.cs,EdgeIntersect,The following statement contains a magic number: v.x = (o2.x + d1.x) / 2;
Magic Number,Tesselate,ActiveRegion,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\ActiveRegion.cs,EdgeIntersect,The following statement contains a magic number: v.y = (o2.y + d1.y) / 2;
Magic Number,Tesselate,Tesselator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\Tesselator.cs,IsWindingInside,The following statement contains a magic number: switch (this.windingRule)  			{  				case Tesselator.WindingRuleType.Odd:  					return (numCrossings & 1) != 0;    				case Tesselator.WindingRuleType.NonZero:  					return (numCrossings != 0);    				case Tesselator.WindingRuleType.Positive:  					return (numCrossings > 0);    				case Tesselator.WindingRuleType.Negative:  					return (numCrossings < 0);    				case Tesselator.WindingRuleType.ABS_GEQ_Two:  					return (numCrossings >= 2) || (numCrossings <= -2);  			}
Magic Number,Tesselate,Tesselator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\Tesselator.cs,IsWindingInside,The following statement contains a magic number: switch (this.windingRule)  			{  				case Tesselator.WindingRuleType.Odd:  					return (numCrossings & 1) != 0;    				case Tesselator.WindingRuleType.NonZero:  					return (numCrossings != 0);    				case Tesselator.WindingRuleType.Positive:  					return (numCrossings > 0);    				case Tesselator.WindingRuleType.Negative:  					return (numCrossings < 0);    				case Tesselator.WindingRuleType.ABS_GEQ_Two:  					return (numCrossings >= 2) || (numCrossings <= -2);  			}
Magic Number,Tesselate,Tesselator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\Tesselator.cs,RenderCache,The following statement contains a magic number: double[] norm3 = new double[3];
Magic Number,Tesselate,Tesselator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\Tesselator.cs,RenderCache,The following statement contains a magic number: this.cacheCount < 3
Magic Number,Tesselate,Tesselator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\Tesselator.cs,RenderCache,The following statement contains a magic number: norm3[2] = 1;
Magic Number,Tesselate,Tesselator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\Tesselator.cs,RenderCache,The following statement contains a magic number: this.CallBegin(this.BoundaryOnly ? Tesselator.TriangleListType.LineLoop  				: (this.cacheCount > 3) ? Tesselator.TriangleListType.TriangleFan  				: Tesselator.TriangleListType.Triangles);
Magic Number,Tesselate,Tesselator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\Tesselator.cs,ComputeNormal,The following statement contains a magic number: double[] n = new double[3];
Magic Number,Tesselate,Tesselator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\Tesselator.cs,ComputeNormal,The following statement contains a magic number: n[2] = xp * yc - yp * xc;
Magic Number,Tesselate,Tesselator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\Tesselator.cs,ComputeNormal,The following statement contains a magic number: dot = n[0] * norm3[0] + n[1] * norm3[1] + n[2] * norm3[2];
Magic Number,Tesselate,Tesselator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\Tesselator.cs,ComputeNormal,The following statement contains a magic number: dot = n[0] * norm3[0] + n[1] * norm3[1] + n[2] * norm3[2];
Missing Default,Tesselate,Tesselator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\Tesselator.cs,IsWindingInside,The following switch statement is missing a default case: switch (this.windingRule)  			{  				case Tesselator.WindingRuleType.Odd:  					return (numCrossings & 1) != 0;    				case Tesselator.WindingRuleType.NonZero:  					return (numCrossings != 0);    				case Tesselator.WindingRuleType.Positive:  					return (numCrossings > 0);    				case Tesselator.WindingRuleType.Negative:  					return (numCrossings < 0);    				case Tesselator.WindingRuleType.ABS_GEQ_Two:  					return (numCrossings >= 2) || (numCrossings <= -2);  			}
Missing Default,Tesselate,Tesselator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Tesselate\Tesselator.cs,RenderCache,The following switch statement is missing a default case: switch (this.windingRule)  			{  				case Tesselator.WindingRuleType.Odd:  				case Tesselator.WindingRuleType.NonZero:  					break;    				case Tesselator.WindingRuleType.Positive:  					if (sign < 0) return true;  					break;    				case Tesselator.WindingRuleType.Negative:  					if (sign > 0) return true;  					break;    				case Tesselator.WindingRuleType.ABS_GEQ_Two:  					return true;  			}
