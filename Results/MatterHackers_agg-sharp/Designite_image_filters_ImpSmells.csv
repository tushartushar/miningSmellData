Implementation smell,Namespace,Class,File,Method,Description
Long Method,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The method has 193 lines of code.
Complex Method,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,Cyclomatic complexity of the method is 24
Long Statement,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,OnParentChanged,The length of the statement  "				image_filters.m_TempDestImage = new ImageBufferFloat(tempImageToLoadInto.Width' tempImageToLoadInto.Height' 128' new BlenderBGRAFloat()); " is 137.
Long Statement,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,OnParentChanged,The length of the statement  "				image_filters.m_TempDestImage = new ImageBuffer(tempImageToLoadInto.Width' tempImageToLoadInto.Height' 32' new BlenderBGRA()); " is 126.
Long Statement,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The length of the statement  "            ImageBufferAccessorClipFloat source = new ImageBufferAccessorClipFloat(m_RotatedImage' RGBA_Floats.rgba_pre(0'0'0'0).ToColorF()); " is 129.
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_step = new Slider(new Vector2(115' 5)' new Vector2(285' 6));
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_step = new Slider(new Vector2(115' 5)' new Vector2(285' 6));
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_step = new Slider(new Vector2(115' 5)' new Vector2(285' 6));
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_step = new Slider(new Vector2(115' 5)' new Vector2(285' 6));
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_radius = new Slider(new Vector2(115' 5 + 15)' new Vector2(285' 6));
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_radius = new Slider(new Vector2(115' 5 + 15)' new Vector2(285' 6));
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_radius = new Slider(new Vector2(115' 5 + 15)' new Vector2(285' 6));
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_radius = new Slider(new Vector2(115' 5 + 15)' new Vector2(285' 6));
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_radius = new Slider(new Vector2(115' 5 + 15)' new Vector2(285' 6));
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: filterSelectionButtons = new RadioButtonGroup(new Vector2(0.0' 10.0)' new Vector2(110.0' 210.0));
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: filterSelectionButtons = new RadioButtonGroup(new Vector2(0.0' 10.0)' new Vector2(110.0' 210.0));
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: filterSelectionButtons = new RadioButtonGroup(new Vector2(0.0' 10.0)' new Vector2(110.0' 210.0));
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_normalize = new CheckBox(8.0' 215.0' "Normalize Filter");
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_normalize = new CheckBox(8.0' 215.0' "Normalize Filter");
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_refresh = new Button(8.0' 273.0' new ButtonViewText("Refresh"' 8' 1' 3));
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_refresh = new Button(8.0' 273.0' new ButtonViewText("Refresh"' 8' 1' 3));
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_refresh = new Button(8.0' 273.0' new ButtonViewText("Refresh"' 8' 1' 3));
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_refresh = new Button(8.0' 273.0' new ButtonViewText("Refresh"' 8' 1' 3));
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_run = new Button(8.0' 253.0' new ButtonViewText("RUN Test!"' 8' 1' 3));
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_run = new Button(8.0' 253.0' new ButtonViewText("RUN Test!"' 8' 1' 3));
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_run = new Button(8.0' 253.0' new ButtonViewText("RUN Test!"' 8' 1' 3));
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_run = new Button(8.0' 253.0' new ButtonViewText("RUN Test!"' 8' 1' 3));
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_single_step = new Button(8.0' 233.0' new ButtonViewText("Single Step"' 8' 1' 3));
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_single_step = new Button(8.0' 233.0' new ButtonViewText("Single Step"' 8' 1' 3));
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_single_step = new Button(8.0' 233.0' new ButtonViewText("Single Step"' 8' 1' 3));
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_single_step = new Button(8.0' 233.0' new ButtonViewText("Single Step"' 8' 1' 3));
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_radius.SetRange(2.0' 8.0);
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_radius.SetRange(2.0' 8.0);
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_radius.Value = 4.0;
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_step.SetRange(1.0' 10.0);
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_step.Value = 5.0;
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: filterSelectionButtons.background_color(new ColorF(0.0' 0.0' 0.0' 0.1));
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,OnDraw,The following statement contains a magic number: clippingProxy.CopyFrom(m_TempDestImage' new RectangleInt(0' 0' (int)Width' (int)Height)' 110' 35);
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,OnDraw,The following statement contains a magic number: clippingProxy.CopyFrom(m_TempDestImage' new RectangleInt(0' 0' (int)Width' (int)Height)' 110' 35);
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,OnDraw,The following statement contains a magic number: t.start_point(200.0' 430);
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,OnDraw,The following statement contains a magic number: t.start_point(200.0' 430);
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,OnDraw,The following statement contains a magic number: t.SetFontSize(10.0);
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,OnDraw,The following statement contains a magic number: pt.Width = 1.5;
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,OnDraw,The following statement contains a magic number: t.start_point(200.0' 450);
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,OnDraw,The following statement contains a magic number: t.start_point(200.0' 450);
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,OnDraw,The following statement contains a magic number: filterSelectionButtons.SelectedIndex >= 14
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: src_mtx *= Affine.NewTranslation(-width / 2.0' -height / 2.0);
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: src_mtx *= Affine.NewTranslation(-width / 2.0' -height / 2.0);
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: src_mtx *= Affine.NewRotation(angle * Math.PI / 180.0);
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: src_mtx *= Affine.NewTranslation(width / 2.0' height / 2.0);
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: src_mtx *= Affine.NewTranslation(width / 2.0' height / 2.0);
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: r *= 0.5;
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: r -= 4.0;
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: VertexSource.Ellipse ell = new MatterHackers.Agg.VertexSource.Ellipse(width / 2.0' height / 2.0' r' r' 200);
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: VertexSource.Ellipse ell = new MatterHackers.Agg.VertexSource.Ellipse(width / 2.0' height / 2.0' r' r' 200);
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: VertexSource.Ellipse ell = new MatterHackers.Agg.VertexSource.Ellipse(width / 2.0' height / 2.0' r' r' 200);
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,OnIdle,The following statement contains a magic number: UiThread.RunOnIdle(OnIdle' .1);
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,OnIdle,The following statement contains a magic number: m_cur_angle < 360.0
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,Main,The following statement contains a magic number: var systemWindow = new SystemWindow(305' 325);
Magic Number,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,Main,The following statement contains a magic number: var systemWindow = new SystemWindow(305' 325);
Missing Default,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following switch statement is missing a default case: switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}
Missing Default,MatterHackers.Agg,image_filters,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following switch statement is missing a default case: switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}
