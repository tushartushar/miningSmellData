Implementation smell,Namespace,Class,File,Method,Description
Long Method,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The method has 193 lines of code.
Long Statement,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,OnParentChanged,The length of the statement  "				image_filters.m_TempDestImage = new ImageBufferFloat(tempImageToLoadInto.Width' tempImageToLoadInto.Height' 128' new BlenderBGRAFloat()); " is 137.
Long Statement,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,OnParentChanged,The length of the statement  "				image_filters.m_TempDestImage = new ImageBuffer(tempImageToLoadInto.Width' tempImageToLoadInto.Height' 32' new BlenderBGRA()); " is 126.
Long Statement,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The length of the statement  "            ImageBufferAccessorClipFloat source = new ImageBufferAccessorClipFloat(m_RotatedImage' RGBA_Floats.rgba_pre(0'0'0'0).GetAsRGBA_Floats()); " is 137.
Long Statement,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The length of the statement  "			ImageBufferAccessorClip source = new ImageBufferAccessorClip(m_RotatedImage' RGBA_Floats.rgba_pre(0' 0' 0' 0).GetAsRGBA_Bytes()); " is 129.
Long Statement,MatterHackers.Agg,ImageFiltersFactory,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,GetAppParameters,The length of the statement  "			"The image transformer algorithm can work with different interpolation filters' such as Bilinear' Bicubic' Sinc' Blackman. The example demonstrates the difference in quality between different filters. When switch the �Run Test� on' the image starts rotating. But at each step there is the previously rotated image taken' so the quality degrades. This degradation as well as the performance depend on the type of the interpolation filter."' " is 439.
Virtual Method Call from Constructor,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The constructor "image_filters" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The constructor "image_filters" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The constructor "image_filters" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The constructor "image_filters" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The constructor "image_filters" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The constructor "image_filters" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The constructor "image_filters" calls a virtual method "AddChild".
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_step = new Slider(new Vector2(115' 5)' new Vector2(285' 6));
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_step = new Slider(new Vector2(115' 5)' new Vector2(285' 6));
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_step = new Slider(new Vector2(115' 5)' new Vector2(285' 6));
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_step = new Slider(new Vector2(115' 5)' new Vector2(285' 6));
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_radius = new Slider(new Vector2(115' 5 + 15)' new Vector2(285' 6));
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_radius = new Slider(new Vector2(115' 5 + 15)' new Vector2(285' 6));
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_radius = new Slider(new Vector2(115' 5 + 15)' new Vector2(285' 6));
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_radius = new Slider(new Vector2(115' 5 + 15)' new Vector2(285' 6));
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_radius = new Slider(new Vector2(115' 5 + 15)' new Vector2(285' 6));
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: filterSelectionButtons = new RadioButtonGroup(new Vector2(0.0' 10.0)' new Vector2(110.0' 210.0));
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: filterSelectionButtons = new RadioButtonGroup(new Vector2(0.0' 10.0)' new Vector2(110.0' 210.0));
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: filterSelectionButtons = new RadioButtonGroup(new Vector2(0.0' 10.0)' new Vector2(110.0' 210.0));
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_normalize = new CheckBox(8.0' 215.0' "Normalize Filter");
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_normalize = new CheckBox(8.0' 215.0' "Normalize Filter");
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_refresh = new Button(8.0' 273.0' new ButtonViewText("Refresh"' 8' 1' 3));
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_refresh = new Button(8.0' 273.0' new ButtonViewText("Refresh"' 8' 1' 3));
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_refresh = new Button(8.0' 273.0' new ButtonViewText("Refresh"' 8' 1' 3));
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_refresh = new Button(8.0' 273.0' new ButtonViewText("Refresh"' 8' 1' 3));
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_run = new Button(8.0' 253.0' new ButtonViewText("RUN Test!"' 8' 1' 3));
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_run = new Button(8.0' 253.0' new ButtonViewText("RUN Test!"' 8' 1' 3));
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_run = new Button(8.0' 253.0' new ButtonViewText("RUN Test!"' 8' 1' 3));
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_run = new Button(8.0' 253.0' new ButtonViewText("RUN Test!"' 8' 1' 3));
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_single_step = new Button(8.0' 233.0' new ButtonViewText("Single Step"' 8' 1' 3));
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_single_step = new Button(8.0' 233.0' new ButtonViewText("Single Step"' 8' 1' 3));
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_single_step = new Button(8.0' 233.0' new ButtonViewText("Single Step"' 8' 1' 3));
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_single_step = new Button(8.0' 233.0' new ButtonViewText("Single Step"' 8' 1' 3));
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_radius.SetRange(2.0' 8.0);
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_radius.SetRange(2.0' 8.0);
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_radius.Value = 4.0;
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_step.SetRange(1.0' 10.0);
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: m_step.Value = 5.0;
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,image_filters,The following statement contains a magic number: filterSelectionButtons.background_color(new RGBA_Floats(0.0' 0.0' 0.0' 0.1));
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,OnParentChanged,The following statement contains a magic number: if (!ImageIO.LoadImageData(img_name' tempImageToLoadInto))  			{  				string buf;  				buf = "File not found: "  					+ img_name  					+ ".bmp"  					+ ". Download http://www.antigrain.com/" + img_name + "\n"  					+ "or copy it from another directory if available.";  				MessageBox.ShowMessageBox(buf' "Missing Files");  			}  			else  			{  #if SourceDepth24                  image_filters.m_TempDestImage = new ImageBuffer(tempImageToLoadInto' new BlenderBGR());                    image_filters.m_RotatedImage = new ImageBuffer(image_filters.m_TempDestImage' new BlenderBGR());                  image_filters.m_OriginalImage = new ImageBuffer(image_filters.m_TempDestImage' new BlenderBGR());    				image_filters.m_TempDestImage.SetRecieveBlender(new BlenderPreMultBGR());  #else  #if SourceDepthFloat  				image_filters.m_TempDestImage = new ImageBufferFloat(tempImageToLoadInto.Width' tempImageToLoadInto.Height' 128' new BlenderBGRAFloat());  				image_filters.m_TempDestImage.CopyFrom(tempImageToLoadInto);    				image_filters.m_RotatedImage = new ImageBufferFloat(image_filters.m_TempDestImage' new BlenderBGRAFloat());  				image_filters.m_OriginalImage = new ImageBufferFloat(image_filters.m_TempDestImage' new BlenderBGRAFloat());    				//image_filters.m_TempDestImage.SetRecieveBlender(new BlenderBGRAFloat());  				image_filters.m_TempDestImage.SetRecieveBlender(new BlenderPreMultBGRAFloat());  #else  				image_filters.m_TempDestImage = new ImageBuffer(tempImageToLoadInto.Width' tempImageToLoadInto.Height' 32' new BlenderBGRA());  				image_filters.m_TempDestImage.CopyFrom(tempImageToLoadInto);    				image_filters.m_RotatedImage = new ImageBuffer(image_filters.m_TempDestImage' new BlenderBGRA());  				image_filters.m_OriginalImage = new ImageBuffer(image_filters.m_TempDestImage' new BlenderBGRA());    				image_filters.m_TempDestImage.SetRecieveBlender(new BlenderPreMultBGRA());  #endif  #endif    				int w = image_filters.m_TempDestImage.Width + 220;  				int h = image_filters.m_TempDestImage.Height + 200;    				if (w < 305) w = 305;  				if (h < 325) h = 325;    				Parent.LocalBounds = new RectangleDouble(0' 0' w' h);    				transform_image(0.0);  			}
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,OnParentChanged,The following statement contains a magic number: if (!ImageIO.LoadImageData(img_name' tempImageToLoadInto))  			{  				string buf;  				buf = "File not found: "  					+ img_name  					+ ".bmp"  					+ ". Download http://www.antigrain.com/" + img_name + "\n"  					+ "or copy it from another directory if available.";  				MessageBox.ShowMessageBox(buf' "Missing Files");  			}  			else  			{  #if SourceDepth24                  image_filters.m_TempDestImage = new ImageBuffer(tempImageToLoadInto' new BlenderBGR());                    image_filters.m_RotatedImage = new ImageBuffer(image_filters.m_TempDestImage' new BlenderBGR());                  image_filters.m_OriginalImage = new ImageBuffer(image_filters.m_TempDestImage' new BlenderBGR());    				image_filters.m_TempDestImage.SetRecieveBlender(new BlenderPreMultBGR());  #else  #if SourceDepthFloat  				image_filters.m_TempDestImage = new ImageBufferFloat(tempImageToLoadInto.Width' tempImageToLoadInto.Height' 128' new BlenderBGRAFloat());  				image_filters.m_TempDestImage.CopyFrom(tempImageToLoadInto);    				image_filters.m_RotatedImage = new ImageBufferFloat(image_filters.m_TempDestImage' new BlenderBGRAFloat());  				image_filters.m_OriginalImage = new ImageBufferFloat(image_filters.m_TempDestImage' new BlenderBGRAFloat());    				//image_filters.m_TempDestImage.SetRecieveBlender(new BlenderBGRAFloat());  				image_filters.m_TempDestImage.SetRecieveBlender(new BlenderPreMultBGRAFloat());  #else  				image_filters.m_TempDestImage = new ImageBuffer(tempImageToLoadInto.Width' tempImageToLoadInto.Height' 32' new BlenderBGRA());  				image_filters.m_TempDestImage.CopyFrom(tempImageToLoadInto);    				image_filters.m_RotatedImage = new ImageBuffer(image_filters.m_TempDestImage' new BlenderBGRA());  				image_filters.m_OriginalImage = new ImageBuffer(image_filters.m_TempDestImage' new BlenderBGRA());    				image_filters.m_TempDestImage.SetRecieveBlender(new BlenderPreMultBGRA());  #endif  #endif    				int w = image_filters.m_TempDestImage.Width + 220;  				int h = image_filters.m_TempDestImage.Height + 200;    				if (w < 305) w = 305;  				if (h < 325) h = 325;    				Parent.LocalBounds = new RectangleDouble(0' 0' w' h);    				transform_image(0.0);  			}
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,OnParentChanged,The following statement contains a magic number: if (!ImageIO.LoadImageData(img_name' tempImageToLoadInto))  			{  				string buf;  				buf = "File not found: "  					+ img_name  					+ ".bmp"  					+ ". Download http://www.antigrain.com/" + img_name + "\n"  					+ "or copy it from another directory if available.";  				MessageBox.ShowMessageBox(buf' "Missing Files");  			}  			else  			{  #if SourceDepth24                  image_filters.m_TempDestImage = new ImageBuffer(tempImageToLoadInto' new BlenderBGR());                    image_filters.m_RotatedImage = new ImageBuffer(image_filters.m_TempDestImage' new BlenderBGR());                  image_filters.m_OriginalImage = new ImageBuffer(image_filters.m_TempDestImage' new BlenderBGR());    				image_filters.m_TempDestImage.SetRecieveBlender(new BlenderPreMultBGR());  #else  #if SourceDepthFloat  				image_filters.m_TempDestImage = new ImageBufferFloat(tempImageToLoadInto.Width' tempImageToLoadInto.Height' 128' new BlenderBGRAFloat());  				image_filters.m_TempDestImage.CopyFrom(tempImageToLoadInto);    				image_filters.m_RotatedImage = new ImageBufferFloat(image_filters.m_TempDestImage' new BlenderBGRAFloat());  				image_filters.m_OriginalImage = new ImageBufferFloat(image_filters.m_TempDestImage' new BlenderBGRAFloat());    				//image_filters.m_TempDestImage.SetRecieveBlender(new BlenderBGRAFloat());  				image_filters.m_TempDestImage.SetRecieveBlender(new BlenderPreMultBGRAFloat());  #else  				image_filters.m_TempDestImage = new ImageBuffer(tempImageToLoadInto.Width' tempImageToLoadInto.Height' 32' new BlenderBGRA());  				image_filters.m_TempDestImage.CopyFrom(tempImageToLoadInto);    				image_filters.m_RotatedImage = new ImageBuffer(image_filters.m_TempDestImage' new BlenderBGRA());  				image_filters.m_OriginalImage = new ImageBuffer(image_filters.m_TempDestImage' new BlenderBGRA());    				image_filters.m_TempDestImage.SetRecieveBlender(new BlenderPreMultBGRA());  #endif  #endif    				int w = image_filters.m_TempDestImage.Width + 220;  				int h = image_filters.m_TempDestImage.Height + 200;    				if (w < 305) w = 305;  				if (h < 325) h = 325;    				Parent.LocalBounds = new RectangleDouble(0' 0' w' h);    				transform_image(0.0);  			}
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,OnParentChanged,The following statement contains a magic number: if (!ImageIO.LoadImageData(img_name' tempImageToLoadInto))  			{  				string buf;  				buf = "File not found: "  					+ img_name  					+ ".bmp"  					+ ". Download http://www.antigrain.com/" + img_name + "\n"  					+ "or copy it from another directory if available.";  				MessageBox.ShowMessageBox(buf' "Missing Files");  			}  			else  			{  #if SourceDepth24                  image_filters.m_TempDestImage = new ImageBuffer(tempImageToLoadInto' new BlenderBGR());                    image_filters.m_RotatedImage = new ImageBuffer(image_filters.m_TempDestImage' new BlenderBGR());                  image_filters.m_OriginalImage = new ImageBuffer(image_filters.m_TempDestImage' new BlenderBGR());    				image_filters.m_TempDestImage.SetRecieveBlender(new BlenderPreMultBGR());  #else  #if SourceDepthFloat  				image_filters.m_TempDestImage = new ImageBufferFloat(tempImageToLoadInto.Width' tempImageToLoadInto.Height' 128' new BlenderBGRAFloat());  				image_filters.m_TempDestImage.CopyFrom(tempImageToLoadInto);    				image_filters.m_RotatedImage = new ImageBufferFloat(image_filters.m_TempDestImage' new BlenderBGRAFloat());  				image_filters.m_OriginalImage = new ImageBufferFloat(image_filters.m_TempDestImage' new BlenderBGRAFloat());    				//image_filters.m_TempDestImage.SetRecieveBlender(new BlenderBGRAFloat());  				image_filters.m_TempDestImage.SetRecieveBlender(new BlenderPreMultBGRAFloat());  #else  				image_filters.m_TempDestImage = new ImageBuffer(tempImageToLoadInto.Width' tempImageToLoadInto.Height' 32' new BlenderBGRA());  				image_filters.m_TempDestImage.CopyFrom(tempImageToLoadInto);    				image_filters.m_RotatedImage = new ImageBuffer(image_filters.m_TempDestImage' new BlenderBGRA());  				image_filters.m_OriginalImage = new ImageBuffer(image_filters.m_TempDestImage' new BlenderBGRA());    				image_filters.m_TempDestImage.SetRecieveBlender(new BlenderPreMultBGRA());  #endif  #endif    				int w = image_filters.m_TempDestImage.Width + 220;  				int h = image_filters.m_TempDestImage.Height + 200;    				if (w < 305) w = 305;  				if (h < 325) h = 325;    				Parent.LocalBounds = new RectangleDouble(0' 0' w' h);    				transform_image(0.0);  			}
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,OnParentChanged,The following statement contains a magic number: if (!ImageIO.LoadImageData(img_name' tempImageToLoadInto))  			{  				string buf;  				buf = "File not found: "  					+ img_name  					+ ".bmp"  					+ ". Download http://www.antigrain.com/" + img_name + "\n"  					+ "or copy it from another directory if available.";  				MessageBox.ShowMessageBox(buf' "Missing Files");  			}  			else  			{  #if SourceDepth24                  image_filters.m_TempDestImage = new ImageBuffer(tempImageToLoadInto' new BlenderBGR());                    image_filters.m_RotatedImage = new ImageBuffer(image_filters.m_TempDestImage' new BlenderBGR());                  image_filters.m_OriginalImage = new ImageBuffer(image_filters.m_TempDestImage' new BlenderBGR());    				image_filters.m_TempDestImage.SetRecieveBlender(new BlenderPreMultBGR());  #else  #if SourceDepthFloat  				image_filters.m_TempDestImage = new ImageBufferFloat(tempImageToLoadInto.Width' tempImageToLoadInto.Height' 128' new BlenderBGRAFloat());  				image_filters.m_TempDestImage.CopyFrom(tempImageToLoadInto);    				image_filters.m_RotatedImage = new ImageBufferFloat(image_filters.m_TempDestImage' new BlenderBGRAFloat());  				image_filters.m_OriginalImage = new ImageBufferFloat(image_filters.m_TempDestImage' new BlenderBGRAFloat());    				//image_filters.m_TempDestImage.SetRecieveBlender(new BlenderBGRAFloat());  				image_filters.m_TempDestImage.SetRecieveBlender(new BlenderPreMultBGRAFloat());  #else  				image_filters.m_TempDestImage = new ImageBuffer(tempImageToLoadInto.Width' tempImageToLoadInto.Height' 32' new BlenderBGRA());  				image_filters.m_TempDestImage.CopyFrom(tempImageToLoadInto);    				image_filters.m_RotatedImage = new ImageBuffer(image_filters.m_TempDestImage' new BlenderBGRA());  				image_filters.m_OriginalImage = new ImageBuffer(image_filters.m_TempDestImage' new BlenderBGRA());    				image_filters.m_TempDestImage.SetRecieveBlender(new BlenderPreMultBGRA());  #endif  #endif    				int w = image_filters.m_TempDestImage.Width + 220;  				int h = image_filters.m_TempDestImage.Height + 200;    				if (w < 305) w = 305;  				if (h < 325) h = 325;    				Parent.LocalBounds = new RectangleDouble(0' 0' w' h);    				transform_image(0.0);  			}
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,OnParentChanged,The following statement contains a magic number: if (!ImageIO.LoadImageData(img_name' tempImageToLoadInto))  			{  				string buf;  				buf = "File not found: "  					+ img_name  					+ ".bmp"  					+ ". Download http://www.antigrain.com/" + img_name + "\n"  					+ "or copy it from another directory if available.";  				MessageBox.ShowMessageBox(buf' "Missing Files");  			}  			else  			{  #if SourceDepth24                  image_filters.m_TempDestImage = new ImageBuffer(tempImageToLoadInto' new BlenderBGR());                    image_filters.m_RotatedImage = new ImageBuffer(image_filters.m_TempDestImage' new BlenderBGR());                  image_filters.m_OriginalImage = new ImageBuffer(image_filters.m_TempDestImage' new BlenderBGR());    				image_filters.m_TempDestImage.SetRecieveBlender(new BlenderPreMultBGR());  #else  #if SourceDepthFloat  				image_filters.m_TempDestImage = new ImageBufferFloat(tempImageToLoadInto.Width' tempImageToLoadInto.Height' 128' new BlenderBGRAFloat());  				image_filters.m_TempDestImage.CopyFrom(tempImageToLoadInto);    				image_filters.m_RotatedImage = new ImageBufferFloat(image_filters.m_TempDestImage' new BlenderBGRAFloat());  				image_filters.m_OriginalImage = new ImageBufferFloat(image_filters.m_TempDestImage' new BlenderBGRAFloat());    				//image_filters.m_TempDestImage.SetRecieveBlender(new BlenderBGRAFloat());  				image_filters.m_TempDestImage.SetRecieveBlender(new BlenderPreMultBGRAFloat());  #else  				image_filters.m_TempDestImage = new ImageBuffer(tempImageToLoadInto.Width' tempImageToLoadInto.Height' 32' new BlenderBGRA());  				image_filters.m_TempDestImage.CopyFrom(tempImageToLoadInto);    				image_filters.m_RotatedImage = new ImageBuffer(image_filters.m_TempDestImage' new BlenderBGRA());  				image_filters.m_OriginalImage = new ImageBuffer(image_filters.m_TempDestImage' new BlenderBGRA());    				image_filters.m_TempDestImage.SetRecieveBlender(new BlenderPreMultBGRA());  #endif  #endif    				int w = image_filters.m_TempDestImage.Width + 220;  				int h = image_filters.m_TempDestImage.Height + 200;    				if (w < 305) w = 305;  				if (h < 325) h = 325;    				Parent.LocalBounds = new RectangleDouble(0' 0' w' h);    				transform_image(0.0);  			}
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,OnParentChanged,The following statement contains a magic number: if (!ImageIO.LoadImageData(img_name' tempImageToLoadInto))  			{  				string buf;  				buf = "File not found: "  					+ img_name  					+ ".bmp"  					+ ". Download http://www.antigrain.com/" + img_name + "\n"  					+ "or copy it from another directory if available.";  				MessageBox.ShowMessageBox(buf' "Missing Files");  			}  			else  			{  #if SourceDepth24                  image_filters.m_TempDestImage = new ImageBuffer(tempImageToLoadInto' new BlenderBGR());                    image_filters.m_RotatedImage = new ImageBuffer(image_filters.m_TempDestImage' new BlenderBGR());                  image_filters.m_OriginalImage = new ImageBuffer(image_filters.m_TempDestImage' new BlenderBGR());    				image_filters.m_TempDestImage.SetRecieveBlender(new BlenderPreMultBGR());  #else  #if SourceDepthFloat  				image_filters.m_TempDestImage = new ImageBufferFloat(tempImageToLoadInto.Width' tempImageToLoadInto.Height' 128' new BlenderBGRAFloat());  				image_filters.m_TempDestImage.CopyFrom(tempImageToLoadInto);    				image_filters.m_RotatedImage = new ImageBufferFloat(image_filters.m_TempDestImage' new BlenderBGRAFloat());  				image_filters.m_OriginalImage = new ImageBufferFloat(image_filters.m_TempDestImage' new BlenderBGRAFloat());    				//image_filters.m_TempDestImage.SetRecieveBlender(new BlenderBGRAFloat());  				image_filters.m_TempDestImage.SetRecieveBlender(new BlenderPreMultBGRAFloat());  #else  				image_filters.m_TempDestImage = new ImageBuffer(tempImageToLoadInto.Width' tempImageToLoadInto.Height' 32' new BlenderBGRA());  				image_filters.m_TempDestImage.CopyFrom(tempImageToLoadInto);    				image_filters.m_RotatedImage = new ImageBuffer(image_filters.m_TempDestImage' new BlenderBGRA());  				image_filters.m_OriginalImage = new ImageBuffer(image_filters.m_TempDestImage' new BlenderBGRA());    				image_filters.m_TempDestImage.SetRecieveBlender(new BlenderPreMultBGRA());  #endif  #endif    				int w = image_filters.m_TempDestImage.Width + 220;  				int h = image_filters.m_TempDestImage.Height + 200;    				if (w < 305) w = 305;  				if (h < 325) h = 325;    				Parent.LocalBounds = new RectangleDouble(0' 0' w' h);    				transform_image(0.0);  			}
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,OnDraw,The following statement contains a magic number: clippingProxy.CopyFrom(m_TempDestImage' new RectangleInt(0' 0' (int)Width' (int)Height)' 110' 35);
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,OnDraw,The following statement contains a magic number: clippingProxy.CopyFrom(m_TempDestImage' new RectangleInt(0' 0' (int)Width' (int)Height)' 110' 35);
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,OnDraw,The following statement contains a magic number: t.start_point(200.0' 430);
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,OnDraw,The following statement contains a magic number: t.start_point(200.0' 430);
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,OnDraw,The following statement contains a magic number: t.SetFontSize(10.0);
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,OnDraw,The following statement contains a magic number: pt.width(1.5);
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,OnDraw,The following statement contains a magic number: if (m_time1 != m_time2 && m_num_pix > 0.0)  			{  				buf = string.Format("{0:F2} Kpix/sec"' m_num_pix / (m_time2 - m_time1));  				t.start_point(200.0' 450);  				t.text(buf);  				m_Rasterizer.add_path(pt);  				scanlineRenderer.RenderSolid(clippingProxy' m_Rasterizer' m_ScanlinePacked' colorBlack);  			}
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,OnDraw,The following statement contains a magic number: if (m_time1 != m_time2 && m_num_pix > 0.0)  			{  				buf = string.Format("{0:F2} Kpix/sec"' m_num_pix / (m_time2 - m_time1));  				t.start_point(200.0' 450);  				t.text(buf);  				m_Rasterizer.add_path(pt);  				scanlineRenderer.RenderSolid(clippingProxy' m_Rasterizer' m_ScanlinePacked' colorBlack);  			}
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,OnDraw,The following statement contains a magic number: if (filterSelectionButtons.SelectedIndex >= 14)  			{  				m_radius.Visible = true;  			}  			else  			{  				m_radius.Visible = true;  			}
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: src_mtx *= Affine.NewTranslation(-width / 2.0' -height / 2.0);
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: src_mtx *= Affine.NewTranslation(-width / 2.0' -height / 2.0);
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: src_mtx *= Affine.NewRotation(angle * Math.PI / 180.0);
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: src_mtx *= Affine.NewTranslation(width / 2.0' height / 2.0);
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: src_mtx *= Affine.NewTranslation(width / 2.0' height / 2.0);
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: r *= 0.5;
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: r -= 4.0;
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: VertexSource.Ellipse ell = new MatterHackers.Agg.VertexSource.Ellipse(width / 2.0' height / 2.0' r' r' 200);
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: VertexSource.Ellipse ell = new MatterHackers.Agg.VertexSource.Ellipse(width / 2.0' height / 2.0' r' r' 200);
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: VertexSource.Ellipse ell = new MatterHackers.Agg.VertexSource.Ellipse(width / 2.0' height / 2.0' r' r' 200);
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following statement contains a magic number: switch (filterSelectionButtons.SelectedIndex)  			{  				case 0:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif    						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_nn(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_nn(source' interpolator);  #endif  								break;    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 1:  					{  #if SourceDepthFloat                      span_image_filter_float spanGenerator;  #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb_bilinear(source' interpolator);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba_bilinear(source' interpolator);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_bilinear_float(source' interpolator);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}  						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;    				case 5:  				case 6:  				case 7:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}    #if SourceDepthFloat                      throw new NotImplementedException();  #else  						span_image_filter_rgb_2x2 spanGenerator = new span_image_filter_rgb_2x2(source' interpolator' filter);  #endif  						m_Rasterizer.add_path(tr);  #if SourceDepthFloat                      throw new NotImplementedException();  #else  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  #endif  					}  					break;    				case 2:  				case 3:  				case 4:  				case 8:  				case 9:  				case 10:  				case 11:  				case 12:  				case 13:  				case 14:  				case 15:  				case 16:  					{  						switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}    #if SourceDepthFloat                      span_image_filter_float spanGenerator;    #else  						span_image_filter spanGenerator;  #endif  						switch (source.SourceImage.BitDepth)  						{  							case 24:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgb(source' interpolator' filter);  #endif  								break;    							case 32:  #if SourceDepthFloat                              throw new NotImplementedException();  #else  								spanGenerator = new span_image_filter_rgba(source' interpolator' filter);  #endif  								break;    #if SourceDepthFloat                          case 128:                              spanGenerator = new span_image_filter_rgba_float(source' interpolator' filterFunction);                              break;  #endif    							default:  								throw new NotImplementedException("only support 24 and 32 bit");  						}    						m_Rasterizer.add_path(tr);  						scanlineRenderer.GenerateAndRender(m_Rasterizer' m_ScanlineUnpacked' clippedDest' m_SpanAllocator' spanGenerator);  					}  					break;  			}
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,OnIdle,The following statement contains a magic number: if (m_cur_angle < 360.0)  			{  				m_cur_angle += m_step.Value;  				image_filters.m_RotatedImage.CopyFrom(image_filters.m_TempDestImage);  				stopwatch.Restart();  				transform_image(m_step.Value);  				m_time2 += stopwatch.ElapsedMilliseconds;  				m_num_steps++;  				UiThread.RunOnIdle(OnIdle' .1);  			}  			else  			{  				m_cur_angle = 0.0;  				//m_time2 = clock();  			}
Magic Number,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,OnIdle,The following statement contains a magic number: if (m_cur_angle < 360.0)  			{  				m_cur_angle += m_step.Value;  				image_filters.m_RotatedImage.CopyFrom(image_filters.m_TempDestImage);  				stopwatch.Restart();  				transform_image(m_step.Value);  				m_time2 += stopwatch.ElapsedMilliseconds;  				m_num_steps++;  				UiThread.RunOnIdle(OnIdle' .1);  			}  			else  			{  				m_cur_angle = 0.0;  				//m_time2 = clock();  			}
Magic Number,MatterHackers.Agg,ImageFiltersFactory,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,GetAppParameters,The following statement contains a magic number: AppWidgetInfo appWidgetInfo = new AppWidgetInfo(  			"Bitmap"'  			"Image Filters Comparison"'  			"The image transformer algorithm can work with different interpolation filters' such as Bilinear' Bicubic' Sinc' Blackman. The example demonstrates the difference in quality between different filters. When switch the �Run Test� on' the image starts rotating. But at each step there is the previously rotated image taken' so the quality degrades. This degradation as well as the performance depend on the type of the interpolation filter."'  			305'  			325);
Magic Number,MatterHackers.Agg,ImageFiltersFactory,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,GetAppParameters,The following statement contains a magic number: AppWidgetInfo appWidgetInfo = new AppWidgetInfo(  			"Bitmap"'  			"Image Filters Comparison"'  			"The image transformer algorithm can work with different interpolation filters' such as Bilinear' Bicubic' Sinc' Blackman. The example demonstrates the difference in quality between different filters. When switch the �Run Test� on' the image starts rotating. But at each step there is the previously rotated image taken' so the quality degrades. This degradation as well as the performance depend on the type of the interpolation filter."'  			305'  			325);
Missing Default,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following switch statement is missing a default case: switch (filterSelectionButtons.SelectedIndex)  						{  							case 5: filter.calculate(new image_filter_hanning()' norm); break;  							case 6: filter.calculate(new image_filter_hamming()' norm); break;  							case 7: filter.calculate(new image_filter_hermite()' norm); break;  						}
Missing Default,MatterHackers.Agg,image_filters,C:\repos\MatterHackers_agg-sharp\examples\image_filters\image_filters.cs,transform_image,The following switch statement is missing a default case: switch (filterSelectionButtons.SelectedIndex)  						{  							case 2: filter.calculate(new image_filter_bicubic()' norm); break;  							case 3: filter.calculate(new image_filter_spline16()' norm); break;  							case 4: filter.calculate(new image_filter_spline36()' norm); break;  							case 8: filter.calculate(new image_filter_kaiser()' norm); break;  							case 9: filter.calculate(new image_filter_quadric()' norm); break;  							case 10: filter.calculate(new image_filter_catrom()' norm); break;  							case 11: filter.calculate(new image_filter_gaussian()' norm); break;  							case 12: filter.calculate(new image_filter_bessel()' norm); break;  							case 13: filter.calculate(new image_filter_mitchell()' norm); break;  							case 14: filter.calculate(new image_filter_sinc(m_radius.Value)' norm); break;  							case 15: filter.calculate(new image_filter_lanczos(m_radius.Value)' norm); break;  							case 16:  								filterFunction = new image_filter_blackman(m_radius.Value);  								//filterFunction = new image_filter_bilinear();  								filter.calculate(filterFunction' norm);  								break;  						}
