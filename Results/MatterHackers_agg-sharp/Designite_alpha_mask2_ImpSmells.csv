Implementation smell,Namespace,Class,File,Method,Description
Long Method,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,OnDraw,The method has 125 lines of code.
Long Statement,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,generate_alpha_mask,The length of the statement  "						ellipseForMask.init(ellipseForMask.originX' ellipseForMask.originY' ellipseForMask.radiusX - 10' ellipseForMask.radiusY - 10' 100); " is 131.
Long Statement,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,generate_alpha_mask,The length of the statement  "						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes((int)((float)i / (float)num * 255)' 0' 0' 255)); " is 123.
Long Statement,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,OnDraw,The length of the statement  "				MatterHackers.Agg.Image.AlphaMaskAdaptor imageAlphaMaskAdaptor = new MatterHackers.Agg.Image.AlphaMaskAdaptor(widgetsSubImage' alphaMask); " is 138.
Long Statement,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,OnDraw,The length of the statement  "							VertexSource.RoundedRect rect = new VertexSource.RoundedRect(i * RectWidth' j * RectWidth' (i + 1) * RectWidth' (j + 1) * RectWidth' 0); " is 136.
Long Statement,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,OnDraw,The length of the statement  "				scanlineRenderer.RenderSolidAllPaths(alphaMaskClippingProxy' rasterizer' scanlineCache' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths); " is 154.
Virtual Method Call from Constructor,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,alpha_mask2_application,The constructor "alpha_mask2_application" calls a virtual method "AddChild".
Magic Number,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,alpha_mask2_application,The following statement contains a magic number: numMasksSlider = new UI.Slider(5' 5' 150' 12);
Magic Number,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,alpha_mask2_application,The following statement contains a magic number: numMasksSlider = new UI.Slider(5' 5' 150' 12);
Magic Number,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,alpha_mask2_application,The following statement contains a magic number: numMasksSlider = new UI.Slider(5' 5' 150' 12);
Magic Number,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,alpha_mask2_application,The following statement contains a magic number: numMasksSlider = new UI.Slider(5' 5' 150' 12);
Magic Number,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,alpha_mask2_application,The following statement contains a magic number: numMasksSlider.SetRange(5' 100);
Magic Number,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,alpha_mask2_application,The following statement contains a magic number: numMasksSlider.SetRange(5' 100);
Magic Number,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,alpha_mask2_application,The following statement contains a magic number: numMasksSlider.Value = 10;
Magic Number,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,generate_alpha_mask,The following statement contains a magic number: {  #if USE_CLIPPING_ALPHA_MASK  				alphaMaskImageBuffer.AttachBuffer(alphaByteArray' 20 * cx + 20' cx - 40' cy - 40' cx' 8' 1);  #else                  alphaMaskImageBuffer.attach(alphaByteArray' (int)cx' (int)cy' cx' 1);  #endif    				ImageBuffer image = new ImageBuffer();  				image.Attach(alphaMaskImageBuffer' new blender_gray(1)' 1' 0' 8);  				ImageClippingProxy clippingProxy = new ImageClippingProxy(image);  				ScanlineCachePacked8 sl = new ScanlineCachePacked8();    				clippingProxy.clear(new RGBA_Floats(0));    				VertexSource.Ellipse ellipseForMask = new MatterHackers.Agg.VertexSource.Ellipse();    				System.Random randGenerator = new Random(1432);    				ScanlineRenderer scanlineRenderer = new ScanlineRenderer();  				int i;  				int num = (int)numMasksSlider.Value;  				for (i = 0; i < num; i++)  				{  					if (i == num - 1)  					{  						ellipseForMask.init(Width / 2' Height / 2' 110' 110' 100);  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes(0' 0' 0' 255));    						ellipseForMask.init(ellipseForMask.originX' ellipseForMask.originY' ellipseForMask.radiusX - 10' ellipseForMask.radiusY - 10' 100);  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes(255' 0' 0' 255));  					}  					else  					{  						ellipseForMask.init(randGenerator.Next() % cx'  								 randGenerator.Next() % cy'  								 randGenerator.Next() % 100 + 20'  								 randGenerator.Next() % 100 + 20'  								 100);  						// set the color to draw into the alpha channel.  						// there is not very much reason to set the alpha as you will get the amount of  						// transparency based on the color you draw.  (you might want some type of different edeg effect but it will be minor).  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes((int)((float)i / (float)num * 255)' 0' 0' 255));  					}  				}    				alphaMaskImageBuffer.DettachBuffer();  			}
Magic Number,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,generate_alpha_mask,The following statement contains a magic number: {  #if USE_CLIPPING_ALPHA_MASK  				alphaMaskImageBuffer.AttachBuffer(alphaByteArray' 20 * cx + 20' cx - 40' cy - 40' cx' 8' 1);  #else                  alphaMaskImageBuffer.attach(alphaByteArray' (int)cx' (int)cy' cx' 1);  #endif    				ImageBuffer image = new ImageBuffer();  				image.Attach(alphaMaskImageBuffer' new blender_gray(1)' 1' 0' 8);  				ImageClippingProxy clippingProxy = new ImageClippingProxy(image);  				ScanlineCachePacked8 sl = new ScanlineCachePacked8();    				clippingProxy.clear(new RGBA_Floats(0));    				VertexSource.Ellipse ellipseForMask = new MatterHackers.Agg.VertexSource.Ellipse();    				System.Random randGenerator = new Random(1432);    				ScanlineRenderer scanlineRenderer = new ScanlineRenderer();  				int i;  				int num = (int)numMasksSlider.Value;  				for (i = 0; i < num; i++)  				{  					if (i == num - 1)  					{  						ellipseForMask.init(Width / 2' Height / 2' 110' 110' 100);  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes(0' 0' 0' 255));    						ellipseForMask.init(ellipseForMask.originX' ellipseForMask.originY' ellipseForMask.radiusX - 10' ellipseForMask.radiusY - 10' 100);  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes(255' 0' 0' 255));  					}  					else  					{  						ellipseForMask.init(randGenerator.Next() % cx'  								 randGenerator.Next() % cy'  								 randGenerator.Next() % 100 + 20'  								 randGenerator.Next() % 100 + 20'  								 100);  						// set the color to draw into the alpha channel.  						// there is not very much reason to set the alpha as you will get the amount of  						// transparency based on the color you draw.  (you might want some type of different edeg effect but it will be minor).  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes((int)((float)i / (float)num * 255)' 0' 0' 255));  					}  				}    				alphaMaskImageBuffer.DettachBuffer();  			}
Magic Number,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,generate_alpha_mask,The following statement contains a magic number: {  #if USE_CLIPPING_ALPHA_MASK  				alphaMaskImageBuffer.AttachBuffer(alphaByteArray' 20 * cx + 20' cx - 40' cy - 40' cx' 8' 1);  #else                  alphaMaskImageBuffer.attach(alphaByteArray' (int)cx' (int)cy' cx' 1);  #endif    				ImageBuffer image = new ImageBuffer();  				image.Attach(alphaMaskImageBuffer' new blender_gray(1)' 1' 0' 8);  				ImageClippingProxy clippingProxy = new ImageClippingProxy(image);  				ScanlineCachePacked8 sl = new ScanlineCachePacked8();    				clippingProxy.clear(new RGBA_Floats(0));    				VertexSource.Ellipse ellipseForMask = new MatterHackers.Agg.VertexSource.Ellipse();    				System.Random randGenerator = new Random(1432);    				ScanlineRenderer scanlineRenderer = new ScanlineRenderer();  				int i;  				int num = (int)numMasksSlider.Value;  				for (i = 0; i < num; i++)  				{  					if (i == num - 1)  					{  						ellipseForMask.init(Width / 2' Height / 2' 110' 110' 100);  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes(0' 0' 0' 255));    						ellipseForMask.init(ellipseForMask.originX' ellipseForMask.originY' ellipseForMask.radiusX - 10' ellipseForMask.radiusY - 10' 100);  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes(255' 0' 0' 255));  					}  					else  					{  						ellipseForMask.init(randGenerator.Next() % cx'  								 randGenerator.Next() % cy'  								 randGenerator.Next() % 100 + 20'  								 randGenerator.Next() % 100 + 20'  								 100);  						// set the color to draw into the alpha channel.  						// there is not very much reason to set the alpha as you will get the amount of  						// transparency based on the color you draw.  (you might want some type of different edeg effect but it will be minor).  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes((int)((float)i / (float)num * 255)' 0' 0' 255));  					}  				}    				alphaMaskImageBuffer.DettachBuffer();  			}
Magic Number,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,generate_alpha_mask,The following statement contains a magic number: {  #if USE_CLIPPING_ALPHA_MASK  				alphaMaskImageBuffer.AttachBuffer(alphaByteArray' 20 * cx + 20' cx - 40' cy - 40' cx' 8' 1);  #else                  alphaMaskImageBuffer.attach(alphaByteArray' (int)cx' (int)cy' cx' 1);  #endif    				ImageBuffer image = new ImageBuffer();  				image.Attach(alphaMaskImageBuffer' new blender_gray(1)' 1' 0' 8);  				ImageClippingProxy clippingProxy = new ImageClippingProxy(image);  				ScanlineCachePacked8 sl = new ScanlineCachePacked8();    				clippingProxy.clear(new RGBA_Floats(0));    				VertexSource.Ellipse ellipseForMask = new MatterHackers.Agg.VertexSource.Ellipse();    				System.Random randGenerator = new Random(1432);    				ScanlineRenderer scanlineRenderer = new ScanlineRenderer();  				int i;  				int num = (int)numMasksSlider.Value;  				for (i = 0; i < num; i++)  				{  					if (i == num - 1)  					{  						ellipseForMask.init(Width / 2' Height / 2' 110' 110' 100);  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes(0' 0' 0' 255));    						ellipseForMask.init(ellipseForMask.originX' ellipseForMask.originY' ellipseForMask.radiusX - 10' ellipseForMask.radiusY - 10' 100);  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes(255' 0' 0' 255));  					}  					else  					{  						ellipseForMask.init(randGenerator.Next() % cx'  								 randGenerator.Next() % cy'  								 randGenerator.Next() % 100 + 20'  								 randGenerator.Next() % 100 + 20'  								 100);  						// set the color to draw into the alpha channel.  						// there is not very much reason to set the alpha as you will get the amount of  						// transparency based on the color you draw.  (you might want some type of different edeg effect but it will be minor).  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes((int)((float)i / (float)num * 255)' 0' 0' 255));  					}  				}    				alphaMaskImageBuffer.DettachBuffer();  			}
Magic Number,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,generate_alpha_mask,The following statement contains a magic number: {  #if USE_CLIPPING_ALPHA_MASK  				alphaMaskImageBuffer.AttachBuffer(alphaByteArray' 20 * cx + 20' cx - 40' cy - 40' cx' 8' 1);  #else                  alphaMaskImageBuffer.attach(alphaByteArray' (int)cx' (int)cy' cx' 1);  #endif    				ImageBuffer image = new ImageBuffer();  				image.Attach(alphaMaskImageBuffer' new blender_gray(1)' 1' 0' 8);  				ImageClippingProxy clippingProxy = new ImageClippingProxy(image);  				ScanlineCachePacked8 sl = new ScanlineCachePacked8();    				clippingProxy.clear(new RGBA_Floats(0));    				VertexSource.Ellipse ellipseForMask = new MatterHackers.Agg.VertexSource.Ellipse();    				System.Random randGenerator = new Random(1432);    				ScanlineRenderer scanlineRenderer = new ScanlineRenderer();  				int i;  				int num = (int)numMasksSlider.Value;  				for (i = 0; i < num; i++)  				{  					if (i == num - 1)  					{  						ellipseForMask.init(Width / 2' Height / 2' 110' 110' 100);  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes(0' 0' 0' 255));    						ellipseForMask.init(ellipseForMask.originX' ellipseForMask.originY' ellipseForMask.radiusX - 10' ellipseForMask.radiusY - 10' 100);  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes(255' 0' 0' 255));  					}  					else  					{  						ellipseForMask.init(randGenerator.Next() % cx'  								 randGenerator.Next() % cy'  								 randGenerator.Next() % 100 + 20'  								 randGenerator.Next() % 100 + 20'  								 100);  						// set the color to draw into the alpha channel.  						// there is not very much reason to set the alpha as you will get the amount of  						// transparency based on the color you draw.  (you might want some type of different edeg effect but it will be minor).  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes((int)((float)i / (float)num * 255)' 0' 0' 255));  					}  				}    				alphaMaskImageBuffer.DettachBuffer();  			}
Magic Number,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,generate_alpha_mask,The following statement contains a magic number: {  #if USE_CLIPPING_ALPHA_MASK  				alphaMaskImageBuffer.AttachBuffer(alphaByteArray' 20 * cx + 20' cx - 40' cy - 40' cx' 8' 1);  #else                  alphaMaskImageBuffer.attach(alphaByteArray' (int)cx' (int)cy' cx' 1);  #endif    				ImageBuffer image = new ImageBuffer();  				image.Attach(alphaMaskImageBuffer' new blender_gray(1)' 1' 0' 8);  				ImageClippingProxy clippingProxy = new ImageClippingProxy(image);  				ScanlineCachePacked8 sl = new ScanlineCachePacked8();    				clippingProxy.clear(new RGBA_Floats(0));    				VertexSource.Ellipse ellipseForMask = new MatterHackers.Agg.VertexSource.Ellipse();    				System.Random randGenerator = new Random(1432);    				ScanlineRenderer scanlineRenderer = new ScanlineRenderer();  				int i;  				int num = (int)numMasksSlider.Value;  				for (i = 0; i < num; i++)  				{  					if (i == num - 1)  					{  						ellipseForMask.init(Width / 2' Height / 2' 110' 110' 100);  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes(0' 0' 0' 255));    						ellipseForMask.init(ellipseForMask.originX' ellipseForMask.originY' ellipseForMask.radiusX - 10' ellipseForMask.radiusY - 10' 100);  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes(255' 0' 0' 255));  					}  					else  					{  						ellipseForMask.init(randGenerator.Next() % cx'  								 randGenerator.Next() % cy'  								 randGenerator.Next() % 100 + 20'  								 randGenerator.Next() % 100 + 20'  								 100);  						// set the color to draw into the alpha channel.  						// there is not very much reason to set the alpha as you will get the amount of  						// transparency based on the color you draw.  (you might want some type of different edeg effect but it will be minor).  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes((int)((float)i / (float)num * 255)' 0' 0' 255));  					}  				}    				alphaMaskImageBuffer.DettachBuffer();  			}
Magic Number,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,generate_alpha_mask,The following statement contains a magic number: {  #if USE_CLIPPING_ALPHA_MASK  				alphaMaskImageBuffer.AttachBuffer(alphaByteArray' 20 * cx + 20' cx - 40' cy - 40' cx' 8' 1);  #else                  alphaMaskImageBuffer.attach(alphaByteArray' (int)cx' (int)cy' cx' 1);  #endif    				ImageBuffer image = new ImageBuffer();  				image.Attach(alphaMaskImageBuffer' new blender_gray(1)' 1' 0' 8);  				ImageClippingProxy clippingProxy = new ImageClippingProxy(image);  				ScanlineCachePacked8 sl = new ScanlineCachePacked8();    				clippingProxy.clear(new RGBA_Floats(0));    				VertexSource.Ellipse ellipseForMask = new MatterHackers.Agg.VertexSource.Ellipse();    				System.Random randGenerator = new Random(1432);    				ScanlineRenderer scanlineRenderer = new ScanlineRenderer();  				int i;  				int num = (int)numMasksSlider.Value;  				for (i = 0; i < num; i++)  				{  					if (i == num - 1)  					{  						ellipseForMask.init(Width / 2' Height / 2' 110' 110' 100);  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes(0' 0' 0' 255));    						ellipseForMask.init(ellipseForMask.originX' ellipseForMask.originY' ellipseForMask.radiusX - 10' ellipseForMask.radiusY - 10' 100);  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes(255' 0' 0' 255));  					}  					else  					{  						ellipseForMask.init(randGenerator.Next() % cx'  								 randGenerator.Next() % cy'  								 randGenerator.Next() % 100 + 20'  								 randGenerator.Next() % 100 + 20'  								 100);  						// set the color to draw into the alpha channel.  						// there is not very much reason to set the alpha as you will get the amount of  						// transparency based on the color you draw.  (you might want some type of different edeg effect but it will be minor).  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes((int)((float)i / (float)num * 255)' 0' 0' 255));  					}  				}    				alphaMaskImageBuffer.DettachBuffer();  			}
Magic Number,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,generate_alpha_mask,The following statement contains a magic number: {  #if USE_CLIPPING_ALPHA_MASK  				alphaMaskImageBuffer.AttachBuffer(alphaByteArray' 20 * cx + 20' cx - 40' cy - 40' cx' 8' 1);  #else                  alphaMaskImageBuffer.attach(alphaByteArray' (int)cx' (int)cy' cx' 1);  #endif    				ImageBuffer image = new ImageBuffer();  				image.Attach(alphaMaskImageBuffer' new blender_gray(1)' 1' 0' 8);  				ImageClippingProxy clippingProxy = new ImageClippingProxy(image);  				ScanlineCachePacked8 sl = new ScanlineCachePacked8();    				clippingProxy.clear(new RGBA_Floats(0));    				VertexSource.Ellipse ellipseForMask = new MatterHackers.Agg.VertexSource.Ellipse();    				System.Random randGenerator = new Random(1432);    				ScanlineRenderer scanlineRenderer = new ScanlineRenderer();  				int i;  				int num = (int)numMasksSlider.Value;  				for (i = 0; i < num; i++)  				{  					if (i == num - 1)  					{  						ellipseForMask.init(Width / 2' Height / 2' 110' 110' 100);  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes(0' 0' 0' 255));    						ellipseForMask.init(ellipseForMask.originX' ellipseForMask.originY' ellipseForMask.radiusX - 10' ellipseForMask.radiusY - 10' 100);  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes(255' 0' 0' 255));  					}  					else  					{  						ellipseForMask.init(randGenerator.Next() % cx'  								 randGenerator.Next() % cy'  								 randGenerator.Next() % 100 + 20'  								 randGenerator.Next() % 100 + 20'  								 100);  						// set the color to draw into the alpha channel.  						// there is not very much reason to set the alpha as you will get the amount of  						// transparency based on the color you draw.  (you might want some type of different edeg effect but it will be minor).  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes((int)((float)i / (float)num * 255)' 0' 0' 255));  					}  				}    				alphaMaskImageBuffer.DettachBuffer();  			}
Magic Number,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,generate_alpha_mask,The following statement contains a magic number: {  #if USE_CLIPPING_ALPHA_MASK  				alphaMaskImageBuffer.AttachBuffer(alphaByteArray' 20 * cx + 20' cx - 40' cy - 40' cx' 8' 1);  #else                  alphaMaskImageBuffer.attach(alphaByteArray' (int)cx' (int)cy' cx' 1);  #endif    				ImageBuffer image = new ImageBuffer();  				image.Attach(alphaMaskImageBuffer' new blender_gray(1)' 1' 0' 8);  				ImageClippingProxy clippingProxy = new ImageClippingProxy(image);  				ScanlineCachePacked8 sl = new ScanlineCachePacked8();    				clippingProxy.clear(new RGBA_Floats(0));    				VertexSource.Ellipse ellipseForMask = new MatterHackers.Agg.VertexSource.Ellipse();    				System.Random randGenerator = new Random(1432);    				ScanlineRenderer scanlineRenderer = new ScanlineRenderer();  				int i;  				int num = (int)numMasksSlider.Value;  				for (i = 0; i < num; i++)  				{  					if (i == num - 1)  					{  						ellipseForMask.init(Width / 2' Height / 2' 110' 110' 100);  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes(0' 0' 0' 255));    						ellipseForMask.init(ellipseForMask.originX' ellipseForMask.originY' ellipseForMask.radiusX - 10' ellipseForMask.radiusY - 10' 100);  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes(255' 0' 0' 255));  					}  					else  					{  						ellipseForMask.init(randGenerator.Next() % cx'  								 randGenerator.Next() % cy'  								 randGenerator.Next() % 100 + 20'  								 randGenerator.Next() % 100 + 20'  								 100);  						// set the color to draw into the alpha channel.  						// there is not very much reason to set the alpha as you will get the amount of  						// transparency based on the color you draw.  (you might want some type of different edeg effect but it will be minor).  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes((int)((float)i / (float)num * 255)' 0' 0' 255));  					}  				}    				alphaMaskImageBuffer.DettachBuffer();  			}
Magic Number,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,generate_alpha_mask,The following statement contains a magic number: {  #if USE_CLIPPING_ALPHA_MASK  				alphaMaskImageBuffer.AttachBuffer(alphaByteArray' 20 * cx + 20' cx - 40' cy - 40' cx' 8' 1);  #else                  alphaMaskImageBuffer.attach(alphaByteArray' (int)cx' (int)cy' cx' 1);  #endif    				ImageBuffer image = new ImageBuffer();  				image.Attach(alphaMaskImageBuffer' new blender_gray(1)' 1' 0' 8);  				ImageClippingProxy clippingProxy = new ImageClippingProxy(image);  				ScanlineCachePacked8 sl = new ScanlineCachePacked8();    				clippingProxy.clear(new RGBA_Floats(0));    				VertexSource.Ellipse ellipseForMask = new MatterHackers.Agg.VertexSource.Ellipse();    				System.Random randGenerator = new Random(1432);    				ScanlineRenderer scanlineRenderer = new ScanlineRenderer();  				int i;  				int num = (int)numMasksSlider.Value;  				for (i = 0; i < num; i++)  				{  					if (i == num - 1)  					{  						ellipseForMask.init(Width / 2' Height / 2' 110' 110' 100);  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes(0' 0' 0' 255));    						ellipseForMask.init(ellipseForMask.originX' ellipseForMask.originY' ellipseForMask.radiusX - 10' ellipseForMask.radiusY - 10' 100);  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes(255' 0' 0' 255));  					}  					else  					{  						ellipseForMask.init(randGenerator.Next() % cx'  								 randGenerator.Next() % cy'  								 randGenerator.Next() % 100 + 20'  								 randGenerator.Next() % 100 + 20'  								 100);  						// set the color to draw into the alpha channel.  						// there is not very much reason to set the alpha as you will get the amount of  						// transparency based on the color you draw.  (you might want some type of different edeg effect but it will be minor).  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes((int)((float)i / (float)num * 255)' 0' 0' 255));  					}  				}    				alphaMaskImageBuffer.DettachBuffer();  			}
Magic Number,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,generate_alpha_mask,The following statement contains a magic number: {  #if USE_CLIPPING_ALPHA_MASK  				alphaMaskImageBuffer.AttachBuffer(alphaByteArray' 20 * cx + 20' cx - 40' cy - 40' cx' 8' 1);  #else                  alphaMaskImageBuffer.attach(alphaByteArray' (int)cx' (int)cy' cx' 1);  #endif    				ImageBuffer image = new ImageBuffer();  				image.Attach(alphaMaskImageBuffer' new blender_gray(1)' 1' 0' 8);  				ImageClippingProxy clippingProxy = new ImageClippingProxy(image);  				ScanlineCachePacked8 sl = new ScanlineCachePacked8();    				clippingProxy.clear(new RGBA_Floats(0));    				VertexSource.Ellipse ellipseForMask = new MatterHackers.Agg.VertexSource.Ellipse();    				System.Random randGenerator = new Random(1432);    				ScanlineRenderer scanlineRenderer = new ScanlineRenderer();  				int i;  				int num = (int)numMasksSlider.Value;  				for (i = 0; i < num; i++)  				{  					if (i == num - 1)  					{  						ellipseForMask.init(Width / 2' Height / 2' 110' 110' 100);  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes(0' 0' 0' 255));    						ellipseForMask.init(ellipseForMask.originX' ellipseForMask.originY' ellipseForMask.radiusX - 10' ellipseForMask.radiusY - 10' 100);  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes(255' 0' 0' 255));  					}  					else  					{  						ellipseForMask.init(randGenerator.Next() % cx'  								 randGenerator.Next() % cy'  								 randGenerator.Next() % 100 + 20'  								 randGenerator.Next() % 100 + 20'  								 100);  						// set the color to draw into the alpha channel.  						// there is not very much reason to set the alpha as you will get the amount of  						// transparency based on the color you draw.  (you might want some type of different edeg effect but it will be minor).  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes((int)((float)i / (float)num * 255)' 0' 0' 255));  					}  				}    				alphaMaskImageBuffer.DettachBuffer();  			}
Magic Number,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,generate_alpha_mask,The following statement contains a magic number: {  #if USE_CLIPPING_ALPHA_MASK  				alphaMaskImageBuffer.AttachBuffer(alphaByteArray' 20 * cx + 20' cx - 40' cy - 40' cx' 8' 1);  #else                  alphaMaskImageBuffer.attach(alphaByteArray' (int)cx' (int)cy' cx' 1);  #endif    				ImageBuffer image = new ImageBuffer();  				image.Attach(alphaMaskImageBuffer' new blender_gray(1)' 1' 0' 8);  				ImageClippingProxy clippingProxy = new ImageClippingProxy(image);  				ScanlineCachePacked8 sl = new ScanlineCachePacked8();    				clippingProxy.clear(new RGBA_Floats(0));    				VertexSource.Ellipse ellipseForMask = new MatterHackers.Agg.VertexSource.Ellipse();    				System.Random randGenerator = new Random(1432);    				ScanlineRenderer scanlineRenderer = new ScanlineRenderer();  				int i;  				int num = (int)numMasksSlider.Value;  				for (i = 0; i < num; i++)  				{  					if (i == num - 1)  					{  						ellipseForMask.init(Width / 2' Height / 2' 110' 110' 100);  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes(0' 0' 0' 255));    						ellipseForMask.init(ellipseForMask.originX' ellipseForMask.originY' ellipseForMask.radiusX - 10' ellipseForMask.radiusY - 10' 100);  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes(255' 0' 0' 255));  					}  					else  					{  						ellipseForMask.init(randGenerator.Next() % cx'  								 randGenerator.Next() % cy'  								 randGenerator.Next() % 100 + 20'  								 randGenerator.Next() % 100 + 20'  								 100);  						// set the color to draw into the alpha channel.  						// there is not very much reason to set the alpha as you will get the amount of  						// transparency based on the color you draw.  (you might want some type of different edeg effect but it will be minor).  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes((int)((float)i / (float)num * 255)' 0' 0' 255));  					}  				}    				alphaMaskImageBuffer.DettachBuffer();  			}
Magic Number,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,generate_alpha_mask,The following statement contains a magic number: {  #if USE_CLIPPING_ALPHA_MASK  				alphaMaskImageBuffer.AttachBuffer(alphaByteArray' 20 * cx + 20' cx - 40' cy - 40' cx' 8' 1);  #else                  alphaMaskImageBuffer.attach(alphaByteArray' (int)cx' (int)cy' cx' 1);  #endif    				ImageBuffer image = new ImageBuffer();  				image.Attach(alphaMaskImageBuffer' new blender_gray(1)' 1' 0' 8);  				ImageClippingProxy clippingProxy = new ImageClippingProxy(image);  				ScanlineCachePacked8 sl = new ScanlineCachePacked8();    				clippingProxy.clear(new RGBA_Floats(0));    				VertexSource.Ellipse ellipseForMask = new MatterHackers.Agg.VertexSource.Ellipse();    				System.Random randGenerator = new Random(1432);    				ScanlineRenderer scanlineRenderer = new ScanlineRenderer();  				int i;  				int num = (int)numMasksSlider.Value;  				for (i = 0; i < num; i++)  				{  					if (i == num - 1)  					{  						ellipseForMask.init(Width / 2' Height / 2' 110' 110' 100);  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes(0' 0' 0' 255));    						ellipseForMask.init(ellipseForMask.originX' ellipseForMask.originY' ellipseForMask.radiusX - 10' ellipseForMask.radiusY - 10' 100);  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes(255' 0' 0' 255));  					}  					else  					{  						ellipseForMask.init(randGenerator.Next() % cx'  								 randGenerator.Next() % cy'  								 randGenerator.Next() % 100 + 20'  								 randGenerator.Next() % 100 + 20'  								 100);  						// set the color to draw into the alpha channel.  						// there is not very much reason to set the alpha as you will get the amount of  						// transparency based on the color you draw.  (you might want some type of different edeg effect but it will be minor).  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes((int)((float)i / (float)num * 255)' 0' 0' 255));  					}  				}    				alphaMaskImageBuffer.DettachBuffer();  			}
Magic Number,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,generate_alpha_mask,The following statement contains a magic number: {  #if USE_CLIPPING_ALPHA_MASK  				alphaMaskImageBuffer.AttachBuffer(alphaByteArray' 20 * cx + 20' cx - 40' cy - 40' cx' 8' 1);  #else                  alphaMaskImageBuffer.attach(alphaByteArray' (int)cx' (int)cy' cx' 1);  #endif    				ImageBuffer image = new ImageBuffer();  				image.Attach(alphaMaskImageBuffer' new blender_gray(1)' 1' 0' 8);  				ImageClippingProxy clippingProxy = new ImageClippingProxy(image);  				ScanlineCachePacked8 sl = new ScanlineCachePacked8();    				clippingProxy.clear(new RGBA_Floats(0));    				VertexSource.Ellipse ellipseForMask = new MatterHackers.Agg.VertexSource.Ellipse();    				System.Random randGenerator = new Random(1432);    				ScanlineRenderer scanlineRenderer = new ScanlineRenderer();  				int i;  				int num = (int)numMasksSlider.Value;  				for (i = 0; i < num; i++)  				{  					if (i == num - 1)  					{  						ellipseForMask.init(Width / 2' Height / 2' 110' 110' 100);  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes(0' 0' 0' 255));    						ellipseForMask.init(ellipseForMask.originX' ellipseForMask.originY' ellipseForMask.radiusX - 10' ellipseForMask.radiusY - 10' 100);  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes(255' 0' 0' 255));  					}  					else  					{  						ellipseForMask.init(randGenerator.Next() % cx'  								 randGenerator.Next() % cy'  								 randGenerator.Next() % 100 + 20'  								 randGenerator.Next() % 100 + 20'  								 100);  						// set the color to draw into the alpha channel.  						// there is not very much reason to set the alpha as you will get the amount of  						// transparency based on the color you draw.  (you might want some type of different edeg effect but it will be minor).  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes((int)((float)i / (float)num * 255)' 0' 0' 255));  					}  				}    				alphaMaskImageBuffer.DettachBuffer();  			}
Magic Number,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,generate_alpha_mask,The following statement contains a magic number: {  #if USE_CLIPPING_ALPHA_MASK  				alphaMaskImageBuffer.AttachBuffer(alphaByteArray' 20 * cx + 20' cx - 40' cy - 40' cx' 8' 1);  #else                  alphaMaskImageBuffer.attach(alphaByteArray' (int)cx' (int)cy' cx' 1);  #endif    				ImageBuffer image = new ImageBuffer();  				image.Attach(alphaMaskImageBuffer' new blender_gray(1)' 1' 0' 8);  				ImageClippingProxy clippingProxy = new ImageClippingProxy(image);  				ScanlineCachePacked8 sl = new ScanlineCachePacked8();    				clippingProxy.clear(new RGBA_Floats(0));    				VertexSource.Ellipse ellipseForMask = new MatterHackers.Agg.VertexSource.Ellipse();    				System.Random randGenerator = new Random(1432);    				ScanlineRenderer scanlineRenderer = new ScanlineRenderer();  				int i;  				int num = (int)numMasksSlider.Value;  				for (i = 0; i < num; i++)  				{  					if (i == num - 1)  					{  						ellipseForMask.init(Width / 2' Height / 2' 110' 110' 100);  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes(0' 0' 0' 255));    						ellipseForMask.init(ellipseForMask.originX' ellipseForMask.originY' ellipseForMask.radiusX - 10' ellipseForMask.radiusY - 10' 100);  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes(255' 0' 0' 255));  					}  					else  					{  						ellipseForMask.init(randGenerator.Next() % cx'  								 randGenerator.Next() % cy'  								 randGenerator.Next() % 100 + 20'  								 randGenerator.Next() % 100 + 20'  								 100);  						// set the color to draw into the alpha channel.  						// there is not very much reason to set the alpha as you will get the amount of  						// transparency based on the color you draw.  (you might want some type of different edeg effect but it will be minor).  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes((int)((float)i / (float)num * 255)' 0' 0' 255));  					}  				}    				alphaMaskImageBuffer.DettachBuffer();  			}
Magic Number,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,generate_alpha_mask,The following statement contains a magic number: {  #if USE_CLIPPING_ALPHA_MASK  				alphaMaskImageBuffer.AttachBuffer(alphaByteArray' 20 * cx + 20' cx - 40' cy - 40' cx' 8' 1);  #else                  alphaMaskImageBuffer.attach(alphaByteArray' (int)cx' (int)cy' cx' 1);  #endif    				ImageBuffer image = new ImageBuffer();  				image.Attach(alphaMaskImageBuffer' new blender_gray(1)' 1' 0' 8);  				ImageClippingProxy clippingProxy = new ImageClippingProxy(image);  				ScanlineCachePacked8 sl = new ScanlineCachePacked8();    				clippingProxy.clear(new RGBA_Floats(0));    				VertexSource.Ellipse ellipseForMask = new MatterHackers.Agg.VertexSource.Ellipse();    				System.Random randGenerator = new Random(1432);    				ScanlineRenderer scanlineRenderer = new ScanlineRenderer();  				int i;  				int num = (int)numMasksSlider.Value;  				for (i = 0; i < num; i++)  				{  					if (i == num - 1)  					{  						ellipseForMask.init(Width / 2' Height / 2' 110' 110' 100);  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes(0' 0' 0' 255));    						ellipseForMask.init(ellipseForMask.originX' ellipseForMask.originY' ellipseForMask.radiusX - 10' ellipseForMask.radiusY - 10' 100);  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes(255' 0' 0' 255));  					}  					else  					{  						ellipseForMask.init(randGenerator.Next() % cx'  								 randGenerator.Next() % cy'  								 randGenerator.Next() % 100 + 20'  								 randGenerator.Next() % 100 + 20'  								 100);  						// set the color to draw into the alpha channel.  						// there is not very much reason to set the alpha as you will get the amount of  						// transparency based on the color you draw.  (you might want some type of different edeg effect but it will be minor).  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes((int)((float)i / (float)num * 255)' 0' 0' 255));  					}  				}    				alphaMaskImageBuffer.DettachBuffer();  			}
Magic Number,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,generate_alpha_mask,The following statement contains a magic number: {  #if USE_CLIPPING_ALPHA_MASK  				alphaMaskImageBuffer.AttachBuffer(alphaByteArray' 20 * cx + 20' cx - 40' cy - 40' cx' 8' 1);  #else                  alphaMaskImageBuffer.attach(alphaByteArray' (int)cx' (int)cy' cx' 1);  #endif    				ImageBuffer image = new ImageBuffer();  				image.Attach(alphaMaskImageBuffer' new blender_gray(1)' 1' 0' 8);  				ImageClippingProxy clippingProxy = new ImageClippingProxy(image);  				ScanlineCachePacked8 sl = new ScanlineCachePacked8();    				clippingProxy.clear(new RGBA_Floats(0));    				VertexSource.Ellipse ellipseForMask = new MatterHackers.Agg.VertexSource.Ellipse();    				System.Random randGenerator = new Random(1432);    				ScanlineRenderer scanlineRenderer = new ScanlineRenderer();  				int i;  				int num = (int)numMasksSlider.Value;  				for (i = 0; i < num; i++)  				{  					if (i == num - 1)  					{  						ellipseForMask.init(Width / 2' Height / 2' 110' 110' 100);  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes(0' 0' 0' 255));    						ellipseForMask.init(ellipseForMask.originX' ellipseForMask.originY' ellipseForMask.radiusX - 10' ellipseForMask.radiusY - 10' 100);  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes(255' 0' 0' 255));  					}  					else  					{  						ellipseForMask.init(randGenerator.Next() % cx'  								 randGenerator.Next() % cy'  								 randGenerator.Next() % 100 + 20'  								 randGenerator.Next() % 100 + 20'  								 100);  						// set the color to draw into the alpha channel.  						// there is not very much reason to set the alpha as you will get the amount of  						// transparency based on the color you draw.  (you might want some type of different edeg effect but it will be minor).  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes((int)((float)i / (float)num * 255)' 0' 0' 255));  					}  				}    				alphaMaskImageBuffer.DettachBuffer();  			}
Magic Number,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,generate_alpha_mask,The following statement contains a magic number: {  #if USE_CLIPPING_ALPHA_MASK  				alphaMaskImageBuffer.AttachBuffer(alphaByteArray' 20 * cx + 20' cx - 40' cy - 40' cx' 8' 1);  #else                  alphaMaskImageBuffer.attach(alphaByteArray' (int)cx' (int)cy' cx' 1);  #endif    				ImageBuffer image = new ImageBuffer();  				image.Attach(alphaMaskImageBuffer' new blender_gray(1)' 1' 0' 8);  				ImageClippingProxy clippingProxy = new ImageClippingProxy(image);  				ScanlineCachePacked8 sl = new ScanlineCachePacked8();    				clippingProxy.clear(new RGBA_Floats(0));    				VertexSource.Ellipse ellipseForMask = new MatterHackers.Agg.VertexSource.Ellipse();    				System.Random randGenerator = new Random(1432);    				ScanlineRenderer scanlineRenderer = new ScanlineRenderer();  				int i;  				int num = (int)numMasksSlider.Value;  				for (i = 0; i < num; i++)  				{  					if (i == num - 1)  					{  						ellipseForMask.init(Width / 2' Height / 2' 110' 110' 100);  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes(0' 0' 0' 255));    						ellipseForMask.init(ellipseForMask.originX' ellipseForMask.originY' ellipseForMask.radiusX - 10' ellipseForMask.radiusY - 10' 100);  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes(255' 0' 0' 255));  					}  					else  					{  						ellipseForMask.init(randGenerator.Next() % cx'  								 randGenerator.Next() % cy'  								 randGenerator.Next() % 100 + 20'  								 randGenerator.Next() % 100 + 20'  								 100);  						// set the color to draw into the alpha channel.  						// there is not very much reason to set the alpha as you will get the amount of  						// transparency based on the color you draw.  (you might want some type of different edeg effect but it will be minor).  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes((int)((float)i / (float)num * 255)' 0' 0' 255));  					}  				}    				alphaMaskImageBuffer.DettachBuffer();  			}
Magic Number,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,generate_alpha_mask,The following statement contains a magic number: {  #if USE_CLIPPING_ALPHA_MASK  				alphaMaskImageBuffer.AttachBuffer(alphaByteArray' 20 * cx + 20' cx - 40' cy - 40' cx' 8' 1);  #else                  alphaMaskImageBuffer.attach(alphaByteArray' (int)cx' (int)cy' cx' 1);  #endif    				ImageBuffer image = new ImageBuffer();  				image.Attach(alphaMaskImageBuffer' new blender_gray(1)' 1' 0' 8);  				ImageClippingProxy clippingProxy = new ImageClippingProxy(image);  				ScanlineCachePacked8 sl = new ScanlineCachePacked8();    				clippingProxy.clear(new RGBA_Floats(0));    				VertexSource.Ellipse ellipseForMask = new MatterHackers.Agg.VertexSource.Ellipse();    				System.Random randGenerator = new Random(1432);    				ScanlineRenderer scanlineRenderer = new ScanlineRenderer();  				int i;  				int num = (int)numMasksSlider.Value;  				for (i = 0; i < num; i++)  				{  					if (i == num - 1)  					{  						ellipseForMask.init(Width / 2' Height / 2' 110' 110' 100);  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes(0' 0' 0' 255));    						ellipseForMask.init(ellipseForMask.originX' ellipseForMask.originY' ellipseForMask.radiusX - 10' ellipseForMask.radiusY - 10' 100);  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes(255' 0' 0' 255));  					}  					else  					{  						ellipseForMask.init(randGenerator.Next() % cx'  								 randGenerator.Next() % cy'  								 randGenerator.Next() % 100 + 20'  								 randGenerator.Next() % 100 + 20'  								 100);  						// set the color to draw into the alpha channel.  						// there is not very much reason to set the alpha as you will get the amount of  						// transparency based on the color you draw.  (you might want some type of different edeg effect but it will be minor).  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes((int)((float)i / (float)num * 255)' 0' 0' 255));  					}  				}    				alphaMaskImageBuffer.DettachBuffer();  			}
Magic Number,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,generate_alpha_mask,The following statement contains a magic number: {  #if USE_CLIPPING_ALPHA_MASK  				alphaMaskImageBuffer.AttachBuffer(alphaByteArray' 20 * cx + 20' cx - 40' cy - 40' cx' 8' 1);  #else                  alphaMaskImageBuffer.attach(alphaByteArray' (int)cx' (int)cy' cx' 1);  #endif    				ImageBuffer image = new ImageBuffer();  				image.Attach(alphaMaskImageBuffer' new blender_gray(1)' 1' 0' 8);  				ImageClippingProxy clippingProxy = new ImageClippingProxy(image);  				ScanlineCachePacked8 sl = new ScanlineCachePacked8();    				clippingProxy.clear(new RGBA_Floats(0));    				VertexSource.Ellipse ellipseForMask = new MatterHackers.Agg.VertexSource.Ellipse();    				System.Random randGenerator = new Random(1432);    				ScanlineRenderer scanlineRenderer = new ScanlineRenderer();  				int i;  				int num = (int)numMasksSlider.Value;  				for (i = 0; i < num; i++)  				{  					if (i == num - 1)  					{  						ellipseForMask.init(Width / 2' Height / 2' 110' 110' 100);  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes(0' 0' 0' 255));    						ellipseForMask.init(ellipseForMask.originX' ellipseForMask.originY' ellipseForMask.radiusX - 10' ellipseForMask.radiusY - 10' 100);  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes(255' 0' 0' 255));  					}  					else  					{  						ellipseForMask.init(randGenerator.Next() % cx'  								 randGenerator.Next() % cy'  								 randGenerator.Next() % 100 + 20'  								 randGenerator.Next() % 100 + 20'  								 100);  						// set the color to draw into the alpha channel.  						// there is not very much reason to set the alpha as you will get the amount of  						// transparency based on the color you draw.  (you might want some type of different edeg effect but it will be minor).  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes((int)((float)i / (float)num * 255)' 0' 0' 255));  					}  				}    				alphaMaskImageBuffer.DettachBuffer();  			}
Magic Number,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,generate_alpha_mask,The following statement contains a magic number: {  #if USE_CLIPPING_ALPHA_MASK  				alphaMaskImageBuffer.AttachBuffer(alphaByteArray' 20 * cx + 20' cx - 40' cy - 40' cx' 8' 1);  #else                  alphaMaskImageBuffer.attach(alphaByteArray' (int)cx' (int)cy' cx' 1);  #endif    				ImageBuffer image = new ImageBuffer();  				image.Attach(alphaMaskImageBuffer' new blender_gray(1)' 1' 0' 8);  				ImageClippingProxy clippingProxy = new ImageClippingProxy(image);  				ScanlineCachePacked8 sl = new ScanlineCachePacked8();    				clippingProxy.clear(new RGBA_Floats(0));    				VertexSource.Ellipse ellipseForMask = new MatterHackers.Agg.VertexSource.Ellipse();    				System.Random randGenerator = new Random(1432);    				ScanlineRenderer scanlineRenderer = new ScanlineRenderer();  				int i;  				int num = (int)numMasksSlider.Value;  				for (i = 0; i < num; i++)  				{  					if (i == num - 1)  					{  						ellipseForMask.init(Width / 2' Height / 2' 110' 110' 100);  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes(0' 0' 0' 255));    						ellipseForMask.init(ellipseForMask.originX' ellipseForMask.originY' ellipseForMask.radiusX - 10' ellipseForMask.radiusY - 10' 100);  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes(255' 0' 0' 255));  					}  					else  					{  						ellipseForMask.init(randGenerator.Next() % cx'  								 randGenerator.Next() % cy'  								 randGenerator.Next() % 100 + 20'  								 randGenerator.Next() % 100 + 20'  								 100);  						// set the color to draw into the alpha channel.  						// there is not very much reason to set the alpha as you will get the amount of  						// transparency based on the color you draw.  (you might want some type of different edeg effect but it will be minor).  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes((int)((float)i / (float)num * 255)' 0' 0' 255));  					}  				}    				alphaMaskImageBuffer.DettachBuffer();  			}
Magic Number,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,generate_alpha_mask,The following statement contains a magic number: {  #if USE_CLIPPING_ALPHA_MASK  				alphaMaskImageBuffer.AttachBuffer(alphaByteArray' 20 * cx + 20' cx - 40' cy - 40' cx' 8' 1);  #else                  alphaMaskImageBuffer.attach(alphaByteArray' (int)cx' (int)cy' cx' 1);  #endif    				ImageBuffer image = new ImageBuffer();  				image.Attach(alphaMaskImageBuffer' new blender_gray(1)' 1' 0' 8);  				ImageClippingProxy clippingProxy = new ImageClippingProxy(image);  				ScanlineCachePacked8 sl = new ScanlineCachePacked8();    				clippingProxy.clear(new RGBA_Floats(0));    				VertexSource.Ellipse ellipseForMask = new MatterHackers.Agg.VertexSource.Ellipse();    				System.Random randGenerator = new Random(1432);    				ScanlineRenderer scanlineRenderer = new ScanlineRenderer();  				int i;  				int num = (int)numMasksSlider.Value;  				for (i = 0; i < num; i++)  				{  					if (i == num - 1)  					{  						ellipseForMask.init(Width / 2' Height / 2' 110' 110' 100);  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes(0' 0' 0' 255));    						ellipseForMask.init(ellipseForMask.originX' ellipseForMask.originY' ellipseForMask.radiusX - 10' ellipseForMask.radiusY - 10' 100);  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes(255' 0' 0' 255));  					}  					else  					{  						ellipseForMask.init(randGenerator.Next() % cx'  								 randGenerator.Next() % cy'  								 randGenerator.Next() % 100 + 20'  								 randGenerator.Next() % 100 + 20'  								 100);  						// set the color to draw into the alpha channel.  						// there is not very much reason to set the alpha as you will get the amount of  						// transparency based on the color you draw.  (you might want some type of different edeg effect but it will be minor).  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes((int)((float)i / (float)num * 255)' 0' 0' 255));  					}  				}    				alphaMaskImageBuffer.DettachBuffer();  			}
Magic Number,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,generate_alpha_mask,The following statement contains a magic number: {  #if USE_CLIPPING_ALPHA_MASK  				alphaMaskImageBuffer.AttachBuffer(alphaByteArray' 20 * cx + 20' cx - 40' cy - 40' cx' 8' 1);  #else                  alphaMaskImageBuffer.attach(alphaByteArray' (int)cx' (int)cy' cx' 1);  #endif    				ImageBuffer image = new ImageBuffer();  				image.Attach(alphaMaskImageBuffer' new blender_gray(1)' 1' 0' 8);  				ImageClippingProxy clippingProxy = new ImageClippingProxy(image);  				ScanlineCachePacked8 sl = new ScanlineCachePacked8();    				clippingProxy.clear(new RGBA_Floats(0));    				VertexSource.Ellipse ellipseForMask = new MatterHackers.Agg.VertexSource.Ellipse();    				System.Random randGenerator = new Random(1432);    				ScanlineRenderer scanlineRenderer = new ScanlineRenderer();  				int i;  				int num = (int)numMasksSlider.Value;  				for (i = 0; i < num; i++)  				{  					if (i == num - 1)  					{  						ellipseForMask.init(Width / 2' Height / 2' 110' 110' 100);  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes(0' 0' 0' 255));    						ellipseForMask.init(ellipseForMask.originX' ellipseForMask.originY' ellipseForMask.radiusX - 10' ellipseForMask.radiusY - 10' 100);  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes(255' 0' 0' 255));  					}  					else  					{  						ellipseForMask.init(randGenerator.Next() % cx'  								 randGenerator.Next() % cy'  								 randGenerator.Next() % 100 + 20'  								 randGenerator.Next() % 100 + 20'  								 100);  						// set the color to draw into the alpha channel.  						// there is not very much reason to set the alpha as you will get the amount of  						// transparency based on the color you draw.  (you might want some type of different edeg effect but it will be minor).  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes((int)((float)i / (float)num * 255)' 0' 0' 255));  					}  				}    				alphaMaskImageBuffer.DettachBuffer();  			}
Magic Number,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,generate_alpha_mask,The following statement contains a magic number: {  #if USE_CLIPPING_ALPHA_MASK  				alphaMaskImageBuffer.AttachBuffer(alphaByteArray' 20 * cx + 20' cx - 40' cy - 40' cx' 8' 1);  #else                  alphaMaskImageBuffer.attach(alphaByteArray' (int)cx' (int)cy' cx' 1);  #endif    				ImageBuffer image = new ImageBuffer();  				image.Attach(alphaMaskImageBuffer' new blender_gray(1)' 1' 0' 8);  				ImageClippingProxy clippingProxy = new ImageClippingProxy(image);  				ScanlineCachePacked8 sl = new ScanlineCachePacked8();    				clippingProxy.clear(new RGBA_Floats(0));    				VertexSource.Ellipse ellipseForMask = new MatterHackers.Agg.VertexSource.Ellipse();    				System.Random randGenerator = new Random(1432);    				ScanlineRenderer scanlineRenderer = new ScanlineRenderer();  				int i;  				int num = (int)numMasksSlider.Value;  				for (i = 0; i < num; i++)  				{  					if (i == num - 1)  					{  						ellipseForMask.init(Width / 2' Height / 2' 110' 110' 100);  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes(0' 0' 0' 255));    						ellipseForMask.init(ellipseForMask.originX' ellipseForMask.originY' ellipseForMask.radiusX - 10' ellipseForMask.radiusY - 10' 100);  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes(255' 0' 0' 255));  					}  					else  					{  						ellipseForMask.init(randGenerator.Next() % cx'  								 randGenerator.Next() % cy'  								 randGenerator.Next() % 100 + 20'  								 randGenerator.Next() % 100 + 20'  								 100);  						// set the color to draw into the alpha channel.  						// there is not very much reason to set the alpha as you will get the amount of  						// transparency based on the color you draw.  (you might want some type of different edeg effect but it will be minor).  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes((int)((float)i / (float)num * 255)' 0' 0' 255));  					}  				}    				alphaMaskImageBuffer.DettachBuffer();  			}
Magic Number,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,generate_alpha_mask,The following statement contains a magic number: {  #if USE_CLIPPING_ALPHA_MASK  				alphaMaskImageBuffer.AttachBuffer(alphaByteArray' 20 * cx + 20' cx - 40' cy - 40' cx' 8' 1);  #else                  alphaMaskImageBuffer.attach(alphaByteArray' (int)cx' (int)cy' cx' 1);  #endif    				ImageBuffer image = new ImageBuffer();  				image.Attach(alphaMaskImageBuffer' new blender_gray(1)' 1' 0' 8);  				ImageClippingProxy clippingProxy = new ImageClippingProxy(image);  				ScanlineCachePacked8 sl = new ScanlineCachePacked8();    				clippingProxy.clear(new RGBA_Floats(0));    				VertexSource.Ellipse ellipseForMask = new MatterHackers.Agg.VertexSource.Ellipse();    				System.Random randGenerator = new Random(1432);    				ScanlineRenderer scanlineRenderer = new ScanlineRenderer();  				int i;  				int num = (int)numMasksSlider.Value;  				for (i = 0; i < num; i++)  				{  					if (i == num - 1)  					{  						ellipseForMask.init(Width / 2' Height / 2' 110' 110' 100);  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes(0' 0' 0' 255));    						ellipseForMask.init(ellipseForMask.originX' ellipseForMask.originY' ellipseForMask.radiusX - 10' ellipseForMask.radiusY - 10' 100);  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes(255' 0' 0' 255));  					}  					else  					{  						ellipseForMask.init(randGenerator.Next() % cx'  								 randGenerator.Next() % cy'  								 randGenerator.Next() % 100 + 20'  								 randGenerator.Next() % 100 + 20'  								 100);  						// set the color to draw into the alpha channel.  						// there is not very much reason to set the alpha as you will get the amount of  						// transparency based on the color you draw.  (you might want some type of different edeg effect but it will be minor).  						rasterizer.add_path(ellipseForMask);  						scanlineRenderer.RenderSolid(clippingProxy' rasterizer' sl' new RGBA_Bytes((int)((float)i / (float)num * 255)' 0' 0' 255));  					}  				}    				alphaMaskImageBuffer.DettachBuffer();  			}
Magic Number,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,OnDraw,The following statement contains a magic number: unsafe  			{  				alphaMaskImageBuffer.AttachBuffer(alphaByteArray' 0' width' height' width' 8' 1);    				MatterHackers.Agg.Image.AlphaMaskAdaptor imageAlphaMaskAdaptor = new MatterHackers.Agg.Image.AlphaMaskAdaptor(widgetsSubImage' alphaMask);  				ImageClippingProxy alphaMaskClippingProxy = new ImageClippingProxy(imageAlphaMaskAdaptor);  				ImageClippingProxy clippingProxy = new ImageClippingProxy(widgetsSubImage);    				Affine transform = Affine.NewIdentity();  				transform *= Affine.NewTranslation(-lionShape.Center.x' -lionShape.Center.y);  				transform *= Affine.NewScaling(lionScale' lionScale);  				transform *= Affine.NewRotation(angle + Math.PI);  				transform *= Affine.NewSkewing(skewX / 1000.0' skewY / 1000.0);  				transform *= Affine.NewTranslation(Width / 2' Height / 2);    				clippingProxy.clear(new RGBA_Floats(1' 1' 1));    				ScanlineRenderer scanlineRenderer = new ScanlineRenderer();  				// draw a background to show how the mask is working better  				int RectWidth = 30;  				for (int i = 0; i < 40; i++)  				{  					for (int j = 0; j < 40; j++)  					{  						if ((i + j) % 2 != 0)  						{  							VertexSource.RoundedRect rect = new VertexSource.RoundedRect(i * RectWidth' j * RectWidth' (i + 1) * RectWidth' (j + 1) * RectWidth' 0);  							rect.normalize_radius();    							// Drawing as an outline  							rasterizer.add_path(rect);  							scanlineRenderer.RenderSolid(clippingProxy' rasterizer' scanlineCache' new RGBA_Bytes(.9' .9' .9));  						}  					}  				}    				//int x' y;    				// Render the lion  				VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' transform);  				scanlineRenderer.RenderSolidAllPaths(alphaMaskClippingProxy' rasterizer' scanlineCache' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);    				/*  				// Render random Bresenham lines and markers  				agg::renderer_markers<amask_ren_type> m(r);  				for(i = 0; i < 50; i++)  				{  					m.line_color(agg::rgba8(randGenerator.Next() & 0x7F'  											randGenerator.Next() & 0x7F'  											randGenerator.Next() & 0x7F'  											(randGenerator.Next() & 0x7F) + 0x7F));  					m.fill_color(agg::rgba8(randGenerator.Next() & 0x7F'  											randGenerator.Next() & 0x7F'  											randGenerator.Next() & 0x7F'  											(randGenerator.Next() & 0x7F) + 0x7F));    					m.line(m.coord(randGenerator.Next() % width)' m.coord(randGenerator.Next() % height)'  						   m.coord(randGenerator.Next() % width)' m.coord(randGenerator.Next() % height));    					m.marker(randGenerator.Next() % width' randGenerator.Next() % height' randGenerator.Next() % 10 + 5'  							 agg::marker_e(randGenerator.Next() % agg::end_of_markers));  				}    				// Render random anti-aliased lines  				double w = 5.0;  				agg::line_profile_aa profile;  				profile.width(w);    				typedef agg::renderer_outline_aa<amask_ren_type> renderer_type;  				renderer_type ren(r' profile);    				typedef agg::rasterizer_outline_aa<renderer_type> rasterizer_type;  				rasterizer_type ras(ren);  				ras.round_cap(true);    				for(i = 0; i < 50; i++)  				{  					ren.Color = agg::rgba8(randGenerator.Next() & 0x7F'  										 randGenerator.Next() & 0x7F'  										 randGenerator.Next() & 0x7F'  										 //255));  										 (randGenerator.Next() & 0x7F) + 0x7F);  					ras.move_to_d(randGenerator.Next() % width' randGenerator.Next() % height);  					ras.line_to_d(randGenerator.Next() % width' randGenerator.Next() % height);  					ras.render(false);  				}    				// Render random circles with gradient  				typedef agg::gradient_linear_color<color_type> grad_color;  				typedef agg::gradient_circle grad_func;  				typedef agg::span_interpolator_linear<> interpolator_type;  				typedef agg::span_gradient<color_type'  										  interpolator_type'  										  grad_func'  										  grad_color> span_grad_type;    				agg::trans_affine grm;  				grad_func grf;  				grad_color grc(agg::rgba8(0'0'0)' agg::rgba8(0'0'0));  				agg::ellipse ell;  				agg::span_allocator<color_type> sa;  				interpolator_type inter(grm);  				span_grad_type sg(inter' grf' grc' 0' 10);  				agg::renderer_scanline_aa<amask_ren_type'  										  agg::span_allocator<color_type>'  										  span_grad_type> rg(r' sa' sg);  				for(i = 0; i < 50; i++)  				{  					x = randGenerator.Next() % width;  					y = randGenerator.Next() % height;  					double r = randGenerator.Next() % 10 + 5;  					grm.reset();  					grm *= agg::trans_affine_scaling(r / 10.0);  					grm *= agg::trans_affine_translation(x' y);  					grm.invert();  					grc.colors(agg::rgba8(255' 255' 255' 0)'  							   agg::rgba8(randGenerator.Next() & 0x7F'  										  randGenerator.Next() & 0x7F'  										  randGenerator.Next() & 0x7F'  										  255));  					sg.color_function(grc);  					ell.init(x' y' r' r' 32);  					g_rasterizer.add_path(ell);  					agg::render_scanlines(g_rasterizer' g_scanline' rg);  				}  				 */    				//m_num_cb.Render(g_rasterizer' g_scanline' clippingProxy);  			}
Magic Number,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,OnDraw,The following statement contains a magic number: unsafe  			{  				alphaMaskImageBuffer.AttachBuffer(alphaByteArray' 0' width' height' width' 8' 1);    				MatterHackers.Agg.Image.AlphaMaskAdaptor imageAlphaMaskAdaptor = new MatterHackers.Agg.Image.AlphaMaskAdaptor(widgetsSubImage' alphaMask);  				ImageClippingProxy alphaMaskClippingProxy = new ImageClippingProxy(imageAlphaMaskAdaptor);  				ImageClippingProxy clippingProxy = new ImageClippingProxy(widgetsSubImage);    				Affine transform = Affine.NewIdentity();  				transform *= Affine.NewTranslation(-lionShape.Center.x' -lionShape.Center.y);  				transform *= Affine.NewScaling(lionScale' lionScale);  				transform *= Affine.NewRotation(angle + Math.PI);  				transform *= Affine.NewSkewing(skewX / 1000.0' skewY / 1000.0);  				transform *= Affine.NewTranslation(Width / 2' Height / 2);    				clippingProxy.clear(new RGBA_Floats(1' 1' 1));    				ScanlineRenderer scanlineRenderer = new ScanlineRenderer();  				// draw a background to show how the mask is working better  				int RectWidth = 30;  				for (int i = 0; i < 40; i++)  				{  					for (int j = 0; j < 40; j++)  					{  						if ((i + j) % 2 != 0)  						{  							VertexSource.RoundedRect rect = new VertexSource.RoundedRect(i * RectWidth' j * RectWidth' (i + 1) * RectWidth' (j + 1) * RectWidth' 0);  							rect.normalize_radius();    							// Drawing as an outline  							rasterizer.add_path(rect);  							scanlineRenderer.RenderSolid(clippingProxy' rasterizer' scanlineCache' new RGBA_Bytes(.9' .9' .9));  						}  					}  				}    				//int x' y;    				// Render the lion  				VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' transform);  				scanlineRenderer.RenderSolidAllPaths(alphaMaskClippingProxy' rasterizer' scanlineCache' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);    				/*  				// Render random Bresenham lines and markers  				agg::renderer_markers<amask_ren_type> m(r);  				for(i = 0; i < 50; i++)  				{  					m.line_color(agg::rgba8(randGenerator.Next() & 0x7F'  											randGenerator.Next() & 0x7F'  											randGenerator.Next() & 0x7F'  											(randGenerator.Next() & 0x7F) + 0x7F));  					m.fill_color(agg::rgba8(randGenerator.Next() & 0x7F'  											randGenerator.Next() & 0x7F'  											randGenerator.Next() & 0x7F'  											(randGenerator.Next() & 0x7F) + 0x7F));    					m.line(m.coord(randGenerator.Next() % width)' m.coord(randGenerator.Next() % height)'  						   m.coord(randGenerator.Next() % width)' m.coord(randGenerator.Next() % height));    					m.marker(randGenerator.Next() % width' randGenerator.Next() % height' randGenerator.Next() % 10 + 5'  							 agg::marker_e(randGenerator.Next() % agg::end_of_markers));  				}    				// Render random anti-aliased lines  				double w = 5.0;  				agg::line_profile_aa profile;  				profile.width(w);    				typedef agg::renderer_outline_aa<amask_ren_type> renderer_type;  				renderer_type ren(r' profile);    				typedef agg::rasterizer_outline_aa<renderer_type> rasterizer_type;  				rasterizer_type ras(ren);  				ras.round_cap(true);    				for(i = 0; i < 50; i++)  				{  					ren.Color = agg::rgba8(randGenerator.Next() & 0x7F'  										 randGenerator.Next() & 0x7F'  										 randGenerator.Next() & 0x7F'  										 //255));  										 (randGenerator.Next() & 0x7F) + 0x7F);  					ras.move_to_d(randGenerator.Next() % width' randGenerator.Next() % height);  					ras.line_to_d(randGenerator.Next() % width' randGenerator.Next() % height);  					ras.render(false);  				}    				// Render random circles with gradient  				typedef agg::gradient_linear_color<color_type> grad_color;  				typedef agg::gradient_circle grad_func;  				typedef agg::span_interpolator_linear<> interpolator_type;  				typedef agg::span_gradient<color_type'  										  interpolator_type'  										  grad_func'  										  grad_color> span_grad_type;    				agg::trans_affine grm;  				grad_func grf;  				grad_color grc(agg::rgba8(0'0'0)' agg::rgba8(0'0'0));  				agg::ellipse ell;  				agg::span_allocator<color_type> sa;  				interpolator_type inter(grm);  				span_grad_type sg(inter' grf' grc' 0' 10);  				agg::renderer_scanline_aa<amask_ren_type'  										  agg::span_allocator<color_type>'  										  span_grad_type> rg(r' sa' sg);  				for(i = 0; i < 50; i++)  				{  					x = randGenerator.Next() % width;  					y = randGenerator.Next() % height;  					double r = randGenerator.Next() % 10 + 5;  					grm.reset();  					grm *= agg::trans_affine_scaling(r / 10.0);  					grm *= agg::trans_affine_translation(x' y);  					grm.invert();  					grc.colors(agg::rgba8(255' 255' 255' 0)'  							   agg::rgba8(randGenerator.Next() & 0x7F'  										  randGenerator.Next() & 0x7F'  										  randGenerator.Next() & 0x7F'  										  255));  					sg.color_function(grc);  					ell.init(x' y' r' r' 32);  					g_rasterizer.add_path(ell);  					agg::render_scanlines(g_rasterizer' g_scanline' rg);  				}  				 */    				//m_num_cb.Render(g_rasterizer' g_scanline' clippingProxy);  			}
Magic Number,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,OnDraw,The following statement contains a magic number: unsafe  			{  				alphaMaskImageBuffer.AttachBuffer(alphaByteArray' 0' width' height' width' 8' 1);    				MatterHackers.Agg.Image.AlphaMaskAdaptor imageAlphaMaskAdaptor = new MatterHackers.Agg.Image.AlphaMaskAdaptor(widgetsSubImage' alphaMask);  				ImageClippingProxy alphaMaskClippingProxy = new ImageClippingProxy(imageAlphaMaskAdaptor);  				ImageClippingProxy clippingProxy = new ImageClippingProxy(widgetsSubImage);    				Affine transform = Affine.NewIdentity();  				transform *= Affine.NewTranslation(-lionShape.Center.x' -lionShape.Center.y);  				transform *= Affine.NewScaling(lionScale' lionScale);  				transform *= Affine.NewRotation(angle + Math.PI);  				transform *= Affine.NewSkewing(skewX / 1000.0' skewY / 1000.0);  				transform *= Affine.NewTranslation(Width / 2' Height / 2);    				clippingProxy.clear(new RGBA_Floats(1' 1' 1));    				ScanlineRenderer scanlineRenderer = new ScanlineRenderer();  				// draw a background to show how the mask is working better  				int RectWidth = 30;  				for (int i = 0; i < 40; i++)  				{  					for (int j = 0; j < 40; j++)  					{  						if ((i + j) % 2 != 0)  						{  							VertexSource.RoundedRect rect = new VertexSource.RoundedRect(i * RectWidth' j * RectWidth' (i + 1) * RectWidth' (j + 1) * RectWidth' 0);  							rect.normalize_radius();    							// Drawing as an outline  							rasterizer.add_path(rect);  							scanlineRenderer.RenderSolid(clippingProxy' rasterizer' scanlineCache' new RGBA_Bytes(.9' .9' .9));  						}  					}  				}    				//int x' y;    				// Render the lion  				VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' transform);  				scanlineRenderer.RenderSolidAllPaths(alphaMaskClippingProxy' rasterizer' scanlineCache' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);    				/*  				// Render random Bresenham lines and markers  				agg::renderer_markers<amask_ren_type> m(r);  				for(i = 0; i < 50; i++)  				{  					m.line_color(agg::rgba8(randGenerator.Next() & 0x7F'  											randGenerator.Next() & 0x7F'  											randGenerator.Next() & 0x7F'  											(randGenerator.Next() & 0x7F) + 0x7F));  					m.fill_color(agg::rgba8(randGenerator.Next() & 0x7F'  											randGenerator.Next() & 0x7F'  											randGenerator.Next() & 0x7F'  											(randGenerator.Next() & 0x7F) + 0x7F));    					m.line(m.coord(randGenerator.Next() % width)' m.coord(randGenerator.Next() % height)'  						   m.coord(randGenerator.Next() % width)' m.coord(randGenerator.Next() % height));    					m.marker(randGenerator.Next() % width' randGenerator.Next() % height' randGenerator.Next() % 10 + 5'  							 agg::marker_e(randGenerator.Next() % agg::end_of_markers));  				}    				// Render random anti-aliased lines  				double w = 5.0;  				agg::line_profile_aa profile;  				profile.width(w);    				typedef agg::renderer_outline_aa<amask_ren_type> renderer_type;  				renderer_type ren(r' profile);    				typedef agg::rasterizer_outline_aa<renderer_type> rasterizer_type;  				rasterizer_type ras(ren);  				ras.round_cap(true);    				for(i = 0; i < 50; i++)  				{  					ren.Color = agg::rgba8(randGenerator.Next() & 0x7F'  										 randGenerator.Next() & 0x7F'  										 randGenerator.Next() & 0x7F'  										 //255));  										 (randGenerator.Next() & 0x7F) + 0x7F);  					ras.move_to_d(randGenerator.Next() % width' randGenerator.Next() % height);  					ras.line_to_d(randGenerator.Next() % width' randGenerator.Next() % height);  					ras.render(false);  				}    				// Render random circles with gradient  				typedef agg::gradient_linear_color<color_type> grad_color;  				typedef agg::gradient_circle grad_func;  				typedef agg::span_interpolator_linear<> interpolator_type;  				typedef agg::span_gradient<color_type'  										  interpolator_type'  										  grad_func'  										  grad_color> span_grad_type;    				agg::trans_affine grm;  				grad_func grf;  				grad_color grc(agg::rgba8(0'0'0)' agg::rgba8(0'0'0));  				agg::ellipse ell;  				agg::span_allocator<color_type> sa;  				interpolator_type inter(grm);  				span_grad_type sg(inter' grf' grc' 0' 10);  				agg::renderer_scanline_aa<amask_ren_type'  										  agg::span_allocator<color_type>'  										  span_grad_type> rg(r' sa' sg);  				for(i = 0; i < 50; i++)  				{  					x = randGenerator.Next() % width;  					y = randGenerator.Next() % height;  					double r = randGenerator.Next() % 10 + 5;  					grm.reset();  					grm *= agg::trans_affine_scaling(r / 10.0);  					grm *= agg::trans_affine_translation(x' y);  					grm.invert();  					grc.colors(agg::rgba8(255' 255' 255' 0)'  							   agg::rgba8(randGenerator.Next() & 0x7F'  										  randGenerator.Next() & 0x7F'  										  randGenerator.Next() & 0x7F'  										  255));  					sg.color_function(grc);  					ell.init(x' y' r' r' 32);  					g_rasterizer.add_path(ell);  					agg::render_scanlines(g_rasterizer' g_scanline' rg);  				}  				 */    				//m_num_cb.Render(g_rasterizer' g_scanline' clippingProxy);  			}
Magic Number,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,OnDraw,The following statement contains a magic number: unsafe  			{  				alphaMaskImageBuffer.AttachBuffer(alphaByteArray' 0' width' height' width' 8' 1);    				MatterHackers.Agg.Image.AlphaMaskAdaptor imageAlphaMaskAdaptor = new MatterHackers.Agg.Image.AlphaMaskAdaptor(widgetsSubImage' alphaMask);  				ImageClippingProxy alphaMaskClippingProxy = new ImageClippingProxy(imageAlphaMaskAdaptor);  				ImageClippingProxy clippingProxy = new ImageClippingProxy(widgetsSubImage);    				Affine transform = Affine.NewIdentity();  				transform *= Affine.NewTranslation(-lionShape.Center.x' -lionShape.Center.y);  				transform *= Affine.NewScaling(lionScale' lionScale);  				transform *= Affine.NewRotation(angle + Math.PI);  				transform *= Affine.NewSkewing(skewX / 1000.0' skewY / 1000.0);  				transform *= Affine.NewTranslation(Width / 2' Height / 2);    				clippingProxy.clear(new RGBA_Floats(1' 1' 1));    				ScanlineRenderer scanlineRenderer = new ScanlineRenderer();  				// draw a background to show how the mask is working better  				int RectWidth = 30;  				for (int i = 0; i < 40; i++)  				{  					for (int j = 0; j < 40; j++)  					{  						if ((i + j) % 2 != 0)  						{  							VertexSource.RoundedRect rect = new VertexSource.RoundedRect(i * RectWidth' j * RectWidth' (i + 1) * RectWidth' (j + 1) * RectWidth' 0);  							rect.normalize_radius();    							// Drawing as an outline  							rasterizer.add_path(rect);  							scanlineRenderer.RenderSolid(clippingProxy' rasterizer' scanlineCache' new RGBA_Bytes(.9' .9' .9));  						}  					}  				}    				//int x' y;    				// Render the lion  				VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' transform);  				scanlineRenderer.RenderSolidAllPaths(alphaMaskClippingProxy' rasterizer' scanlineCache' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);    				/*  				// Render random Bresenham lines and markers  				agg::renderer_markers<amask_ren_type> m(r);  				for(i = 0; i < 50; i++)  				{  					m.line_color(agg::rgba8(randGenerator.Next() & 0x7F'  											randGenerator.Next() & 0x7F'  											randGenerator.Next() & 0x7F'  											(randGenerator.Next() & 0x7F) + 0x7F));  					m.fill_color(agg::rgba8(randGenerator.Next() & 0x7F'  											randGenerator.Next() & 0x7F'  											randGenerator.Next() & 0x7F'  											(randGenerator.Next() & 0x7F) + 0x7F));    					m.line(m.coord(randGenerator.Next() % width)' m.coord(randGenerator.Next() % height)'  						   m.coord(randGenerator.Next() % width)' m.coord(randGenerator.Next() % height));    					m.marker(randGenerator.Next() % width' randGenerator.Next() % height' randGenerator.Next() % 10 + 5'  							 agg::marker_e(randGenerator.Next() % agg::end_of_markers));  				}    				// Render random anti-aliased lines  				double w = 5.0;  				agg::line_profile_aa profile;  				profile.width(w);    				typedef agg::renderer_outline_aa<amask_ren_type> renderer_type;  				renderer_type ren(r' profile);    				typedef agg::rasterizer_outline_aa<renderer_type> rasterizer_type;  				rasterizer_type ras(ren);  				ras.round_cap(true);    				for(i = 0; i < 50; i++)  				{  					ren.Color = agg::rgba8(randGenerator.Next() & 0x7F'  										 randGenerator.Next() & 0x7F'  										 randGenerator.Next() & 0x7F'  										 //255));  										 (randGenerator.Next() & 0x7F) + 0x7F);  					ras.move_to_d(randGenerator.Next() % width' randGenerator.Next() % height);  					ras.line_to_d(randGenerator.Next() % width' randGenerator.Next() % height);  					ras.render(false);  				}    				// Render random circles with gradient  				typedef agg::gradient_linear_color<color_type> grad_color;  				typedef agg::gradient_circle grad_func;  				typedef agg::span_interpolator_linear<> interpolator_type;  				typedef agg::span_gradient<color_type'  										  interpolator_type'  										  grad_func'  										  grad_color> span_grad_type;    				agg::trans_affine grm;  				grad_func grf;  				grad_color grc(agg::rgba8(0'0'0)' agg::rgba8(0'0'0));  				agg::ellipse ell;  				agg::span_allocator<color_type> sa;  				interpolator_type inter(grm);  				span_grad_type sg(inter' grf' grc' 0' 10);  				agg::renderer_scanline_aa<amask_ren_type'  										  agg::span_allocator<color_type>'  										  span_grad_type> rg(r' sa' sg);  				for(i = 0; i < 50; i++)  				{  					x = randGenerator.Next() % width;  					y = randGenerator.Next() % height;  					double r = randGenerator.Next() % 10 + 5;  					grm.reset();  					grm *= agg::trans_affine_scaling(r / 10.0);  					grm *= agg::trans_affine_translation(x' y);  					grm.invert();  					grc.colors(agg::rgba8(255' 255' 255' 0)'  							   agg::rgba8(randGenerator.Next() & 0x7F'  										  randGenerator.Next() & 0x7F'  										  randGenerator.Next() & 0x7F'  										  255));  					sg.color_function(grc);  					ell.init(x' y' r' r' 32);  					g_rasterizer.add_path(ell);  					agg::render_scanlines(g_rasterizer' g_scanline' rg);  				}  				 */    				//m_num_cb.Render(g_rasterizer' g_scanline' clippingProxy);  			}
Magic Number,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,OnDraw,The following statement contains a magic number: unsafe  			{  				alphaMaskImageBuffer.AttachBuffer(alphaByteArray' 0' width' height' width' 8' 1);    				MatterHackers.Agg.Image.AlphaMaskAdaptor imageAlphaMaskAdaptor = new MatterHackers.Agg.Image.AlphaMaskAdaptor(widgetsSubImage' alphaMask);  				ImageClippingProxy alphaMaskClippingProxy = new ImageClippingProxy(imageAlphaMaskAdaptor);  				ImageClippingProxy clippingProxy = new ImageClippingProxy(widgetsSubImage);    				Affine transform = Affine.NewIdentity();  				transform *= Affine.NewTranslation(-lionShape.Center.x' -lionShape.Center.y);  				transform *= Affine.NewScaling(lionScale' lionScale);  				transform *= Affine.NewRotation(angle + Math.PI);  				transform *= Affine.NewSkewing(skewX / 1000.0' skewY / 1000.0);  				transform *= Affine.NewTranslation(Width / 2' Height / 2);    				clippingProxy.clear(new RGBA_Floats(1' 1' 1));    				ScanlineRenderer scanlineRenderer = new ScanlineRenderer();  				// draw a background to show how the mask is working better  				int RectWidth = 30;  				for (int i = 0; i < 40; i++)  				{  					for (int j = 0; j < 40; j++)  					{  						if ((i + j) % 2 != 0)  						{  							VertexSource.RoundedRect rect = new VertexSource.RoundedRect(i * RectWidth' j * RectWidth' (i + 1) * RectWidth' (j + 1) * RectWidth' 0);  							rect.normalize_radius();    							// Drawing as an outline  							rasterizer.add_path(rect);  							scanlineRenderer.RenderSolid(clippingProxy' rasterizer' scanlineCache' new RGBA_Bytes(.9' .9' .9));  						}  					}  				}    				//int x' y;    				// Render the lion  				VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' transform);  				scanlineRenderer.RenderSolidAllPaths(alphaMaskClippingProxy' rasterizer' scanlineCache' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);    				/*  				// Render random Bresenham lines and markers  				agg::renderer_markers<amask_ren_type> m(r);  				for(i = 0; i < 50; i++)  				{  					m.line_color(agg::rgba8(randGenerator.Next() & 0x7F'  											randGenerator.Next() & 0x7F'  											randGenerator.Next() & 0x7F'  											(randGenerator.Next() & 0x7F) + 0x7F));  					m.fill_color(agg::rgba8(randGenerator.Next() & 0x7F'  											randGenerator.Next() & 0x7F'  											randGenerator.Next() & 0x7F'  											(randGenerator.Next() & 0x7F) + 0x7F));    					m.line(m.coord(randGenerator.Next() % width)' m.coord(randGenerator.Next() % height)'  						   m.coord(randGenerator.Next() % width)' m.coord(randGenerator.Next() % height));    					m.marker(randGenerator.Next() % width' randGenerator.Next() % height' randGenerator.Next() % 10 + 5'  							 agg::marker_e(randGenerator.Next() % agg::end_of_markers));  				}    				// Render random anti-aliased lines  				double w = 5.0;  				agg::line_profile_aa profile;  				profile.width(w);    				typedef agg::renderer_outline_aa<amask_ren_type> renderer_type;  				renderer_type ren(r' profile);    				typedef agg::rasterizer_outline_aa<renderer_type> rasterizer_type;  				rasterizer_type ras(ren);  				ras.round_cap(true);    				for(i = 0; i < 50; i++)  				{  					ren.Color = agg::rgba8(randGenerator.Next() & 0x7F'  										 randGenerator.Next() & 0x7F'  										 randGenerator.Next() & 0x7F'  										 //255));  										 (randGenerator.Next() & 0x7F) + 0x7F);  					ras.move_to_d(randGenerator.Next() % width' randGenerator.Next() % height);  					ras.line_to_d(randGenerator.Next() % width' randGenerator.Next() % height);  					ras.render(false);  				}    				// Render random circles with gradient  				typedef agg::gradient_linear_color<color_type> grad_color;  				typedef agg::gradient_circle grad_func;  				typedef agg::span_interpolator_linear<> interpolator_type;  				typedef agg::span_gradient<color_type'  										  interpolator_type'  										  grad_func'  										  grad_color> span_grad_type;    				agg::trans_affine grm;  				grad_func grf;  				grad_color grc(agg::rgba8(0'0'0)' agg::rgba8(0'0'0));  				agg::ellipse ell;  				agg::span_allocator<color_type> sa;  				interpolator_type inter(grm);  				span_grad_type sg(inter' grf' grc' 0' 10);  				agg::renderer_scanline_aa<amask_ren_type'  										  agg::span_allocator<color_type>'  										  span_grad_type> rg(r' sa' sg);  				for(i = 0; i < 50; i++)  				{  					x = randGenerator.Next() % width;  					y = randGenerator.Next() % height;  					double r = randGenerator.Next() % 10 + 5;  					grm.reset();  					grm *= agg::trans_affine_scaling(r / 10.0);  					grm *= agg::trans_affine_translation(x' y);  					grm.invert();  					grc.colors(agg::rgba8(255' 255' 255' 0)'  							   agg::rgba8(randGenerator.Next() & 0x7F'  										  randGenerator.Next() & 0x7F'  										  randGenerator.Next() & 0x7F'  										  255));  					sg.color_function(grc);  					ell.init(x' y' r' r' 32);  					g_rasterizer.add_path(ell);  					agg::render_scanlines(g_rasterizer' g_scanline' rg);  				}  				 */    				//m_num_cb.Render(g_rasterizer' g_scanline' clippingProxy);  			}
Magic Number,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,OnDraw,The following statement contains a magic number: unsafe  			{  				alphaMaskImageBuffer.AttachBuffer(alphaByteArray' 0' width' height' width' 8' 1);    				MatterHackers.Agg.Image.AlphaMaskAdaptor imageAlphaMaskAdaptor = new MatterHackers.Agg.Image.AlphaMaskAdaptor(widgetsSubImage' alphaMask);  				ImageClippingProxy alphaMaskClippingProxy = new ImageClippingProxy(imageAlphaMaskAdaptor);  				ImageClippingProxy clippingProxy = new ImageClippingProxy(widgetsSubImage);    				Affine transform = Affine.NewIdentity();  				transform *= Affine.NewTranslation(-lionShape.Center.x' -lionShape.Center.y);  				transform *= Affine.NewScaling(lionScale' lionScale);  				transform *= Affine.NewRotation(angle + Math.PI);  				transform *= Affine.NewSkewing(skewX / 1000.0' skewY / 1000.0);  				transform *= Affine.NewTranslation(Width / 2' Height / 2);    				clippingProxy.clear(new RGBA_Floats(1' 1' 1));    				ScanlineRenderer scanlineRenderer = new ScanlineRenderer();  				// draw a background to show how the mask is working better  				int RectWidth = 30;  				for (int i = 0; i < 40; i++)  				{  					for (int j = 0; j < 40; j++)  					{  						if ((i + j) % 2 != 0)  						{  							VertexSource.RoundedRect rect = new VertexSource.RoundedRect(i * RectWidth' j * RectWidth' (i + 1) * RectWidth' (j + 1) * RectWidth' 0);  							rect.normalize_radius();    							// Drawing as an outline  							rasterizer.add_path(rect);  							scanlineRenderer.RenderSolid(clippingProxy' rasterizer' scanlineCache' new RGBA_Bytes(.9' .9' .9));  						}  					}  				}    				//int x' y;    				// Render the lion  				VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' transform);  				scanlineRenderer.RenderSolidAllPaths(alphaMaskClippingProxy' rasterizer' scanlineCache' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);    				/*  				// Render random Bresenham lines and markers  				agg::renderer_markers<amask_ren_type> m(r);  				for(i = 0; i < 50; i++)  				{  					m.line_color(agg::rgba8(randGenerator.Next() & 0x7F'  											randGenerator.Next() & 0x7F'  											randGenerator.Next() & 0x7F'  											(randGenerator.Next() & 0x7F) + 0x7F));  					m.fill_color(agg::rgba8(randGenerator.Next() & 0x7F'  											randGenerator.Next() & 0x7F'  											randGenerator.Next() & 0x7F'  											(randGenerator.Next() & 0x7F) + 0x7F));    					m.line(m.coord(randGenerator.Next() % width)' m.coord(randGenerator.Next() % height)'  						   m.coord(randGenerator.Next() % width)' m.coord(randGenerator.Next() % height));    					m.marker(randGenerator.Next() % width' randGenerator.Next() % height' randGenerator.Next() % 10 + 5'  							 agg::marker_e(randGenerator.Next() % agg::end_of_markers));  				}    				// Render random anti-aliased lines  				double w = 5.0;  				agg::line_profile_aa profile;  				profile.width(w);    				typedef agg::renderer_outline_aa<amask_ren_type> renderer_type;  				renderer_type ren(r' profile);    				typedef agg::rasterizer_outline_aa<renderer_type> rasterizer_type;  				rasterizer_type ras(ren);  				ras.round_cap(true);    				for(i = 0; i < 50; i++)  				{  					ren.Color = agg::rgba8(randGenerator.Next() & 0x7F'  										 randGenerator.Next() & 0x7F'  										 randGenerator.Next() & 0x7F'  										 //255));  										 (randGenerator.Next() & 0x7F) + 0x7F);  					ras.move_to_d(randGenerator.Next() % width' randGenerator.Next() % height);  					ras.line_to_d(randGenerator.Next() % width' randGenerator.Next() % height);  					ras.render(false);  				}    				// Render random circles with gradient  				typedef agg::gradient_linear_color<color_type> grad_color;  				typedef agg::gradient_circle grad_func;  				typedef agg::span_interpolator_linear<> interpolator_type;  				typedef agg::span_gradient<color_type'  										  interpolator_type'  										  grad_func'  										  grad_color> span_grad_type;    				agg::trans_affine grm;  				grad_func grf;  				grad_color grc(agg::rgba8(0'0'0)' agg::rgba8(0'0'0));  				agg::ellipse ell;  				agg::span_allocator<color_type> sa;  				interpolator_type inter(grm);  				span_grad_type sg(inter' grf' grc' 0' 10);  				agg::renderer_scanline_aa<amask_ren_type'  										  agg::span_allocator<color_type>'  										  span_grad_type> rg(r' sa' sg);  				for(i = 0; i < 50; i++)  				{  					x = randGenerator.Next() % width;  					y = randGenerator.Next() % height;  					double r = randGenerator.Next() % 10 + 5;  					grm.reset();  					grm *= agg::trans_affine_scaling(r / 10.0);  					grm *= agg::trans_affine_translation(x' y);  					grm.invert();  					grc.colors(agg::rgba8(255' 255' 255' 0)'  							   agg::rgba8(randGenerator.Next() & 0x7F'  										  randGenerator.Next() & 0x7F'  										  randGenerator.Next() & 0x7F'  										  255));  					sg.color_function(grc);  					ell.init(x' y' r' r' 32);  					g_rasterizer.add_path(ell);  					agg::render_scanlines(g_rasterizer' g_scanline' rg);  				}  				 */    				//m_num_cb.Render(g_rasterizer' g_scanline' clippingProxy);  			}
Magic Number,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,OnDraw,The following statement contains a magic number: unsafe  			{  				alphaMaskImageBuffer.AttachBuffer(alphaByteArray' 0' width' height' width' 8' 1);    				MatterHackers.Agg.Image.AlphaMaskAdaptor imageAlphaMaskAdaptor = new MatterHackers.Agg.Image.AlphaMaskAdaptor(widgetsSubImage' alphaMask);  				ImageClippingProxy alphaMaskClippingProxy = new ImageClippingProxy(imageAlphaMaskAdaptor);  				ImageClippingProxy clippingProxy = new ImageClippingProxy(widgetsSubImage);    				Affine transform = Affine.NewIdentity();  				transform *= Affine.NewTranslation(-lionShape.Center.x' -lionShape.Center.y);  				transform *= Affine.NewScaling(lionScale' lionScale);  				transform *= Affine.NewRotation(angle + Math.PI);  				transform *= Affine.NewSkewing(skewX / 1000.0' skewY / 1000.0);  				transform *= Affine.NewTranslation(Width / 2' Height / 2);    				clippingProxy.clear(new RGBA_Floats(1' 1' 1));    				ScanlineRenderer scanlineRenderer = new ScanlineRenderer();  				// draw a background to show how the mask is working better  				int RectWidth = 30;  				for (int i = 0; i < 40; i++)  				{  					for (int j = 0; j < 40; j++)  					{  						if ((i + j) % 2 != 0)  						{  							VertexSource.RoundedRect rect = new VertexSource.RoundedRect(i * RectWidth' j * RectWidth' (i + 1) * RectWidth' (j + 1) * RectWidth' 0);  							rect.normalize_radius();    							// Drawing as an outline  							rasterizer.add_path(rect);  							scanlineRenderer.RenderSolid(clippingProxy' rasterizer' scanlineCache' new RGBA_Bytes(.9' .9' .9));  						}  					}  				}    				//int x' y;    				// Render the lion  				VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' transform);  				scanlineRenderer.RenderSolidAllPaths(alphaMaskClippingProxy' rasterizer' scanlineCache' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);    				/*  				// Render random Bresenham lines and markers  				agg::renderer_markers<amask_ren_type> m(r);  				for(i = 0; i < 50; i++)  				{  					m.line_color(agg::rgba8(randGenerator.Next() & 0x7F'  											randGenerator.Next() & 0x7F'  											randGenerator.Next() & 0x7F'  											(randGenerator.Next() & 0x7F) + 0x7F));  					m.fill_color(agg::rgba8(randGenerator.Next() & 0x7F'  											randGenerator.Next() & 0x7F'  											randGenerator.Next() & 0x7F'  											(randGenerator.Next() & 0x7F) + 0x7F));    					m.line(m.coord(randGenerator.Next() % width)' m.coord(randGenerator.Next() % height)'  						   m.coord(randGenerator.Next() % width)' m.coord(randGenerator.Next() % height));    					m.marker(randGenerator.Next() % width' randGenerator.Next() % height' randGenerator.Next() % 10 + 5'  							 agg::marker_e(randGenerator.Next() % agg::end_of_markers));  				}    				// Render random anti-aliased lines  				double w = 5.0;  				agg::line_profile_aa profile;  				profile.width(w);    				typedef agg::renderer_outline_aa<amask_ren_type> renderer_type;  				renderer_type ren(r' profile);    				typedef agg::rasterizer_outline_aa<renderer_type> rasterizer_type;  				rasterizer_type ras(ren);  				ras.round_cap(true);    				for(i = 0; i < 50; i++)  				{  					ren.Color = agg::rgba8(randGenerator.Next() & 0x7F'  										 randGenerator.Next() & 0x7F'  										 randGenerator.Next() & 0x7F'  										 //255));  										 (randGenerator.Next() & 0x7F) + 0x7F);  					ras.move_to_d(randGenerator.Next() % width' randGenerator.Next() % height);  					ras.line_to_d(randGenerator.Next() % width' randGenerator.Next() % height);  					ras.render(false);  				}    				// Render random circles with gradient  				typedef agg::gradient_linear_color<color_type> grad_color;  				typedef agg::gradient_circle grad_func;  				typedef agg::span_interpolator_linear<> interpolator_type;  				typedef agg::span_gradient<color_type'  										  interpolator_type'  										  grad_func'  										  grad_color> span_grad_type;    				agg::trans_affine grm;  				grad_func grf;  				grad_color grc(agg::rgba8(0'0'0)' agg::rgba8(0'0'0));  				agg::ellipse ell;  				agg::span_allocator<color_type> sa;  				interpolator_type inter(grm);  				span_grad_type sg(inter' grf' grc' 0' 10);  				agg::renderer_scanline_aa<amask_ren_type'  										  agg::span_allocator<color_type>'  										  span_grad_type> rg(r' sa' sg);  				for(i = 0; i < 50; i++)  				{  					x = randGenerator.Next() % width;  					y = randGenerator.Next() % height;  					double r = randGenerator.Next() % 10 + 5;  					grm.reset();  					grm *= agg::trans_affine_scaling(r / 10.0);  					grm *= agg::trans_affine_translation(x' y);  					grm.invert();  					grc.colors(agg::rgba8(255' 255' 255' 0)'  							   agg::rgba8(randGenerator.Next() & 0x7F'  										  randGenerator.Next() & 0x7F'  										  randGenerator.Next() & 0x7F'  										  255));  					sg.color_function(grc);  					ell.init(x' y' r' r' 32);  					g_rasterizer.add_path(ell);  					agg::render_scanlines(g_rasterizer' g_scanline' rg);  				}  				 */    				//m_num_cb.Render(g_rasterizer' g_scanline' clippingProxy);  			}
Magic Number,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,OnDraw,The following statement contains a magic number: unsafe  			{  				alphaMaskImageBuffer.AttachBuffer(alphaByteArray' 0' width' height' width' 8' 1);    				MatterHackers.Agg.Image.AlphaMaskAdaptor imageAlphaMaskAdaptor = new MatterHackers.Agg.Image.AlphaMaskAdaptor(widgetsSubImage' alphaMask);  				ImageClippingProxy alphaMaskClippingProxy = new ImageClippingProxy(imageAlphaMaskAdaptor);  				ImageClippingProxy clippingProxy = new ImageClippingProxy(widgetsSubImage);    				Affine transform = Affine.NewIdentity();  				transform *= Affine.NewTranslation(-lionShape.Center.x' -lionShape.Center.y);  				transform *= Affine.NewScaling(lionScale' lionScale);  				transform *= Affine.NewRotation(angle + Math.PI);  				transform *= Affine.NewSkewing(skewX / 1000.0' skewY / 1000.0);  				transform *= Affine.NewTranslation(Width / 2' Height / 2);    				clippingProxy.clear(new RGBA_Floats(1' 1' 1));    				ScanlineRenderer scanlineRenderer = new ScanlineRenderer();  				// draw a background to show how the mask is working better  				int RectWidth = 30;  				for (int i = 0; i < 40; i++)  				{  					for (int j = 0; j < 40; j++)  					{  						if ((i + j) % 2 != 0)  						{  							VertexSource.RoundedRect rect = new VertexSource.RoundedRect(i * RectWidth' j * RectWidth' (i + 1) * RectWidth' (j + 1) * RectWidth' 0);  							rect.normalize_radius();    							// Drawing as an outline  							rasterizer.add_path(rect);  							scanlineRenderer.RenderSolid(clippingProxy' rasterizer' scanlineCache' new RGBA_Bytes(.9' .9' .9));  						}  					}  				}    				//int x' y;    				// Render the lion  				VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' transform);  				scanlineRenderer.RenderSolidAllPaths(alphaMaskClippingProxy' rasterizer' scanlineCache' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);    				/*  				// Render random Bresenham lines and markers  				agg::renderer_markers<amask_ren_type> m(r);  				for(i = 0; i < 50; i++)  				{  					m.line_color(agg::rgba8(randGenerator.Next() & 0x7F'  											randGenerator.Next() & 0x7F'  											randGenerator.Next() & 0x7F'  											(randGenerator.Next() & 0x7F) + 0x7F));  					m.fill_color(agg::rgba8(randGenerator.Next() & 0x7F'  											randGenerator.Next() & 0x7F'  											randGenerator.Next() & 0x7F'  											(randGenerator.Next() & 0x7F) + 0x7F));    					m.line(m.coord(randGenerator.Next() % width)' m.coord(randGenerator.Next() % height)'  						   m.coord(randGenerator.Next() % width)' m.coord(randGenerator.Next() % height));    					m.marker(randGenerator.Next() % width' randGenerator.Next() % height' randGenerator.Next() % 10 + 5'  							 agg::marker_e(randGenerator.Next() % agg::end_of_markers));  				}    				// Render random anti-aliased lines  				double w = 5.0;  				agg::line_profile_aa profile;  				profile.width(w);    				typedef agg::renderer_outline_aa<amask_ren_type> renderer_type;  				renderer_type ren(r' profile);    				typedef agg::rasterizer_outline_aa<renderer_type> rasterizer_type;  				rasterizer_type ras(ren);  				ras.round_cap(true);    				for(i = 0; i < 50; i++)  				{  					ren.Color = agg::rgba8(randGenerator.Next() & 0x7F'  										 randGenerator.Next() & 0x7F'  										 randGenerator.Next() & 0x7F'  										 //255));  										 (randGenerator.Next() & 0x7F) + 0x7F);  					ras.move_to_d(randGenerator.Next() % width' randGenerator.Next() % height);  					ras.line_to_d(randGenerator.Next() % width' randGenerator.Next() % height);  					ras.render(false);  				}    				// Render random circles with gradient  				typedef agg::gradient_linear_color<color_type> grad_color;  				typedef agg::gradient_circle grad_func;  				typedef agg::span_interpolator_linear<> interpolator_type;  				typedef agg::span_gradient<color_type'  										  interpolator_type'  										  grad_func'  										  grad_color> span_grad_type;    				agg::trans_affine grm;  				grad_func grf;  				grad_color grc(agg::rgba8(0'0'0)' agg::rgba8(0'0'0));  				agg::ellipse ell;  				agg::span_allocator<color_type> sa;  				interpolator_type inter(grm);  				span_grad_type sg(inter' grf' grc' 0' 10);  				agg::renderer_scanline_aa<amask_ren_type'  										  agg::span_allocator<color_type>'  										  span_grad_type> rg(r' sa' sg);  				for(i = 0; i < 50; i++)  				{  					x = randGenerator.Next() % width;  					y = randGenerator.Next() % height;  					double r = randGenerator.Next() % 10 + 5;  					grm.reset();  					grm *= agg::trans_affine_scaling(r / 10.0);  					grm *= agg::trans_affine_translation(x' y);  					grm.invert();  					grc.colors(agg::rgba8(255' 255' 255' 0)'  							   agg::rgba8(randGenerator.Next() & 0x7F'  										  randGenerator.Next() & 0x7F'  										  randGenerator.Next() & 0x7F'  										  255));  					sg.color_function(grc);  					ell.init(x' y' r' r' 32);  					g_rasterizer.add_path(ell);  					agg::render_scanlines(g_rasterizer' g_scanline' rg);  				}  				 */    				//m_num_cb.Render(g_rasterizer' g_scanline' clippingProxy);  			}
Magic Number,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,OnDraw,The following statement contains a magic number: unsafe  			{  				alphaMaskImageBuffer.AttachBuffer(alphaByteArray' 0' width' height' width' 8' 1);    				MatterHackers.Agg.Image.AlphaMaskAdaptor imageAlphaMaskAdaptor = new MatterHackers.Agg.Image.AlphaMaskAdaptor(widgetsSubImage' alphaMask);  				ImageClippingProxy alphaMaskClippingProxy = new ImageClippingProxy(imageAlphaMaskAdaptor);  				ImageClippingProxy clippingProxy = new ImageClippingProxy(widgetsSubImage);    				Affine transform = Affine.NewIdentity();  				transform *= Affine.NewTranslation(-lionShape.Center.x' -lionShape.Center.y);  				transform *= Affine.NewScaling(lionScale' lionScale);  				transform *= Affine.NewRotation(angle + Math.PI);  				transform *= Affine.NewSkewing(skewX / 1000.0' skewY / 1000.0);  				transform *= Affine.NewTranslation(Width / 2' Height / 2);    				clippingProxy.clear(new RGBA_Floats(1' 1' 1));    				ScanlineRenderer scanlineRenderer = new ScanlineRenderer();  				// draw a background to show how the mask is working better  				int RectWidth = 30;  				for (int i = 0; i < 40; i++)  				{  					for (int j = 0; j < 40; j++)  					{  						if ((i + j) % 2 != 0)  						{  							VertexSource.RoundedRect rect = new VertexSource.RoundedRect(i * RectWidth' j * RectWidth' (i + 1) * RectWidth' (j + 1) * RectWidth' 0);  							rect.normalize_radius();    							// Drawing as an outline  							rasterizer.add_path(rect);  							scanlineRenderer.RenderSolid(clippingProxy' rasterizer' scanlineCache' new RGBA_Bytes(.9' .9' .9));  						}  					}  				}    				//int x' y;    				// Render the lion  				VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' transform);  				scanlineRenderer.RenderSolidAllPaths(alphaMaskClippingProxy' rasterizer' scanlineCache' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);    				/*  				// Render random Bresenham lines and markers  				agg::renderer_markers<amask_ren_type> m(r);  				for(i = 0; i < 50; i++)  				{  					m.line_color(agg::rgba8(randGenerator.Next() & 0x7F'  											randGenerator.Next() & 0x7F'  											randGenerator.Next() & 0x7F'  											(randGenerator.Next() & 0x7F) + 0x7F));  					m.fill_color(agg::rgba8(randGenerator.Next() & 0x7F'  											randGenerator.Next() & 0x7F'  											randGenerator.Next() & 0x7F'  											(randGenerator.Next() & 0x7F) + 0x7F));    					m.line(m.coord(randGenerator.Next() % width)' m.coord(randGenerator.Next() % height)'  						   m.coord(randGenerator.Next() % width)' m.coord(randGenerator.Next() % height));    					m.marker(randGenerator.Next() % width' randGenerator.Next() % height' randGenerator.Next() % 10 + 5'  							 agg::marker_e(randGenerator.Next() % agg::end_of_markers));  				}    				// Render random anti-aliased lines  				double w = 5.0;  				agg::line_profile_aa profile;  				profile.width(w);    				typedef agg::renderer_outline_aa<amask_ren_type> renderer_type;  				renderer_type ren(r' profile);    				typedef agg::rasterizer_outline_aa<renderer_type> rasterizer_type;  				rasterizer_type ras(ren);  				ras.round_cap(true);    				for(i = 0; i < 50; i++)  				{  					ren.Color = agg::rgba8(randGenerator.Next() & 0x7F'  										 randGenerator.Next() & 0x7F'  										 randGenerator.Next() & 0x7F'  										 //255));  										 (randGenerator.Next() & 0x7F) + 0x7F);  					ras.move_to_d(randGenerator.Next() % width' randGenerator.Next() % height);  					ras.line_to_d(randGenerator.Next() % width' randGenerator.Next() % height);  					ras.render(false);  				}    				// Render random circles with gradient  				typedef agg::gradient_linear_color<color_type> grad_color;  				typedef agg::gradient_circle grad_func;  				typedef agg::span_interpolator_linear<> interpolator_type;  				typedef agg::span_gradient<color_type'  										  interpolator_type'  										  grad_func'  										  grad_color> span_grad_type;    				agg::trans_affine grm;  				grad_func grf;  				grad_color grc(agg::rgba8(0'0'0)' agg::rgba8(0'0'0));  				agg::ellipse ell;  				agg::span_allocator<color_type> sa;  				interpolator_type inter(grm);  				span_grad_type sg(inter' grf' grc' 0' 10);  				agg::renderer_scanline_aa<amask_ren_type'  										  agg::span_allocator<color_type>'  										  span_grad_type> rg(r' sa' sg);  				for(i = 0; i < 50; i++)  				{  					x = randGenerator.Next() % width;  					y = randGenerator.Next() % height;  					double r = randGenerator.Next() % 10 + 5;  					grm.reset();  					grm *= agg::trans_affine_scaling(r / 10.0);  					grm *= agg::trans_affine_translation(x' y);  					grm.invert();  					grc.colors(agg::rgba8(255' 255' 255' 0)'  							   agg::rgba8(randGenerator.Next() & 0x7F'  										  randGenerator.Next() & 0x7F'  										  randGenerator.Next() & 0x7F'  										  255));  					sg.color_function(grc);  					ell.init(x' y' r' r' 32);  					g_rasterizer.add_path(ell);  					agg::render_scanlines(g_rasterizer' g_scanline' rg);  				}  				 */    				//m_num_cb.Render(g_rasterizer' g_scanline' clippingProxy);  			}
Magic Number,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,OnDraw,The following statement contains a magic number: unsafe  			{  				alphaMaskImageBuffer.AttachBuffer(alphaByteArray' 0' width' height' width' 8' 1);    				MatterHackers.Agg.Image.AlphaMaskAdaptor imageAlphaMaskAdaptor = new MatterHackers.Agg.Image.AlphaMaskAdaptor(widgetsSubImage' alphaMask);  				ImageClippingProxy alphaMaskClippingProxy = new ImageClippingProxy(imageAlphaMaskAdaptor);  				ImageClippingProxy clippingProxy = new ImageClippingProxy(widgetsSubImage);    				Affine transform = Affine.NewIdentity();  				transform *= Affine.NewTranslation(-lionShape.Center.x' -lionShape.Center.y);  				transform *= Affine.NewScaling(lionScale' lionScale);  				transform *= Affine.NewRotation(angle + Math.PI);  				transform *= Affine.NewSkewing(skewX / 1000.0' skewY / 1000.0);  				transform *= Affine.NewTranslation(Width / 2' Height / 2);    				clippingProxy.clear(new RGBA_Floats(1' 1' 1));    				ScanlineRenderer scanlineRenderer = new ScanlineRenderer();  				// draw a background to show how the mask is working better  				int RectWidth = 30;  				for (int i = 0; i < 40; i++)  				{  					for (int j = 0; j < 40; j++)  					{  						if ((i + j) % 2 != 0)  						{  							VertexSource.RoundedRect rect = new VertexSource.RoundedRect(i * RectWidth' j * RectWidth' (i + 1) * RectWidth' (j + 1) * RectWidth' 0);  							rect.normalize_radius();    							// Drawing as an outline  							rasterizer.add_path(rect);  							scanlineRenderer.RenderSolid(clippingProxy' rasterizer' scanlineCache' new RGBA_Bytes(.9' .9' .9));  						}  					}  				}    				//int x' y;    				// Render the lion  				VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' transform);  				scanlineRenderer.RenderSolidAllPaths(alphaMaskClippingProxy' rasterizer' scanlineCache' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);    				/*  				// Render random Bresenham lines and markers  				agg::renderer_markers<amask_ren_type> m(r);  				for(i = 0; i < 50; i++)  				{  					m.line_color(agg::rgba8(randGenerator.Next() & 0x7F'  											randGenerator.Next() & 0x7F'  											randGenerator.Next() & 0x7F'  											(randGenerator.Next() & 0x7F) + 0x7F));  					m.fill_color(agg::rgba8(randGenerator.Next() & 0x7F'  											randGenerator.Next() & 0x7F'  											randGenerator.Next() & 0x7F'  											(randGenerator.Next() & 0x7F) + 0x7F));    					m.line(m.coord(randGenerator.Next() % width)' m.coord(randGenerator.Next() % height)'  						   m.coord(randGenerator.Next() % width)' m.coord(randGenerator.Next() % height));    					m.marker(randGenerator.Next() % width' randGenerator.Next() % height' randGenerator.Next() % 10 + 5'  							 agg::marker_e(randGenerator.Next() % agg::end_of_markers));  				}    				// Render random anti-aliased lines  				double w = 5.0;  				agg::line_profile_aa profile;  				profile.width(w);    				typedef agg::renderer_outline_aa<amask_ren_type> renderer_type;  				renderer_type ren(r' profile);    				typedef agg::rasterizer_outline_aa<renderer_type> rasterizer_type;  				rasterizer_type ras(ren);  				ras.round_cap(true);    				for(i = 0; i < 50; i++)  				{  					ren.Color = agg::rgba8(randGenerator.Next() & 0x7F'  										 randGenerator.Next() & 0x7F'  										 randGenerator.Next() & 0x7F'  										 //255));  										 (randGenerator.Next() & 0x7F) + 0x7F);  					ras.move_to_d(randGenerator.Next() % width' randGenerator.Next() % height);  					ras.line_to_d(randGenerator.Next() % width' randGenerator.Next() % height);  					ras.render(false);  				}    				// Render random circles with gradient  				typedef agg::gradient_linear_color<color_type> grad_color;  				typedef agg::gradient_circle grad_func;  				typedef agg::span_interpolator_linear<> interpolator_type;  				typedef agg::span_gradient<color_type'  										  interpolator_type'  										  grad_func'  										  grad_color> span_grad_type;    				agg::trans_affine grm;  				grad_func grf;  				grad_color grc(agg::rgba8(0'0'0)' agg::rgba8(0'0'0));  				agg::ellipse ell;  				agg::span_allocator<color_type> sa;  				interpolator_type inter(grm);  				span_grad_type sg(inter' grf' grc' 0' 10);  				agg::renderer_scanline_aa<amask_ren_type'  										  agg::span_allocator<color_type>'  										  span_grad_type> rg(r' sa' sg);  				for(i = 0; i < 50; i++)  				{  					x = randGenerator.Next() % width;  					y = randGenerator.Next() % height;  					double r = randGenerator.Next() % 10 + 5;  					grm.reset();  					grm *= agg::trans_affine_scaling(r / 10.0);  					grm *= agg::trans_affine_translation(x' y);  					grm.invert();  					grc.colors(agg::rgba8(255' 255' 255' 0)'  							   agg::rgba8(randGenerator.Next() & 0x7F'  										  randGenerator.Next() & 0x7F'  										  randGenerator.Next() & 0x7F'  										  255));  					sg.color_function(grc);  					ell.init(x' y' r' r' 32);  					g_rasterizer.add_path(ell);  					agg::render_scanlines(g_rasterizer' g_scanline' rg);  				}  				 */    				//m_num_cb.Render(g_rasterizer' g_scanline' clippingProxy);  			}
Magic Number,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,OnDraw,The following statement contains a magic number: unsafe  			{  				alphaMaskImageBuffer.AttachBuffer(alphaByteArray' 0' width' height' width' 8' 1);    				MatterHackers.Agg.Image.AlphaMaskAdaptor imageAlphaMaskAdaptor = new MatterHackers.Agg.Image.AlphaMaskAdaptor(widgetsSubImage' alphaMask);  				ImageClippingProxy alphaMaskClippingProxy = new ImageClippingProxy(imageAlphaMaskAdaptor);  				ImageClippingProxy clippingProxy = new ImageClippingProxy(widgetsSubImage);    				Affine transform = Affine.NewIdentity();  				transform *= Affine.NewTranslation(-lionShape.Center.x' -lionShape.Center.y);  				transform *= Affine.NewScaling(lionScale' lionScale);  				transform *= Affine.NewRotation(angle + Math.PI);  				transform *= Affine.NewSkewing(skewX / 1000.0' skewY / 1000.0);  				transform *= Affine.NewTranslation(Width / 2' Height / 2);    				clippingProxy.clear(new RGBA_Floats(1' 1' 1));    				ScanlineRenderer scanlineRenderer = new ScanlineRenderer();  				// draw a background to show how the mask is working better  				int RectWidth = 30;  				for (int i = 0; i < 40; i++)  				{  					for (int j = 0; j < 40; j++)  					{  						if ((i + j) % 2 != 0)  						{  							VertexSource.RoundedRect rect = new VertexSource.RoundedRect(i * RectWidth' j * RectWidth' (i + 1) * RectWidth' (j + 1) * RectWidth' 0);  							rect.normalize_radius();    							// Drawing as an outline  							rasterizer.add_path(rect);  							scanlineRenderer.RenderSolid(clippingProxy' rasterizer' scanlineCache' new RGBA_Bytes(.9' .9' .9));  						}  					}  				}    				//int x' y;    				// Render the lion  				VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' transform);  				scanlineRenderer.RenderSolidAllPaths(alphaMaskClippingProxy' rasterizer' scanlineCache' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);    				/*  				// Render random Bresenham lines and markers  				agg::renderer_markers<amask_ren_type> m(r);  				for(i = 0; i < 50; i++)  				{  					m.line_color(agg::rgba8(randGenerator.Next() & 0x7F'  											randGenerator.Next() & 0x7F'  											randGenerator.Next() & 0x7F'  											(randGenerator.Next() & 0x7F) + 0x7F));  					m.fill_color(agg::rgba8(randGenerator.Next() & 0x7F'  											randGenerator.Next() & 0x7F'  											randGenerator.Next() & 0x7F'  											(randGenerator.Next() & 0x7F) + 0x7F));    					m.line(m.coord(randGenerator.Next() % width)' m.coord(randGenerator.Next() % height)'  						   m.coord(randGenerator.Next() % width)' m.coord(randGenerator.Next() % height));    					m.marker(randGenerator.Next() % width' randGenerator.Next() % height' randGenerator.Next() % 10 + 5'  							 agg::marker_e(randGenerator.Next() % agg::end_of_markers));  				}    				// Render random anti-aliased lines  				double w = 5.0;  				agg::line_profile_aa profile;  				profile.width(w);    				typedef agg::renderer_outline_aa<amask_ren_type> renderer_type;  				renderer_type ren(r' profile);    				typedef agg::rasterizer_outline_aa<renderer_type> rasterizer_type;  				rasterizer_type ras(ren);  				ras.round_cap(true);    				for(i = 0; i < 50; i++)  				{  					ren.Color = agg::rgba8(randGenerator.Next() & 0x7F'  										 randGenerator.Next() & 0x7F'  										 randGenerator.Next() & 0x7F'  										 //255));  										 (randGenerator.Next() & 0x7F) + 0x7F);  					ras.move_to_d(randGenerator.Next() % width' randGenerator.Next() % height);  					ras.line_to_d(randGenerator.Next() % width' randGenerator.Next() % height);  					ras.render(false);  				}    				// Render random circles with gradient  				typedef agg::gradient_linear_color<color_type> grad_color;  				typedef agg::gradient_circle grad_func;  				typedef agg::span_interpolator_linear<> interpolator_type;  				typedef agg::span_gradient<color_type'  										  interpolator_type'  										  grad_func'  										  grad_color> span_grad_type;    				agg::trans_affine grm;  				grad_func grf;  				grad_color grc(agg::rgba8(0'0'0)' agg::rgba8(0'0'0));  				agg::ellipse ell;  				agg::span_allocator<color_type> sa;  				interpolator_type inter(grm);  				span_grad_type sg(inter' grf' grc' 0' 10);  				agg::renderer_scanline_aa<amask_ren_type'  										  agg::span_allocator<color_type>'  										  span_grad_type> rg(r' sa' sg);  				for(i = 0; i < 50; i++)  				{  					x = randGenerator.Next() % width;  					y = randGenerator.Next() % height;  					double r = randGenerator.Next() % 10 + 5;  					grm.reset();  					grm *= agg::trans_affine_scaling(r / 10.0);  					grm *= agg::trans_affine_translation(x' y);  					grm.invert();  					grc.colors(agg::rgba8(255' 255' 255' 0)'  							   agg::rgba8(randGenerator.Next() & 0x7F'  										  randGenerator.Next() & 0x7F'  										  randGenerator.Next() & 0x7F'  										  255));  					sg.color_function(grc);  					ell.init(x' y' r' r' 32);  					g_rasterizer.add_path(ell);  					agg::render_scanlines(g_rasterizer' g_scanline' rg);  				}  				 */    				//m_num_cb.Render(g_rasterizer' g_scanline' clippingProxy);  			}
Magic Number,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,OnDraw,The following statement contains a magic number: unsafe  			{  				alphaMaskImageBuffer.AttachBuffer(alphaByteArray' 0' width' height' width' 8' 1);    				MatterHackers.Agg.Image.AlphaMaskAdaptor imageAlphaMaskAdaptor = new MatterHackers.Agg.Image.AlphaMaskAdaptor(widgetsSubImage' alphaMask);  				ImageClippingProxy alphaMaskClippingProxy = new ImageClippingProxy(imageAlphaMaskAdaptor);  				ImageClippingProxy clippingProxy = new ImageClippingProxy(widgetsSubImage);    				Affine transform = Affine.NewIdentity();  				transform *= Affine.NewTranslation(-lionShape.Center.x' -lionShape.Center.y);  				transform *= Affine.NewScaling(lionScale' lionScale);  				transform *= Affine.NewRotation(angle + Math.PI);  				transform *= Affine.NewSkewing(skewX / 1000.0' skewY / 1000.0);  				transform *= Affine.NewTranslation(Width / 2' Height / 2);    				clippingProxy.clear(new RGBA_Floats(1' 1' 1));    				ScanlineRenderer scanlineRenderer = new ScanlineRenderer();  				// draw a background to show how the mask is working better  				int RectWidth = 30;  				for (int i = 0; i < 40; i++)  				{  					for (int j = 0; j < 40; j++)  					{  						if ((i + j) % 2 != 0)  						{  							VertexSource.RoundedRect rect = new VertexSource.RoundedRect(i * RectWidth' j * RectWidth' (i + 1) * RectWidth' (j + 1) * RectWidth' 0);  							rect.normalize_radius();    							// Drawing as an outline  							rasterizer.add_path(rect);  							scanlineRenderer.RenderSolid(clippingProxy' rasterizer' scanlineCache' new RGBA_Bytes(.9' .9' .9));  						}  					}  				}    				//int x' y;    				// Render the lion  				VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' transform);  				scanlineRenderer.RenderSolidAllPaths(alphaMaskClippingProxy' rasterizer' scanlineCache' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);    				/*  				// Render random Bresenham lines and markers  				agg::renderer_markers<amask_ren_type> m(r);  				for(i = 0; i < 50; i++)  				{  					m.line_color(agg::rgba8(randGenerator.Next() & 0x7F'  											randGenerator.Next() & 0x7F'  											randGenerator.Next() & 0x7F'  											(randGenerator.Next() & 0x7F) + 0x7F));  					m.fill_color(agg::rgba8(randGenerator.Next() & 0x7F'  											randGenerator.Next() & 0x7F'  											randGenerator.Next() & 0x7F'  											(randGenerator.Next() & 0x7F) + 0x7F));    					m.line(m.coord(randGenerator.Next() % width)' m.coord(randGenerator.Next() % height)'  						   m.coord(randGenerator.Next() % width)' m.coord(randGenerator.Next() % height));    					m.marker(randGenerator.Next() % width' randGenerator.Next() % height' randGenerator.Next() % 10 + 5'  							 agg::marker_e(randGenerator.Next() % agg::end_of_markers));  				}    				// Render random anti-aliased lines  				double w = 5.0;  				agg::line_profile_aa profile;  				profile.width(w);    				typedef agg::renderer_outline_aa<amask_ren_type> renderer_type;  				renderer_type ren(r' profile);    				typedef agg::rasterizer_outline_aa<renderer_type> rasterizer_type;  				rasterizer_type ras(ren);  				ras.round_cap(true);    				for(i = 0; i < 50; i++)  				{  					ren.Color = agg::rgba8(randGenerator.Next() & 0x7F'  										 randGenerator.Next() & 0x7F'  										 randGenerator.Next() & 0x7F'  										 //255));  										 (randGenerator.Next() & 0x7F) + 0x7F);  					ras.move_to_d(randGenerator.Next() % width' randGenerator.Next() % height);  					ras.line_to_d(randGenerator.Next() % width' randGenerator.Next() % height);  					ras.render(false);  				}    				// Render random circles with gradient  				typedef agg::gradient_linear_color<color_type> grad_color;  				typedef agg::gradient_circle grad_func;  				typedef agg::span_interpolator_linear<> interpolator_type;  				typedef agg::span_gradient<color_type'  										  interpolator_type'  										  grad_func'  										  grad_color> span_grad_type;    				agg::trans_affine grm;  				grad_func grf;  				grad_color grc(agg::rgba8(0'0'0)' agg::rgba8(0'0'0));  				agg::ellipse ell;  				agg::span_allocator<color_type> sa;  				interpolator_type inter(grm);  				span_grad_type sg(inter' grf' grc' 0' 10);  				agg::renderer_scanline_aa<amask_ren_type'  										  agg::span_allocator<color_type>'  										  span_grad_type> rg(r' sa' sg);  				for(i = 0; i < 50; i++)  				{  					x = randGenerator.Next() % width;  					y = randGenerator.Next() % height;  					double r = randGenerator.Next() % 10 + 5;  					grm.reset();  					grm *= agg::trans_affine_scaling(r / 10.0);  					grm *= agg::trans_affine_translation(x' y);  					grm.invert();  					grc.colors(agg::rgba8(255' 255' 255' 0)'  							   agg::rgba8(randGenerator.Next() & 0x7F'  										  randGenerator.Next() & 0x7F'  										  randGenerator.Next() & 0x7F'  										  255));  					sg.color_function(grc);  					ell.init(x' y' r' r' 32);  					g_rasterizer.add_path(ell);  					agg::render_scanlines(g_rasterizer' g_scanline' rg);  				}  				 */    				//m_num_cb.Render(g_rasterizer' g_scanline' clippingProxy);  			}
Magic Number,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,doTransform,The following statement contains a magic number: x -= width / 2;
Magic Number,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,doTransform,The following statement contains a magic number: y -= height / 2;
Magic Number,MatterHackers.Agg,alpha_mask2_application,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,doTransform,The following statement contains a magic number: lionScale = Math.Sqrt(y * y + x * x) / 100.0;
Magic Number,MatterHackers.Agg,AlphaMask2Factory,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,GetAppParameters,The following statement contains a magic number: AppWidgetInfo appWidgetInfo = new AppWidgetInfo(  				"Bitmap"'  				"Clipping to multiple rectangle regions"'  				@""'  										   512'  										   400);
Magic Number,MatterHackers.Agg,AlphaMask2Factory,C:\repos\MatterHackers_agg-sharp\examples\alpha_mask2\alpha_mask2.cs,GetAppParameters,The following statement contains a magic number: AppWidgetInfo appWidgetInfo = new AppWidgetInfo(  				"Bitmap"'  				"Clipping to multiple rectangle regions"'  				@""'  										   512'  										   400);
