Implementation smell,Namespace,Class,File,Method,Description
Long Method,MatterHackers.VeldridProvider,VeldridWindowProvider,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\VeldridWindowProvider.cs,ShowSystemWindow,The method has 112 lines of code.
Complex Method,MatterHackers.VeldridProvider,VeldridWindowProvider,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\VeldridWindowProvider.cs,ShowSystemWindow,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,DrawArrays,Cyclomatic complexity of the method is 9
Long Parameter List,MatterHackers.VeldridProvider,Graphics2DVeldrid,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\Graphics2DVeldrid.cs,FillRectangle,The method has 5 parameters. Parameters: left' bottom' right' top' fillColor
Long Parameter List,MatterHackers.VeldridProvider,Graphics2DVeldrid,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\Graphics2DVeldrid.cs,Rectangle,The method has 6 parameters. Parameters: left' bottom' right' top' color' strokeWidth
Long Parameter List,MatterHackers.VeldridProvider,Graphics2DVeldrid,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\Graphics2DVeldrid.cs,Render,The method has 6 parameters. Parameters: imageSource' x' y' angleRadians' scaleX' ScaleY
Long Parameter List,MatterHackers.VeldridProvider,Graphics2DVeldrid,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\Graphics2DVeldrid.cs,Render,The method has 6 parameters. Parameters: imageSource' x' y' angleRadians' scaleX' ScaleY
Long Parameter List,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,DrawRangeElements,The method has 6 parameters. Parameters: mode' start' end' count' type' indices
Long Parameter List,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,Ortho,The method has 6 parameters. Parameters: left' right' bottom' top' zNear' zFar
Long Parameter List,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,ReadPixels,The method has 7 parameters. Parameters: x' y' width' height' pixelFormat' pixelType' buffer
Long Parameter List,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,TexImage2D,The method has 9 parameters. Parameters: target' level' internalFormat' width' height' border' format' type' pixels
Long Identifier,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,,The length of the parameter modelViewProjectionResourceSet is 30.
Long Identifier,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,,The length of the parameter currentElementArrayBufferIndex is 30.
Long Statement,MatterHackers.VeldridProvider,Graphics2DVeldrid,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\Graphics2DVeldrid.cs,Render,The length of the statement  "				var targetTexture = veldridGL.CreateTexture(veldridGL.GraphicsDevice' resourceFactory' TextureUsage.Sampled | TextureUsage.Storage' imageSource as ImageBuffer); " is 160.
Long Statement,MatterHackers.VeldridProvider,VeldridWindowProvider,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\VeldridWindowProvider.cs,ShowSystemWindow,The length of the statement  "						systemWindow.OnMouseWheel(new MouseEventArgs(MouseButtons.None' 0' position.X' position.Y' (int)inputSnapshot.WheelDelta * 120)); " is 129.
Long Statement,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,CreateResources,The length of the statement  "			BufferDescription vbDescription = new BufferDescription((uint)(positionColorVertices.Length * VertexPositionColorGL.SizeInBytes)' BufferUsage.VertexBuffer); " is 156.
Long Statement,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,CreateResources,The length of the statement  "			BufferDescription indexBufferDescription = new BufferDescription((uint)(positionColorVertices.Length * sizeof(ushort))' BufferUsage.IndexBuffer); " is 145.
Long Statement,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,DrawArrays,The length of the statement  "								positionF = new System.Numerics.Vector3(positions[polygonIndex * 3 + 0]' positions[polygonIndex * 3 + 1]' positions[polygonIndex * 3 + 2]); " is 139.
Long Statement,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,DrawArrays,The length of the statement  "								colorF = new RgbaFloat(currentImediateData.color4b[i * 4 + 0] / 255.0f' currentImediateData.color4b[i * 4 + 1] / 255.0f' currentImediateData.color4b[i * 4 + 2] / 255.0f' currentImediateData.color4b[i * 4 + 3] / 255.0f); " is 219.
Long Statement,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,Ortho,The length of the statement  "				orthoD3D = System.Numerics.Matrix4x4.CreateOrthographicOffCenter((float)left' (float)right' (float)bottom' (float)top' (float)zNear' (float)zFar); " is 146.
Magic Number,MatterHackers.VeldridProvider,Graphics2DVeldrid,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\Graphics2DVeldrid.cs,FillRectangle,The following statement contains a magic number: var sl = (float)(-1 + fastLeft / this.Width * 2);
Magic Number,MatterHackers.VeldridProvider,Graphics2DVeldrid,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\Graphics2DVeldrid.cs,FillRectangle,The following statement contains a magic number: var sr = (float)(-1 + fastRight / this.Width * 2);
Magic Number,MatterHackers.VeldridProvider,Graphics2DVeldrid,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\Graphics2DVeldrid.cs,FillRectangle,The following statement contains a magic number: var st = (float)(-1 + fastTop / this.Height * 2);
Magic Number,MatterHackers.VeldridProvider,Graphics2DVeldrid,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\Graphics2DVeldrid.cs,FillRectangle,The following statement contains a magic number: var sb = (float)(-1 + fastBottom / this.Height * 2);
Magic Number,MatterHackers.VeldridProvider,Graphics2DVeldrid,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\Graphics2DVeldrid.cs,FillRectangle,The following statement contains a magic number: quadVertices[2] = new VertexPositionColor(new System.Numerics.Vector2(sl' sb)' color);
Magic Number,MatterHackers.VeldridProvider,Graphics2DVeldrid,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\Graphics2DVeldrid.cs,FillRectangle,The following statement contains a magic number: quadVertices[3] = new VertexPositionColor(new System.Numerics.Vector2(sr' sb)' color);
Magic Number,MatterHackers.VeldridProvider,Graphics2DVeldrid,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\Graphics2DVeldrid.cs,FillRectangle,The following statement contains a magic number: veldridGL.CommandList.DrawIndexed(4' 1' 0' 0' 0);
Magic Number,MatterHackers.VeldridProvider,Graphics2DVeldrid,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\Graphics2DVeldrid.cs,Render,The following statement contains a magic number: var sl = (float)(-1 + fastLeft / this.Width * 2);
Magic Number,MatterHackers.VeldridProvider,Graphics2DVeldrid,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\Graphics2DVeldrid.cs,Render,The following statement contains a magic number: var sr = (float)(-1 + fastRight / this.Width * 2);
Magic Number,MatterHackers.VeldridProvider,Graphics2DVeldrid,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\Graphics2DVeldrid.cs,Render,The following statement contains a magic number: var st = (float)(-1 + fastTop / this.Height * 2);
Magic Number,MatterHackers.VeldridProvider,Graphics2DVeldrid,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\Graphics2DVeldrid.cs,Render,The following statement contains a magic number: var sb = (float)(-1 + fastBottom / this.Height * 2);
Magic Number,MatterHackers.VeldridProvider,Graphics2DVeldrid,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\Graphics2DVeldrid.cs,Render,The following statement contains a magic number: quadVerts[2] = new System.Numerics.Vector4(sr' sb' 1' 0);
Magic Number,MatterHackers.VeldridProvider,Graphics2DVeldrid,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\Graphics2DVeldrid.cs,Render,The following statement contains a magic number: quadVerts[3] = new System.Numerics.Vector4(sl' sb' 0' 0);
Magic Number,MatterHackers.VeldridProvider,Graphics2DVeldrid,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\Graphics2DVeldrid.cs,Render,The following statement contains a magic number: veldridGL.CommandList.DrawIndexed(6' 1' 0' 0' 0);
Magic Number,MatterHackers.VeldridProvider,ShaderData,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\ShaderData.cs,GetFormatSize,The following statement contains a magic number: switch (format)  			{  				case PixelFormat.R8_G8_B8_A8_UNorm:  					return 4;  				case PixelFormat.B8_G8_R8_A8_UNorm:  					return 4;  				case PixelFormat.BC3_UNorm:  					return 1;  				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.VeldridProvider,ShaderData,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\ShaderData.cs,GetFormatSize,The following statement contains a magic number: switch (format)  			{  				case PixelFormat.R8_G8_B8_A8_UNorm:  					return 4;  				case PixelFormat.B8_G8_R8_A8_UNorm:  					return 4;  				case PixelFormat.BC3_UNorm:  					return 1;  				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.VeldridProvider,ShaderData,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\ShaderData.cs,GetDimension,The following statement contains a magic number: ret /= 2;
Magic Number,MatterHackers.VeldridProvider,ShaderData,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\ShaderData.cs,CreateStandardPipeline,The following statement contains a magic number: vertexPositionColor = new[]  			{  				new VertexPositionColor(new Vector2(-.75f' .75f)' RgbaFloat.Red)'  				new VertexPositionColor(new Vector2(.75f' .75f)' RgbaFloat.Green)'  				new VertexPositionColor(new Vector2(-.75f' -.75f)' RgbaFloat.Blue)'  				new VertexPositionColor(new Vector2(.75f' -.75f)' RgbaFloat.Yellow)  			};
Magic Number,MatterHackers.VeldridProvider,ShaderData,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\ShaderData.cs,CreateStandardPipeline,The following statement contains a magic number: vertexPositionColor = new[]  			{  				new VertexPositionColor(new Vector2(-.75f' .75f)' RgbaFloat.Red)'  				new VertexPositionColor(new Vector2(.75f' .75f)' RgbaFloat.Green)'  				new VertexPositionColor(new Vector2(-.75f' -.75f)' RgbaFloat.Blue)'  				new VertexPositionColor(new Vector2(.75f' -.75f)' RgbaFloat.Yellow)  			};
Magic Number,MatterHackers.VeldridProvider,ShaderData,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\ShaderData.cs,CreateStandardPipeline,The following statement contains a magic number: vertexPositionColor = new[]  			{  				new VertexPositionColor(new Vector2(-.75f' .75f)' RgbaFloat.Red)'  				new VertexPositionColor(new Vector2(.75f' .75f)' RgbaFloat.Green)'  				new VertexPositionColor(new Vector2(-.75f' -.75f)' RgbaFloat.Blue)'  				new VertexPositionColor(new Vector2(.75f' -.75f)' RgbaFloat.Yellow)  			};
Magic Number,MatterHackers.VeldridProvider,ShaderData,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\ShaderData.cs,CreateStandardPipeline,The following statement contains a magic number: vertexPositionColor = new[]  			{  				new VertexPositionColor(new Vector2(-.75f' .75f)' RgbaFloat.Red)'  				new VertexPositionColor(new Vector2(.75f' .75f)' RgbaFloat.Green)'  				new VertexPositionColor(new Vector2(-.75f' -.75f)' RgbaFloat.Blue)'  				new VertexPositionColor(new Vector2(.75f' -.75f)' RgbaFloat.Yellow)  			};
Magic Number,MatterHackers.VeldridProvider,ShaderData,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\ShaderData.cs,CreateStandardPipeline,The following statement contains a magic number: vertexPositionColor = new[]  			{  				new VertexPositionColor(new Vector2(-.75f' .75f)' RgbaFloat.Red)'  				new VertexPositionColor(new Vector2(.75f' .75f)' RgbaFloat.Green)'  				new VertexPositionColor(new Vector2(-.75f' -.75f)' RgbaFloat.Blue)'  				new VertexPositionColor(new Vector2(.75f' -.75f)' RgbaFloat.Yellow)  			};
Magic Number,MatterHackers.VeldridProvider,ShaderData,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\ShaderData.cs,CreateStandardPipeline,The following statement contains a magic number: vertexPositionColor = new[]  			{  				new VertexPositionColor(new Vector2(-.75f' .75f)' RgbaFloat.Red)'  				new VertexPositionColor(new Vector2(.75f' .75f)' RgbaFloat.Green)'  				new VertexPositionColor(new Vector2(-.75f' -.75f)' RgbaFloat.Blue)'  				new VertexPositionColor(new Vector2(.75f' -.75f)' RgbaFloat.Yellow)  			};
Magic Number,MatterHackers.VeldridProvider,ShaderData,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\ShaderData.cs,CreateStandardPipeline,The following statement contains a magic number: vertexPositionColor = new[]  			{  				new VertexPositionColor(new Vector2(-.75f' .75f)' RgbaFloat.Red)'  				new VertexPositionColor(new Vector2(.75f' .75f)' RgbaFloat.Green)'  				new VertexPositionColor(new Vector2(-.75f' -.75f)' RgbaFloat.Blue)'  				new VertexPositionColor(new Vector2(.75f' -.75f)' RgbaFloat.Yellow)  			};
Magic Number,MatterHackers.VeldridProvider,ShaderData,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\ShaderData.cs,CreateStandardPipeline,The following statement contains a magic number: vertexPositionColor = new[]  			{  				new VertexPositionColor(new Vector2(-.75f' .75f)' RgbaFloat.Red)'  				new VertexPositionColor(new Vector2(.75f' .75f)' RgbaFloat.Green)'  				new VertexPositionColor(new Vector2(-.75f' -.75f)' RgbaFloat.Blue)'  				new VertexPositionColor(new Vector2(.75f' -.75f)' RgbaFloat.Yellow)  			};
Magic Number,MatterHackers.VeldridProvider,ShaderData,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\ShaderData.cs,CreateStandardPipeline,The following statement contains a magic number: this.VertexBufferPositionColor = resourceFactory.CreateBuffer(  				new BufferDescription(  					4 * VertexPositionColor.SizeInBytes'  					BufferUsage.VertexBuffer));
Magic Number,MatterHackers.VeldridProvider,ShaderData,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\ShaderData.cs,CreateStandardPipeline,The following statement contains a magic number: this.IndexBufferPositionColor = resourceFactory.CreateBuffer(  				new BufferDescription(  					4 * sizeof(ushort)'  					BufferUsage.IndexBuffer));
Magic Number,MatterHackers.VeldridProvider,ShaderData,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\ShaderData.cs,CreateStandardPipeline,The following statement contains a magic number: this.GraphicsDevice.UpdateBuffer(this.IndexBufferPositionColor' 0' new ushort[] { 0' 1' 2' 3 });
Magic Number,MatterHackers.VeldridProvider,ShaderData,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\ShaderData.cs,CreateStandardPipeline,The following statement contains a magic number: this.GraphicsDevice.UpdateBuffer(this.IndexBufferPositionColor' 0' new ushort[] { 0' 1' 2' 3 });
Magic Number,MatterHackers.VeldridProvider,ShaderData,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\ShaderData.cs,CreateTexturePipeline,The following statement contains a magic number: this.TextureVertexBuffer = resourceFactory.CreateBuffer(new BufferDescription(16 * 4' BufferUsage.VertexBuffer));
Magic Number,MatterHackers.VeldridProvider,ShaderData,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\ShaderData.cs,CreateTexturePipeline,The following statement contains a magic number: this.TextureVertexBuffer = resourceFactory.CreateBuffer(new BufferDescription(16 * 4' BufferUsage.VertexBuffer));
Magic Number,MatterHackers.VeldridProvider,ShaderData,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\ShaderData.cs,CreateTexturePipeline,The following statement contains a magic number: this.TextureIndexBuffer = resourceFactory.CreateBuffer(new BufferDescription(2 * 6' BufferUsage.IndexBuffer));
Magic Number,MatterHackers.VeldridProvider,ShaderData,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\ShaderData.cs,CreateTexturePipeline,The following statement contains a magic number: this.TextureIndexBuffer = resourceFactory.CreateBuffer(new BufferDescription(2 * 6' BufferUsage.IndexBuffer));
Magic Number,MatterHackers.VeldridProvider,ShaderData,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\ShaderData.cs,CreateTexturePipeline,The following statement contains a magic number: ushort[] indices = { 0' 1' 2' 0' 2' 3 };
Magic Number,MatterHackers.VeldridProvider,ShaderData,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\ShaderData.cs,CreateTexturePipeline,The following statement contains a magic number: ushort[] indices = { 0' 1' 2' 0' 2' 3 };
Magic Number,MatterHackers.VeldridProvider,ShaderData,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\ShaderData.cs,CreateTexturePipeline,The following statement contains a magic number: ushort[] indices = { 0' 1' 2' 0' 2' 3 };
Magic Number,MatterHackers.VeldridProvider,VeldridWindowProvider,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\VeldridWindowProvider.cs,ShowSystemWindow,The following statement contains a magic number: WindowCreateInfo windowCI = new WindowCreateInfo()  				{  					X = 100'  					Y = 100'  					WindowWidth = 960'  					WindowHeight = 540'  					WindowTitle = "Veldrid Tutorial"'  				};
Magic Number,MatterHackers.VeldridProvider,VeldridWindowProvider,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\VeldridWindowProvider.cs,ShowSystemWindow,The following statement contains a magic number: WindowCreateInfo windowCI = new WindowCreateInfo()  				{  					X = 100'  					Y = 100'  					WindowWidth = 960'  					WindowHeight = 540'  					WindowTitle = "Veldrid Tutorial"'  				};
Magic Number,MatterHackers.VeldridProvider,VeldridWindowProvider,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\VeldridWindowProvider.cs,ShowSystemWindow,The following statement contains a magic number: WindowCreateInfo windowCI = new WindowCreateInfo()  				{  					X = 100'  					Y = 100'  					WindowWidth = 960'  					WindowHeight = 540'  					WindowTitle = "Veldrid Tutorial"'  				};
Magic Number,MatterHackers.VeldridProvider,VeldridWindowProvider,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\VeldridWindowProvider.cs,ShowSystemWindow,The following statement contains a magic number: WindowCreateInfo windowCI = new WindowCreateInfo()  				{  					X = 100'  					Y = 100'  					WindowWidth = 960'  					WindowHeight = 540'  					WindowTitle = "Veldrid Tutorial"'  				};
Magic Number,MatterHackers.VeldridProvider,VeldridWindowProvider,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\VeldridWindowProvider.cs,ShowSystemWindow,The following statement contains a magic number: systemWindow.OnMouseWheel(new MouseEventArgs(MouseButtons.None' 0' position.X' position.Y' (int)inputSnapshot.WheelDelta * 120));
Magic Number,MatterHackers.VeldridProvider,VeldridWindowProvider,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\VeldridWindowProvider.cs,ShowSystemWindow,The following statement contains a magic number: runNextMs = UiThread.CurrentTimerMs + 10;
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,Color4,The following statement contains a magic number: ImediateMode.currentColor[2] = (byte)blue;
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,Color4,The following statement contains a magic number: ImediateMode.currentColor[3] = (byte)alpha;
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,CreateResources,The following statement contains a magic number: projectionBuffer = resourceFactory.CreateBuffer(new BufferDescription(64' BufferUsage.UniformBuffer));
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,CreateResources,The following statement contains a magic number: modelViewBuffer = resourceFactory.CreateBuffer(new BufferDescription(64' BufferUsage.UniformBuffer));
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,CreateResources,The following statement contains a magic number: positionColorVertices = new VertexPositionColorGL[128 * 3];
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,CreateResources,The following statement contains a magic number: positionColorVertices = new VertexPositionColorGL[128 * 3];
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,RightHandToLeftHand,The following statement contains a magic number: var projectionD3D = new System.Numerics.Matrix4x4(  						rhd[0]' rhd[1]' -rhd[2]' rhd[3]'  						rhd[4]' rhd[5]' -rhd[6]' rhd[7]'  						rhd[8]' rhd[9]' -rhd[10]' rhd[11]'  						rhd[12]' rhd[13]' -rhd[14]' rhd[15]  					);
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,RightHandToLeftHand,The following statement contains a magic number: var projectionD3D = new System.Numerics.Matrix4x4(  						rhd[0]' rhd[1]' -rhd[2]' rhd[3]'  						rhd[4]' rhd[5]' -rhd[6]' rhd[7]'  						rhd[8]' rhd[9]' -rhd[10]' rhd[11]'  						rhd[12]' rhd[13]' -rhd[14]' rhd[15]  					);
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,RightHandToLeftHand,The following statement contains a magic number: var projectionD3D = new System.Numerics.Matrix4x4(  						rhd[0]' rhd[1]' -rhd[2]' rhd[3]'  						rhd[4]' rhd[5]' -rhd[6]' rhd[7]'  						rhd[8]' rhd[9]' -rhd[10]' rhd[11]'  						rhd[12]' rhd[13]' -rhd[14]' rhd[15]  					);
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,RightHandToLeftHand,The following statement contains a magic number: var projectionD3D = new System.Numerics.Matrix4x4(  						rhd[0]' rhd[1]' -rhd[2]' rhd[3]'  						rhd[4]' rhd[5]' -rhd[6]' rhd[7]'  						rhd[8]' rhd[9]' -rhd[10]' rhd[11]'  						rhd[12]' rhd[13]' -rhd[14]' rhd[15]  					);
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,RightHandToLeftHand,The following statement contains a magic number: var projectionD3D = new System.Numerics.Matrix4x4(  						rhd[0]' rhd[1]' -rhd[2]' rhd[3]'  						rhd[4]' rhd[5]' -rhd[6]' rhd[7]'  						rhd[8]' rhd[9]' -rhd[10]' rhd[11]'  						rhd[12]' rhd[13]' -rhd[14]' rhd[15]  					);
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,RightHandToLeftHand,The following statement contains a magic number: var projectionD3D = new System.Numerics.Matrix4x4(  						rhd[0]' rhd[1]' -rhd[2]' rhd[3]'  						rhd[4]' rhd[5]' -rhd[6]' rhd[7]'  						rhd[8]' rhd[9]' -rhd[10]' rhd[11]'  						rhd[12]' rhd[13]' -rhd[14]' rhd[15]  					);
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,RightHandToLeftHand,The following statement contains a magic number: var projectionD3D = new System.Numerics.Matrix4x4(  						rhd[0]' rhd[1]' -rhd[2]' rhd[3]'  						rhd[4]' rhd[5]' -rhd[6]' rhd[7]'  						rhd[8]' rhd[9]' -rhd[10]' rhd[11]'  						rhd[12]' rhd[13]' -rhd[14]' rhd[15]  					);
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,RightHandToLeftHand,The following statement contains a magic number: var projectionD3D = new System.Numerics.Matrix4x4(  						rhd[0]' rhd[1]' -rhd[2]' rhd[3]'  						rhd[4]' rhd[5]' -rhd[6]' rhd[7]'  						rhd[8]' rhd[9]' -rhd[10]' rhd[11]'  						rhd[12]' rhd[13]' -rhd[14]' rhd[15]  					);
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,RightHandToLeftHand,The following statement contains a magic number: var projectionD3D = new System.Numerics.Matrix4x4(  						rhd[0]' rhd[1]' -rhd[2]' rhd[3]'  						rhd[4]' rhd[5]' -rhd[6]' rhd[7]'  						rhd[8]' rhd[9]' -rhd[10]' rhd[11]'  						rhd[12]' rhd[13]' -rhd[14]' rhd[15]  					);
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,RightHandToLeftHand,The following statement contains a magic number: var projectionD3D = new System.Numerics.Matrix4x4(  						rhd[0]' rhd[1]' -rhd[2]' rhd[3]'  						rhd[4]' rhd[5]' -rhd[6]' rhd[7]'  						rhd[8]' rhd[9]' -rhd[10]' rhd[11]'  						rhd[12]' rhd[13]' -rhd[14]' rhd[15]  					);
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,RightHandToLeftHand,The following statement contains a magic number: var projectionD3D = new System.Numerics.Matrix4x4(  						rhd[0]' rhd[1]' -rhd[2]' rhd[3]'  						rhd[4]' rhd[5]' -rhd[6]' rhd[7]'  						rhd[8]' rhd[9]' -rhd[10]' rhd[11]'  						rhd[12]' rhd[13]' -rhd[14]' rhd[15]  					);
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,RightHandToLeftHand,The following statement contains a magic number: var projectionD3D = new System.Numerics.Matrix4x4(  						rhd[0]' rhd[1]' -rhd[2]' rhd[3]'  						rhd[4]' rhd[5]' -rhd[6]' rhd[7]'  						rhd[8]' rhd[9]' -rhd[10]' rhd[11]'  						rhd[12]' rhd[13]' -rhd[14]' rhd[15]  					);
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,RightHandToLeftHand,The following statement contains a magic number: var projectionD3D = new System.Numerics.Matrix4x4(  						rhd[0]' rhd[1]' -rhd[2]' rhd[3]'  						rhd[4]' rhd[5]' -rhd[6]' rhd[7]'  						rhd[8]' rhd[9]' -rhd[10]' rhd[11]'  						rhd[12]' rhd[13]' -rhd[14]' rhd[15]  					);
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,RightHandToLeftHand,The following statement contains a magic number: var projectionD3D = new System.Numerics.Matrix4x4(  						rhd[0]' rhd[1]' -rhd[2]' rhd[3]'  						rhd[4]' rhd[5]' -rhd[6]' rhd[7]'  						rhd[8]' rhd[9]' -rhd[10]' rhd[11]'  						rhd[12]' rhd[13]' -rhd[14]' rhd[15]  					);
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,RightHandToLeftHand,The following statement contains a magic number: return new System.Numerics.Matrix4x4(  					rhd[0]' rhd[1]' -rhd[2]' rhd[3]'  					rhd[4]' rhd[5]' -rhd[6]' rhd[7]'  					-rhd[8]' -rhd[9]' rhd[10]' -rhd[11]'  					rhd[12]' rhd[13]' rhd[14]' rhd[15]  				);
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,RightHandToLeftHand,The following statement contains a magic number: return new System.Numerics.Matrix4x4(  					rhd[0]' rhd[1]' -rhd[2]' rhd[3]'  					rhd[4]' rhd[5]' -rhd[6]' rhd[7]'  					-rhd[8]' -rhd[9]' rhd[10]' -rhd[11]'  					rhd[12]' rhd[13]' rhd[14]' rhd[15]  				);
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,RightHandToLeftHand,The following statement contains a magic number: return new System.Numerics.Matrix4x4(  					rhd[0]' rhd[1]' -rhd[2]' rhd[3]'  					rhd[4]' rhd[5]' -rhd[6]' rhd[7]'  					-rhd[8]' -rhd[9]' rhd[10]' -rhd[11]'  					rhd[12]' rhd[13]' rhd[14]' rhd[15]  				);
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,RightHandToLeftHand,The following statement contains a magic number: return new System.Numerics.Matrix4x4(  					rhd[0]' rhd[1]' -rhd[2]' rhd[3]'  					rhd[4]' rhd[5]' -rhd[6]' rhd[7]'  					-rhd[8]' -rhd[9]' rhd[10]' -rhd[11]'  					rhd[12]' rhd[13]' rhd[14]' rhd[15]  				);
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,RightHandToLeftHand,The following statement contains a magic number: return new System.Numerics.Matrix4x4(  					rhd[0]' rhd[1]' -rhd[2]' rhd[3]'  					rhd[4]' rhd[5]' -rhd[6]' rhd[7]'  					-rhd[8]' -rhd[9]' rhd[10]' -rhd[11]'  					rhd[12]' rhd[13]' rhd[14]' rhd[15]  				);
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,RightHandToLeftHand,The following statement contains a magic number: return new System.Numerics.Matrix4x4(  					rhd[0]' rhd[1]' -rhd[2]' rhd[3]'  					rhd[4]' rhd[5]' -rhd[6]' rhd[7]'  					-rhd[8]' -rhd[9]' rhd[10]' -rhd[11]'  					rhd[12]' rhd[13]' rhd[14]' rhd[15]  				);
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,RightHandToLeftHand,The following statement contains a magic number: return new System.Numerics.Matrix4x4(  					rhd[0]' rhd[1]' -rhd[2]' rhd[3]'  					rhd[4]' rhd[5]' -rhd[6]' rhd[7]'  					-rhd[8]' -rhd[9]' rhd[10]' -rhd[11]'  					rhd[12]' rhd[13]' rhd[14]' rhd[15]  				);
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,RightHandToLeftHand,The following statement contains a magic number: return new System.Numerics.Matrix4x4(  					rhd[0]' rhd[1]' -rhd[2]' rhd[3]'  					rhd[4]' rhd[5]' -rhd[6]' rhd[7]'  					-rhd[8]' -rhd[9]' rhd[10]' -rhd[11]'  					rhd[12]' rhd[13]' rhd[14]' rhd[15]  				);
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,RightHandToLeftHand,The following statement contains a magic number: return new System.Numerics.Matrix4x4(  					rhd[0]' rhd[1]' -rhd[2]' rhd[3]'  					rhd[4]' rhd[5]' -rhd[6]' rhd[7]'  					-rhd[8]' -rhd[9]' rhd[10]' -rhd[11]'  					rhd[12]' rhd[13]' rhd[14]' rhd[15]  				);
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,RightHandToLeftHand,The following statement contains a magic number: return new System.Numerics.Matrix4x4(  					rhd[0]' rhd[1]' -rhd[2]' rhd[3]'  					rhd[4]' rhd[5]' -rhd[6]' rhd[7]'  					-rhd[8]' -rhd[9]' rhd[10]' -rhd[11]'  					rhd[12]' rhd[13]' rhd[14]' rhd[15]  				);
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,RightHandToLeftHand,The following statement contains a magic number: return new System.Numerics.Matrix4x4(  					rhd[0]' rhd[1]' -rhd[2]' rhd[3]'  					rhd[4]' rhd[5]' -rhd[6]' rhd[7]'  					-rhd[8]' -rhd[9]' rhd[10]' -rhd[11]'  					rhd[12]' rhd[13]' rhd[14]' rhd[15]  				);
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,RightHandToLeftHand,The following statement contains a magic number: return new System.Numerics.Matrix4x4(  					rhd[0]' rhd[1]' -rhd[2]' rhd[3]'  					rhd[4]' rhd[5]' -rhd[6]' rhd[7]'  					-rhd[8]' -rhd[9]' rhd[10]' -rhd[11]'  					rhd[12]' rhd[13]' rhd[14]' rhd[15]  				);
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,RightHandToLeftHand,The following statement contains a magic number: return new System.Numerics.Matrix4x4(  					rhd[0]' rhd[1]' -rhd[2]' rhd[3]'  					rhd[4]' rhd[5]' -rhd[6]' rhd[7]'  					-rhd[8]' -rhd[9]' rhd[10]' -rhd[11]'  					rhd[12]' rhd[13]' rhd[14]' rhd[15]  				);
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,RightHandToLeftHand,The following statement contains a magic number: return new System.Numerics.Matrix4x4(  					rhd[0]' rhd[1]' -rhd[2]' rhd[3]'  					rhd[4]' rhd[5]' -rhd[6]' rhd[7]'  					-rhd[8]' -rhd[9]' rhd[10]' -rhd[11]'  					rhd[12]' rhd[13]' rhd[14]' rhd[15]  				);
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,DrawArrays,The following statement contains a magic number: currentImediateData.positions3f.Count < 6
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,DrawArrays,The following statement contains a magic number: switch (mode)  			{  				case BeginMode.Lines:  					break;    				case BeginMode.Triangles:  					int polygons = count / 3;  					if(polygons > 2)  					{  						int a = 0;  					}  					int polygonIndex = 0;  					while (polygons > 0)  					{  						// copy our data to the buffer  						for (int i = 0; i < Math.Min(polygons*3' positionColorVertices.Length/3); i++)  						{  							System.Numerics.Vector3 positionF;  							unsafe  							{  								float* positions = (float*)vertexPointer.pointer;  								positionF = new System.Numerics.Vector3(positions[polygonIndex * 3 + 0]' positions[polygonIndex * 3 + 1]' positions[polygonIndex * 3 + 2]);  								polygonIndex++;  							}    							RgbaFloat colorF;  							if (i < currentImediateData.color4b.Length / 4)  							{  								colorF = new RgbaFloat(currentImediateData.color4b[i * 4 + 0] / 255.0f' currentImediateData.color4b[i * 4 + 1] / 255.0f' currentImediateData.color4b[i * 4 + 2] / 255.0f' currentImediateData.color4b[i * 4 + 3] / 255.0f);  							}  							else  							{  								colorF = new RgbaFloat((float)rand.NextDouble()' (float)rand.NextDouble()' (float)rand.NextDouble()' 1);  							}  							positionColorVertices[i] = new VertexPositionColorGL(positionF' colorF);  						}    						commandList.Begin();  						commandList.UpdateBuffer(positionColorVertexBuffer' 0' positionColorVertices);  						commandList.UpdateBuffer(modelViewBuffer' 0' RightHandToLeftHand(modelViewStack.Peek()' false));    						commandList.UpdateBuffer(projectionBuffer' 0' RightHandToLeftHand(projectionStack.Peek()' true));  						//commandList.UpdateBuffer(projectionBuffer' 0' orthoD3D);    						commandList.SetPipeline(positionColorGLPipeline);    						commandList.SetVertexBuffer(0' positionColorVertexBuffer);  						commandList.SetIndexBuffer(positionColorIndexBuffer' IndexFormat.UInt16);  						commandList.SetGraphicsResourceSet(0' modelViewProjectionResourceSet);  						commandList.SetFramebuffer(graphicsDevice.SwapchainFramebuffer);  						commandList.DrawIndexed((uint)Math.Min(polygons * 3' positionColorVertices.Length / 3)' 1' 0' 0' 0);    						commandList.End();  						graphicsDevice.SubmitCommands(commandList);  						polygons -= positionColorVertices.Length/3;  					}  					break;    				case BeginMode.TriangleStrip:  					break;    				case BeginMode.TriangleFan:  					break;  			}
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,DrawArrays,The following statement contains a magic number: switch (mode)  			{  				case BeginMode.Lines:  					break;    				case BeginMode.Triangles:  					int polygons = count / 3;  					if(polygons > 2)  					{  						int a = 0;  					}  					int polygonIndex = 0;  					while (polygons > 0)  					{  						// copy our data to the buffer  						for (int i = 0; i < Math.Min(polygons*3' positionColorVertices.Length/3); i++)  						{  							System.Numerics.Vector3 positionF;  							unsafe  							{  								float* positions = (float*)vertexPointer.pointer;  								positionF = new System.Numerics.Vector3(positions[polygonIndex * 3 + 0]' positions[polygonIndex * 3 + 1]' positions[polygonIndex * 3 + 2]);  								polygonIndex++;  							}    							RgbaFloat colorF;  							if (i < currentImediateData.color4b.Length / 4)  							{  								colorF = new RgbaFloat(currentImediateData.color4b[i * 4 + 0] / 255.0f' currentImediateData.color4b[i * 4 + 1] / 255.0f' currentImediateData.color4b[i * 4 + 2] / 255.0f' currentImediateData.color4b[i * 4 + 3] / 255.0f);  							}  							else  							{  								colorF = new RgbaFloat((float)rand.NextDouble()' (float)rand.NextDouble()' (float)rand.NextDouble()' 1);  							}  							positionColorVertices[i] = new VertexPositionColorGL(positionF' colorF);  						}    						commandList.Begin();  						commandList.UpdateBuffer(positionColorVertexBuffer' 0' positionColorVertices);  						commandList.UpdateBuffer(modelViewBuffer' 0' RightHandToLeftHand(modelViewStack.Peek()' false));    						commandList.UpdateBuffer(projectionBuffer' 0' RightHandToLeftHand(projectionStack.Peek()' true));  						//commandList.UpdateBuffer(projectionBuffer' 0' orthoD3D);    						commandList.SetPipeline(positionColorGLPipeline);    						commandList.SetVertexBuffer(0' positionColorVertexBuffer);  						commandList.SetIndexBuffer(positionColorIndexBuffer' IndexFormat.UInt16);  						commandList.SetGraphicsResourceSet(0' modelViewProjectionResourceSet);  						commandList.SetFramebuffer(graphicsDevice.SwapchainFramebuffer);  						commandList.DrawIndexed((uint)Math.Min(polygons * 3' positionColorVertices.Length / 3)' 1' 0' 0' 0);    						commandList.End();  						graphicsDevice.SubmitCommands(commandList);  						polygons -= positionColorVertices.Length/3;  					}  					break;    				case BeginMode.TriangleStrip:  					break;    				case BeginMode.TriangleFan:  					break;  			}
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,DrawArrays,The following statement contains a magic number: switch (mode)  			{  				case BeginMode.Lines:  					break;    				case BeginMode.Triangles:  					int polygons = count / 3;  					if(polygons > 2)  					{  						int a = 0;  					}  					int polygonIndex = 0;  					while (polygons > 0)  					{  						// copy our data to the buffer  						for (int i = 0; i < Math.Min(polygons*3' positionColorVertices.Length/3); i++)  						{  							System.Numerics.Vector3 positionF;  							unsafe  							{  								float* positions = (float*)vertexPointer.pointer;  								positionF = new System.Numerics.Vector3(positions[polygonIndex * 3 + 0]' positions[polygonIndex * 3 + 1]' positions[polygonIndex * 3 + 2]);  								polygonIndex++;  							}    							RgbaFloat colorF;  							if (i < currentImediateData.color4b.Length / 4)  							{  								colorF = new RgbaFloat(currentImediateData.color4b[i * 4 + 0] / 255.0f' currentImediateData.color4b[i * 4 + 1] / 255.0f' currentImediateData.color4b[i * 4 + 2] / 255.0f' currentImediateData.color4b[i * 4 + 3] / 255.0f);  							}  							else  							{  								colorF = new RgbaFloat((float)rand.NextDouble()' (float)rand.NextDouble()' (float)rand.NextDouble()' 1);  							}  							positionColorVertices[i] = new VertexPositionColorGL(positionF' colorF);  						}    						commandList.Begin();  						commandList.UpdateBuffer(positionColorVertexBuffer' 0' positionColorVertices);  						commandList.UpdateBuffer(modelViewBuffer' 0' RightHandToLeftHand(modelViewStack.Peek()' false));    						commandList.UpdateBuffer(projectionBuffer' 0' RightHandToLeftHand(projectionStack.Peek()' true));  						//commandList.UpdateBuffer(projectionBuffer' 0' orthoD3D);    						commandList.SetPipeline(positionColorGLPipeline);    						commandList.SetVertexBuffer(0' positionColorVertexBuffer);  						commandList.SetIndexBuffer(positionColorIndexBuffer' IndexFormat.UInt16);  						commandList.SetGraphicsResourceSet(0' modelViewProjectionResourceSet);  						commandList.SetFramebuffer(graphicsDevice.SwapchainFramebuffer);  						commandList.DrawIndexed((uint)Math.Min(polygons * 3' positionColorVertices.Length / 3)' 1' 0' 0' 0);    						commandList.End();  						graphicsDevice.SubmitCommands(commandList);  						polygons -= positionColorVertices.Length/3;  					}  					break;    				case BeginMode.TriangleStrip:  					break;    				case BeginMode.TriangleFan:  					break;  			}
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,DrawArrays,The following statement contains a magic number: switch (mode)  			{  				case BeginMode.Lines:  					break;    				case BeginMode.Triangles:  					int polygons = count / 3;  					if(polygons > 2)  					{  						int a = 0;  					}  					int polygonIndex = 0;  					while (polygons > 0)  					{  						// copy our data to the buffer  						for (int i = 0; i < Math.Min(polygons*3' positionColorVertices.Length/3); i++)  						{  							System.Numerics.Vector3 positionF;  							unsafe  							{  								float* positions = (float*)vertexPointer.pointer;  								positionF = new System.Numerics.Vector3(positions[polygonIndex * 3 + 0]' positions[polygonIndex * 3 + 1]' positions[polygonIndex * 3 + 2]);  								polygonIndex++;  							}    							RgbaFloat colorF;  							if (i < currentImediateData.color4b.Length / 4)  							{  								colorF = new RgbaFloat(currentImediateData.color4b[i * 4 + 0] / 255.0f' currentImediateData.color4b[i * 4 + 1] / 255.0f' currentImediateData.color4b[i * 4 + 2] / 255.0f' currentImediateData.color4b[i * 4 + 3] / 255.0f);  							}  							else  							{  								colorF = new RgbaFloat((float)rand.NextDouble()' (float)rand.NextDouble()' (float)rand.NextDouble()' 1);  							}  							positionColorVertices[i] = new VertexPositionColorGL(positionF' colorF);  						}    						commandList.Begin();  						commandList.UpdateBuffer(positionColorVertexBuffer' 0' positionColorVertices);  						commandList.UpdateBuffer(modelViewBuffer' 0' RightHandToLeftHand(modelViewStack.Peek()' false));    						commandList.UpdateBuffer(projectionBuffer' 0' RightHandToLeftHand(projectionStack.Peek()' true));  						//commandList.UpdateBuffer(projectionBuffer' 0' orthoD3D);    						commandList.SetPipeline(positionColorGLPipeline);    						commandList.SetVertexBuffer(0' positionColorVertexBuffer);  						commandList.SetIndexBuffer(positionColorIndexBuffer' IndexFormat.UInt16);  						commandList.SetGraphicsResourceSet(0' modelViewProjectionResourceSet);  						commandList.SetFramebuffer(graphicsDevice.SwapchainFramebuffer);  						commandList.DrawIndexed((uint)Math.Min(polygons * 3' positionColorVertices.Length / 3)' 1' 0' 0' 0);    						commandList.End();  						graphicsDevice.SubmitCommands(commandList);  						polygons -= positionColorVertices.Length/3;  					}  					break;    				case BeginMode.TriangleStrip:  					break;    				case BeginMode.TriangleFan:  					break;  			}
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,DrawArrays,The following statement contains a magic number: switch (mode)  			{  				case BeginMode.Lines:  					break;    				case BeginMode.Triangles:  					int polygons = count / 3;  					if(polygons > 2)  					{  						int a = 0;  					}  					int polygonIndex = 0;  					while (polygons > 0)  					{  						// copy our data to the buffer  						for (int i = 0; i < Math.Min(polygons*3' positionColorVertices.Length/3); i++)  						{  							System.Numerics.Vector3 positionF;  							unsafe  							{  								float* positions = (float*)vertexPointer.pointer;  								positionF = new System.Numerics.Vector3(positions[polygonIndex * 3 + 0]' positions[polygonIndex * 3 + 1]' positions[polygonIndex * 3 + 2]);  								polygonIndex++;  							}    							RgbaFloat colorF;  							if (i < currentImediateData.color4b.Length / 4)  							{  								colorF = new RgbaFloat(currentImediateData.color4b[i * 4 + 0] / 255.0f' currentImediateData.color4b[i * 4 + 1] / 255.0f' currentImediateData.color4b[i * 4 + 2] / 255.0f' currentImediateData.color4b[i * 4 + 3] / 255.0f);  							}  							else  							{  								colorF = new RgbaFloat((float)rand.NextDouble()' (float)rand.NextDouble()' (float)rand.NextDouble()' 1);  							}  							positionColorVertices[i] = new VertexPositionColorGL(positionF' colorF);  						}    						commandList.Begin();  						commandList.UpdateBuffer(positionColorVertexBuffer' 0' positionColorVertices);  						commandList.UpdateBuffer(modelViewBuffer' 0' RightHandToLeftHand(modelViewStack.Peek()' false));    						commandList.UpdateBuffer(projectionBuffer' 0' RightHandToLeftHand(projectionStack.Peek()' true));  						//commandList.UpdateBuffer(projectionBuffer' 0' orthoD3D);    						commandList.SetPipeline(positionColorGLPipeline);    						commandList.SetVertexBuffer(0' positionColorVertexBuffer);  						commandList.SetIndexBuffer(positionColorIndexBuffer' IndexFormat.UInt16);  						commandList.SetGraphicsResourceSet(0' modelViewProjectionResourceSet);  						commandList.SetFramebuffer(graphicsDevice.SwapchainFramebuffer);  						commandList.DrawIndexed((uint)Math.Min(polygons * 3' positionColorVertices.Length / 3)' 1' 0' 0' 0);    						commandList.End();  						graphicsDevice.SubmitCommands(commandList);  						polygons -= positionColorVertices.Length/3;  					}  					break;    				case BeginMode.TriangleStrip:  					break;    				case BeginMode.TriangleFan:  					break;  			}
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,DrawArrays,The following statement contains a magic number: switch (mode)  			{  				case BeginMode.Lines:  					break;    				case BeginMode.Triangles:  					int polygons = count / 3;  					if(polygons > 2)  					{  						int a = 0;  					}  					int polygonIndex = 0;  					while (polygons > 0)  					{  						// copy our data to the buffer  						for (int i = 0; i < Math.Min(polygons*3' positionColorVertices.Length/3); i++)  						{  							System.Numerics.Vector3 positionF;  							unsafe  							{  								float* positions = (float*)vertexPointer.pointer;  								positionF = new System.Numerics.Vector3(positions[polygonIndex * 3 + 0]' positions[polygonIndex * 3 + 1]' positions[polygonIndex * 3 + 2]);  								polygonIndex++;  							}    							RgbaFloat colorF;  							if (i < currentImediateData.color4b.Length / 4)  							{  								colorF = new RgbaFloat(currentImediateData.color4b[i * 4 + 0] / 255.0f' currentImediateData.color4b[i * 4 + 1] / 255.0f' currentImediateData.color4b[i * 4 + 2] / 255.0f' currentImediateData.color4b[i * 4 + 3] / 255.0f);  							}  							else  							{  								colorF = new RgbaFloat((float)rand.NextDouble()' (float)rand.NextDouble()' (float)rand.NextDouble()' 1);  							}  							positionColorVertices[i] = new VertexPositionColorGL(positionF' colorF);  						}    						commandList.Begin();  						commandList.UpdateBuffer(positionColorVertexBuffer' 0' positionColorVertices);  						commandList.UpdateBuffer(modelViewBuffer' 0' RightHandToLeftHand(modelViewStack.Peek()' false));    						commandList.UpdateBuffer(projectionBuffer' 0' RightHandToLeftHand(projectionStack.Peek()' true));  						//commandList.UpdateBuffer(projectionBuffer' 0' orthoD3D);    						commandList.SetPipeline(positionColorGLPipeline);    						commandList.SetVertexBuffer(0' positionColorVertexBuffer);  						commandList.SetIndexBuffer(positionColorIndexBuffer' IndexFormat.UInt16);  						commandList.SetGraphicsResourceSet(0' modelViewProjectionResourceSet);  						commandList.SetFramebuffer(graphicsDevice.SwapchainFramebuffer);  						commandList.DrawIndexed((uint)Math.Min(polygons * 3' positionColorVertices.Length / 3)' 1' 0' 0' 0);    						commandList.End();  						graphicsDevice.SubmitCommands(commandList);  						polygons -= positionColorVertices.Length/3;  					}  					break;    				case BeginMode.TriangleStrip:  					break;    				case BeginMode.TriangleFan:  					break;  			}
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,DrawArrays,The following statement contains a magic number: switch (mode)  			{  				case BeginMode.Lines:  					break;    				case BeginMode.Triangles:  					int polygons = count / 3;  					if(polygons > 2)  					{  						int a = 0;  					}  					int polygonIndex = 0;  					while (polygons > 0)  					{  						// copy our data to the buffer  						for (int i = 0; i < Math.Min(polygons*3' positionColorVertices.Length/3); i++)  						{  							System.Numerics.Vector3 positionF;  							unsafe  							{  								float* positions = (float*)vertexPointer.pointer;  								positionF = new System.Numerics.Vector3(positions[polygonIndex * 3 + 0]' positions[polygonIndex * 3 + 1]' positions[polygonIndex * 3 + 2]);  								polygonIndex++;  							}    							RgbaFloat colorF;  							if (i < currentImediateData.color4b.Length / 4)  							{  								colorF = new RgbaFloat(currentImediateData.color4b[i * 4 + 0] / 255.0f' currentImediateData.color4b[i * 4 + 1] / 255.0f' currentImediateData.color4b[i * 4 + 2] / 255.0f' currentImediateData.color4b[i * 4 + 3] / 255.0f);  							}  							else  							{  								colorF = new RgbaFloat((float)rand.NextDouble()' (float)rand.NextDouble()' (float)rand.NextDouble()' 1);  							}  							positionColorVertices[i] = new VertexPositionColorGL(positionF' colorF);  						}    						commandList.Begin();  						commandList.UpdateBuffer(positionColorVertexBuffer' 0' positionColorVertices);  						commandList.UpdateBuffer(modelViewBuffer' 0' RightHandToLeftHand(modelViewStack.Peek()' false));    						commandList.UpdateBuffer(projectionBuffer' 0' RightHandToLeftHand(projectionStack.Peek()' true));  						//commandList.UpdateBuffer(projectionBuffer' 0' orthoD3D);    						commandList.SetPipeline(positionColorGLPipeline);    						commandList.SetVertexBuffer(0' positionColorVertexBuffer);  						commandList.SetIndexBuffer(positionColorIndexBuffer' IndexFormat.UInt16);  						commandList.SetGraphicsResourceSet(0' modelViewProjectionResourceSet);  						commandList.SetFramebuffer(graphicsDevice.SwapchainFramebuffer);  						commandList.DrawIndexed((uint)Math.Min(polygons * 3' positionColorVertices.Length / 3)' 1' 0' 0' 0);    						commandList.End();  						graphicsDevice.SubmitCommands(commandList);  						polygons -= positionColorVertices.Length/3;  					}  					break;    				case BeginMode.TriangleStrip:  					break;    				case BeginMode.TriangleFan:  					break;  			}
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,DrawArrays,The following statement contains a magic number: switch (mode)  			{  				case BeginMode.Lines:  					break;    				case BeginMode.Triangles:  					int polygons = count / 3;  					if(polygons > 2)  					{  						int a = 0;  					}  					int polygonIndex = 0;  					while (polygons > 0)  					{  						// copy our data to the buffer  						for (int i = 0; i < Math.Min(polygons*3' positionColorVertices.Length/3); i++)  						{  							System.Numerics.Vector3 positionF;  							unsafe  							{  								float* positions = (float*)vertexPointer.pointer;  								positionF = new System.Numerics.Vector3(positions[polygonIndex * 3 + 0]' positions[polygonIndex * 3 + 1]' positions[polygonIndex * 3 + 2]);  								polygonIndex++;  							}    							RgbaFloat colorF;  							if (i < currentImediateData.color4b.Length / 4)  							{  								colorF = new RgbaFloat(currentImediateData.color4b[i * 4 + 0] / 255.0f' currentImediateData.color4b[i * 4 + 1] / 255.0f' currentImediateData.color4b[i * 4 + 2] / 255.0f' currentImediateData.color4b[i * 4 + 3] / 255.0f);  							}  							else  							{  								colorF = new RgbaFloat((float)rand.NextDouble()' (float)rand.NextDouble()' (float)rand.NextDouble()' 1);  							}  							positionColorVertices[i] = new VertexPositionColorGL(positionF' colorF);  						}    						commandList.Begin();  						commandList.UpdateBuffer(positionColorVertexBuffer' 0' positionColorVertices);  						commandList.UpdateBuffer(modelViewBuffer' 0' RightHandToLeftHand(modelViewStack.Peek()' false));    						commandList.UpdateBuffer(projectionBuffer' 0' RightHandToLeftHand(projectionStack.Peek()' true));  						//commandList.UpdateBuffer(projectionBuffer' 0' orthoD3D);    						commandList.SetPipeline(positionColorGLPipeline);    						commandList.SetVertexBuffer(0' positionColorVertexBuffer);  						commandList.SetIndexBuffer(positionColorIndexBuffer' IndexFormat.UInt16);  						commandList.SetGraphicsResourceSet(0' modelViewProjectionResourceSet);  						commandList.SetFramebuffer(graphicsDevice.SwapchainFramebuffer);  						commandList.DrawIndexed((uint)Math.Min(polygons * 3' positionColorVertices.Length / 3)' 1' 0' 0' 0);    						commandList.End();  						graphicsDevice.SubmitCommands(commandList);  						polygons -= positionColorVertices.Length/3;  					}  					break;    				case BeginMode.TriangleStrip:  					break;    				case BeginMode.TriangleFan:  					break;  			}
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,DrawArrays,The following statement contains a magic number: switch (mode)  			{  				case BeginMode.Lines:  					break;    				case BeginMode.Triangles:  					int polygons = count / 3;  					if(polygons > 2)  					{  						int a = 0;  					}  					int polygonIndex = 0;  					while (polygons > 0)  					{  						// copy our data to the buffer  						for (int i = 0; i < Math.Min(polygons*3' positionColorVertices.Length/3); i++)  						{  							System.Numerics.Vector3 positionF;  							unsafe  							{  								float* positions = (float*)vertexPointer.pointer;  								positionF = new System.Numerics.Vector3(positions[polygonIndex * 3 + 0]' positions[polygonIndex * 3 + 1]' positions[polygonIndex * 3 + 2]);  								polygonIndex++;  							}    							RgbaFloat colorF;  							if (i < currentImediateData.color4b.Length / 4)  							{  								colorF = new RgbaFloat(currentImediateData.color4b[i * 4 + 0] / 255.0f' currentImediateData.color4b[i * 4 + 1] / 255.0f' currentImediateData.color4b[i * 4 + 2] / 255.0f' currentImediateData.color4b[i * 4 + 3] / 255.0f);  							}  							else  							{  								colorF = new RgbaFloat((float)rand.NextDouble()' (float)rand.NextDouble()' (float)rand.NextDouble()' 1);  							}  							positionColorVertices[i] = new VertexPositionColorGL(positionF' colorF);  						}    						commandList.Begin();  						commandList.UpdateBuffer(positionColorVertexBuffer' 0' positionColorVertices);  						commandList.UpdateBuffer(modelViewBuffer' 0' RightHandToLeftHand(modelViewStack.Peek()' false));    						commandList.UpdateBuffer(projectionBuffer' 0' RightHandToLeftHand(projectionStack.Peek()' true));  						//commandList.UpdateBuffer(projectionBuffer' 0' orthoD3D);    						commandList.SetPipeline(positionColorGLPipeline);    						commandList.SetVertexBuffer(0' positionColorVertexBuffer);  						commandList.SetIndexBuffer(positionColorIndexBuffer' IndexFormat.UInt16);  						commandList.SetGraphicsResourceSet(0' modelViewProjectionResourceSet);  						commandList.SetFramebuffer(graphicsDevice.SwapchainFramebuffer);  						commandList.DrawIndexed((uint)Math.Min(polygons * 3' positionColorVertices.Length / 3)' 1' 0' 0' 0);    						commandList.End();  						graphicsDevice.SubmitCommands(commandList);  						polygons -= positionColorVertices.Length/3;  					}  					break;    				case BeginMode.TriangleStrip:  					break;    				case BeginMode.TriangleFan:  					break;  			}
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,DrawArrays,The following statement contains a magic number: switch (mode)  			{  				case BeginMode.Lines:  					break;    				case BeginMode.Triangles:  					int polygons = count / 3;  					if(polygons > 2)  					{  						int a = 0;  					}  					int polygonIndex = 0;  					while (polygons > 0)  					{  						// copy our data to the buffer  						for (int i = 0; i < Math.Min(polygons*3' positionColorVertices.Length/3); i++)  						{  							System.Numerics.Vector3 positionF;  							unsafe  							{  								float* positions = (float*)vertexPointer.pointer;  								positionF = new System.Numerics.Vector3(positions[polygonIndex * 3 + 0]' positions[polygonIndex * 3 + 1]' positions[polygonIndex * 3 + 2]);  								polygonIndex++;  							}    							RgbaFloat colorF;  							if (i < currentImediateData.color4b.Length / 4)  							{  								colorF = new RgbaFloat(currentImediateData.color4b[i * 4 + 0] / 255.0f' currentImediateData.color4b[i * 4 + 1] / 255.0f' currentImediateData.color4b[i * 4 + 2] / 255.0f' currentImediateData.color4b[i * 4 + 3] / 255.0f);  							}  							else  							{  								colorF = new RgbaFloat((float)rand.NextDouble()' (float)rand.NextDouble()' (float)rand.NextDouble()' 1);  							}  							positionColorVertices[i] = new VertexPositionColorGL(positionF' colorF);  						}    						commandList.Begin();  						commandList.UpdateBuffer(positionColorVertexBuffer' 0' positionColorVertices);  						commandList.UpdateBuffer(modelViewBuffer' 0' RightHandToLeftHand(modelViewStack.Peek()' false));    						commandList.UpdateBuffer(projectionBuffer' 0' RightHandToLeftHand(projectionStack.Peek()' true));  						//commandList.UpdateBuffer(projectionBuffer' 0' orthoD3D);    						commandList.SetPipeline(positionColorGLPipeline);    						commandList.SetVertexBuffer(0' positionColorVertexBuffer);  						commandList.SetIndexBuffer(positionColorIndexBuffer' IndexFormat.UInt16);  						commandList.SetGraphicsResourceSet(0' modelViewProjectionResourceSet);  						commandList.SetFramebuffer(graphicsDevice.SwapchainFramebuffer);  						commandList.DrawIndexed((uint)Math.Min(polygons * 3' positionColorVertices.Length / 3)' 1' 0' 0' 0);    						commandList.End();  						graphicsDevice.SubmitCommands(commandList);  						polygons -= positionColorVertices.Length/3;  					}  					break;    				case BeginMode.TriangleStrip:  					break;    				case BeginMode.TriangleFan:  					break;  			}
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,DrawArrays,The following statement contains a magic number: switch (mode)  			{  				case BeginMode.Lines:  					break;    				case BeginMode.Triangles:  					int polygons = count / 3;  					if(polygons > 2)  					{  						int a = 0;  					}  					int polygonIndex = 0;  					while (polygons > 0)  					{  						// copy our data to the buffer  						for (int i = 0; i < Math.Min(polygons*3' positionColorVertices.Length/3); i++)  						{  							System.Numerics.Vector3 positionF;  							unsafe  							{  								float* positions = (float*)vertexPointer.pointer;  								positionF = new System.Numerics.Vector3(positions[polygonIndex * 3 + 0]' positions[polygonIndex * 3 + 1]' positions[polygonIndex * 3 + 2]);  								polygonIndex++;  							}    							RgbaFloat colorF;  							if (i < currentImediateData.color4b.Length / 4)  							{  								colorF = new RgbaFloat(currentImediateData.color4b[i * 4 + 0] / 255.0f' currentImediateData.color4b[i * 4 + 1] / 255.0f' currentImediateData.color4b[i * 4 + 2] / 255.0f' currentImediateData.color4b[i * 4 + 3] / 255.0f);  							}  							else  							{  								colorF = new RgbaFloat((float)rand.NextDouble()' (float)rand.NextDouble()' (float)rand.NextDouble()' 1);  							}  							positionColorVertices[i] = new VertexPositionColorGL(positionF' colorF);  						}    						commandList.Begin();  						commandList.UpdateBuffer(positionColorVertexBuffer' 0' positionColorVertices);  						commandList.UpdateBuffer(modelViewBuffer' 0' RightHandToLeftHand(modelViewStack.Peek()' false));    						commandList.UpdateBuffer(projectionBuffer' 0' RightHandToLeftHand(projectionStack.Peek()' true));  						//commandList.UpdateBuffer(projectionBuffer' 0' orthoD3D);    						commandList.SetPipeline(positionColorGLPipeline);    						commandList.SetVertexBuffer(0' positionColorVertexBuffer);  						commandList.SetIndexBuffer(positionColorIndexBuffer' IndexFormat.UInt16);  						commandList.SetGraphicsResourceSet(0' modelViewProjectionResourceSet);  						commandList.SetFramebuffer(graphicsDevice.SwapchainFramebuffer);  						commandList.DrawIndexed((uint)Math.Min(polygons * 3' positionColorVertices.Length / 3)' 1' 0' 0' 0);    						commandList.End();  						graphicsDevice.SubmitCommands(commandList);  						polygons -= positionColorVertices.Length/3;  					}  					break;    				case BeginMode.TriangleStrip:  					break;    				case BeginMode.TriangleFan:  					break;  			}
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,DrawArrays,The following statement contains a magic number: switch (mode)  			{  				case BeginMode.Lines:  					break;    				case BeginMode.Triangles:  					int polygons = count / 3;  					if(polygons > 2)  					{  						int a = 0;  					}  					int polygonIndex = 0;  					while (polygons > 0)  					{  						// copy our data to the buffer  						for (int i = 0; i < Math.Min(polygons*3' positionColorVertices.Length/3); i++)  						{  							System.Numerics.Vector3 positionF;  							unsafe  							{  								float* positions = (float*)vertexPointer.pointer;  								positionF = new System.Numerics.Vector3(positions[polygonIndex * 3 + 0]' positions[polygonIndex * 3 + 1]' positions[polygonIndex * 3 + 2]);  								polygonIndex++;  							}    							RgbaFloat colorF;  							if (i < currentImediateData.color4b.Length / 4)  							{  								colorF = new RgbaFloat(currentImediateData.color4b[i * 4 + 0] / 255.0f' currentImediateData.color4b[i * 4 + 1] / 255.0f' currentImediateData.color4b[i * 4 + 2] / 255.0f' currentImediateData.color4b[i * 4 + 3] / 255.0f);  							}  							else  							{  								colorF = new RgbaFloat((float)rand.NextDouble()' (float)rand.NextDouble()' (float)rand.NextDouble()' 1);  							}  							positionColorVertices[i] = new VertexPositionColorGL(positionF' colorF);  						}    						commandList.Begin();  						commandList.UpdateBuffer(positionColorVertexBuffer' 0' positionColorVertices);  						commandList.UpdateBuffer(modelViewBuffer' 0' RightHandToLeftHand(modelViewStack.Peek()' false));    						commandList.UpdateBuffer(projectionBuffer' 0' RightHandToLeftHand(projectionStack.Peek()' true));  						//commandList.UpdateBuffer(projectionBuffer' 0' orthoD3D);    						commandList.SetPipeline(positionColorGLPipeline);    						commandList.SetVertexBuffer(0' positionColorVertexBuffer);  						commandList.SetIndexBuffer(positionColorIndexBuffer' IndexFormat.UInt16);  						commandList.SetGraphicsResourceSet(0' modelViewProjectionResourceSet);  						commandList.SetFramebuffer(graphicsDevice.SwapchainFramebuffer);  						commandList.DrawIndexed((uint)Math.Min(polygons * 3' positionColorVertices.Length / 3)' 1' 0' 0' 0);    						commandList.End();  						graphicsDevice.SubmitCommands(commandList);  						polygons -= positionColorVertices.Length/3;  					}  					break;    				case BeginMode.TriangleStrip:  					break;    				case BeginMode.TriangleFan:  					break;  			}
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,DrawArrays,The following statement contains a magic number: switch (mode)  			{  				case BeginMode.Lines:  					break;    				case BeginMode.Triangles:  					int polygons = count / 3;  					if(polygons > 2)  					{  						int a = 0;  					}  					int polygonIndex = 0;  					while (polygons > 0)  					{  						// copy our data to the buffer  						for (int i = 0; i < Math.Min(polygons*3' positionColorVertices.Length/3); i++)  						{  							System.Numerics.Vector3 positionF;  							unsafe  							{  								float* positions = (float*)vertexPointer.pointer;  								positionF = new System.Numerics.Vector3(positions[polygonIndex * 3 + 0]' positions[polygonIndex * 3 + 1]' positions[polygonIndex * 3 + 2]);  								polygonIndex++;  							}    							RgbaFloat colorF;  							if (i < currentImediateData.color4b.Length / 4)  							{  								colorF = new RgbaFloat(currentImediateData.color4b[i * 4 + 0] / 255.0f' currentImediateData.color4b[i * 4 + 1] / 255.0f' currentImediateData.color4b[i * 4 + 2] / 255.0f' currentImediateData.color4b[i * 4 + 3] / 255.0f);  							}  							else  							{  								colorF = new RgbaFloat((float)rand.NextDouble()' (float)rand.NextDouble()' (float)rand.NextDouble()' 1);  							}  							positionColorVertices[i] = new VertexPositionColorGL(positionF' colorF);  						}    						commandList.Begin();  						commandList.UpdateBuffer(positionColorVertexBuffer' 0' positionColorVertices);  						commandList.UpdateBuffer(modelViewBuffer' 0' RightHandToLeftHand(modelViewStack.Peek()' false));    						commandList.UpdateBuffer(projectionBuffer' 0' RightHandToLeftHand(projectionStack.Peek()' true));  						//commandList.UpdateBuffer(projectionBuffer' 0' orthoD3D);    						commandList.SetPipeline(positionColorGLPipeline);    						commandList.SetVertexBuffer(0' positionColorVertexBuffer);  						commandList.SetIndexBuffer(positionColorIndexBuffer' IndexFormat.UInt16);  						commandList.SetGraphicsResourceSet(0' modelViewProjectionResourceSet);  						commandList.SetFramebuffer(graphicsDevice.SwapchainFramebuffer);  						commandList.DrawIndexed((uint)Math.Min(polygons * 3' positionColorVertices.Length / 3)' 1' 0' 0' 0);    						commandList.End();  						graphicsDevice.SubmitCommands(commandList);  						polygons -= positionColorVertices.Length/3;  					}  					break;    				case BeginMode.TriangleStrip:  					break;    				case BeginMode.TriangleFan:  					break;  			}
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,DrawArrays,The following statement contains a magic number: switch (mode)  			{  				case BeginMode.Lines:  					break;    				case BeginMode.Triangles:  					int polygons = count / 3;  					if(polygons > 2)  					{  						int a = 0;  					}  					int polygonIndex = 0;  					while (polygons > 0)  					{  						// copy our data to the buffer  						for (int i = 0; i < Math.Min(polygons*3' positionColorVertices.Length/3); i++)  						{  							System.Numerics.Vector3 positionF;  							unsafe  							{  								float* positions = (float*)vertexPointer.pointer;  								positionF = new System.Numerics.Vector3(positions[polygonIndex * 3 + 0]' positions[polygonIndex * 3 + 1]' positions[polygonIndex * 3 + 2]);  								polygonIndex++;  							}    							RgbaFloat colorF;  							if (i < currentImediateData.color4b.Length / 4)  							{  								colorF = new RgbaFloat(currentImediateData.color4b[i * 4 + 0] / 255.0f' currentImediateData.color4b[i * 4 + 1] / 255.0f' currentImediateData.color4b[i * 4 + 2] / 255.0f' currentImediateData.color4b[i * 4 + 3] / 255.0f);  							}  							else  							{  								colorF = new RgbaFloat((float)rand.NextDouble()' (float)rand.NextDouble()' (float)rand.NextDouble()' 1);  							}  							positionColorVertices[i] = new VertexPositionColorGL(positionF' colorF);  						}    						commandList.Begin();  						commandList.UpdateBuffer(positionColorVertexBuffer' 0' positionColorVertices);  						commandList.UpdateBuffer(modelViewBuffer' 0' RightHandToLeftHand(modelViewStack.Peek()' false));    						commandList.UpdateBuffer(projectionBuffer' 0' RightHandToLeftHand(projectionStack.Peek()' true));  						//commandList.UpdateBuffer(projectionBuffer' 0' orthoD3D);    						commandList.SetPipeline(positionColorGLPipeline);    						commandList.SetVertexBuffer(0' positionColorVertexBuffer);  						commandList.SetIndexBuffer(positionColorIndexBuffer' IndexFormat.UInt16);  						commandList.SetGraphicsResourceSet(0' modelViewProjectionResourceSet);  						commandList.SetFramebuffer(graphicsDevice.SwapchainFramebuffer);  						commandList.DrawIndexed((uint)Math.Min(polygons * 3' positionColorVertices.Length / 3)' 1' 0' 0' 0);    						commandList.End();  						graphicsDevice.SubmitCommands(commandList);  						polygons -= positionColorVertices.Length/3;  					}  					break;    				case BeginMode.TriangleStrip:  					break;    				case BeginMode.TriangleFan:  					break;  			}
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,DrawArrays,The following statement contains a magic number: switch (mode)  			{  				case BeginMode.Lines:  					break;    				case BeginMode.Triangles:  					int polygons = count / 3;  					if(polygons > 2)  					{  						int a = 0;  					}  					int polygonIndex = 0;  					while (polygons > 0)  					{  						// copy our data to the buffer  						for (int i = 0; i < Math.Min(polygons*3' positionColorVertices.Length/3); i++)  						{  							System.Numerics.Vector3 positionF;  							unsafe  							{  								float* positions = (float*)vertexPointer.pointer;  								positionF = new System.Numerics.Vector3(positions[polygonIndex * 3 + 0]' positions[polygonIndex * 3 + 1]' positions[polygonIndex * 3 + 2]);  								polygonIndex++;  							}    							RgbaFloat colorF;  							if (i < currentImediateData.color4b.Length / 4)  							{  								colorF = new RgbaFloat(currentImediateData.color4b[i * 4 + 0] / 255.0f' currentImediateData.color4b[i * 4 + 1] / 255.0f' currentImediateData.color4b[i * 4 + 2] / 255.0f' currentImediateData.color4b[i * 4 + 3] / 255.0f);  							}  							else  							{  								colorF = new RgbaFloat((float)rand.NextDouble()' (float)rand.NextDouble()' (float)rand.NextDouble()' 1);  							}  							positionColorVertices[i] = new VertexPositionColorGL(positionF' colorF);  						}    						commandList.Begin();  						commandList.UpdateBuffer(positionColorVertexBuffer' 0' positionColorVertices);  						commandList.UpdateBuffer(modelViewBuffer' 0' RightHandToLeftHand(modelViewStack.Peek()' false));    						commandList.UpdateBuffer(projectionBuffer' 0' RightHandToLeftHand(projectionStack.Peek()' true));  						//commandList.UpdateBuffer(projectionBuffer' 0' orthoD3D);    						commandList.SetPipeline(positionColorGLPipeline);    						commandList.SetVertexBuffer(0' positionColorVertexBuffer);  						commandList.SetIndexBuffer(positionColorIndexBuffer' IndexFormat.UInt16);  						commandList.SetGraphicsResourceSet(0' modelViewProjectionResourceSet);  						commandList.SetFramebuffer(graphicsDevice.SwapchainFramebuffer);  						commandList.DrawIndexed((uint)Math.Min(polygons * 3' positionColorVertices.Length / 3)' 1' 0' 0' 0);    						commandList.End();  						graphicsDevice.SubmitCommands(commandList);  						polygons -= positionColorVertices.Length/3;  					}  					break;    				case BeginMode.TriangleStrip:  					break;    				case BeginMode.TriangleFan:  					break;  			}
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,DrawArrays,The following statement contains a magic number: switch (mode)  			{  				case BeginMode.Lines:  					break;    				case BeginMode.Triangles:  					int polygons = count / 3;  					if(polygons > 2)  					{  						int a = 0;  					}  					int polygonIndex = 0;  					while (polygons > 0)  					{  						// copy our data to the buffer  						for (int i = 0; i < Math.Min(polygons*3' positionColorVertices.Length/3); i++)  						{  							System.Numerics.Vector3 positionF;  							unsafe  							{  								float* positions = (float*)vertexPointer.pointer;  								positionF = new System.Numerics.Vector3(positions[polygonIndex * 3 + 0]' positions[polygonIndex * 3 + 1]' positions[polygonIndex * 3 + 2]);  								polygonIndex++;  							}    							RgbaFloat colorF;  							if (i < currentImediateData.color4b.Length / 4)  							{  								colorF = new RgbaFloat(currentImediateData.color4b[i * 4 + 0] / 255.0f' currentImediateData.color4b[i * 4 + 1] / 255.0f' currentImediateData.color4b[i * 4 + 2] / 255.0f' currentImediateData.color4b[i * 4 + 3] / 255.0f);  							}  							else  							{  								colorF = new RgbaFloat((float)rand.NextDouble()' (float)rand.NextDouble()' (float)rand.NextDouble()' 1);  							}  							positionColorVertices[i] = new VertexPositionColorGL(positionF' colorF);  						}    						commandList.Begin();  						commandList.UpdateBuffer(positionColorVertexBuffer' 0' positionColorVertices);  						commandList.UpdateBuffer(modelViewBuffer' 0' RightHandToLeftHand(modelViewStack.Peek()' false));    						commandList.UpdateBuffer(projectionBuffer' 0' RightHandToLeftHand(projectionStack.Peek()' true));  						//commandList.UpdateBuffer(projectionBuffer' 0' orthoD3D);    						commandList.SetPipeline(positionColorGLPipeline);    						commandList.SetVertexBuffer(0' positionColorVertexBuffer);  						commandList.SetIndexBuffer(positionColorIndexBuffer' IndexFormat.UInt16);  						commandList.SetGraphicsResourceSet(0' modelViewProjectionResourceSet);  						commandList.SetFramebuffer(graphicsDevice.SwapchainFramebuffer);  						commandList.DrawIndexed((uint)Math.Min(polygons * 3' positionColorVertices.Length / 3)' 1' 0' 0' 0);    						commandList.End();  						graphicsDevice.SubmitCommands(commandList);  						polygons -= positionColorVertices.Length/3;  					}  					break;    				case BeginMode.TriangleStrip:  					break;    				case BeginMode.TriangleFan:  					break;  			}
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,DrawArrays,The following statement contains a magic number: switch (mode)  			{  				case BeginMode.Lines:  					break;    				case BeginMode.Triangles:  					int polygons = count / 3;  					if(polygons > 2)  					{  						int a = 0;  					}  					int polygonIndex = 0;  					while (polygons > 0)  					{  						// copy our data to the buffer  						for (int i = 0; i < Math.Min(polygons*3' positionColorVertices.Length/3); i++)  						{  							System.Numerics.Vector3 positionF;  							unsafe  							{  								float* positions = (float*)vertexPointer.pointer;  								positionF = new System.Numerics.Vector3(positions[polygonIndex * 3 + 0]' positions[polygonIndex * 3 + 1]' positions[polygonIndex * 3 + 2]);  								polygonIndex++;  							}    							RgbaFloat colorF;  							if (i < currentImediateData.color4b.Length / 4)  							{  								colorF = new RgbaFloat(currentImediateData.color4b[i * 4 + 0] / 255.0f' currentImediateData.color4b[i * 4 + 1] / 255.0f' currentImediateData.color4b[i * 4 + 2] / 255.0f' currentImediateData.color4b[i * 4 + 3] / 255.0f);  							}  							else  							{  								colorF = new RgbaFloat((float)rand.NextDouble()' (float)rand.NextDouble()' (float)rand.NextDouble()' 1);  							}  							positionColorVertices[i] = new VertexPositionColorGL(positionF' colorF);  						}    						commandList.Begin();  						commandList.UpdateBuffer(positionColorVertexBuffer' 0' positionColorVertices);  						commandList.UpdateBuffer(modelViewBuffer' 0' RightHandToLeftHand(modelViewStack.Peek()' false));    						commandList.UpdateBuffer(projectionBuffer' 0' RightHandToLeftHand(projectionStack.Peek()' true));  						//commandList.UpdateBuffer(projectionBuffer' 0' orthoD3D);    						commandList.SetPipeline(positionColorGLPipeline);    						commandList.SetVertexBuffer(0' positionColorVertexBuffer);  						commandList.SetIndexBuffer(positionColorIndexBuffer' IndexFormat.UInt16);  						commandList.SetGraphicsResourceSet(0' modelViewProjectionResourceSet);  						commandList.SetFramebuffer(graphicsDevice.SwapchainFramebuffer);  						commandList.DrawIndexed((uint)Math.Min(polygons * 3' positionColorVertices.Length / 3)' 1' 0' 0' 0);    						commandList.End();  						graphicsDevice.SubmitCommands(commandList);  						polygons -= positionColorVertices.Length/3;  					}  					break;    				case BeginMode.TriangleStrip:  					break;    				case BeginMode.TriangleFan:  					break;  			}
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,DrawArrays,The following statement contains a magic number: switch (mode)  			{  				case BeginMode.Lines:  					break;    				case BeginMode.Triangles:  					int polygons = count / 3;  					if(polygons > 2)  					{  						int a = 0;  					}  					int polygonIndex = 0;  					while (polygons > 0)  					{  						// copy our data to the buffer  						for (int i = 0; i < Math.Min(polygons*3' positionColorVertices.Length/3); i++)  						{  							System.Numerics.Vector3 positionF;  							unsafe  							{  								float* positions = (float*)vertexPointer.pointer;  								positionF = new System.Numerics.Vector3(positions[polygonIndex * 3 + 0]' positions[polygonIndex * 3 + 1]' positions[polygonIndex * 3 + 2]);  								polygonIndex++;  							}    							RgbaFloat colorF;  							if (i < currentImediateData.color4b.Length / 4)  							{  								colorF = new RgbaFloat(currentImediateData.color4b[i * 4 + 0] / 255.0f' currentImediateData.color4b[i * 4 + 1] / 255.0f' currentImediateData.color4b[i * 4 + 2] / 255.0f' currentImediateData.color4b[i * 4 + 3] / 255.0f);  							}  							else  							{  								colorF = new RgbaFloat((float)rand.NextDouble()' (float)rand.NextDouble()' (float)rand.NextDouble()' 1);  							}  							positionColorVertices[i] = new VertexPositionColorGL(positionF' colorF);  						}    						commandList.Begin();  						commandList.UpdateBuffer(positionColorVertexBuffer' 0' positionColorVertices);  						commandList.UpdateBuffer(modelViewBuffer' 0' RightHandToLeftHand(modelViewStack.Peek()' false));    						commandList.UpdateBuffer(projectionBuffer' 0' RightHandToLeftHand(projectionStack.Peek()' true));  						//commandList.UpdateBuffer(projectionBuffer' 0' orthoD3D);    						commandList.SetPipeline(positionColorGLPipeline);    						commandList.SetVertexBuffer(0' positionColorVertexBuffer);  						commandList.SetIndexBuffer(positionColorIndexBuffer' IndexFormat.UInt16);  						commandList.SetGraphicsResourceSet(0' modelViewProjectionResourceSet);  						commandList.SetFramebuffer(graphicsDevice.SwapchainFramebuffer);  						commandList.DrawIndexed((uint)Math.Min(polygons * 3' positionColorVertices.Length / 3)' 1' 0' 0' 0);    						commandList.End();  						graphicsDevice.SubmitCommands(commandList);  						polygons -= positionColorVertices.Length/3;  					}  					break;    				case BeginMode.TriangleStrip:  					break;    				case BeginMode.TriangleFan:  					break;  			}
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,DrawArrays,The following statement contains a magic number: switch (mode)  			{  				case BeginMode.Lines:  					break;    				case BeginMode.Triangles:  					int polygons = count / 3;  					if(polygons > 2)  					{  						int a = 0;  					}  					int polygonIndex = 0;  					while (polygons > 0)  					{  						// copy our data to the buffer  						for (int i = 0; i < Math.Min(polygons*3' positionColorVertices.Length/3); i++)  						{  							System.Numerics.Vector3 positionF;  							unsafe  							{  								float* positions = (float*)vertexPointer.pointer;  								positionF = new System.Numerics.Vector3(positions[polygonIndex * 3 + 0]' positions[polygonIndex * 3 + 1]' positions[polygonIndex * 3 + 2]);  								polygonIndex++;  							}    							RgbaFloat colorF;  							if (i < currentImediateData.color4b.Length / 4)  							{  								colorF = new RgbaFloat(currentImediateData.color4b[i * 4 + 0] / 255.0f' currentImediateData.color4b[i * 4 + 1] / 255.0f' currentImediateData.color4b[i * 4 + 2] / 255.0f' currentImediateData.color4b[i * 4 + 3] / 255.0f);  							}  							else  							{  								colorF = new RgbaFloat((float)rand.NextDouble()' (float)rand.NextDouble()' (float)rand.NextDouble()' 1);  							}  							positionColorVertices[i] = new VertexPositionColorGL(positionF' colorF);  						}    						commandList.Begin();  						commandList.UpdateBuffer(positionColorVertexBuffer' 0' positionColorVertices);  						commandList.UpdateBuffer(modelViewBuffer' 0' RightHandToLeftHand(modelViewStack.Peek()' false));    						commandList.UpdateBuffer(projectionBuffer' 0' RightHandToLeftHand(projectionStack.Peek()' true));  						//commandList.UpdateBuffer(projectionBuffer' 0' orthoD3D);    						commandList.SetPipeline(positionColorGLPipeline);    						commandList.SetVertexBuffer(0' positionColorVertexBuffer);  						commandList.SetIndexBuffer(positionColorIndexBuffer' IndexFormat.UInt16);  						commandList.SetGraphicsResourceSet(0' modelViewProjectionResourceSet);  						commandList.SetFramebuffer(graphicsDevice.SwapchainFramebuffer);  						commandList.DrawIndexed((uint)Math.Min(polygons * 3' positionColorVertices.Length / 3)' 1' 0' 0' 0);    						commandList.End();  						graphicsDevice.SubmitCommands(commandList);  						polygons -= positionColorVertices.Length/3;  					}  					break;    				case BeginMode.TriangleStrip:  					break;    				case BeginMode.TriangleFan:  					break;  			}
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,DrawArrays,The following statement contains a magic number: switch (mode)  			{  				case BeginMode.Lines:  					break;    				case BeginMode.Triangles:  					int polygons = count / 3;  					if(polygons > 2)  					{  						int a = 0;  					}  					int polygonIndex = 0;  					while (polygons > 0)  					{  						// copy our data to the buffer  						for (int i = 0; i < Math.Min(polygons*3' positionColorVertices.Length/3); i++)  						{  							System.Numerics.Vector3 positionF;  							unsafe  							{  								float* positions = (float*)vertexPointer.pointer;  								positionF = new System.Numerics.Vector3(positions[polygonIndex * 3 + 0]' positions[polygonIndex * 3 + 1]' positions[polygonIndex * 3 + 2]);  								polygonIndex++;  							}    							RgbaFloat colorF;  							if (i < currentImediateData.color4b.Length / 4)  							{  								colorF = new RgbaFloat(currentImediateData.color4b[i * 4 + 0] / 255.0f' currentImediateData.color4b[i * 4 + 1] / 255.0f' currentImediateData.color4b[i * 4 + 2] / 255.0f' currentImediateData.color4b[i * 4 + 3] / 255.0f);  							}  							else  							{  								colorF = new RgbaFloat((float)rand.NextDouble()' (float)rand.NextDouble()' (float)rand.NextDouble()' 1);  							}  							positionColorVertices[i] = new VertexPositionColorGL(positionF' colorF);  						}    						commandList.Begin();  						commandList.UpdateBuffer(positionColorVertexBuffer' 0' positionColorVertices);  						commandList.UpdateBuffer(modelViewBuffer' 0' RightHandToLeftHand(modelViewStack.Peek()' false));    						commandList.UpdateBuffer(projectionBuffer' 0' RightHandToLeftHand(projectionStack.Peek()' true));  						//commandList.UpdateBuffer(projectionBuffer' 0' orthoD3D);    						commandList.SetPipeline(positionColorGLPipeline);    						commandList.SetVertexBuffer(0' positionColorVertexBuffer);  						commandList.SetIndexBuffer(positionColorIndexBuffer' IndexFormat.UInt16);  						commandList.SetGraphicsResourceSet(0' modelViewProjectionResourceSet);  						commandList.SetFramebuffer(graphicsDevice.SwapchainFramebuffer);  						commandList.DrawIndexed((uint)Math.Min(polygons * 3' positionColorVertices.Length / 3)' 1' 0' 0' 0);    						commandList.End();  						graphicsDevice.SubmitCommands(commandList);  						polygons -= positionColorVertices.Length/3;  					}  					break;    				case BeginMode.TriangleStrip:  					break;    				case BeginMode.TriangleFan:  					break;  			}
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,DrawArrays,The following statement contains a magic number: switch (mode)  			{  				case BeginMode.Lines:  					break;    				case BeginMode.Triangles:  					int polygons = count / 3;  					if(polygons > 2)  					{  						int a = 0;  					}  					int polygonIndex = 0;  					while (polygons > 0)  					{  						// copy our data to the buffer  						for (int i = 0; i < Math.Min(polygons*3' positionColorVertices.Length/3); i++)  						{  							System.Numerics.Vector3 positionF;  							unsafe  							{  								float* positions = (float*)vertexPointer.pointer;  								positionF = new System.Numerics.Vector3(positions[polygonIndex * 3 + 0]' positions[polygonIndex * 3 + 1]' positions[polygonIndex * 3 + 2]);  								polygonIndex++;  							}    							RgbaFloat colorF;  							if (i < currentImediateData.color4b.Length / 4)  							{  								colorF = new RgbaFloat(currentImediateData.color4b[i * 4 + 0] / 255.0f' currentImediateData.color4b[i * 4 + 1] / 255.0f' currentImediateData.color4b[i * 4 + 2] / 255.0f' currentImediateData.color4b[i * 4 + 3] / 255.0f);  							}  							else  							{  								colorF = new RgbaFloat((float)rand.NextDouble()' (float)rand.NextDouble()' (float)rand.NextDouble()' 1);  							}  							positionColorVertices[i] = new VertexPositionColorGL(positionF' colorF);  						}    						commandList.Begin();  						commandList.UpdateBuffer(positionColorVertexBuffer' 0' positionColorVertices);  						commandList.UpdateBuffer(modelViewBuffer' 0' RightHandToLeftHand(modelViewStack.Peek()' false));    						commandList.UpdateBuffer(projectionBuffer' 0' RightHandToLeftHand(projectionStack.Peek()' true));  						//commandList.UpdateBuffer(projectionBuffer' 0' orthoD3D);    						commandList.SetPipeline(positionColorGLPipeline);    						commandList.SetVertexBuffer(0' positionColorVertexBuffer);  						commandList.SetIndexBuffer(positionColorIndexBuffer' IndexFormat.UInt16);  						commandList.SetGraphicsResourceSet(0' modelViewProjectionResourceSet);  						commandList.SetFramebuffer(graphicsDevice.SwapchainFramebuffer);  						commandList.DrawIndexed((uint)Math.Min(polygons * 3' positionColorVertices.Length / 3)' 1' 0' 0' 0);    						commandList.End();  						graphicsDevice.SubmitCommands(commandList);  						polygons -= positionColorVertices.Length/3;  					}  					break;    				case BeginMode.TriangleStrip:  					break;    				case BeginMode.TriangleFan:  					break;  			}
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,DrawArrays,The following statement contains a magic number: switch (mode)  			{  				case BeginMode.Lines:  					break;    				case BeginMode.Triangles:  					int polygons = count / 3;  					if(polygons > 2)  					{  						int a = 0;  					}  					int polygonIndex = 0;  					while (polygons > 0)  					{  						// copy our data to the buffer  						for (int i = 0; i < Math.Min(polygons*3' positionColorVertices.Length/3); i++)  						{  							System.Numerics.Vector3 positionF;  							unsafe  							{  								float* positions = (float*)vertexPointer.pointer;  								positionF = new System.Numerics.Vector3(positions[polygonIndex * 3 + 0]' positions[polygonIndex * 3 + 1]' positions[polygonIndex * 3 + 2]);  								polygonIndex++;  							}    							RgbaFloat colorF;  							if (i < currentImediateData.color4b.Length / 4)  							{  								colorF = new RgbaFloat(currentImediateData.color4b[i * 4 + 0] / 255.0f' currentImediateData.color4b[i * 4 + 1] / 255.0f' currentImediateData.color4b[i * 4 + 2] / 255.0f' currentImediateData.color4b[i * 4 + 3] / 255.0f);  							}  							else  							{  								colorF = new RgbaFloat((float)rand.NextDouble()' (float)rand.NextDouble()' (float)rand.NextDouble()' 1);  							}  							positionColorVertices[i] = new VertexPositionColorGL(positionF' colorF);  						}    						commandList.Begin();  						commandList.UpdateBuffer(positionColorVertexBuffer' 0' positionColorVertices);  						commandList.UpdateBuffer(modelViewBuffer' 0' RightHandToLeftHand(modelViewStack.Peek()' false));    						commandList.UpdateBuffer(projectionBuffer' 0' RightHandToLeftHand(projectionStack.Peek()' true));  						//commandList.UpdateBuffer(projectionBuffer' 0' orthoD3D);    						commandList.SetPipeline(positionColorGLPipeline);    						commandList.SetVertexBuffer(0' positionColorVertexBuffer);  						commandList.SetIndexBuffer(positionColorIndexBuffer' IndexFormat.UInt16);  						commandList.SetGraphicsResourceSet(0' modelViewProjectionResourceSet);  						commandList.SetFramebuffer(graphicsDevice.SwapchainFramebuffer);  						commandList.DrawIndexed((uint)Math.Min(polygons * 3' positionColorVertices.Length / 3)' 1' 0' 0' 0);    						commandList.End();  						graphicsDevice.SubmitCommands(commandList);  						polygons -= positionColorVertices.Length/3;  					}  					break;    				case BeginMode.TriangleStrip:  					break;    				case BeginMode.TriangleFan:  					break;  			}
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,End,The following statement contains a magic number: switch (currentImediateData.Mode)  			{  				case BeginMode.Lines:  					{  						GL.EnableClientState(ArrayCap.ColorArray);  						GL.EnableClientState(ArrayCap.VertexArray);    						float[] v = currentImediateData.positions3f.Array;  						byte[] c = currentImediateData.color4b.Array;  						// pin the data' so that GC doesn't move them' while used  						// by native code  						unsafe  						{  							fixed (float* pv = v)  							{  								fixed (byte* pc = c)  								{  									GL.ColorPointer(4' ColorPointerType.UnsignedByte' 0' new IntPtr(pc));  									GL.VertexPointer(3' VertexPointerType.Float' 0' new IntPtr(pv));  									GL.DrawArrays(currentImediateData.Mode' 0' currentImediateData.positions3f.Count / 3);  								}  							}  						}  						GL.DisableClientState(ArrayCap.VertexArray);  						GL.DisableClientState(ArrayCap.ColorArray);  					}  					break;    				case BeginMode.TriangleFan:  				case BeginMode.Triangles:  				case BeginMode.TriangleStrip:  					{  						GL.EnableClientState(ArrayCap.ColorArray);  						GL.EnableClientState(ArrayCap.VertexArray);  						GL.EnableClientState(ArrayCap.TextureCoordArray);    						float[] v = currentImediateData.positions3f.Array;  						byte[] c = currentImediateData.color4b.Array;  						float[] t = currentImediateData.textureCoords2f.Array;  						// pin the data' so that GC doesn't move them' while used  						// by native code  						unsafe  						{  							fixed (float* pv = v' pt = t)  							{  								fixed (byte* pc = c)  								{  									GL.ColorPointer(4' ColorPointerType.UnsignedByte' 0' new IntPtr(pc));  									GL.VertexPointer(3' VertexPointerType.Float' 0' new IntPtr(pv));  									GL.TexCoordPointer(2' TexCordPointerType.Float' 0' new IntPtr(pt));  									GL.DrawArrays(currentImediateData.Mode' 0' currentImediateData.positions3f.Count / 3);  								}  							}  						}  						GL.DisableClientState(ArrayCap.VertexArray);  						GL.DisableClientState(ArrayCap.TextureCoordArray);  						GL.DisableClientState(ArrayCap.ColorArray);  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,End,The following statement contains a magic number: switch (currentImediateData.Mode)  			{  				case BeginMode.Lines:  					{  						GL.EnableClientState(ArrayCap.ColorArray);  						GL.EnableClientState(ArrayCap.VertexArray);    						float[] v = currentImediateData.positions3f.Array;  						byte[] c = currentImediateData.color4b.Array;  						// pin the data' so that GC doesn't move them' while used  						// by native code  						unsafe  						{  							fixed (float* pv = v)  							{  								fixed (byte* pc = c)  								{  									GL.ColorPointer(4' ColorPointerType.UnsignedByte' 0' new IntPtr(pc));  									GL.VertexPointer(3' VertexPointerType.Float' 0' new IntPtr(pv));  									GL.DrawArrays(currentImediateData.Mode' 0' currentImediateData.positions3f.Count / 3);  								}  							}  						}  						GL.DisableClientState(ArrayCap.VertexArray);  						GL.DisableClientState(ArrayCap.ColorArray);  					}  					break;    				case BeginMode.TriangleFan:  				case BeginMode.Triangles:  				case BeginMode.TriangleStrip:  					{  						GL.EnableClientState(ArrayCap.ColorArray);  						GL.EnableClientState(ArrayCap.VertexArray);  						GL.EnableClientState(ArrayCap.TextureCoordArray);    						float[] v = currentImediateData.positions3f.Array;  						byte[] c = currentImediateData.color4b.Array;  						float[] t = currentImediateData.textureCoords2f.Array;  						// pin the data' so that GC doesn't move them' while used  						// by native code  						unsafe  						{  							fixed (float* pv = v' pt = t)  							{  								fixed (byte* pc = c)  								{  									GL.ColorPointer(4' ColorPointerType.UnsignedByte' 0' new IntPtr(pc));  									GL.VertexPointer(3' VertexPointerType.Float' 0' new IntPtr(pv));  									GL.TexCoordPointer(2' TexCordPointerType.Float' 0' new IntPtr(pt));  									GL.DrawArrays(currentImediateData.Mode' 0' currentImediateData.positions3f.Count / 3);  								}  							}  						}  						GL.DisableClientState(ArrayCap.VertexArray);  						GL.DisableClientState(ArrayCap.TextureCoordArray);  						GL.DisableClientState(ArrayCap.ColorArray);  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,End,The following statement contains a magic number: switch (currentImediateData.Mode)  			{  				case BeginMode.Lines:  					{  						GL.EnableClientState(ArrayCap.ColorArray);  						GL.EnableClientState(ArrayCap.VertexArray);    						float[] v = currentImediateData.positions3f.Array;  						byte[] c = currentImediateData.color4b.Array;  						// pin the data' so that GC doesn't move them' while used  						// by native code  						unsafe  						{  							fixed (float* pv = v)  							{  								fixed (byte* pc = c)  								{  									GL.ColorPointer(4' ColorPointerType.UnsignedByte' 0' new IntPtr(pc));  									GL.VertexPointer(3' VertexPointerType.Float' 0' new IntPtr(pv));  									GL.DrawArrays(currentImediateData.Mode' 0' currentImediateData.positions3f.Count / 3);  								}  							}  						}  						GL.DisableClientState(ArrayCap.VertexArray);  						GL.DisableClientState(ArrayCap.ColorArray);  					}  					break;    				case BeginMode.TriangleFan:  				case BeginMode.Triangles:  				case BeginMode.TriangleStrip:  					{  						GL.EnableClientState(ArrayCap.ColorArray);  						GL.EnableClientState(ArrayCap.VertexArray);  						GL.EnableClientState(ArrayCap.TextureCoordArray);    						float[] v = currentImediateData.positions3f.Array;  						byte[] c = currentImediateData.color4b.Array;  						float[] t = currentImediateData.textureCoords2f.Array;  						// pin the data' so that GC doesn't move them' while used  						// by native code  						unsafe  						{  							fixed (float* pv = v' pt = t)  							{  								fixed (byte* pc = c)  								{  									GL.ColorPointer(4' ColorPointerType.UnsignedByte' 0' new IntPtr(pc));  									GL.VertexPointer(3' VertexPointerType.Float' 0' new IntPtr(pv));  									GL.TexCoordPointer(2' TexCordPointerType.Float' 0' new IntPtr(pt));  									GL.DrawArrays(currentImediateData.Mode' 0' currentImediateData.positions3f.Count / 3);  								}  							}  						}  						GL.DisableClientState(ArrayCap.VertexArray);  						GL.DisableClientState(ArrayCap.TextureCoordArray);  						GL.DisableClientState(ArrayCap.ColorArray);  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,End,The following statement contains a magic number: switch (currentImediateData.Mode)  			{  				case BeginMode.Lines:  					{  						GL.EnableClientState(ArrayCap.ColorArray);  						GL.EnableClientState(ArrayCap.VertexArray);    						float[] v = currentImediateData.positions3f.Array;  						byte[] c = currentImediateData.color4b.Array;  						// pin the data' so that GC doesn't move them' while used  						// by native code  						unsafe  						{  							fixed (float* pv = v)  							{  								fixed (byte* pc = c)  								{  									GL.ColorPointer(4' ColorPointerType.UnsignedByte' 0' new IntPtr(pc));  									GL.VertexPointer(3' VertexPointerType.Float' 0' new IntPtr(pv));  									GL.DrawArrays(currentImediateData.Mode' 0' currentImediateData.positions3f.Count / 3);  								}  							}  						}  						GL.DisableClientState(ArrayCap.VertexArray);  						GL.DisableClientState(ArrayCap.ColorArray);  					}  					break;    				case BeginMode.TriangleFan:  				case BeginMode.Triangles:  				case BeginMode.TriangleStrip:  					{  						GL.EnableClientState(ArrayCap.ColorArray);  						GL.EnableClientState(ArrayCap.VertexArray);  						GL.EnableClientState(ArrayCap.TextureCoordArray);    						float[] v = currentImediateData.positions3f.Array;  						byte[] c = currentImediateData.color4b.Array;  						float[] t = currentImediateData.textureCoords2f.Array;  						// pin the data' so that GC doesn't move them' while used  						// by native code  						unsafe  						{  							fixed (float* pv = v' pt = t)  							{  								fixed (byte* pc = c)  								{  									GL.ColorPointer(4' ColorPointerType.UnsignedByte' 0' new IntPtr(pc));  									GL.VertexPointer(3' VertexPointerType.Float' 0' new IntPtr(pv));  									GL.TexCoordPointer(2' TexCordPointerType.Float' 0' new IntPtr(pt));  									GL.DrawArrays(currentImediateData.Mode' 0' currentImediateData.positions3f.Count / 3);  								}  							}  						}  						GL.DisableClientState(ArrayCap.VertexArray);  						GL.DisableClientState(ArrayCap.TextureCoordArray);  						GL.DisableClientState(ArrayCap.ColorArray);  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,End,The following statement contains a magic number: switch (currentImediateData.Mode)  			{  				case BeginMode.Lines:  					{  						GL.EnableClientState(ArrayCap.ColorArray);  						GL.EnableClientState(ArrayCap.VertexArray);    						float[] v = currentImediateData.positions3f.Array;  						byte[] c = currentImediateData.color4b.Array;  						// pin the data' so that GC doesn't move them' while used  						// by native code  						unsafe  						{  							fixed (float* pv = v)  							{  								fixed (byte* pc = c)  								{  									GL.ColorPointer(4' ColorPointerType.UnsignedByte' 0' new IntPtr(pc));  									GL.VertexPointer(3' VertexPointerType.Float' 0' new IntPtr(pv));  									GL.DrawArrays(currentImediateData.Mode' 0' currentImediateData.positions3f.Count / 3);  								}  							}  						}  						GL.DisableClientState(ArrayCap.VertexArray);  						GL.DisableClientState(ArrayCap.ColorArray);  					}  					break;    				case BeginMode.TriangleFan:  				case BeginMode.Triangles:  				case BeginMode.TriangleStrip:  					{  						GL.EnableClientState(ArrayCap.ColorArray);  						GL.EnableClientState(ArrayCap.VertexArray);  						GL.EnableClientState(ArrayCap.TextureCoordArray);    						float[] v = currentImediateData.positions3f.Array;  						byte[] c = currentImediateData.color4b.Array;  						float[] t = currentImediateData.textureCoords2f.Array;  						// pin the data' so that GC doesn't move them' while used  						// by native code  						unsafe  						{  							fixed (float* pv = v' pt = t)  							{  								fixed (byte* pc = c)  								{  									GL.ColorPointer(4' ColorPointerType.UnsignedByte' 0' new IntPtr(pc));  									GL.VertexPointer(3' VertexPointerType.Float' 0' new IntPtr(pv));  									GL.TexCoordPointer(2' TexCordPointerType.Float' 0' new IntPtr(pt));  									GL.DrawArrays(currentImediateData.Mode' 0' currentImediateData.positions3f.Count / 3);  								}  							}  						}  						GL.DisableClientState(ArrayCap.VertexArray);  						GL.DisableClientState(ArrayCap.TextureCoordArray);  						GL.DisableClientState(ArrayCap.ColorArray);  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,End,The following statement contains a magic number: switch (currentImediateData.Mode)  			{  				case BeginMode.Lines:  					{  						GL.EnableClientState(ArrayCap.ColorArray);  						GL.EnableClientState(ArrayCap.VertexArray);    						float[] v = currentImediateData.positions3f.Array;  						byte[] c = currentImediateData.color4b.Array;  						// pin the data' so that GC doesn't move them' while used  						// by native code  						unsafe  						{  							fixed (float* pv = v)  							{  								fixed (byte* pc = c)  								{  									GL.ColorPointer(4' ColorPointerType.UnsignedByte' 0' new IntPtr(pc));  									GL.VertexPointer(3' VertexPointerType.Float' 0' new IntPtr(pv));  									GL.DrawArrays(currentImediateData.Mode' 0' currentImediateData.positions3f.Count / 3);  								}  							}  						}  						GL.DisableClientState(ArrayCap.VertexArray);  						GL.DisableClientState(ArrayCap.ColorArray);  					}  					break;    				case BeginMode.TriangleFan:  				case BeginMode.Triangles:  				case BeginMode.TriangleStrip:  					{  						GL.EnableClientState(ArrayCap.ColorArray);  						GL.EnableClientState(ArrayCap.VertexArray);  						GL.EnableClientState(ArrayCap.TextureCoordArray);    						float[] v = currentImediateData.positions3f.Array;  						byte[] c = currentImediateData.color4b.Array;  						float[] t = currentImediateData.textureCoords2f.Array;  						// pin the data' so that GC doesn't move them' while used  						// by native code  						unsafe  						{  							fixed (float* pv = v' pt = t)  							{  								fixed (byte* pc = c)  								{  									GL.ColorPointer(4' ColorPointerType.UnsignedByte' 0' new IntPtr(pc));  									GL.VertexPointer(3' VertexPointerType.Float' 0' new IntPtr(pv));  									GL.TexCoordPointer(2' TexCordPointerType.Float' 0' new IntPtr(pt));  									GL.DrawArrays(currentImediateData.Mode' 0' currentImediateData.positions3f.Count / 3);  								}  							}  						}  						GL.DisableClientState(ArrayCap.VertexArray);  						GL.DisableClientState(ArrayCap.TextureCoordArray);  						GL.DisableClientState(ArrayCap.ColorArray);  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,End,The following statement contains a magic number: switch (currentImediateData.Mode)  			{  				case BeginMode.Lines:  					{  						GL.EnableClientState(ArrayCap.ColorArray);  						GL.EnableClientState(ArrayCap.VertexArray);    						float[] v = currentImediateData.positions3f.Array;  						byte[] c = currentImediateData.color4b.Array;  						// pin the data' so that GC doesn't move them' while used  						// by native code  						unsafe  						{  							fixed (float* pv = v)  							{  								fixed (byte* pc = c)  								{  									GL.ColorPointer(4' ColorPointerType.UnsignedByte' 0' new IntPtr(pc));  									GL.VertexPointer(3' VertexPointerType.Float' 0' new IntPtr(pv));  									GL.DrawArrays(currentImediateData.Mode' 0' currentImediateData.positions3f.Count / 3);  								}  							}  						}  						GL.DisableClientState(ArrayCap.VertexArray);  						GL.DisableClientState(ArrayCap.ColorArray);  					}  					break;    				case BeginMode.TriangleFan:  				case BeginMode.Triangles:  				case BeginMode.TriangleStrip:  					{  						GL.EnableClientState(ArrayCap.ColorArray);  						GL.EnableClientState(ArrayCap.VertexArray);  						GL.EnableClientState(ArrayCap.TextureCoordArray);    						float[] v = currentImediateData.positions3f.Array;  						byte[] c = currentImediateData.color4b.Array;  						float[] t = currentImediateData.textureCoords2f.Array;  						// pin the data' so that GC doesn't move them' while used  						// by native code  						unsafe  						{  							fixed (float* pv = v' pt = t)  							{  								fixed (byte* pc = c)  								{  									GL.ColorPointer(4' ColorPointerType.UnsignedByte' 0' new IntPtr(pc));  									GL.VertexPointer(3' VertexPointerType.Float' 0' new IntPtr(pv));  									GL.TexCoordPointer(2' TexCordPointerType.Float' 0' new IntPtr(pt));  									GL.DrawArrays(currentImediateData.Mode' 0' currentImediateData.positions3f.Count / 3);  								}  							}  						}  						GL.DisableClientState(ArrayCap.VertexArray);  						GL.DisableClientState(ArrayCap.TextureCoordArray);  						GL.DisableClientState(ArrayCap.ColorArray);  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,Vertex2,The following statement contains a magic number: currentImediateData.color4b.add(ImediateMode.currentColor[2]);
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,Vertex2,The following statement contains a magic number: currentImediateData.color4b.add(ImediateMode.currentColor[3]);
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,Vertex3,The following statement contains a magic number: currentImediateData.color4b.add(ImediateMode.currentColor[2]);
Magic Number,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,Vertex3,The following statement contains a magic number: currentImediateData.color4b.add(ImediateMode.currentColor[3]);
Missing Default,MatterHackers.VeldridProvider,VeldridWindowProvider,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\VeldridWindowProvider.cs,ShowSystemWindow,The following switch statement is missing a default case: switch (mouseButton)  				{  					case MouseButton.Left:  						return MouseButtons.Left;  					case MouseButton.Middle:  						break;  					case MouseButton.Right:  						break;  					case MouseButton.Button1:  						break;  					case MouseButton.Button2:  						break;  					case MouseButton.Button3:  						break;  					case MouseButton.Button4:  						break;  					case MouseButton.Button5:  						break;  					case MouseButton.Button6:  						break;  					case MouseButton.Button7:  						break;  					case MouseButton.Button8:  						break;  					case MouseButton.Button9:  						break;  					case MouseButton.LastButton:  						break;  				}
Missing Default,MatterHackers.RenderOpenGl,VeldridGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Veldrid\RenderOpenGL\VeldridGL.cs,DrawArrays,The following switch statement is missing a default case: switch (mode)  			{  				case BeginMode.Lines:  					break;    				case BeginMode.Triangles:  					int polygons = count / 3;  					if(polygons > 2)  					{  						int a = 0;  					}  					int polygonIndex = 0;  					while (polygons > 0)  					{  						// copy our data to the buffer  						for (int i = 0; i < Math.Min(polygons*3' positionColorVertices.Length/3); i++)  						{  							System.Numerics.Vector3 positionF;  							unsafe  							{  								float* positions = (float*)vertexPointer.pointer;  								positionF = new System.Numerics.Vector3(positions[polygonIndex * 3 + 0]' positions[polygonIndex * 3 + 1]' positions[polygonIndex * 3 + 2]);  								polygonIndex++;  							}    							RgbaFloat colorF;  							if (i < currentImediateData.color4b.Length / 4)  							{  								colorF = new RgbaFloat(currentImediateData.color4b[i * 4 + 0] / 255.0f' currentImediateData.color4b[i * 4 + 1] / 255.0f' currentImediateData.color4b[i * 4 + 2] / 255.0f' currentImediateData.color4b[i * 4 + 3] / 255.0f);  							}  							else  							{  								colorF = new RgbaFloat((float)rand.NextDouble()' (float)rand.NextDouble()' (float)rand.NextDouble()' 1);  							}  							positionColorVertices[i] = new VertexPositionColorGL(positionF' colorF);  						}    						commandList.Begin();  						commandList.UpdateBuffer(positionColorVertexBuffer' 0' positionColorVertices);  						commandList.UpdateBuffer(modelViewBuffer' 0' RightHandToLeftHand(modelViewStack.Peek()' false));    						commandList.UpdateBuffer(projectionBuffer' 0' RightHandToLeftHand(projectionStack.Peek()' true));  						//commandList.UpdateBuffer(projectionBuffer' 0' orthoD3D);    						commandList.SetPipeline(positionColorGLPipeline);    						commandList.SetVertexBuffer(0' positionColorVertexBuffer);  						commandList.SetIndexBuffer(positionColorIndexBuffer' IndexFormat.UInt16);  						commandList.SetGraphicsResourceSet(0' modelViewProjectionResourceSet);  						commandList.SetFramebuffer(graphicsDevice.SwapchainFramebuffer);  						commandList.DrawIndexed((uint)Math.Min(polygons * 3' positionColorVertices.Length / 3)' 1' 0' 0' 0);    						commandList.End();  						graphicsDevice.SubmitCommands(commandList);  						polygons -= positionColorVertices.Length/3;  					}  					break;    				case BeginMode.TriangleStrip:  					break;    				case BeginMode.TriangleFan:  					break;  			}
