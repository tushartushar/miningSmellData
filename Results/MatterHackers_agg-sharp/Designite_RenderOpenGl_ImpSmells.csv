Implementation smell,Namespace,Class,File,Method,Description
Complex Method,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,GetImageGlPlugin,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.RenderOpenGl,AAGLTesselator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\AAGLTesselator.cs,RenderLastToGL,Cyclomatic complexity of the method is 10
Complex Method,MatterHackers.RenderOpenGl,GLHelper,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderMeshToGl.cs,Render,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.RenderOpenGl,GLHelper,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderMeshToGl.cs,DrawToGL,Cyclomatic complexity of the method is 10
Long Parameter List,MatterHackers.RenderOpenGl,Graphics2DOpenGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\Graphics2DOpenGL.cs,Render,The method has 6 parameters. Parameters: source' x' y' angleRadians' scaleX' scaleY
Long Parameter List,MatterHackers.RenderOpenGl,Graphics2DOpenGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\Graphics2DOpenGL.cs,Render,The method has 6 parameters. Parameters: imageSource' x' y' angleDegrees' scaleX' ScaleY
Long Parameter List,MatterHackers.RenderOpenGl,Graphics2DOpenGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\Graphics2DOpenGL.cs,Rectangle,The method has 6 parameters. Parameters: left' bottom' right' top' color' strokeWidth
Long Parameter List,MatterHackers.RenderOpenGl,Graphics2DOpenGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\Graphics2DOpenGL.cs,FillRectangle,The method has 5 parameters. Parameters: left' bottom' right' top' fillColor
Long Parameter List,MatterHackers.RenderOpenGl,Graphics2DOpenGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\Graphics2DOpenGL.cs,Line,The method has 6 parameters. Parameters: x1' y1' x2' y2' color' strokeWidth
Long Parameter List,MatterHackers.RenderOpenGl,GLHelper,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderMeshToGl.cs,Render,The method has 7 parameters. Parameters: meshToRender' partColor' renderType' meshToViewTransform' wireFrameColor' meshChanged' blendTexture
Long Parameter List,MatterHackers.RenderOpenGl,GLHelper,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderMeshToGl.cs,Render,The method has 9 parameters. Parameters: meshToRender' color' transform' renderType' meshToViewTransform' wireFrameColor' meshChanged' blendTexture' allowBspRendering
Long Parameter List,MatterHackers.RenderOpenGl,GLHelper,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderMeshToGl.cs,DrawToGL,The method has 5 parameters. Parameters: meshToRender' isTransparent' meshToViewTransform' blendTexture' allowBspRendering
Long Parameter List,MatterHackers.RenderOpenGl,WorldViewExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\WorldViewExtensions.cs,Render3DLine,The method has 6 parameters. Parameters: world' start' end' color' doDepthTest' width
Long Parameter List,MatterHackers.RenderOpenGl,WorldViewExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\WorldViewExtensions.cs,Render3DLine,The method has 7 parameters. Parameters: world' clippingFrustum' start' end' color' doDepthTest' width
Long Parameter List,MatterHackers.RenderOpenGl,WorldViewExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\WorldViewExtensions.cs,Render3DLineNoPrep,The method has 6 parameters. Parameters: world' clippingFrustum' start' end' color' width
Long Parameter List,MatterHackers.RenderOpenGl,WorldViewExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\WorldViewExtensions.cs,Render3DLineNoPrep,The method has 6 parameters. Parameters: world' clippingFrustum' start' end' color' width
Long Parameter List,MatterHackers.RenderOpenGl,WorldViewExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\WorldViewExtensions.cs,RenderCylinderOutline,The method has 9 parameters. Parameters: world' worldMatrix' center' diameter' height' sides' color' lineWidth' extendLineLength
Long Parameter List,MatterHackers.RenderOpenGl,WorldViewExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\WorldViewExtensions.cs,RenderCylinderOutline,The method has 11 parameters. Parameters: world' worldMatrix' center' diameter' height' sides' topBottomRingColor' sideLinesColor' lineWidth' extendLineLength' phase
Long Parameter List,MatterHackers.RenderOpenGl,WorldViewExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\WorldViewExtensions.cs,RenderAabb,The method has 6 parameters. Parameters: world' bounds' matrix' color' width' extendLineLength
Long Parameter List,MatterHackers.RenderOpenGl,WorldViewExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\WorldViewExtensions.cs,RenderAxis,The method has 5 parameters. Parameters: world' position' matrix' size' lineWidth
Long Parameter List,MatterHackers.RenderOpenGl.OpenGl,GL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\GL\GL.cs,DrawRangeElements,The method has 6 parameters. Parameters: mode' start' end' count' type' indices
Long Parameter List,MatterHackers.RenderOpenGl.OpenGl,GL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\GL\GL.cs,Ortho,The method has 6 parameters. Parameters: left' right' bottom' top' zNear' zFar
Long Parameter List,MatterHackers.RenderOpenGl.OpenGl,GL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\GL\GL.cs,TexImage2D,The method has 9 parameters. Parameters: target' level' internalFormat' width' height' border' format' type' pixels
Long Parameter List,MatterHackers.RenderOpenGl.OpenGl,IOpenGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\IOpenGL.cs,DrawRangeElements,The method has 6 parameters. Parameters: mode' start' end' count' type' indices
Long Parameter List,MatterHackers.RenderOpenGl.OpenGl,IOpenGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\IOpenGL.cs,Ortho,The method has 6 parameters. Parameters: left' right' bottom' top' zNear' zFar
Long Parameter List,MatterHackers.RenderOpenGl.OpenGl,IOpenGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\IOpenGL.cs,TexImage2D,The method has 9 parameters. Parameters: target' level' internalFormat' width' height' border' format' type' pixels
Long Identifier,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,,The length of the parameter hwSupportsOnlyPowerOfTwoTextures is 32.
Long Identifier,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,,The length of the parameter checkedForHwSupportsOnlyPowerOfTwoTextures is 42.
Long Statement,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,GetImageGlPlugin,The length of the statement  "						&& glDataNeedingToBeDeleted[i].refreshCountCreatedOn == currentGlobalRefreshCount) // this is to leak on purpose on android for some gl that kills textures " is 155.
Long Statement,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The length of the statement  "				GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMinFilter' (int)TextureMinFilter.LinearMipmapLinear); " is 122.
Long Statement,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The length of the statement  "			glData.textureUVs[0] = 0; glData.textureUVs[1] = 0; glData.positions[0] = 0 - offsetX; glData.positions[1] = 0 - offsetY; " is 121.
Long Statement,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The length of the statement  "			glData.textureUVs[2] = 0; glData.textureUVs[3] = texCoordY; glData.positions[2] = 0 - offsetX; glData.positions[3] = imageHeight - offsetY; " is 139.
Long Statement,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The length of the statement  "			glData.textureUVs[4] = texCoordX; glData.textureUVs[5] = texCoordY; glData.positions[4] = imageWidth - offsetX; glData.positions[5] = imageHeight - offsetY; " is 156.
Long Statement,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The length of the statement  "			glData.textureUVs[6] = texCoordX; glData.textureUVs[7] = 0; glData.positions[6] = imageWidth - offsetX; glData.positions[7] = 0 - offsetY; " is 138.
Long Statement,MatterHackers.RenderOpenGl,Graphics2DOpenGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\Graphics2DOpenGL.cs,PreRender,The length of the statement  "			GL.BindTexture(TextureTarget.Texture2D' RenderOpenGl.ImageGlPlugin.GetImageGlPlugin(AATextureImages[colorIn.Alpha0To255]' false).GLTextureHandle); " is 146.
Long Statement,MatterHackers.RenderOpenGl,Graphics2DOpenGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\Graphics2DOpenGL.cs,Render,The length of the statement  "			RectangleInt destBounds = new RectangleInt((int)cachedClipRect.Left' (int)cachedClipRect.Bottom' (int)cachedClipRect.Right' (int)cachedClipRect.Top); " is 149.
Long Statement,MatterHackers.RenderOpenGl,Graphics2DOpenGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\Graphics2DOpenGL.cs,RenderTransformedPath,The length of the statement  "			GL.BindTexture(TextureTarget.Texture2D' RenderOpenGl.ImageGlPlugin.GetImageGlPlugin(AATextureImages[color.Alpha0To255]' false).GLTextureHandle); " is 144.
Long Statement,MatterHackers.RenderOpenGl,GLHelper,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderMeshToGl.cs,Render,The length of the statement  "			Render(meshToRender' partColor' Matrix4X4.Identity' renderType' meshToViewTransform' wireFrameColor' meshChanged' blendTexture); " is 128.
Long Statement,MatterHackers.RenderOpenGl,GLHelper,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderMeshToGl.cs,DrawToGLUsingBsp,The length of the statement  "			var bspFaceList = FaceBspTree.GetFacesInVisibiltyOrder(mesh' mesh.FaceBspTree' meshToViewTransform' invMeshToViewTransform); " is 124.
Long Statement,MatterHackers.RenderOpenGl,GLHelper,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderMeshToGl.cs,SetGlContext,The length of the statement  "			var lightDirectionVector = new Vector3(lighting.LightDirection0[0]' lighting.LightDirection0[1]' lighting.LightDirection0[2]); " is 126.
Long Statement,MatterHackers.RenderOpenGl,WorldViewExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\WorldViewExtensions.cs,Render3DLineNoPrep,The length of the statement  "				var rotateTransform = Matrix4X4.CreateRotation(new Quaternion(Vector3.UnitX + new Vector3(.0001' -.00001' .00002)' -delta / deltaLength)); " is 138.
Long Statement,MatterHackers.RenderOpenGl,WorldViewExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\WorldViewExtensions.cs,Render3DLineNoPrep,The length of the statement  "						scaledLineMesh.Vertices[i] = new Vector3Float(vertexPosition.X' vertexPosition.Y * startScale' vertexPosition.Z * startScale); " is 126.
Long Statement,MatterHackers.RenderOpenGl,WorldViewExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\WorldViewExtensions.cs,Render3DLineNoPrep,The length of the statement  "						scaledLineMesh.Vertices[i] = new Vector3Float(vertexPosition.X' vertexPosition.Y * endScale' vertexPosition.Z * endScale); " is 122.
Long Statement,MatterHackers.RenderOpenGl,WorldViewExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\WorldViewExtensions.cs,RenderPath,The length of the statement  "			// GL.BindTexture(TextureTarget.Texture2D' RenderOpenGl.ImageGlPlugin.GetImageGlPlugin(AATextureImages[color.Alpha0To255]' false).GLTextureHandle); " is 147.
Complex Conditional,MatterHackers.RenderOpenGl,GLMeshTrianglePlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\GLMeshTrianglePlugin.cs,CreateRenderData,The conditional expression  "subMeshs.Count == 0   					|| (faceTexture != null   						&& (object)subMeshs[subMeshs.Count - 1].texture != (object)faceTexture.image)  					|| (faceTexture == null   						&& subMeshs[subMeshs.Count - 1].texture != null)"  is complex.
Complex Conditional,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,GetImageGlPlugin,The conditional expression  "plugin != null  				&& (imageToGetDisplayListFor.ChangedCount != plugin.imageUpdateCount  				|| plugin.glData.refreshCountCreatedOn != currentGlobalRefreshCount  				|| plugin.glData.glTextureHandle == -1)"  is complex.
Complex Conditional,MatterHackers.RenderOpenGl,Graphics2DOpenGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\Graphics2DOpenGL.cs,Rectangle,The conditional expression  "fastLeft == (int)fastLeft  				&& fastBottom == (int)fastBottom  				&& fastRight == (int)fastRight  				&& fastTop == (int)fastTop  				&& strokeWidth == 1"  is complex.
Complex Conditional,MatterHackers.RenderOpenGl,Graphics2DOpenGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\Graphics2DOpenGL.cs,FillRectangle,The conditional expression  "Math.Abs(fastLeft - (int)fastLeft) < .01  				&& Math.Abs(fastBottom - (int)fastBottom) < .01  				&& Math.Abs(fastRight - (int)fastRight) < .01  				&& Math.Abs(fastTop - (int)fastTop) < .01"  is complex.
Complex Conditional,MatterHackers.RenderOpenGl,GLHelper,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderMeshToGl.cs,DrawToGL,The conditional expression  "meshToViewTransform != null  				&& isTransparent  				&& meshToRender.FaceBspTree != null  				&& meshToRender.Faces.Count > 0  				&& allowBspRendering"  is complex.
Magic Number,MatterHackers.RenderOpenGl,GLMeshNonManifoldPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\GLMeshNonManifoldPlugin.cs,CreateRenderData,The following statement contains a magic number: Task.Run(() =>  			{  				var meshEdgeList = mesh.NewMeshEdges();    				var filteredEdgeLines = new VectorPOD<WireVertexData>();    				foreach (var meshEdge in meshEdgeList)  				{  					if (meshEdge.Faces.Count() != 2)  					{  						AddVertex(filteredEdgeLines'  							mesh.Vertices[meshEdge.Vertex0Index]'  							mesh.Vertices[meshEdge.Vertex1Index]);  					}  				}    				this.EdgeLines = filteredEdgeLines;  				meshChanged?.Invoke();  			});
Magic Number,MatterHackers.RenderOpenGl,GLMeshWirePlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\GLMeshWirePlugin.cs,CreateRenderData,The following statement contains a magic number: Task.Run(() =>  				{  					var meshEdgeList = mesh.NewMeshEdges();    					var filteredEdgeLines = new VectorPOD<WireVertexData>();    					foreach (var meshEdge in meshEdgeList)  					{  						if (meshEdge.Faces.Count() == 2)  						{  							var faceNormal0 = mesh.Faces[meshEdge.Faces[0]].normal;  							var faceNormal1 = mesh.Faces[meshEdge.Faces[1]].normal;  							double angle = faceNormal0.CalculateAngle(faceNormal1);  							if (angle > nonPlanarAngleRequired)  							{  								AddVertex(filteredEdgeLines'  									mesh.Vertices[meshEdge.Vertex0Index]'  									mesh.Vertices[meshEdge.Vertex1Index]);  							}  						}  					}    					this.EdgeLines = filteredEdgeLines;  					meshChanged?.Invoke();  				});
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: switch (bufferedImage.BitDepth)  			{  				case 32:  					GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Rgba' hardwareWidth' hardwareHeight'  						0' PixelFormat.Rgba' PixelType.UnsignedByte' bufferedImage.GetBuffer());  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: switch (bufferedImage.BitDepth)  				{  					case 32:  						{  							var sourceImage = new ImageBuffer(bufferedImage);  							var tempImage = new ImageBuffer(sourceImage.Width / 2' sourceImage.Height / 2);  							tempImage.NewGraphics2D().Render(sourceImage' 0' 0' 0' .5' .5);    							int mipLevel = 1;  							while (sourceImage.Width > 1 || sourceImage.Height > 1)  							{  								GL.TexImage2D(TextureTarget.Texture2D' mipLevel++' PixelInternalFormat.Rgba' tempImage.Width' tempImage.Height'  									0' PixelFormat.Rgba' PixelType.UnsignedByte' tempImage.GetBuffer());    								sourceImage = new ImageBuffer(tempImage);  								tempImage = new ImageBuffer(Math.Max(1' sourceImage.Width / 2)' Math.Max(1' sourceImage.Height / 2));  								tempImage.NewGraphics2D().Render(sourceImage' 0' 0'  									0'  									(double)tempImage.Width / (double)sourceImage.Width'  									(double)tempImage.Height / (double)sourceImage.Height);  							}  						}    						break;    					default:  						throw new NotImplementedException();  				}
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: switch (bufferedImage.BitDepth)  				{  					case 32:  						{  							var sourceImage = new ImageBuffer(bufferedImage);  							var tempImage = new ImageBuffer(sourceImage.Width / 2' sourceImage.Height / 2);  							tempImage.NewGraphics2D().Render(sourceImage' 0' 0' 0' .5' .5);    							int mipLevel = 1;  							while (sourceImage.Width > 1 || sourceImage.Height > 1)  							{  								GL.TexImage2D(TextureTarget.Texture2D' mipLevel++' PixelInternalFormat.Rgba' tempImage.Width' tempImage.Height'  									0' PixelFormat.Rgba' PixelType.UnsignedByte' tempImage.GetBuffer());    								sourceImage = new ImageBuffer(tempImage);  								tempImage = new ImageBuffer(Math.Max(1' sourceImage.Width / 2)' Math.Max(1' sourceImage.Height / 2));  								tempImage.NewGraphics2D().Render(sourceImage' 0' 0'  									0'  									(double)tempImage.Width / (double)sourceImage.Width'  									(double)tempImage.Height / (double)sourceImage.Height);  							}  						}    						break;    					default:  						throw new NotImplementedException();  				}
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: switch (bufferedImage.BitDepth)  				{  					case 32:  						{  							var sourceImage = new ImageBuffer(bufferedImage);  							var tempImage = new ImageBuffer(sourceImage.Width / 2' sourceImage.Height / 2);  							tempImage.NewGraphics2D().Render(sourceImage' 0' 0' 0' .5' .5);    							int mipLevel = 1;  							while (sourceImage.Width > 1 || sourceImage.Height > 1)  							{  								GL.TexImage2D(TextureTarget.Texture2D' mipLevel++' PixelInternalFormat.Rgba' tempImage.Width' tempImage.Height'  									0' PixelFormat.Rgba' PixelType.UnsignedByte' tempImage.GetBuffer());    								sourceImage = new ImageBuffer(tempImage);  								tempImage = new ImageBuffer(Math.Max(1' sourceImage.Width / 2)' Math.Max(1' sourceImage.Height / 2));  								tempImage.NewGraphics2D().Render(sourceImage' 0' 0'  									0'  									(double)tempImage.Width / (double)sourceImage.Width'  									(double)tempImage.Height / (double)sourceImage.Height);  							}  						}    						break;    					default:  						throw new NotImplementedException();  				}
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: switch (bufferedImage.BitDepth)  				{  					case 32:  						{  							var sourceImage = new ImageBuffer(bufferedImage);  							var tempImage = new ImageBuffer(sourceImage.Width / 2' sourceImage.Height / 2);  							tempImage.NewGraphics2D().Render(sourceImage' 0' 0' 0' .5' .5);    							int mipLevel = 1;  							while (sourceImage.Width > 1 || sourceImage.Height > 1)  							{  								GL.TexImage2D(TextureTarget.Texture2D' mipLevel++' PixelInternalFormat.Rgba' tempImage.Width' tempImage.Height'  									0' PixelFormat.Rgba' PixelType.UnsignedByte' tempImage.GetBuffer());    								sourceImage = new ImageBuffer(tempImage);  								tempImage = new ImageBuffer(Math.Max(1' sourceImage.Width / 2)' Math.Max(1' sourceImage.Height / 2));  								tempImage.NewGraphics2D().Render(sourceImage' 0' 0'  									0'  									(double)tempImage.Width / (double)sourceImage.Width'  									(double)tempImage.Height / (double)sourceImage.Height);  							}  						}    						break;    					default:  						throw new NotImplementedException();  				}
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: switch (bufferedImage.BitDepth)  				{  					case 32:  						{  							var sourceImage = new ImageBuffer(bufferedImage);  							var tempImage = new ImageBuffer(sourceImage.Width / 2' sourceImage.Height / 2);  							tempImage.NewGraphics2D().Render(sourceImage' 0' 0' 0' .5' .5);    							int mipLevel = 1;  							while (sourceImage.Width > 1 || sourceImage.Height > 1)  							{  								GL.TexImage2D(TextureTarget.Texture2D' mipLevel++' PixelInternalFormat.Rgba' tempImage.Width' tempImage.Height'  									0' PixelFormat.Rgba' PixelType.UnsignedByte' tempImage.GetBuffer());    								sourceImage = new ImageBuffer(tempImage);  								tempImage = new ImageBuffer(Math.Max(1' sourceImage.Width / 2)' Math.Max(1' sourceImage.Height / 2));  								tempImage.NewGraphics2D().Render(sourceImage' 0' 0'  									0'  									(double)tempImage.Width / (double)sourceImage.Width'  									(double)tempImage.Height / (double)sourceImage.Height);  							}  						}    						break;    					default:  						throw new NotImplementedException();  				}
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: switch (bufferedImage.BitDepth)  				{  					case 32:  						{  							var sourceImage = new ImageBuffer(bufferedImage);  							var tempImage = new ImageBuffer(sourceImage.Width / 2' sourceImage.Height / 2);  							tempImage.NewGraphics2D().Render(sourceImage' 0' 0' 0' .5' .5);    							int mipLevel = 1;  							while (sourceImage.Width > 1 || sourceImage.Height > 1)  							{  								GL.TexImage2D(TextureTarget.Texture2D' mipLevel++' PixelInternalFormat.Rgba' tempImage.Width' tempImage.Height'  									0' PixelFormat.Rgba' PixelType.UnsignedByte' tempImage.GetBuffer());    								sourceImage = new ImageBuffer(tempImage);  								tempImage = new ImageBuffer(Math.Max(1' sourceImage.Width / 2)' Math.Max(1' sourceImage.Height / 2));  								tempImage.NewGraphics2D().Render(sourceImage' 0' 0'  									0'  									(double)tempImage.Width / (double)sourceImage.Width'  									(double)tempImage.Height / (double)sourceImage.Height);  							}  						}    						break;    					default:  						throw new NotImplementedException();  				}
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: switch (bufferedImage.BitDepth)  				{  					case 32:  						{  							var sourceImage = new ImageBuffer(bufferedImage);  							var tempImage = new ImageBuffer(sourceImage.Width / 2' sourceImage.Height / 2);  							tempImage.NewGraphics2D().Render(sourceImage' 0' 0' 0' .5' .5);    							int mipLevel = 1;  							while (sourceImage.Width > 1 || sourceImage.Height > 1)  							{  								GL.TexImage2D(TextureTarget.Texture2D' mipLevel++' PixelInternalFormat.Rgba' tempImage.Width' tempImage.Height'  									0' PixelFormat.Rgba' PixelType.UnsignedByte' tempImage.GetBuffer());    								sourceImage = new ImageBuffer(tempImage);  								tempImage = new ImageBuffer(Math.Max(1' sourceImage.Width / 2)' Math.Max(1' sourceImage.Height / 2));  								tempImage.NewGraphics2D().Render(sourceImage' 0' 0'  									0'  									(double)tempImage.Width / (double)sourceImage.Width'  									(double)tempImage.Height / (double)sourceImage.Height);  							}  						}    						break;    					default:  						throw new NotImplementedException();  				}
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: glData.textureUVs = new float[8];
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: glData.positions = new float[8];
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: glData.textureUVs[2] = 0;
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: glData.textureUVs[3] = texCoordY;
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: glData.positions[2] = 0 - offsetX;
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: glData.positions[3] = imageHeight - offsetY;
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: glData.textureUVs[4] = texCoordX;
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: glData.textureUVs[5] = texCoordY;
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: glData.positions[4] = imageWidth - offsetX;
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: glData.positions[5] = imageHeight - offsetY;
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: glData.textureUVs[6] = texCoordX;
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: glData.textureUVs[7] = 0;
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: glData.positions[6] = imageWidth - offsetX;
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: glData.positions[7] = 0 - offsetY;
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,FixImageColors,The following statement contains a magic number: switch (bufferedImage.BitDepth)  			{  				case 32:  					for (int y = 0; y < imageHeight; y++)  					{  						for (int x = 0; x < imageWidth; x++)  						{  							int pixelIndex = 4 * (x + y * imageWidth);    							byte r = imageBuffer[pixelIndex + 2];  							byte g = imageBuffer[pixelIndex + 1];  							byte b = imageBuffer[pixelIndex + 0];  							byte a = imageBuffer[pixelIndex + 3];    							imageBuffer[pixelIndex + 0] = r;  							imageBuffer[pixelIndex + 1] = g;  							imageBuffer[pixelIndex + 2] = b;  							imageBuffer[pixelIndex + 3] = a;  						}  					}    					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,FixImageColors,The following statement contains a magic number: switch (bufferedImage.BitDepth)  			{  				case 32:  					for (int y = 0; y < imageHeight; y++)  					{  						for (int x = 0; x < imageWidth; x++)  						{  							int pixelIndex = 4 * (x + y * imageWidth);    							byte r = imageBuffer[pixelIndex + 2];  							byte g = imageBuffer[pixelIndex + 1];  							byte b = imageBuffer[pixelIndex + 0];  							byte a = imageBuffer[pixelIndex + 3];    							imageBuffer[pixelIndex + 0] = r;  							imageBuffer[pixelIndex + 1] = g;  							imageBuffer[pixelIndex + 2] = b;  							imageBuffer[pixelIndex + 3] = a;  						}  					}    					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,FixImageColors,The following statement contains a magic number: switch (bufferedImage.BitDepth)  			{  				case 32:  					for (int y = 0; y < imageHeight; y++)  					{  						for (int x = 0; x < imageWidth; x++)  						{  							int pixelIndex = 4 * (x + y * imageWidth);    							byte r = imageBuffer[pixelIndex + 2];  							byte g = imageBuffer[pixelIndex + 1];  							byte b = imageBuffer[pixelIndex + 0];  							byte a = imageBuffer[pixelIndex + 3];    							imageBuffer[pixelIndex + 0] = r;  							imageBuffer[pixelIndex + 1] = g;  							imageBuffer[pixelIndex + 2] = b;  							imageBuffer[pixelIndex + 3] = a;  						}  					}    					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,FixImageColors,The following statement contains a magic number: switch (bufferedImage.BitDepth)  			{  				case 32:  					for (int y = 0; y < imageHeight; y++)  					{  						for (int x = 0; x < imageWidth; x++)  						{  							int pixelIndex = 4 * (x + y * imageWidth);    							byte r = imageBuffer[pixelIndex + 2];  							byte g = imageBuffer[pixelIndex + 1];  							byte b = imageBuffer[pixelIndex + 0];  							byte a = imageBuffer[pixelIndex + 3];    							imageBuffer[pixelIndex + 0] = r;  							imageBuffer[pixelIndex + 1] = g;  							imageBuffer[pixelIndex + 2] = b;  							imageBuffer[pixelIndex + 3] = a;  						}  					}    					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,FixImageColors,The following statement contains a magic number: switch (bufferedImage.BitDepth)  			{  				case 32:  					for (int y = 0; y < imageHeight; y++)  					{  						for (int x = 0; x < imageWidth; x++)  						{  							int pixelIndex = 4 * (x + y * imageWidth);    							byte r = imageBuffer[pixelIndex + 2];  							byte g = imageBuffer[pixelIndex + 1];  							byte b = imageBuffer[pixelIndex + 0];  							byte a = imageBuffer[pixelIndex + 3];    							imageBuffer[pixelIndex + 0] = r;  							imageBuffer[pixelIndex + 1] = g;  							imageBuffer[pixelIndex + 2] = b;  							imageBuffer[pixelIndex + 3] = a;  						}  					}    					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,FixImageColors,The following statement contains a magic number: switch (bufferedImage.BitDepth)  			{  				case 32:  					for (int y = 0; y < imageHeight; y++)  					{  						for (int x = 0; x < imageWidth; x++)  						{  							int pixelIndex = 4 * (x + y * imageWidth);    							byte r = imageBuffer[pixelIndex + 2];  							byte g = imageBuffer[pixelIndex + 1];  							byte b = imageBuffer[pixelIndex + 0];  							byte a = imageBuffer[pixelIndex + 3];    							imageBuffer[pixelIndex + 0] = r;  							imageBuffer[pixelIndex + 1] = g;  							imageBuffer[pixelIndex + 2] = b;  							imageBuffer[pixelIndex + 3] = a;  						}  					}    					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,FixImageSizePower2IfRequired,The following statement contains a magic number: var pow2BufferedImage = new ImageBuffer(hardwareWidth' hardwareHeight' 32' bufferedImage.GetRecieveBlender());
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,DrawToGL,The following statement contains a magic number: GL.TexCoord2(glData.textureUVs[2]' glData.textureUVs[3]);
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,DrawToGL,The following statement contains a magic number: GL.TexCoord2(glData.textureUVs[2]' glData.textureUVs[3]);
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,DrawToGL,The following statement contains a magic number: GL.Vertex2(glData.positions[2]' glData.positions[3]);
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,DrawToGL,The following statement contains a magic number: GL.Vertex2(glData.positions[2]' glData.positions[3]);
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,DrawToGL,The following statement contains a magic number: GL.TexCoord2(glData.textureUVs[4]' glData.textureUVs[5]);
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,DrawToGL,The following statement contains a magic number: GL.TexCoord2(glData.textureUVs[4]' glData.textureUVs[5]);
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,DrawToGL,The following statement contains a magic number: GL.Vertex2(glData.positions[4]' glData.positions[5]);
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,DrawToGL,The following statement contains a magic number: GL.Vertex2(glData.positions[4]' glData.positions[5]);
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,DrawToGL,The following statement contains a magic number: GL.TexCoord2(glData.textureUVs[6]' glData.textureUVs[7]);
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,DrawToGL,The following statement contains a magic number: GL.TexCoord2(glData.textureUVs[6]' glData.textureUVs[7]);
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,DrawToGL,The following statement contains a magic number: GL.Vertex2(glData.positions[6]' glData.positions[7]);
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,DrawToGL,The following statement contains a magic number: GL.Vertex2(glData.positions[6]' glData.positions[7]);
Magic Number,MatterHackers.RenderOpenGl,OverhangRender,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\OverhangRender.cs,EnsureUpdated,The following statement contains a magic number: var error = .0001;
Magic Number,MatterHackers.RenderOpenGl,OverhangRender,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\OverhangRender.cs,EnsureUpdated,The following statement contains a magic number: GLMeshTrianglePlugin.Get(  				meshToRender'  				(normal) =>  				{  					normal = normal.TransformNormal(transform).GetNormal();    					double startColor = 223.0 / 360.0;  					double endColor = 5.0 / 360.0;  					double delta = endColor - startColor;    					var polyColor = ColorF.FromHSL(startColor' .99' .49).ToColor();  					if (normal.Z < 0)  					{  						polyColor = ColorF.FromHSL(startColor - delta * normal.Z' .99' .49).ToColor();  					}    					return polyColor;  				});
Magic Number,MatterHackers.RenderOpenGl,OverhangRender,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\OverhangRender.cs,EnsureUpdated,The following statement contains a magic number: GLMeshTrianglePlugin.Get(  				meshToRender'  				(normal) =>  				{  					normal = normal.TransformNormal(transform).GetNormal();    					double startColor = 223.0 / 360.0;  					double endColor = 5.0 / 360.0;  					double delta = endColor - startColor;    					var polyColor = ColorF.FromHSL(startColor' .99' .49).ToColor();  					if (normal.Z < 0)  					{  						polyColor = ColorF.FromHSL(startColor - delta * normal.Z' .99' .49).ToColor();  					}    					return polyColor;  				});
Magic Number,MatterHackers.RenderOpenGl,OverhangRender,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\OverhangRender.cs,EnsureUpdated,The following statement contains a magic number: GLMeshTrianglePlugin.Get(  				meshToRender'  				(normal) =>  				{  					normal = normal.TransformNormal(transform).GetNormal();    					double startColor = 223.0 / 360.0;  					double endColor = 5.0 / 360.0;  					double delta = endColor - startColor;    					var polyColor = ColorF.FromHSL(startColor' .99' .49).ToColor();  					if (normal.Z < 0)  					{  						polyColor = ColorF.FromHSL(startColor - delta * normal.Z' .99' .49).ToColor();  					}    					return polyColor;  				});
Magic Number,MatterHackers.RenderOpenGl,OverhangRender,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\OverhangRender.cs,EnsureUpdated,The following statement contains a magic number: GLMeshTrianglePlugin.Get(  				meshToRender'  				(normal) =>  				{  					normal = normal.TransformNormal(transform).GetNormal();    					double startColor = 223.0 / 360.0;  					double endColor = 5.0 / 360.0;  					double delta = endColor - startColor;    					var polyColor = ColorF.FromHSL(startColor' .99' .49).ToColor();  					if (normal.Z < 0)  					{  						polyColor = ColorF.FromHSL(startColor - delta * normal.Z' .99' .49).ToColor();  					}    					return polyColor;  				});
Magic Number,MatterHackers.RenderOpenGl,OverhangRender,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\OverhangRender.cs,EnsureUpdated,The following statement contains a magic number: GLMeshTrianglePlugin.Get(  				meshToRender'  				(normal) =>  				{  					normal = normal.TransformNormal(transform).GetNormal();    					double startColor = 223.0 / 360.0;  					double endColor = 5.0 / 360.0;  					double delta = endColor - startColor;    					var polyColor = ColorF.FromHSL(startColor' .99' .49).ToColor();  					if (normal.Z < 0)  					{  						polyColor = ColorF.FromHSL(startColor - delta * normal.Z' .99' .49).ToColor();  					}    					return polyColor;  				});
Magic Number,MatterHackers.RenderOpenGl,OverhangRender,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\OverhangRender.cs,EnsureUpdated,The following statement contains a magic number: GLMeshTrianglePlugin.Get(  				meshToRender'  				(normal) =>  				{  					normal = normal.TransformNormal(transform).GetNormal();    					double startColor = 223.0 / 360.0;  					double endColor = 5.0 / 360.0;  					double delta = endColor - startColor;    					var polyColor = ColorF.FromHSL(startColor' .99' .49).ToColor();  					if (normal.Z < 0)  					{  						polyColor = ColorF.FromHSL(startColor - delta * normal.Z' .99' .49).ToColor();  					}    					return polyColor;  				});
Magic Number,MatterHackers.RenderOpenGl,OverhangRender,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\OverhangRender.cs,EnsureUpdated,The following statement contains a magic number: GLMeshTrianglePlugin.Get(  				meshToRender'  				(normal) =>  				{  					normal = normal.TransformNormal(transform).GetNormal();    					double startColor = 223.0 / 360.0;  					double endColor = 5.0 / 360.0;  					double delta = endColor - startColor;    					var polyColor = ColorF.FromHSL(startColor' .99' .49).ToColor();  					if (normal.Z < 0)  					{  						polyColor = ColorF.FromHSL(startColor - delta * normal.Z' .99' .49).ToColor();  					}    					return polyColor;  				});
Magic Number,MatterHackers.RenderOpenGl,OverhangRender,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\OverhangRender.cs,EnsureUpdated,The following statement contains a magic number: GLMeshTrianglePlugin.Get(  				meshToRender'  				(normal) =>  				{  					normal = normal.TransformNormal(transform).GetNormal();    					double startColor = 223.0 / 360.0;  					double endColor = 5.0 / 360.0;  					double delta = endColor - startColor;    					var polyColor = ColorF.FromHSL(startColor' .99' .49).ToColor();  					if (normal.Z < 0)  					{  						polyColor = ColorF.FromHSL(startColor - delta * normal.Z' .99' .49).ToColor();  					}    					return polyColor;  				});
Magic Number,MatterHackers.RenderOpenGl,AAGLTesselator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\AAGLTesselator.cs,DrawNonAATriangle,The following statement contains a magic number: GL.TexCoord2(.2' .25);
Magic Number,MatterHackers.RenderOpenGl,AAGLTesselator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\AAGLTesselator.cs,DrawNonAATriangle,The following statement contains a magic number: GL.TexCoord2(.2' .25);
Magic Number,MatterHackers.RenderOpenGl,AAGLTesselator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\AAGLTesselator.cs,DrawNonAATriangle,The following statement contains a magic number: GL.TexCoord2(.2' .75);
Magic Number,MatterHackers.RenderOpenGl,AAGLTesselator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\AAGLTesselator.cs,DrawNonAATriangle,The following statement contains a magic number: GL.TexCoord2(.2' .75);
Magic Number,MatterHackers.RenderOpenGl,AAGLTesselator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\AAGLTesselator.cs,DrawNonAATriangle,The following statement contains a magic number: GL.TexCoord2(.9' .5);
Magic Number,MatterHackers.RenderOpenGl,AAGLTesselator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\AAGLTesselator.cs,DrawNonAATriangle,The following statement contains a magic number: GL.TexCoord2(.9' .5);
Magic Number,MatterHackers.RenderOpenGl,AAGLTesselator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\AAGLTesselator.cs,Draw1EdgeTriangle,The following statement contains a magic number: Vector2 texP0 = new Vector2(1 / 1023.0' .25);
Magic Number,MatterHackers.RenderOpenGl,AAGLTesselator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\AAGLTesselator.cs,Draw1EdgeTriangle,The following statement contains a magic number: Vector2 texP0 = new Vector2(1 / 1023.0' .25);
Magic Number,MatterHackers.RenderOpenGl,AAGLTesselator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\AAGLTesselator.cs,Draw1EdgeTriangle,The following statement contains a magic number: Vector2 texP1 = new Vector2(1 / 1023.0' .75);
Magic Number,MatterHackers.RenderOpenGl,AAGLTesselator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\AAGLTesselator.cs,Draw1EdgeTriangle,The following statement contains a magic number: Vector2 texP1 = new Vector2(1 / 1023.0' .75);
Magic Number,MatterHackers.RenderOpenGl,AAGLTesselator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\AAGLTesselator.cs,Draw1EdgeTriangle,The following statement contains a magic number: Vector2 texP2 = new Vector2((1 + edgeDotP3) / 1023.0' .25);
Magic Number,MatterHackers.RenderOpenGl,AAGLTesselator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\AAGLTesselator.cs,Draw1EdgeTriangle,The following statement contains a magic number: Vector2 texP2 = new Vector2((1 + edgeDotP3) / 1023.0' .25);
Magic Number,MatterHackers.RenderOpenGl,AAGLTesselator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\AAGLTesselator.cs,Draw1EdgeTriangle,The following statement contains a magic number: Vector2 texEdgeP0Offset = new Vector2(0' .25);
Magic Number,MatterHackers.RenderOpenGl,AAGLTesselator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\AAGLTesselator.cs,Draw1EdgeTriangle,The following statement contains a magic number: Vector2 texEdgeP1Offset = new Vector2(0' .75);
Magic Number,MatterHackers.RenderOpenGl,AAGLTesselator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\AAGLTesselator.cs,Draw2EdgeTriangle,The following statement contains a magic number: centerPoint /= 3;
Magic Number,MatterHackers.RenderOpenGl,AAGLTesselator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\AAGLTesselator.cs,Draw2EdgeTriangle,The following statement contains a magic number: Draw1EdgeTriangle(p0' p1' (p0 + p1) / 2 + (centerPoint - (p0 + p1) / 2) * .001);
Magic Number,MatterHackers.RenderOpenGl,AAGLTesselator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\AAGLTesselator.cs,Draw2EdgeTriangle,The following statement contains a magic number: Draw1EdgeTriangle(p0' p1' (p0 + p1) / 2 + (centerPoint - (p0 + p1) / 2) * .001);
Magic Number,MatterHackers.RenderOpenGl,AAGLTesselator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\AAGLTesselator.cs,Draw2EdgeTriangle,The following statement contains a magic number: Draw1EdgeTriangle(p0' p1' (p0 + p1) / 2 + (centerPoint - (p0 + p1) / 2) * .001);
Magic Number,MatterHackers.RenderOpenGl,AAGLTesselator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\AAGLTesselator.cs,Draw2EdgeTriangle,The following statement contains a magic number: Draw1EdgeTriangle(p1' p2' (p1 + p2) / 2 + (centerPoint - (p1 + p2) / 2) * .001);
Magic Number,MatterHackers.RenderOpenGl,AAGLTesselator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\AAGLTesselator.cs,Draw2EdgeTriangle,The following statement contains a magic number: Draw1EdgeTriangle(p1' p2' (p1 + p2) / 2 + (centerPoint - (p1 + p2) / 2) * .001);
Magic Number,MatterHackers.RenderOpenGl,AAGLTesselator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\AAGLTesselator.cs,Draw2EdgeTriangle,The following statement contains a magic number: Draw1EdgeTriangle(p1' p2' (p1 + p2) / 2 + (centerPoint - (p1 + p2) / 2) * .001);
Magic Number,MatterHackers.RenderOpenGl,AAGLTesselator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\AAGLTesselator.cs,Draw3EdgeTriangle,The following statement contains a magic number: centerPoint /= 3;
Magic Number,MatterHackers.RenderOpenGl,AAGLTesselator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\AAGLTesselator.cs,RenderLastToGL,The following statement contains a magic number: Vector2 v2 = VerticesCache[IndicesCache[i + 2].Index].Position;
Magic Number,MatterHackers.RenderOpenGl,AAGLTesselator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\AAGLTesselator.cs,RenderLastToGL,The following statement contains a magic number: int e2 = IndicesCache[i + 2].IsEdge ? 1 : 0;
Magic Number,MatterHackers.RenderOpenGl,AAGLTesselator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\AAGLTesselator.cs,RenderLastToGL,The following statement contains a magic number: switch (e0 + e1 + e2)  				{  					case 0:  						DrawNonAATriangle(v0' v1' v2);  						break;    					case 1:  						if (e0 == 1)  						{  							Draw1EdgeTriangle(v0' v1' v2);  						}  						else if (e1 == 1)  						{  							Draw1EdgeTriangle(v1' v2' v0);  						}  						else  						{  							Draw1EdgeTriangle(v2' v0' v1);  						}  						break;    					case 2:  						if (e0 == 1)  						{  							if (e1 == 1)  							{  								Draw2EdgeTriangle(v0' v1' v2);  							}  							else  							{  								Draw2EdgeTriangle(v2' v0' v1);  							}  						}  						else  						{  							Draw2EdgeTriangle(v1' v2' v0);  						}  						break;    					case 3:  						Draw3EdgeTriangle(v0' v1' v2);  						break;  				}
Magic Number,MatterHackers.RenderOpenGl,AAGLTesselator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\AAGLTesselator.cs,RenderLastToGL,The following statement contains a magic number: switch (e0 + e1 + e2)  				{  					case 0:  						DrawNonAATriangle(v0' v1' v2);  						break;    					case 1:  						if (e0 == 1)  						{  							Draw1EdgeTriangle(v0' v1' v2);  						}  						else if (e1 == 1)  						{  							Draw1EdgeTriangle(v1' v2' v0);  						}  						else  						{  							Draw1EdgeTriangle(v2' v0' v1);  						}  						break;    					case 2:  						if (e0 == 1)  						{  							if (e1 == 1)  							{  								Draw2EdgeTriangle(v0' v1' v2);  							}  							else  							{  								Draw2EdgeTriangle(v2' v0' v1);  							}  						}  						else  						{  							Draw2EdgeTriangle(v1' v2' v0);  						}  						break;    					case 3:  						Draw3EdgeTriangle(v0' v1' v2);  						break;  				}
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\Graphics2DOpenGL.cs,CheckLineImageCache,The following statement contains a magic number: var texture = new ImageBuffer(1024' 4);
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\Graphics2DOpenGL.cs,CheckLineImageCache,The following statement contains a magic number: var texture = new ImageBuffer(1024' 4);
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\Graphics2DOpenGL.cs,CheckLineImageCache,The following statement contains a magic number: hardwarePixelBuffer[(y * 1024 + x) * 4 + 0] = 255;
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\Graphics2DOpenGL.cs,CheckLineImageCache,The following statement contains a magic number: hardwarePixelBuffer[(y * 1024 + x) * 4 + 0] = 255;
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\Graphics2DOpenGL.cs,CheckLineImageCache,The following statement contains a magic number: hardwarePixelBuffer[(y * 1024 + x) * 4 + 0] = 255;
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\Graphics2DOpenGL.cs,CheckLineImageCache,The following statement contains a magic number: hardwarePixelBuffer[(y * 1024 + x) * 4 + 1] = 255;
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\Graphics2DOpenGL.cs,CheckLineImageCache,The following statement contains a magic number: hardwarePixelBuffer[(y * 1024 + x) * 4 + 1] = 255;
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\Graphics2DOpenGL.cs,CheckLineImageCache,The following statement contains a magic number: hardwarePixelBuffer[(y * 1024 + x) * 4 + 1] = 255;
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\Graphics2DOpenGL.cs,CheckLineImageCache,The following statement contains a magic number: hardwarePixelBuffer[(y * 1024 + x) * 4 + 2] = 255;
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\Graphics2DOpenGL.cs,CheckLineImageCache,The following statement contains a magic number: hardwarePixelBuffer[(y * 1024 + x) * 4 + 2] = 255;
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\Graphics2DOpenGL.cs,CheckLineImageCache,The following statement contains a magic number: hardwarePixelBuffer[(y * 1024 + x) * 4 + 2] = 255;
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\Graphics2DOpenGL.cs,CheckLineImageCache,The following statement contains a magic number: hardwarePixelBuffer[(y * 1024 + x) * 4 + 2] = 255;
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\Graphics2DOpenGL.cs,CheckLineImageCache,The following statement contains a magic number: hardwarePixelBuffer[(y * 1024 + x) * 4 + 3] = alpha;
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\Graphics2DOpenGL.cs,CheckLineImageCache,The following statement contains a magic number: hardwarePixelBuffer[(y * 1024 + x) * 4 + 3] = alpha;
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\Graphics2DOpenGL.cs,CheckLineImageCache,The following statement contains a magic number: hardwarePixelBuffer[(y * 1024 + x) * 4 + 3] = alpha;
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\Graphics2DOpenGL.cs,CheckLineImageCache,The following statement contains a magic number: x < 1024
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\Graphics2DOpenGL.cs,CheckLineImageCache,The following statement contains a magic number: y < 4
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\Graphics2DOpenGL.cs,CheckLineImageCache,The following statement contains a magic number: i < 256
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\Graphics2DOpenGL.cs,DrawAAShape,The following statement contains a magic number: GL.Color4(colorBytes.red' colorBytes.green' colorBytes.blue' (byte)255);
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\Graphics2DOpenGL.cs,DrawAALineRounded,The following statement contains a magic number: Vector2 widthRightOffset = (end - start).GetPerpendicularRight().GetNormal() * halfWidth / 2;
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\Graphics2DOpenGL.cs,DrawAALineRounded,The following statement contains a magic number: int numSegments = 5;
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\Graphics2DOpenGL.cs,DrawAACircle,The following statement contains a magic number: int numSegments = 12;
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\Graphics2DOpenGL.cs,FillRectangle,The following statement contains a magic number: Math.Abs(fastLeft - (int)fastLeft) < .01  				&& Math.Abs(fastBottom - (int)fastBottom) < .01  				&& Math.Abs(fastRight - (int)fastRight) < .01  				&& Math.Abs(fastTop - (int)fastTop) < .01
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\Graphics2DOpenGL.cs,FillRectangle,The following statement contains a magic number: Math.Abs(fastLeft - (int)fastLeft) < .01  				&& Math.Abs(fastBottom - (int)fastBottom) < .01  				&& Math.Abs(fastRight - (int)fastRight) < .01  				&& Math.Abs(fastTop - (int)fastTop) < .01
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\Graphics2DOpenGL.cs,FillRectangle,The following statement contains a magic number: Math.Abs(fastLeft - (int)fastLeft) < .01  				&& Math.Abs(fastBottom - (int)fastBottom) < .01  				&& Math.Abs(fastRight - (int)fastRight) < .01  				&& Math.Abs(fastTop - (int)fastTop) < .01
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\Graphics2DOpenGL.cs,FillRectangle,The following statement contains a magic number: Math.Abs(fastLeft - (int)fastLeft) < .01  				&& Math.Abs(fastBottom - (int)fastBottom) < .01  				&& Math.Abs(fastRight - (int)fastRight) < .01  				&& Math.Abs(fastTop - (int)fastTop) < .01
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\Graphics2DOpenGL.cs,Line,The following statement contains a magic number: strokeBounds = new RectangleDouble(x1 - strokeWidth / 2' y1' x1 + strokeWidth / 2' y2);
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\Graphics2DOpenGL.cs,Line,The following statement contains a magic number: strokeBounds = new RectangleDouble(x1 - strokeWidth / 2' y1' x1 + strokeWidth / 2' y2);
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\Graphics2DOpenGL.cs,Line,The following statement contains a magic number: bool canUseFill = (x1 == x2 || y1 == y2) // we are vertical or horizontal  				&& Math.Abs(strokeBounds.Left - (int)strokeBounds.Left) < .01  				&& Math.Abs(strokeBounds.Right - (int)strokeBounds.Right) < .01  				&& Math.Abs(strokeBounds.Bottom - (int)strokeBounds.Bottom) < .01  				&& Math.Abs(strokeBounds.Top - (int)strokeBounds.Top) < .01;
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\Graphics2DOpenGL.cs,Line,The following statement contains a magic number: bool canUseFill = (x1 == x2 || y1 == y2) // we are vertical or horizontal  				&& Math.Abs(strokeBounds.Left - (int)strokeBounds.Left) < .01  				&& Math.Abs(strokeBounds.Right - (int)strokeBounds.Right) < .01  				&& Math.Abs(strokeBounds.Bottom - (int)strokeBounds.Bottom) < .01  				&& Math.Abs(strokeBounds.Top - (int)strokeBounds.Top) < .01;
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\Graphics2DOpenGL.cs,Line,The following statement contains a magic number: bool canUseFill = (x1 == x2 || y1 == y2) // we are vertical or horizontal  				&& Math.Abs(strokeBounds.Left - (int)strokeBounds.Left) < .01  				&& Math.Abs(strokeBounds.Right - (int)strokeBounds.Right) < .01  				&& Math.Abs(strokeBounds.Bottom - (int)strokeBounds.Bottom) < .01  				&& Math.Abs(strokeBounds.Top - (int)strokeBounds.Top) < .01;
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\Graphics2DOpenGL.cs,Line,The following statement contains a magic number: bool canUseFill = (x1 == x2 || y1 == y2) // we are vertical or horizontal  				&& Math.Abs(strokeBounds.Left - (int)strokeBounds.Left) < .01  				&& Math.Abs(strokeBounds.Right - (int)strokeBounds.Right) < .01  				&& Math.Abs(strokeBounds.Bottom - (int)strokeBounds.Bottom) < .01  				&& Math.Abs(strokeBounds.Top - (int)strokeBounds.Top) < .01;
Magic Number,MatterHackers.RenderOpenGl,GLHelper,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderMeshToGl.cs,DrawToGL,The following statement contains a magic number: GL.TexCoordPointer(2' TexCordPointerType.Float' 0' new IntPtr(pTextureData));
Magic Number,MatterHackers.RenderOpenGl,GLHelper,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderMeshToGl.cs,DrawToGL,The following statement contains a magic number: GL.ColorPointer(3' ColorPointerType.UnsignedByte' 0' new IntPtr(pColorData));
Magic Number,MatterHackers.RenderOpenGl,GLHelper,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderMeshToGl.cs,DrawToGL,The following statement contains a magic number: GL.VertexPointer(3' VertexPointerType.Float' 0' new IntPtr(pPosition));
Magic Number,MatterHackers.RenderOpenGl,GLHelper,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderMeshToGl.cs,DrawToGL,The following statement contains a magic number: GL.TexCoordPointer(2' TexCordPointerType.Float' 0' new IntPtr(0));
Magic Number,MatterHackers.RenderOpenGl,GLHelper,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderMeshToGl.cs,DrawToGL,The following statement contains a magic number: GL.ColorPointer(3' ColorPointerType.UnsignedByte' 0' new IntPtr(0));
Magic Number,MatterHackers.RenderOpenGl,GLHelper,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderMeshToGl.cs,DrawToGL,The following statement contains a magic number: GL.VertexPointer(3' VertexPointerType.Float' 0' new IntPtr(0));
Magic Number,MatterHackers.RenderOpenGl,GLHelper,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderMeshToGl.cs,DrawWireOverlay,The following statement contains a magic number: GL.Color4(color.red' color.green' color.blue' color.alpha == 0 ? 255 : color.alpha);
Magic Number,MatterHackers.RenderOpenGl,GLHelper,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderMeshToGl.cs,DrawWireOverlay,The following statement contains a magic number: edgeLinesContainer = GLMeshWirePlugin.Get(meshToRender' MathHelper.Tau / 8' meshChanged);
Magic Number,MatterHackers.RenderOpenGl,GLHelper,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderMeshToGl.cs,DrawWireOverlay,The following statement contains a magic number: GL.VertexPointer(3' VertexPointerType.Float' 0' new IntPtr(pv));
Magic Number,MatterHackers.RenderOpenGl,GLHelper,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderMeshToGl.cs,SetGlContext,The following statement contains a magic number: var lightDirectionVector = new Vector3(lighting.LightDirection0[0]' lighting.LightDirection0[1]' lighting.LightDirection0[2]);
Magic Number,MatterHackers.RenderOpenGl,GLHelper,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderMeshToGl.cs,SetGlContext,The following statement contains a magic number: lighting.LightDirection0[2] = (float)lightDirectionVector.Z;
Magic Number,MatterHackers.RenderOpenGl,WorldViewExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\WorldViewExtensions.cs,Render3DLineNoPrep,The following statement contains a magic number: var rotateTransform = Matrix4X4.CreateRotation(new Quaternion(Vector3.UnitX + new Vector3(.0001' -.00001' .00002)' -delta / deltaLength));
Magic Number,MatterHackers.RenderOpenGl,WorldViewExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\WorldViewExtensions.cs,Render3DLineNoPrep,The following statement contains a magic number: var rotateTransform = Matrix4X4.CreateRotation(new Quaternion(Vector3.UnitX + new Vector3(.0001' -.00001' .00002)' -delta / deltaLength));
Magic Number,MatterHackers.RenderOpenGl,WorldViewExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\WorldViewExtensions.cs,Render3DLineNoPrep,The following statement contains a magic number: var rotateTransform = Matrix4X4.CreateRotation(new Quaternion(Vector3.UnitX + new Vector3(.0001' -.00001' .00002)' -delta / deltaLength));
Magic Number,MatterHackers.RenderOpenGl,WorldViewExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\WorldViewExtensions.cs,Render3DLineNoPrep,The following statement contains a magic number: Vector3 lineCenter = (start + end) / 2;
Magic Number,MatterHackers.RenderOpenGl,WorldViewExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\WorldViewExtensions.cs,RenderCylinderOutline,The following statement contains a magic number: var rotatedPoint = new Vector3(Math.Cos(startAngle)' Math.Sin(startAngle)' 0) * diameter / 2;
Magic Number,MatterHackers.RenderOpenGl,WorldViewExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\WorldViewExtensions.cs,RenderCylinderOutline,The following statement contains a magic number: var sideTop = Vector3Ex.Transform(center + rotatedPoint + new Vector3(0' 0' height / 2)' worldMatrix);
Magic Number,MatterHackers.RenderOpenGl,WorldViewExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\WorldViewExtensions.cs,RenderCylinderOutline,The following statement contains a magic number: var sideBottom = Vector3Ex.Transform(center + rotatedPoint + new Vector3(0' 0' -height / 2)' worldMatrix);
Magic Number,MatterHackers.RenderOpenGl,WorldViewExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\WorldViewExtensions.cs,RenderCylinderOutline,The following statement contains a magic number: var rotated2Point = new Vector3(Math.Cos(endAngle)' Math.Sin(endAngle)' 0) * diameter / 2;
Magic Number,MatterHackers.RenderOpenGl,WorldViewExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\WorldViewExtensions.cs,RenderCylinderOutline,The following statement contains a magic number: var topEnd = Vector3Ex.Transform(center + rotated2Point + new Vector3(0' 0' height / 2)' worldMatrix);
Magic Number,MatterHackers.RenderOpenGl,WorldViewExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\WorldViewExtensions.cs,RenderCylinderOutline,The following statement contains a magic number: var bottomEnd = Vector3Ex.Transform(center + rotated2Point + new Vector3(0' 0' -height / 2)' worldMatrix);
Magic Number,MatterHackers.RenderOpenGl,WorldViewExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\WorldViewExtensions.cs,RenderAabb,The following statement contains a magic number: Vector3 bottomEndPosition = Vector3Ex.Transform(bounds.GetBottomCorner((i + 1) % 4)' matrix);
Magic Number,MatterHackers.RenderOpenGl,WorldViewExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\WorldViewExtensions.cs,RenderAabb,The following statement contains a magic number: Vector3 topEndPosition = Vector3Ex.Transform(bounds.GetTopCorner((i + 1) % 4)' matrix);
Magic Number,MatterHackers.RenderOpenGl,WorldViewExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\WorldViewExtensions.cs,RenderAabb,The following statement contains a magic number: i < 4
Magic Number,MatterHackers.RenderOpenGl,WorldViewExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\WorldViewExtensions.cs,RenderAxis,The following statement contains a magic number: switch (i)  				{  					case 1:  						color = Agg.Color.Green;  						break;    					case 2:  						color = Agg.Color.Blue;  						break;  				}
Magic Number,MatterHackers.RenderOpenGl,WorldViewExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\WorldViewExtensions.cs,RenderAxis,The following statement contains a magic number: i < 3
Magic Number,MatterHackers.RenderOpenGl,WorldViewExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\WorldViewExtensions.cs,RenderPath,The following statement contains a magic number: GL.Color4(color.red' color.green' color.blue' (byte)255);
Missing Default,MatterHackers.RenderOpenGl,AAGLTesselator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\AAGLTesselator.cs,RenderLastToGL,The following switch statement is missing a default case: switch (e0 + e1 + e2)  				{  					case 0:  						DrawNonAATriangle(v0' v1' v2);  						break;    					case 1:  						if (e0 == 1)  						{  							Draw1EdgeTriangle(v0' v1' v2);  						}  						else if (e1 == 1)  						{  							Draw1EdgeTriangle(v1' v2' v0);  						}  						else  						{  							Draw1EdgeTriangle(v2' v0' v1);  						}  						break;    					case 2:  						if (e0 == 1)  						{  							if (e1 == 1)  							{  								Draw2EdgeTriangle(v0' v1' v2);  							}  							else  							{  								Draw2EdgeTriangle(v2' v0' v1);  							}  						}  						else  						{  							Draw2EdgeTriangle(v1' v2' v0);  						}  						break;    					case 3:  						Draw3EdgeTriangle(v0' v1' v2);  						break;  				}
Missing Default,MatterHackers.RenderOpenGl,GLTesselator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\GLTesselator.cs,BeginCallBack,The following switch statement is missing a default case: switch (type)  			{  				case Tesselator.TriangleListType.Triangles:  					GL.Begin(BeginMode.Triangles);  					break;    				case Tesselator.TriangleListType.TriangleFan:  					GL.Begin(BeginMode.TriangleFan);  					break;    				case Tesselator.TriangleListType.TriangleStrip:  					GL.Begin(BeginMode.TriangleStrip);  					break;  			}
Missing Default,MatterHackers.RenderOpenGl,GLHelper,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderMeshToGl.cs,Render,The following switch statement is missing a default case: switch (renderType)  				{  					case RenderTypes.Hidden:  						break;    					case RenderTypes.Polygons:  					case RenderTypes.Outlines:  					case RenderTypes.NonManifold:  						if (color.Alpha0To255 > 0)  						{  							GL.Enable(EnableCap.PolygonOffsetFill);  							GL.PolygonOffset(1' 1);  							DrawToGL(meshToRender' color.Alpha0To1 < 1' meshToViewTransform' allowBspRendering: allowBspRendering);  							GL.PolygonOffset(0' 0);  							GL.Disable(EnableCap.PolygonOffsetFill);  						}    						DrawWireOverlay(meshToRender' renderType' wireFrameColor' meshChanged);  						break;    					case RenderTypes.Wireframe:  						DrawWireOverlay(meshToRender' renderType' wireFrameColor);  						break;    					case RenderTypes.Overhang:  						OverhangRender.EnsureUpdated(meshToRender' transform);  						DrawToGL(meshToRender' color.Alpha0To1 < 1' meshToViewTransform);  						break;    					case RenderTypes.Shaded:  					case RenderTypes.Materials:  						DrawToGL(meshToRender' color.Alpha0To1 < 1' meshToViewTransform' blendTexture' allowBspRendering);  						break;  				}
Missing Default,MatterHackers.RenderOpenGl,WorldViewExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\RenderOpenGl\WorldViewExtensions.cs,RenderAxis,The following switch statement is missing a default case: switch (i)  				{  					case 1:  						color = Agg.Color.Green;  						break;    					case 2:  						color = Agg.Color.Blue;  						break;  				}
