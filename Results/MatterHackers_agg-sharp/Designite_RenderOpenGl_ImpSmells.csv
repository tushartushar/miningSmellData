Implementation smell,Namespace,Class,File,Method,Description
Long Method,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,GetImageGlPlugin,The method has 127 lines of code.
Long Method,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The method has 134 lines of code.
Complex Method,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,Cyclomatic complexity of the method is 8
Long Parameter List,MatterHackers.RenderOpenGl.OpenGl,GL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\GL.cs,Ortho,The method has 6 parameters. Parameters: left' right' bottom' top' zNear' zFar
Long Parameter List,MatterHackers.RenderOpenGl.OpenGl,GL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\GL.cs,TexImage2D,The method has 9 parameters. Parameters: target' level' internalFormat' width' height' border' format' type' pixels
Long Parameter List,MatterHackers.RenderOpenGl.OpenGl,GL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\GL.cs,DrawRangeElements,The method has 6 parameters. Parameters: mode' start' end' count' type' indices
Long Parameter List,MatterHackers.RenderOpenGl,Graphics2DOpenGL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\RendererOpenGL.cs,Render,The method has 6 parameters. Parameters: source' x' y' angleRadians' scaleX' scaleY
Long Parameter List,MatterHackers.RenderOpenGl,Graphics2DOpenGL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\RendererOpenGL.cs,Render,The method has 6 parameters. Parameters: imageSource' x' y' angleDegrees' scaleX' ScaleY
Long Parameter List,MatterHackers.RenderOpenGl,Graphics2DOpenGL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\RendererOpenGL.cs,Rectangle,The method has 6 parameters. Parameters: left' bottom' right' top' color' strokeWidth
Long Parameter List,MatterHackers.RenderOpenGl,Graphics2DOpenGL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\RendererOpenGL.cs,FillRectangle,The method has 5 parameters. Parameters: left' bottom' right' top' fillColor
Long Identifier,MatterHackers.RenderOpenGl.OpenGl,GL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\GL.cs,,The length of the parameter currentElementArrayBufferIndex is 30.
Long Identifier,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,,The length of the parameter hwSupportsOnlyPowerOfTwoTextures is 32.
Long Identifier,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,,The length of the parameter checkedForHwSupportsOnlyPowerOfTwoTextures is 42.
Long Statement,MatterHackers.RenderOpenGl.OpenGl,GL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\GL.cs,BlendFunc,The length of the statement  "				OpenTK.Graphics.OpenGL.GL.BlendFunc((OpenTK.Graphics.OpenGL.BlendingFactorSrc)sfactor' (OpenTK.Graphics.OpenGL.BlendingFactorDest)dfactor); " is 139.
Long Statement,MatterHackers.RenderOpenGl.OpenGl,GL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\GL.cs,Color4,The length of the statement  "            OpenTK.Graphics.ES11.GL.Color4(ImediateMode.currentColor[0]' ImediateMode.currentColor[1]' ImediateMode.currentColor[2]' ImediateMode.currentColor[3]); " is 151.
Long Statement,MatterHackers.RenderOpenGl.OpenGl,GL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\GL.cs,TexParameter,The length of the statement  "				OpenTK.Graphics.OpenGL.GL.TexParameter((OpenTK.Graphics.OpenGL.TextureTarget)target' (OpenTK.Graphics.OpenGL.TextureParameterName)pname' param); " is 144.
Long Statement,MatterHackers.RenderOpenGl.OpenGl,GL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\GL.cs,BufferData,The length of the statement  "					OpenTK.Graphics.OpenGL.GL.BufferData((OpenTK.Graphics.OpenGL.BufferTarget)target' (IntPtr)size' data' (OpenTK.Graphics.OpenGL.BufferUsageHint)usage); " is 149.
Long Statement,MatterHackers.RenderOpenGl.OpenGl,GL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\GL.cs,BufferData,The length of the statement  "				OpenTK.Graphics.ES11.GL.BufferData((OpenTK.Graphics.ES11.All)target' (IntPtr)size' data' (OpenTK.Graphics.ES11.All)usage); " is 122.
Long Statement,MatterHackers.RenderOpenGl.OpenGl,GL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\GL.cs,EnableClientState,The length of the statement  "				if (glHasBufferObjects || arrayCap != ArrayCap.IndexArray) // don't set index array if we don't have buffer objects (we will render through DrawElements instead). " is 162.
Long Statement,MatterHackers.RenderOpenGl.OpenGl,GL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\GL.cs,EnableClientState,The length of the statement  "			if (glHasBufferObjects || arrayCap != ArrayCap.IndexArray) // don't set index array if we don't have buffer objects (we will render through DrawElements instead). " is 162.
Long Statement,MatterHackers.RenderOpenGl.OpenGl,GL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\GL.cs,ColorPointer,The length of the statement  "							OpenTK.Graphics.OpenGL.GL.ColorPointer(size' (OpenTK.Graphics.OpenGL.ColorPointerType)type' stride' new IntPtr(&buffer[(int)pointer])); " is 135.
Long Statement,MatterHackers.RenderOpenGl.OpenGl,GL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\GL.cs,NormalPointer,The length of the statement  "							OpenTK.Graphics.OpenGL.GL.NormalPointer((OpenTK.Graphics.OpenGL.NormalPointerType)type' stride' new IntPtr(&buffer[(int)pointer])); " is 131.
Long Statement,MatterHackers.RenderOpenGl.OpenGl,GL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\GL.cs,VertexPointer,The length of the statement  "							OpenTK.Graphics.OpenGL.GL.VertexPointer(size' (OpenTK.Graphics.OpenGL.VertexPointerType)type' stride' new IntPtr(&buffer[(int)pointer])); " is 137.
Long Statement,MatterHackers.RenderOpenGl.OpenGl,GL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\GL.cs,DrawRangeElements,The length of the statement  "					OpenTK.Graphics.OpenGL.GL.DrawRangeElements((OpenTK.Graphics.OpenGL.BeginMode)mode' start' end' count' (OpenTK.Graphics.OpenGL.DrawElementsType)type' indices); " is 159.
Long Statement,MatterHackers.RenderOpenGl.OpenGl,GL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\GL.cs,DrawRangeElements,The length of the statement  "							OpenTK.Graphics.OpenGL.GL.DrawElements((OpenTK.Graphics.OpenGL.BeginMode)mode' count' (OpenTK.Graphics.OpenGL.DrawElementsType)type' new IntPtr(passedBuffer)); " is 159.
Long Statement,MatterHackers.RenderOpenGl.OpenGl,GL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\GL.cs,DrawRangeElements,The length of the statement  "						OpenTK.Graphics.ES11.GL.DrawElements((OpenTK.Graphics.ES11.All)mode' count' (OpenTK.Graphics.ES11.All)type' new IntPtr(passedBuffer)); " is 134.
Long Statement,MatterHackers.RenderOpenGl.OpenGl,GL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\GL.cs,Light,The length of the statement  "				OpenTK.Graphics.OpenGL.GL.Light((OpenTK.Graphics.OpenGL.LightName)light' (OpenTK.Graphics.OpenGL.LightParameter)pname' param); " is 126.
Long Statement,MatterHackers.RenderOpenGl.OpenGl,GL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\GL.cs,ColorMaterial,The length of the statement  "				OpenTK.Graphics.OpenGL.GL.ColorMaterial((OpenTK.Graphics.OpenGL.MaterialFace)face' (OpenTK.Graphics.OpenGL.ColorMaterialParameter)mode); " is 136.
Long Statement,MatterHackers.RenderOpenGl,GLMeshTrianglePlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\GLMeshTrianglePlugin.cs,CreateRenderData,The length of the statement  "						tempNormal.normalX = (float)face.normal.x; tempNormal.normalY = (float)face.normal.y; tempNormal.normalZ = (float)face.normal.z; " is 128.
Long Statement,MatterHackers.RenderOpenGl,GLMeshTrianglePlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\GLMeshTrianglePlugin.cs,CreateRenderData,The length of the statement  "						tempPosition.positionX = (float)position[0].x; tempPosition.positionY = (float)position[0].y; tempPosition.positionZ = (float)position[0].z; " is 140.
Long Statement,MatterHackers.RenderOpenGl,GLMeshTrianglePlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\GLMeshTrianglePlugin.cs,CreateRenderData,The length of the statement  "						tempNormal.normalX = (float)face.normal.x; tempNormal.normalY = (float)face.normal.y; tempNormal.normalZ = (float)face.normal.z; " is 128.
Long Statement,MatterHackers.RenderOpenGl,GLMeshTrianglePlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\GLMeshTrianglePlugin.cs,CreateRenderData,The length of the statement  "						tempPosition.positionX = (float)position[1].x; tempPosition.positionY = (float)position[1].y; tempPosition.positionZ = (float)position[1].z; " is 140.
Long Statement,MatterHackers.RenderOpenGl,GLMeshTrianglePlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\GLMeshTrianglePlugin.cs,CreateRenderData,The length of the statement  "						tempNormal.normalX = (float)face.normal.x; tempNormal.normalY = (float)face.normal.y; tempNormal.normalZ = (float)face.normal.z; " is 128.
Long Statement,MatterHackers.RenderOpenGl,GLMeshTrianglePlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\GLMeshTrianglePlugin.cs,CreateRenderData,The length of the statement  "						tempPosition.positionX = (float)position2.x; tempPosition.positionY = (float)position2.y; tempPosition.positionZ = (float)position2.z; " is 134.
Long Statement,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,GetImageGlPlugin,The length of the statement  "                        && glDataNeedingToBeDeleted[i].refreshCountCreatedOn == currentGlobalRefreshCount) // this is to leak on purpose on android for some gl that kills textures " is 155.
Long Statement,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The length of the statement  "				GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMinFilter' (int)TextureMinFilter.LinearMipmapLinear); " is 122.
Long Statement,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The length of the statement  "			glData.textureUVs[0] = 0; glData.textureUVs[1] = 0; glData.positions[0] = 0 - OffsetX; glData.positions[1] = 0 - OffsetY; " is 121.
Long Statement,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The length of the statement  "			glData.textureUVs[2] = 0; glData.textureUVs[3] = texCoordY; glData.positions[2] = 0 - OffsetX; glData.positions[3] = imageHeight - OffsetY; " is 139.
Long Statement,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The length of the statement  "			glData.textureUVs[4] = texCoordX; glData.textureUVs[5] = texCoordY; glData.positions[4] = imageWidth - OffsetX; glData.positions[5] = imageHeight - OffsetY; " is 156.
Long Statement,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The length of the statement  "			glData.textureUVs[6] = texCoordX; glData.textureUVs[7] = 0; glData.positions[6] = imageWidth - OffsetX; glData.positions[7] = 0 - OffsetY; " is 138.
Long Statement,MatterHackers.RenderOpenGl,Graphics2DOpenGL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\RendererOpenGL.cs,PreRender,The length of the statement  "			GL.BindTexture(TextureTarget.Texture2D' RenderOpenGl.ImageGlPlugin.GetImageGlPlugin(AATextureImage' false).GLTextureHandle); " is 124.
Long Statement,MatterHackers.RenderOpenGl,Graphics2DOpenGL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\RendererOpenGL.cs,Render,The length of the statement  "			RectangleInt destBounds = new RectangleInt((int)cachedClipRect.Left' (int)cachedClipRect.Bottom' (int)cachedClipRect.Right' (int)cachedClipRect.Top); " is 149.
Long Statement,MatterHackers.RenderOpenGl,RenderCsgToGl,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderCsgToGl.cs,CreateCylinder,The length of the statement  "				Vertex bottomVertex = cylinder.CreateVertex(new Vector3(bottomRadialPos.x' bottomRadialPos.y' -cylinderToMeasure.Height / 2)); " is 126.
Long Statement,MatterHackers.RenderOpenGl,RenderCsgToGl,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderCsgToGl.cs,RenderToGlRecursive,The length of the statement  "            info += "cylinder(r1=" + objectToProcess.Radius1.ToString() + "' r2=" + objectToProcess.Radius1.ToString() + "' h=" + objectToProcess.Height.ToString() + "' center=true' $fn=" + objectToProcess.NumSides.ToString() + ");"; " is 221.
Long Statement,MatterHackers.RenderOpenGl,RenderCsgToGl,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderCsgToGl.cs,RenderToGlRecursive,The length of the statement  "            return ApplyIndent("intersection()" + "\n{\n" + RenderToGlRecursive((dynamic)objectToProcess.a' level + 1) + "\n" + RenderToGlRecursive((dynamic)objectToProcess.b' level + 1) + "\n}"); " is 184.
Complex Conditional,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,GetImageGlPlugin,The conditional expression  "plugin != null  				&& (imageToGetDisplayListFor.ChangedCount != plugin.imageUpdateCount  				|| plugin.glData.refreshCountCreatedOn != currentGlobalRefreshCount                  || plugin.glData.glTextureHandle == -1)"  is complex.
Complex Conditional,MatterHackers.RenderOpenGl,Graphics2DOpenGL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\RendererOpenGL.cs,Rectangle,The conditional expression  "fastLeft == (int)fastLeft  				&& fastBottom == (int)fastBottom  				&& fastRight == (int)fastRight  				&& fastTop == (int)fastTop"  is complex.
Complex Conditional,MatterHackers.RenderOpenGl,Graphics2DOpenGL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\RendererOpenGL.cs,FillRectangle,The conditional expression  "fastLeft == (int)fastLeft  				&& fastBottom == (int)fastBottom  				&& fastRight == (int)fastRight  				&& fastTop == (int)fastTop"  is complex.
Magic Number,MatterHackers.RenderOpenGl,GLMeshWirePlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\GLMeshWirePlugin.cs,CreateRenderData,The following statement contains a magic number: foreach (MeshEdge meshEdge in meshToBuildListFor.MeshEdges)  			{  				if (nonPlanarAngleRequired > 0)  				{  					if (meshEdge.GetNumFacesSharingEdge() == 2)  					{  						FaceEdge firstFaceEdge = meshEdge.firstFaceEdge;  						FaceEdge nextFaceEdge = meshEdge.firstFaceEdge.radialNextFaceEdge;  						double angle = Vector3.CalculateAngle(firstFaceEdge.containingFace.normal' nextFaceEdge.containingFace.normal);  						if (angle > MathHelper.Tau * .1)  						{  							edgeLinesData.Add(AddVertex(meshEdge.VertexOnEnd[0].Position' meshEdge.VertexOnEnd[1].Position));  						}  					}  					else  					{  						edgeLinesData.Add(AddVertex(meshEdge.VertexOnEnd[0].Position' meshEdge.VertexOnEnd[1].Position));  					}  				}  				else  				{  					edgeLinesData.Add(AddVertex(meshEdge.VertexOnEnd[0].Position' meshEdge.VertexOnEnd[1].Position));  				}  			}
Magic Number,MatterHackers.RenderOpenGl,GLMeshWirePlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\GLMeshWirePlugin.cs,CreateRenderData,The following statement contains a magic number: foreach (MeshEdge meshEdge in meshToBuildListFor.MeshEdges)  			{  				if (nonPlanarAngleRequired > 0)  				{  					if (meshEdge.GetNumFacesSharingEdge() == 2)  					{  						FaceEdge firstFaceEdge = meshEdge.firstFaceEdge;  						FaceEdge nextFaceEdge = meshEdge.firstFaceEdge.radialNextFaceEdge;  						double angle = Vector3.CalculateAngle(firstFaceEdge.containingFace.normal' nextFaceEdge.containingFace.normal);  						if (angle > MathHelper.Tau * .1)  						{  							edgeLinesData.Add(AddVertex(meshEdge.VertexOnEnd[0].Position' meshEdge.VertexOnEnd[1].Position));  						}  					}  					else  					{  						edgeLinesData.Add(AddVertex(meshEdge.VertexOnEnd[0].Position' meshEdge.VertexOnEnd[1].Position));  					}  				}  				else  				{  					edgeLinesData.Add(AddVertex(meshEdge.VertexOnEnd[0].Position' meshEdge.VertexOnEnd[1].Position));  				}  			}
Magic Number,MatterHackers.RenderOpenGl,GLMeshTrianglePlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\GLMeshTrianglePlugin.cs,CreateRenderData,The following statement contains a magic number: foreach (Face face in meshToBuildListFor.Faces)  			{  				ImageBuffer faceTexture = face.GetTexture(0);  				if (faceTexture != null)  				{  					ImageGlPlugin.GetImageGlPlugin(faceTexture' true);  				}    				// don't compare the data of the texture but rather if they are just the same object  				if (subMeshs.Count == 0 || (object)subMeshs[subMeshs.Count - 1].texture != (object)faceTexture)  				{  					SubTriangleMesh newSubMesh = new SubTriangleMesh();  					newSubMesh.texture = faceTexture;  					subMeshs.Add(newSubMesh);    					currentSubMesh = subMeshs[subMeshs.Count - 1];  					textureData = currentSubMesh.textrueData;  					normalData = currentSubMesh.normalData;  					positionData = currentSubMesh.positionData;  				}    				Vector2[] textureUV = new Vector2[2];  				Vector3[] position = new Vector3[2];  				int vertexIndex = 0;  				foreach (FaceEdge faceEdge in face.FaceEdges())  				{  					if (vertexIndex < 2)  					{  						textureUV[vertexIndex] = faceEdge.GetUVs(0);  						position[vertexIndex] = faceEdge.firstVertex.Position;  					}  					else  					{  						VertexTextureData tempTexture;  						VertexNormalData tempNormal;  						VertexPositionData tempPosition;  						tempTexture.textureU = (float)textureUV[0].x; tempTexture.textureV = (float)textureUV[0].y;  						tempNormal.normalX = (float)face.normal.x; tempNormal.normalY = (float)face.normal.y; tempNormal.normalZ = (float)face.normal.z;  						tempPosition.positionX = (float)position[0].x; tempPosition.positionY = (float)position[0].y; tempPosition.positionZ = (float)position[0].z;  						textureData.Add(tempTexture);  						normalData.Add(tempNormal);  						positionData.Add(tempPosition);    						tempTexture.textureU = (float)textureUV[1].x; tempTexture.textureV = (float)textureUV[1].y;  						tempNormal.normalX = (float)face.normal.x; tempNormal.normalY = (float)face.normal.y; tempNormal.normalZ = (float)face.normal.z;  						tempPosition.positionX = (float)position[1].x; tempPosition.positionY = (float)position[1].y; tempPosition.positionZ = (float)position[1].z;  						textureData.Add(tempTexture);  						normalData.Add(tempNormal);  						positionData.Add(tempPosition);    						Vector2 textureUV2 = faceEdge.GetUVs(0);  						Vector3 position2 = faceEdge.firstVertex.Position;  						tempTexture.textureU = (float)textureUV2.x; tempTexture.textureV = (float)textureUV2.y;  						tempNormal.normalX = (float)face.normal.x; tempNormal.normalY = (float)face.normal.y; tempNormal.normalZ = (float)face.normal.z;  						tempPosition.positionX = (float)position2.x; tempPosition.positionY = (float)position2.y; tempPosition.positionZ = (float)position2.z;  						textureData.Add(tempTexture);  						normalData.Add(tempNormal);  						positionData.Add(tempPosition);    						textureUV[1] = faceEdge.GetUVs(0);  						position[1] = faceEdge.firstVertex.Position;  					}    					vertexIndex++;  				}  			}
Magic Number,MatterHackers.RenderOpenGl,GLMeshTrianglePlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\GLMeshTrianglePlugin.cs,CreateRenderData,The following statement contains a magic number: foreach (Face face in meshToBuildListFor.Faces)  			{  				ImageBuffer faceTexture = face.GetTexture(0);  				if (faceTexture != null)  				{  					ImageGlPlugin.GetImageGlPlugin(faceTexture' true);  				}    				// don't compare the data of the texture but rather if they are just the same object  				if (subMeshs.Count == 0 || (object)subMeshs[subMeshs.Count - 1].texture != (object)faceTexture)  				{  					SubTriangleMesh newSubMesh = new SubTriangleMesh();  					newSubMesh.texture = faceTexture;  					subMeshs.Add(newSubMesh);    					currentSubMesh = subMeshs[subMeshs.Count - 1];  					textureData = currentSubMesh.textrueData;  					normalData = currentSubMesh.normalData;  					positionData = currentSubMesh.positionData;  				}    				Vector2[] textureUV = new Vector2[2];  				Vector3[] position = new Vector3[2];  				int vertexIndex = 0;  				foreach (FaceEdge faceEdge in face.FaceEdges())  				{  					if (vertexIndex < 2)  					{  						textureUV[vertexIndex] = faceEdge.GetUVs(0);  						position[vertexIndex] = faceEdge.firstVertex.Position;  					}  					else  					{  						VertexTextureData tempTexture;  						VertexNormalData tempNormal;  						VertexPositionData tempPosition;  						tempTexture.textureU = (float)textureUV[0].x; tempTexture.textureV = (float)textureUV[0].y;  						tempNormal.normalX = (float)face.normal.x; tempNormal.normalY = (float)face.normal.y; tempNormal.normalZ = (float)face.normal.z;  						tempPosition.positionX = (float)position[0].x; tempPosition.positionY = (float)position[0].y; tempPosition.positionZ = (float)position[0].z;  						textureData.Add(tempTexture);  						normalData.Add(tempNormal);  						positionData.Add(tempPosition);    						tempTexture.textureU = (float)textureUV[1].x; tempTexture.textureV = (float)textureUV[1].y;  						tempNormal.normalX = (float)face.normal.x; tempNormal.normalY = (float)face.normal.y; tempNormal.normalZ = (float)face.normal.z;  						tempPosition.positionX = (float)position[1].x; tempPosition.positionY = (float)position[1].y; tempPosition.positionZ = (float)position[1].z;  						textureData.Add(tempTexture);  						normalData.Add(tempNormal);  						positionData.Add(tempPosition);    						Vector2 textureUV2 = faceEdge.GetUVs(0);  						Vector3 position2 = faceEdge.firstVertex.Position;  						tempTexture.textureU = (float)textureUV2.x; tempTexture.textureV = (float)textureUV2.y;  						tempNormal.normalX = (float)face.normal.x; tempNormal.normalY = (float)face.normal.y; tempNormal.normalZ = (float)face.normal.z;  						tempPosition.positionX = (float)position2.x; tempPosition.positionY = (float)position2.y; tempPosition.positionZ = (float)position2.z;  						textureData.Add(tempTexture);  						normalData.Add(tempNormal);  						positionData.Add(tempPosition);    						textureUV[1] = faceEdge.GetUVs(0);  						position[1] = faceEdge.firstVertex.Position;  					}    					vertexIndex++;  				}  			}
Magic Number,MatterHackers.RenderOpenGl,GLMeshTrianglePlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\GLMeshTrianglePlugin.cs,CreateRenderData,The following statement contains a magic number: foreach (Face face in meshToBuildListFor.Faces)  			{  				ImageBuffer faceTexture = face.GetTexture(0);  				if (faceTexture != null)  				{  					ImageGlPlugin.GetImageGlPlugin(faceTexture' true);  				}    				// don't compare the data of the texture but rather if they are just the same object  				if (subMeshs.Count == 0 || (object)subMeshs[subMeshs.Count - 1].texture != (object)faceTexture)  				{  					SubTriangleMesh newSubMesh = new SubTriangleMesh();  					newSubMesh.texture = faceTexture;  					subMeshs.Add(newSubMesh);    					currentSubMesh = subMeshs[subMeshs.Count - 1];  					textureData = currentSubMesh.textrueData;  					normalData = currentSubMesh.normalData;  					positionData = currentSubMesh.positionData;  				}    				Vector2[] textureUV = new Vector2[2];  				Vector3[] position = new Vector3[2];  				int vertexIndex = 0;  				foreach (FaceEdge faceEdge in face.FaceEdges())  				{  					if (vertexIndex < 2)  					{  						textureUV[vertexIndex] = faceEdge.GetUVs(0);  						position[vertexIndex] = faceEdge.firstVertex.Position;  					}  					else  					{  						VertexTextureData tempTexture;  						VertexNormalData tempNormal;  						VertexPositionData tempPosition;  						tempTexture.textureU = (float)textureUV[0].x; tempTexture.textureV = (float)textureUV[0].y;  						tempNormal.normalX = (float)face.normal.x; tempNormal.normalY = (float)face.normal.y; tempNormal.normalZ = (float)face.normal.z;  						tempPosition.positionX = (float)position[0].x; tempPosition.positionY = (float)position[0].y; tempPosition.positionZ = (float)position[0].z;  						textureData.Add(tempTexture);  						normalData.Add(tempNormal);  						positionData.Add(tempPosition);    						tempTexture.textureU = (float)textureUV[1].x; tempTexture.textureV = (float)textureUV[1].y;  						tempNormal.normalX = (float)face.normal.x; tempNormal.normalY = (float)face.normal.y; tempNormal.normalZ = (float)face.normal.z;  						tempPosition.positionX = (float)position[1].x; tempPosition.positionY = (float)position[1].y; tempPosition.positionZ = (float)position[1].z;  						textureData.Add(tempTexture);  						normalData.Add(tempNormal);  						positionData.Add(tempPosition);    						Vector2 textureUV2 = faceEdge.GetUVs(0);  						Vector3 position2 = faceEdge.firstVertex.Position;  						tempTexture.textureU = (float)textureUV2.x; tempTexture.textureV = (float)textureUV2.y;  						tempNormal.normalX = (float)face.normal.x; tempNormal.normalY = (float)face.normal.y; tempNormal.normalZ = (float)face.normal.z;  						tempPosition.positionX = (float)position2.x; tempPosition.positionY = (float)position2.y; tempPosition.positionZ = (float)position2.z;  						textureData.Add(tempTexture);  						normalData.Add(tempNormal);  						positionData.Add(tempPosition);    						textureUV[1] = faceEdge.GetUVs(0);  						position[1] = faceEdge.firstVertex.Position;  					}    					vertexIndex++;  				}  			}
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: if (hardwareWidth != imageWidth || hardwareHeight != imageHeight)  			{  				// we have to put the data on a buffer that GL can handle.  				hardwareExpandedPixelBuffer = new byte[4 * hardwareWidth * hardwareHeight];  				switch (bufferedImage.BitDepth)  				{  					case 32:  						for (int y = 0; y < hardwareHeight; y++)  						{  							for (int x = 0; x < hardwareWidth; x++)  							{  								int pixelIndex = 4 * (x + y * hardwareWidth);  								if (x >= imageWidth || y >= imageHeight)  								{  									hardwareExpandedPixelBuffer[pixelIndex + 0] = 0;  									hardwareExpandedPixelBuffer[pixelIndex + 1] = 0;  									hardwareExpandedPixelBuffer[pixelIndex + 2] = 0;  									hardwareExpandedPixelBuffer[pixelIndex + 3] = 0;  								}  								else  								{  									hardwareExpandedPixelBuffer[pixelIndex + 0] = imageBuffer[4 * (x + y * imageWidth) + 2];  									hardwareExpandedPixelBuffer[pixelIndex + 1] = imageBuffer[4 * (x + y * imageWidth) + 1];  									hardwareExpandedPixelBuffer[pixelIndex + 2] = imageBuffer[4 * (x + y * imageWidth) + 0];  									hardwareExpandedPixelBuffer[pixelIndex + 3] = imageBuffer[4 * (x + y * imageWidth) + 3];  								}  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: if (hardwareWidth != imageWidth || hardwareHeight != imageHeight)  			{  				// we have to put the data on a buffer that GL can handle.  				hardwareExpandedPixelBuffer = new byte[4 * hardwareWidth * hardwareHeight];  				switch (bufferedImage.BitDepth)  				{  					case 32:  						for (int y = 0; y < hardwareHeight; y++)  						{  							for (int x = 0; x < hardwareWidth; x++)  							{  								int pixelIndex = 4 * (x + y * hardwareWidth);  								if (x >= imageWidth || y >= imageHeight)  								{  									hardwareExpandedPixelBuffer[pixelIndex + 0] = 0;  									hardwareExpandedPixelBuffer[pixelIndex + 1] = 0;  									hardwareExpandedPixelBuffer[pixelIndex + 2] = 0;  									hardwareExpandedPixelBuffer[pixelIndex + 3] = 0;  								}  								else  								{  									hardwareExpandedPixelBuffer[pixelIndex + 0] = imageBuffer[4 * (x + y * imageWidth) + 2];  									hardwareExpandedPixelBuffer[pixelIndex + 1] = imageBuffer[4 * (x + y * imageWidth) + 1];  									hardwareExpandedPixelBuffer[pixelIndex + 2] = imageBuffer[4 * (x + y * imageWidth) + 0];  									hardwareExpandedPixelBuffer[pixelIndex + 3] = imageBuffer[4 * (x + y * imageWidth) + 3];  								}  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: if (hardwareWidth != imageWidth || hardwareHeight != imageHeight)  			{  				// we have to put the data on a buffer that GL can handle.  				hardwareExpandedPixelBuffer = new byte[4 * hardwareWidth * hardwareHeight];  				switch (bufferedImage.BitDepth)  				{  					case 32:  						for (int y = 0; y < hardwareHeight; y++)  						{  							for (int x = 0; x < hardwareWidth; x++)  							{  								int pixelIndex = 4 * (x + y * hardwareWidth);  								if (x >= imageWidth || y >= imageHeight)  								{  									hardwareExpandedPixelBuffer[pixelIndex + 0] = 0;  									hardwareExpandedPixelBuffer[pixelIndex + 1] = 0;  									hardwareExpandedPixelBuffer[pixelIndex + 2] = 0;  									hardwareExpandedPixelBuffer[pixelIndex + 3] = 0;  								}  								else  								{  									hardwareExpandedPixelBuffer[pixelIndex + 0] = imageBuffer[4 * (x + y * imageWidth) + 2];  									hardwareExpandedPixelBuffer[pixelIndex + 1] = imageBuffer[4 * (x + y * imageWidth) + 1];  									hardwareExpandedPixelBuffer[pixelIndex + 2] = imageBuffer[4 * (x + y * imageWidth) + 0];  									hardwareExpandedPixelBuffer[pixelIndex + 3] = imageBuffer[4 * (x + y * imageWidth) + 3];  								}  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: if (hardwareWidth != imageWidth || hardwareHeight != imageHeight)  			{  				// we have to put the data on a buffer that GL can handle.  				hardwareExpandedPixelBuffer = new byte[4 * hardwareWidth * hardwareHeight];  				switch (bufferedImage.BitDepth)  				{  					case 32:  						for (int y = 0; y < hardwareHeight; y++)  						{  							for (int x = 0; x < hardwareWidth; x++)  							{  								int pixelIndex = 4 * (x + y * hardwareWidth);  								if (x >= imageWidth || y >= imageHeight)  								{  									hardwareExpandedPixelBuffer[pixelIndex + 0] = 0;  									hardwareExpandedPixelBuffer[pixelIndex + 1] = 0;  									hardwareExpandedPixelBuffer[pixelIndex + 2] = 0;  									hardwareExpandedPixelBuffer[pixelIndex + 3] = 0;  								}  								else  								{  									hardwareExpandedPixelBuffer[pixelIndex + 0] = imageBuffer[4 * (x + y * imageWidth) + 2];  									hardwareExpandedPixelBuffer[pixelIndex + 1] = imageBuffer[4 * (x + y * imageWidth) + 1];  									hardwareExpandedPixelBuffer[pixelIndex + 2] = imageBuffer[4 * (x + y * imageWidth) + 0];  									hardwareExpandedPixelBuffer[pixelIndex + 3] = imageBuffer[4 * (x + y * imageWidth) + 3];  								}  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: if (hardwareWidth != imageWidth || hardwareHeight != imageHeight)  			{  				// we have to put the data on a buffer that GL can handle.  				hardwareExpandedPixelBuffer = new byte[4 * hardwareWidth * hardwareHeight];  				switch (bufferedImage.BitDepth)  				{  					case 32:  						for (int y = 0; y < hardwareHeight; y++)  						{  							for (int x = 0; x < hardwareWidth; x++)  							{  								int pixelIndex = 4 * (x + y * hardwareWidth);  								if (x >= imageWidth || y >= imageHeight)  								{  									hardwareExpandedPixelBuffer[pixelIndex + 0] = 0;  									hardwareExpandedPixelBuffer[pixelIndex + 1] = 0;  									hardwareExpandedPixelBuffer[pixelIndex + 2] = 0;  									hardwareExpandedPixelBuffer[pixelIndex + 3] = 0;  								}  								else  								{  									hardwareExpandedPixelBuffer[pixelIndex + 0] = imageBuffer[4 * (x + y * imageWidth) + 2];  									hardwareExpandedPixelBuffer[pixelIndex + 1] = imageBuffer[4 * (x + y * imageWidth) + 1];  									hardwareExpandedPixelBuffer[pixelIndex + 2] = imageBuffer[4 * (x + y * imageWidth) + 0];  									hardwareExpandedPixelBuffer[pixelIndex + 3] = imageBuffer[4 * (x + y * imageWidth) + 3];  								}  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: if (hardwareWidth != imageWidth || hardwareHeight != imageHeight)  			{  				// we have to put the data on a buffer that GL can handle.  				hardwareExpandedPixelBuffer = new byte[4 * hardwareWidth * hardwareHeight];  				switch (bufferedImage.BitDepth)  				{  					case 32:  						for (int y = 0; y < hardwareHeight; y++)  						{  							for (int x = 0; x < hardwareWidth; x++)  							{  								int pixelIndex = 4 * (x + y * hardwareWidth);  								if (x >= imageWidth || y >= imageHeight)  								{  									hardwareExpandedPixelBuffer[pixelIndex + 0] = 0;  									hardwareExpandedPixelBuffer[pixelIndex + 1] = 0;  									hardwareExpandedPixelBuffer[pixelIndex + 2] = 0;  									hardwareExpandedPixelBuffer[pixelIndex + 3] = 0;  								}  								else  								{  									hardwareExpandedPixelBuffer[pixelIndex + 0] = imageBuffer[4 * (x + y * imageWidth) + 2];  									hardwareExpandedPixelBuffer[pixelIndex + 1] = imageBuffer[4 * (x + y * imageWidth) + 1];  									hardwareExpandedPixelBuffer[pixelIndex + 2] = imageBuffer[4 * (x + y * imageWidth) + 0];  									hardwareExpandedPixelBuffer[pixelIndex + 3] = imageBuffer[4 * (x + y * imageWidth) + 3];  								}  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: if (hardwareWidth != imageWidth || hardwareHeight != imageHeight)  			{  				// we have to put the data on a buffer that GL can handle.  				hardwareExpandedPixelBuffer = new byte[4 * hardwareWidth * hardwareHeight];  				switch (bufferedImage.BitDepth)  				{  					case 32:  						for (int y = 0; y < hardwareHeight; y++)  						{  							for (int x = 0; x < hardwareWidth; x++)  							{  								int pixelIndex = 4 * (x + y * hardwareWidth);  								if (x >= imageWidth || y >= imageHeight)  								{  									hardwareExpandedPixelBuffer[pixelIndex + 0] = 0;  									hardwareExpandedPixelBuffer[pixelIndex + 1] = 0;  									hardwareExpandedPixelBuffer[pixelIndex + 2] = 0;  									hardwareExpandedPixelBuffer[pixelIndex + 3] = 0;  								}  								else  								{  									hardwareExpandedPixelBuffer[pixelIndex + 0] = imageBuffer[4 * (x + y * imageWidth) + 2];  									hardwareExpandedPixelBuffer[pixelIndex + 1] = imageBuffer[4 * (x + y * imageWidth) + 1];  									hardwareExpandedPixelBuffer[pixelIndex + 2] = imageBuffer[4 * (x + y * imageWidth) + 0];  									hardwareExpandedPixelBuffer[pixelIndex + 3] = imageBuffer[4 * (x + y * imageWidth) + 3];  								}  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: if (hardwareWidth != imageWidth || hardwareHeight != imageHeight)  			{  				// we have to put the data on a buffer that GL can handle.  				hardwareExpandedPixelBuffer = new byte[4 * hardwareWidth * hardwareHeight];  				switch (bufferedImage.BitDepth)  				{  					case 32:  						for (int y = 0; y < hardwareHeight; y++)  						{  							for (int x = 0; x < hardwareWidth; x++)  							{  								int pixelIndex = 4 * (x + y * hardwareWidth);  								if (x >= imageWidth || y >= imageHeight)  								{  									hardwareExpandedPixelBuffer[pixelIndex + 0] = 0;  									hardwareExpandedPixelBuffer[pixelIndex + 1] = 0;  									hardwareExpandedPixelBuffer[pixelIndex + 2] = 0;  									hardwareExpandedPixelBuffer[pixelIndex + 3] = 0;  								}  								else  								{  									hardwareExpandedPixelBuffer[pixelIndex + 0] = imageBuffer[4 * (x + y * imageWidth) + 2];  									hardwareExpandedPixelBuffer[pixelIndex + 1] = imageBuffer[4 * (x + y * imageWidth) + 1];  									hardwareExpandedPixelBuffer[pixelIndex + 2] = imageBuffer[4 * (x + y * imageWidth) + 0];  									hardwareExpandedPixelBuffer[pixelIndex + 3] = imageBuffer[4 * (x + y * imageWidth) + 3];  								}  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: if (hardwareWidth != imageWidth || hardwareHeight != imageHeight)  			{  				// we have to put the data on a buffer that GL can handle.  				hardwareExpandedPixelBuffer = new byte[4 * hardwareWidth * hardwareHeight];  				switch (bufferedImage.BitDepth)  				{  					case 32:  						for (int y = 0; y < hardwareHeight; y++)  						{  							for (int x = 0; x < hardwareWidth; x++)  							{  								int pixelIndex = 4 * (x + y * hardwareWidth);  								if (x >= imageWidth || y >= imageHeight)  								{  									hardwareExpandedPixelBuffer[pixelIndex + 0] = 0;  									hardwareExpandedPixelBuffer[pixelIndex + 1] = 0;  									hardwareExpandedPixelBuffer[pixelIndex + 2] = 0;  									hardwareExpandedPixelBuffer[pixelIndex + 3] = 0;  								}  								else  								{  									hardwareExpandedPixelBuffer[pixelIndex + 0] = imageBuffer[4 * (x + y * imageWidth) + 2];  									hardwareExpandedPixelBuffer[pixelIndex + 1] = imageBuffer[4 * (x + y * imageWidth) + 1];  									hardwareExpandedPixelBuffer[pixelIndex + 2] = imageBuffer[4 * (x + y * imageWidth) + 0];  									hardwareExpandedPixelBuffer[pixelIndex + 3] = imageBuffer[4 * (x + y * imageWidth) + 3];  								}  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: if (hardwareWidth != imageWidth || hardwareHeight != imageHeight)  			{  				// we have to put the data on a buffer that GL can handle.  				hardwareExpandedPixelBuffer = new byte[4 * hardwareWidth * hardwareHeight];  				switch (bufferedImage.BitDepth)  				{  					case 32:  						for (int y = 0; y < hardwareHeight; y++)  						{  							for (int x = 0; x < hardwareWidth; x++)  							{  								int pixelIndex = 4 * (x + y * hardwareWidth);  								if (x >= imageWidth || y >= imageHeight)  								{  									hardwareExpandedPixelBuffer[pixelIndex + 0] = 0;  									hardwareExpandedPixelBuffer[pixelIndex + 1] = 0;  									hardwareExpandedPixelBuffer[pixelIndex + 2] = 0;  									hardwareExpandedPixelBuffer[pixelIndex + 3] = 0;  								}  								else  								{  									hardwareExpandedPixelBuffer[pixelIndex + 0] = imageBuffer[4 * (x + y * imageWidth) + 2];  									hardwareExpandedPixelBuffer[pixelIndex + 1] = imageBuffer[4 * (x + y * imageWidth) + 1];  									hardwareExpandedPixelBuffer[pixelIndex + 2] = imageBuffer[4 * (x + y * imageWidth) + 0];  									hardwareExpandedPixelBuffer[pixelIndex + 3] = imageBuffer[4 * (x + y * imageWidth) + 3];  								}  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: if (hardwareWidth != imageWidth || hardwareHeight != imageHeight)  			{  				// we have to put the data on a buffer that GL can handle.  				hardwareExpandedPixelBuffer = new byte[4 * hardwareWidth * hardwareHeight];  				switch (bufferedImage.BitDepth)  				{  					case 32:  						for (int y = 0; y < hardwareHeight; y++)  						{  							for (int x = 0; x < hardwareWidth; x++)  							{  								int pixelIndex = 4 * (x + y * hardwareWidth);  								if (x >= imageWidth || y >= imageHeight)  								{  									hardwareExpandedPixelBuffer[pixelIndex + 0] = 0;  									hardwareExpandedPixelBuffer[pixelIndex + 1] = 0;  									hardwareExpandedPixelBuffer[pixelIndex + 2] = 0;  									hardwareExpandedPixelBuffer[pixelIndex + 3] = 0;  								}  								else  								{  									hardwareExpandedPixelBuffer[pixelIndex + 0] = imageBuffer[4 * (x + y * imageWidth) + 2];  									hardwareExpandedPixelBuffer[pixelIndex + 1] = imageBuffer[4 * (x + y * imageWidth) + 1];  									hardwareExpandedPixelBuffer[pixelIndex + 2] = imageBuffer[4 * (x + y * imageWidth) + 0];  									hardwareExpandedPixelBuffer[pixelIndex + 3] = imageBuffer[4 * (x + y * imageWidth) + 3];  								}  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: if (hardwareWidth != imageWidth || hardwareHeight != imageHeight)  			{  				// we have to put the data on a buffer that GL can handle.  				hardwareExpandedPixelBuffer = new byte[4 * hardwareWidth * hardwareHeight];  				switch (bufferedImage.BitDepth)  				{  					case 32:  						for (int y = 0; y < hardwareHeight; y++)  						{  							for (int x = 0; x < hardwareWidth; x++)  							{  								int pixelIndex = 4 * (x + y * hardwareWidth);  								if (x >= imageWidth || y >= imageHeight)  								{  									hardwareExpandedPixelBuffer[pixelIndex + 0] = 0;  									hardwareExpandedPixelBuffer[pixelIndex + 1] = 0;  									hardwareExpandedPixelBuffer[pixelIndex + 2] = 0;  									hardwareExpandedPixelBuffer[pixelIndex + 3] = 0;  								}  								else  								{  									hardwareExpandedPixelBuffer[pixelIndex + 0] = imageBuffer[4 * (x + y * imageWidth) + 2];  									hardwareExpandedPixelBuffer[pixelIndex + 1] = imageBuffer[4 * (x + y * imageWidth) + 1];  									hardwareExpandedPixelBuffer[pixelIndex + 2] = imageBuffer[4 * (x + y * imageWidth) + 0];  									hardwareExpandedPixelBuffer[pixelIndex + 3] = imageBuffer[4 * (x + y * imageWidth) + 3];  								}  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: if (hardwareWidth != imageWidth || hardwareHeight != imageHeight)  			{  				// we have to put the data on a buffer that GL can handle.  				hardwareExpandedPixelBuffer = new byte[4 * hardwareWidth * hardwareHeight];  				switch (bufferedImage.BitDepth)  				{  					case 32:  						for (int y = 0; y < hardwareHeight; y++)  						{  							for (int x = 0; x < hardwareWidth; x++)  							{  								int pixelIndex = 4 * (x + y * hardwareWidth);  								if (x >= imageWidth || y >= imageHeight)  								{  									hardwareExpandedPixelBuffer[pixelIndex + 0] = 0;  									hardwareExpandedPixelBuffer[pixelIndex + 1] = 0;  									hardwareExpandedPixelBuffer[pixelIndex + 2] = 0;  									hardwareExpandedPixelBuffer[pixelIndex + 3] = 0;  								}  								else  								{  									hardwareExpandedPixelBuffer[pixelIndex + 0] = imageBuffer[4 * (x + y * imageWidth) + 2];  									hardwareExpandedPixelBuffer[pixelIndex + 1] = imageBuffer[4 * (x + y * imageWidth) + 1];  									hardwareExpandedPixelBuffer[pixelIndex + 2] = imageBuffer[4 * (x + y * imageWidth) + 0];  									hardwareExpandedPixelBuffer[pixelIndex + 3] = imageBuffer[4 * (x + y * imageWidth) + 3];  								}  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: switch (bufferedImage.BitDepth)  			{  #if false // not implemented in our gl wrapper and never used in our current code                  case 8:                      GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Luminance' hardwareWidth' hardwareHeight'                          0' PixelFormat.Luminance' PixelType.UnsignedByte' hardwareExpandedPixelBuffer);                      break;                    case 24:                      GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Rgb' hardwareWidth' hardwareHeight'                          0' PixelFormat.Rgb' PixelType.UnsignedByte' hardwareExpandedPixelBuffer);                      break;  #endif    				case 32:  #if __ANDROID__  					GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Rgba' hardwareWidth' hardwareHeight'  						0' PixelFormat.Rgba' PixelType.UnsignedByte' hardwareExpandedPixelBuffer);  #else  					GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Rgba' hardwareWidth' hardwareHeight'  						0' PixelFormat.Bgra' PixelType.UnsignedByte' hardwareExpandedPixelBuffer);  #endif  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: if (createdWithMipMaps)  			{  				switch (bufferedImage.BitDepth)  				{  					case 32:  						{  							ImageBuffer sourceImage = new ImageBuffer(bufferedImage);  							ImageBuffer tempImage = new ImageBuffer(sourceImage.Width / 2' sourceImage.Height / 2);  							tempImage.NewGraphics2D().Render(sourceImage' 0' 0' 0' .5' .5);  							int mipLevel = 1;  							while (sourceImage.Width > 1 && sourceImage.Height > 1)  							{  #if __ANDROID__                                  GL.TexImage2D(TextureTarget.Texture2D' mipLevel++' PixelInternalFormat.Rgba' tempImage.Width' tempImage.Height'  									0' PixelFormat.Rgba' PixelType.UnsignedByte' tempImage.GetBuffer());  #else  								GL.TexImage2D(TextureTarget.Texture2D' mipLevel++' PixelInternalFormat.Rgba' tempImage.Width' tempImage.Height'  									0' PixelFormat.Bgra' PixelType.UnsignedByte' tempImage.GetBuffer());  #endif  								sourceImage = new ImageBuffer(tempImage);  								tempImage = new ImageBuffer(Math.Max(1' sourceImage.Width / 2)' Math.Max(1' sourceImage.Height / 2));  								tempImage.NewGraphics2D().Render(sourceImage' 0' 0'  									0'  									(double)tempImage.Width / (double)sourceImage.Width'  									(double)tempImage.Height / (double)sourceImage.Height);  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: if (createdWithMipMaps)  			{  				switch (bufferedImage.BitDepth)  				{  					case 32:  						{  							ImageBuffer sourceImage = new ImageBuffer(bufferedImage);  							ImageBuffer tempImage = new ImageBuffer(sourceImage.Width / 2' sourceImage.Height / 2);  							tempImage.NewGraphics2D().Render(sourceImage' 0' 0' 0' .5' .5);  							int mipLevel = 1;  							while (sourceImage.Width > 1 && sourceImage.Height > 1)  							{  #if __ANDROID__                                  GL.TexImage2D(TextureTarget.Texture2D' mipLevel++' PixelInternalFormat.Rgba' tempImage.Width' tempImage.Height'  									0' PixelFormat.Rgba' PixelType.UnsignedByte' tempImage.GetBuffer());  #else  								GL.TexImage2D(TextureTarget.Texture2D' mipLevel++' PixelInternalFormat.Rgba' tempImage.Width' tempImage.Height'  									0' PixelFormat.Bgra' PixelType.UnsignedByte' tempImage.GetBuffer());  #endif  								sourceImage = new ImageBuffer(tempImage);  								tempImage = new ImageBuffer(Math.Max(1' sourceImage.Width / 2)' Math.Max(1' sourceImage.Height / 2));  								tempImage.NewGraphics2D().Render(sourceImage' 0' 0'  									0'  									(double)tempImage.Width / (double)sourceImage.Width'  									(double)tempImage.Height / (double)sourceImage.Height);  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: if (createdWithMipMaps)  			{  				switch (bufferedImage.BitDepth)  				{  					case 32:  						{  							ImageBuffer sourceImage = new ImageBuffer(bufferedImage);  							ImageBuffer tempImage = new ImageBuffer(sourceImage.Width / 2' sourceImage.Height / 2);  							tempImage.NewGraphics2D().Render(sourceImage' 0' 0' 0' .5' .5);  							int mipLevel = 1;  							while (sourceImage.Width > 1 && sourceImage.Height > 1)  							{  #if __ANDROID__                                  GL.TexImage2D(TextureTarget.Texture2D' mipLevel++' PixelInternalFormat.Rgba' tempImage.Width' tempImage.Height'  									0' PixelFormat.Rgba' PixelType.UnsignedByte' tempImage.GetBuffer());  #else  								GL.TexImage2D(TextureTarget.Texture2D' mipLevel++' PixelInternalFormat.Rgba' tempImage.Width' tempImage.Height'  									0' PixelFormat.Bgra' PixelType.UnsignedByte' tempImage.GetBuffer());  #endif  								sourceImage = new ImageBuffer(tempImage);  								tempImage = new ImageBuffer(Math.Max(1' sourceImage.Width / 2)' Math.Max(1' sourceImage.Height / 2));  								tempImage.NewGraphics2D().Render(sourceImage' 0' 0'  									0'  									(double)tempImage.Width / (double)sourceImage.Width'  									(double)tempImage.Height / (double)sourceImage.Height);  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: if (createdWithMipMaps)  			{  				switch (bufferedImage.BitDepth)  				{  					case 32:  						{  							ImageBuffer sourceImage = new ImageBuffer(bufferedImage);  							ImageBuffer tempImage = new ImageBuffer(sourceImage.Width / 2' sourceImage.Height / 2);  							tempImage.NewGraphics2D().Render(sourceImage' 0' 0' 0' .5' .5);  							int mipLevel = 1;  							while (sourceImage.Width > 1 && sourceImage.Height > 1)  							{  #if __ANDROID__                                  GL.TexImage2D(TextureTarget.Texture2D' mipLevel++' PixelInternalFormat.Rgba' tempImage.Width' tempImage.Height'  									0' PixelFormat.Rgba' PixelType.UnsignedByte' tempImage.GetBuffer());  #else  								GL.TexImage2D(TextureTarget.Texture2D' mipLevel++' PixelInternalFormat.Rgba' tempImage.Width' tempImage.Height'  									0' PixelFormat.Bgra' PixelType.UnsignedByte' tempImage.GetBuffer());  #endif  								sourceImage = new ImageBuffer(tempImage);  								tempImage = new ImageBuffer(Math.Max(1' sourceImage.Width / 2)' Math.Max(1' sourceImage.Height / 2));  								tempImage.NewGraphics2D().Render(sourceImage' 0' 0'  									0'  									(double)tempImage.Width / (double)sourceImage.Width'  									(double)tempImage.Height / (double)sourceImage.Height);  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: if (createdWithMipMaps)  			{  				switch (bufferedImage.BitDepth)  				{  					case 32:  						{  							ImageBuffer sourceImage = new ImageBuffer(bufferedImage);  							ImageBuffer tempImage = new ImageBuffer(sourceImage.Width / 2' sourceImage.Height / 2);  							tempImage.NewGraphics2D().Render(sourceImage' 0' 0' 0' .5' .5);  							int mipLevel = 1;  							while (sourceImage.Width > 1 && sourceImage.Height > 1)  							{  #if __ANDROID__                                  GL.TexImage2D(TextureTarget.Texture2D' mipLevel++' PixelInternalFormat.Rgba' tempImage.Width' tempImage.Height'  									0' PixelFormat.Rgba' PixelType.UnsignedByte' tempImage.GetBuffer());  #else  								GL.TexImage2D(TextureTarget.Texture2D' mipLevel++' PixelInternalFormat.Rgba' tempImage.Width' tempImage.Height'  									0' PixelFormat.Bgra' PixelType.UnsignedByte' tempImage.GetBuffer());  #endif  								sourceImage = new ImageBuffer(tempImage);  								tempImage = new ImageBuffer(Math.Max(1' sourceImage.Width / 2)' Math.Max(1' sourceImage.Height / 2));  								tempImage.NewGraphics2D().Render(sourceImage' 0' 0'  									0'  									(double)tempImage.Width / (double)sourceImage.Width'  									(double)tempImage.Height / (double)sourceImage.Height);  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: if (createdWithMipMaps)  			{  				switch (bufferedImage.BitDepth)  				{  					case 32:  						{  							ImageBuffer sourceImage = new ImageBuffer(bufferedImage);  							ImageBuffer tempImage = new ImageBuffer(sourceImage.Width / 2' sourceImage.Height / 2);  							tempImage.NewGraphics2D().Render(sourceImage' 0' 0' 0' .5' .5);  							int mipLevel = 1;  							while (sourceImage.Width > 1 && sourceImage.Height > 1)  							{  #if __ANDROID__                                  GL.TexImage2D(TextureTarget.Texture2D' mipLevel++' PixelInternalFormat.Rgba' tempImage.Width' tempImage.Height'  									0' PixelFormat.Rgba' PixelType.UnsignedByte' tempImage.GetBuffer());  #else  								GL.TexImage2D(TextureTarget.Texture2D' mipLevel++' PixelInternalFormat.Rgba' tempImage.Width' tempImage.Height'  									0' PixelFormat.Bgra' PixelType.UnsignedByte' tempImage.GetBuffer());  #endif  								sourceImage = new ImageBuffer(tempImage);  								tempImage = new ImageBuffer(Math.Max(1' sourceImage.Width / 2)' Math.Max(1' sourceImage.Height / 2));  								tempImage.NewGraphics2D().Render(sourceImage' 0' 0'  									0'  									(double)tempImage.Width / (double)sourceImage.Width'  									(double)tempImage.Height / (double)sourceImage.Height);  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: if (createdWithMipMaps)  			{  				switch (bufferedImage.BitDepth)  				{  					case 32:  						{  							ImageBuffer sourceImage = new ImageBuffer(bufferedImage);  							ImageBuffer tempImage = new ImageBuffer(sourceImage.Width / 2' sourceImage.Height / 2);  							tempImage.NewGraphics2D().Render(sourceImage' 0' 0' 0' .5' .5);  							int mipLevel = 1;  							while (sourceImage.Width > 1 && sourceImage.Height > 1)  							{  #if __ANDROID__                                  GL.TexImage2D(TextureTarget.Texture2D' mipLevel++' PixelInternalFormat.Rgba' tempImage.Width' tempImage.Height'  									0' PixelFormat.Rgba' PixelType.UnsignedByte' tempImage.GetBuffer());  #else  								GL.TexImage2D(TextureTarget.Texture2D' mipLevel++' PixelInternalFormat.Rgba' tempImage.Width' tempImage.Height'  									0' PixelFormat.Bgra' PixelType.UnsignedByte' tempImage.GetBuffer());  #endif  								sourceImage = new ImageBuffer(tempImage);  								tempImage = new ImageBuffer(Math.Max(1' sourceImage.Width / 2)' Math.Max(1' sourceImage.Height / 2));  								tempImage.NewGraphics2D().Render(sourceImage' 0' 0'  									0'  									(double)tempImage.Width / (double)sourceImage.Width'  									(double)tempImage.Height / (double)sourceImage.Height);  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: glData.textureUVs = new float[8];
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: glData.positions = new float[8];
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: glData.textureUVs[2] = 0;
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: glData.textureUVs[3] = texCoordY;
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: glData.positions[2] = 0 - OffsetX;
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: glData.positions[3] = imageHeight - OffsetY;
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: glData.textureUVs[4] = texCoordX;
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: glData.textureUVs[5] = texCoordY;
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: glData.positions[4] = imageWidth - OffsetX;
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: glData.positions[5] = imageHeight - OffsetY;
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: glData.textureUVs[6] = texCoordX;
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: glData.textureUVs[7] = 0;
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: glData.positions[6] = imageWidth - OffsetX;
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,CreateGlDataForImage,The following statement contains a magic number: glData.positions[7] = 0 - OffsetY;
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,DrawToGL,The following statement contains a magic number: GL.TexCoord2(glData.textureUVs[2]' glData.textureUVs[3]);
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,DrawToGL,The following statement contains a magic number: GL.TexCoord2(glData.textureUVs[2]' glData.textureUVs[3]);
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,DrawToGL,The following statement contains a magic number: GL.Vertex2(glData.positions[2]' glData.positions[3]);
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,DrawToGL,The following statement contains a magic number: GL.Vertex2(glData.positions[2]' glData.positions[3]);
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,DrawToGL,The following statement contains a magic number: GL.TexCoord2(glData.textureUVs[4]' glData.textureUVs[5]);
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,DrawToGL,The following statement contains a magic number: GL.TexCoord2(glData.textureUVs[4]' glData.textureUVs[5]);
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,DrawToGL,The following statement contains a magic number: GL.Vertex2(glData.positions[4]' glData.positions[5]);
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,DrawToGL,The following statement contains a magic number: GL.Vertex2(glData.positions[4]' glData.positions[5]);
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,DrawToGL,The following statement contains a magic number: GL.TexCoord2(glData.textureUVs[6]' glData.textureUVs[7]);
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,DrawToGL,The following statement contains a magic number: GL.TexCoord2(glData.textureUVs[6]' glData.textureUVs[7]);
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,DrawToGL,The following statement contains a magic number: GL.Vertex2(glData.positions[6]' glData.positions[7]);
Magic Number,MatterHackers.RenderOpenGl,ImageGlPlugin,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\ImageGlPlugin.cs,DrawToGL,The following statement contains a magic number: GL.Vertex2(glData.positions[6]' glData.positions[7]);
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\RendererOpenGL.cs,CheckLineImageCache,The following statement contains a magic number: if (AATextureImage == null)  			{  				AATextureImage = new ImageBuffer(1024' 4);  				byte[] hardwarePixelBuffer = AATextureImage.GetBuffer();  				for (int y = 0; y < 4; y++)  				{  					byte alpha = 0;  					for (int x = 0; x < 1024; x++)  					{  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 0] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 1] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 2] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 3] = alpha;  						alpha = 255;  					}  				}  			}
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\RendererOpenGL.cs,CheckLineImageCache,The following statement contains a magic number: if (AATextureImage == null)  			{  				AATextureImage = new ImageBuffer(1024' 4);  				byte[] hardwarePixelBuffer = AATextureImage.GetBuffer();  				for (int y = 0; y < 4; y++)  				{  					byte alpha = 0;  					for (int x = 0; x < 1024; x++)  					{  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 0] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 1] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 2] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 3] = alpha;  						alpha = 255;  					}  				}  			}
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\RendererOpenGL.cs,CheckLineImageCache,The following statement contains a magic number: if (AATextureImage == null)  			{  				AATextureImage = new ImageBuffer(1024' 4);  				byte[] hardwarePixelBuffer = AATextureImage.GetBuffer();  				for (int y = 0; y < 4; y++)  				{  					byte alpha = 0;  					for (int x = 0; x < 1024; x++)  					{  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 0] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 1] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 2] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 3] = alpha;  						alpha = 255;  					}  				}  			}
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\RendererOpenGL.cs,CheckLineImageCache,The following statement contains a magic number: if (AATextureImage == null)  			{  				AATextureImage = new ImageBuffer(1024' 4);  				byte[] hardwarePixelBuffer = AATextureImage.GetBuffer();  				for (int y = 0; y < 4; y++)  				{  					byte alpha = 0;  					for (int x = 0; x < 1024; x++)  					{  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 0] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 1] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 2] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 3] = alpha;  						alpha = 255;  					}  				}  			}
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\RendererOpenGL.cs,CheckLineImageCache,The following statement contains a magic number: if (AATextureImage == null)  			{  				AATextureImage = new ImageBuffer(1024' 4);  				byte[] hardwarePixelBuffer = AATextureImage.GetBuffer();  				for (int y = 0; y < 4; y++)  				{  					byte alpha = 0;  					for (int x = 0; x < 1024; x++)  					{  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 0] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 1] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 2] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 3] = alpha;  						alpha = 255;  					}  				}  			}
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\RendererOpenGL.cs,CheckLineImageCache,The following statement contains a magic number: if (AATextureImage == null)  			{  				AATextureImage = new ImageBuffer(1024' 4);  				byte[] hardwarePixelBuffer = AATextureImage.GetBuffer();  				for (int y = 0; y < 4; y++)  				{  					byte alpha = 0;  					for (int x = 0; x < 1024; x++)  					{  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 0] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 1] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 2] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 3] = alpha;  						alpha = 255;  					}  				}  			}
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\RendererOpenGL.cs,CheckLineImageCache,The following statement contains a magic number: if (AATextureImage == null)  			{  				AATextureImage = new ImageBuffer(1024' 4);  				byte[] hardwarePixelBuffer = AATextureImage.GetBuffer();  				for (int y = 0; y < 4; y++)  				{  					byte alpha = 0;  					for (int x = 0; x < 1024; x++)  					{  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 0] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 1] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 2] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 3] = alpha;  						alpha = 255;  					}  				}  			}
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\RendererOpenGL.cs,CheckLineImageCache,The following statement contains a magic number: if (AATextureImage == null)  			{  				AATextureImage = new ImageBuffer(1024' 4);  				byte[] hardwarePixelBuffer = AATextureImage.GetBuffer();  				for (int y = 0; y < 4; y++)  				{  					byte alpha = 0;  					for (int x = 0; x < 1024; x++)  					{  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 0] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 1] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 2] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 3] = alpha;  						alpha = 255;  					}  				}  			}
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\RendererOpenGL.cs,CheckLineImageCache,The following statement contains a magic number: if (AATextureImage == null)  			{  				AATextureImage = new ImageBuffer(1024' 4);  				byte[] hardwarePixelBuffer = AATextureImage.GetBuffer();  				for (int y = 0; y < 4; y++)  				{  					byte alpha = 0;  					for (int x = 0; x < 1024; x++)  					{  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 0] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 1] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 2] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 3] = alpha;  						alpha = 255;  					}  				}  			}
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\RendererOpenGL.cs,CheckLineImageCache,The following statement contains a magic number: if (AATextureImage == null)  			{  				AATextureImage = new ImageBuffer(1024' 4);  				byte[] hardwarePixelBuffer = AATextureImage.GetBuffer();  				for (int y = 0; y < 4; y++)  				{  					byte alpha = 0;  					for (int x = 0; x < 1024; x++)  					{  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 0] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 1] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 2] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 3] = alpha;  						alpha = 255;  					}  				}  			}
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\RendererOpenGL.cs,CheckLineImageCache,The following statement contains a magic number: if (AATextureImage == null)  			{  				AATextureImage = new ImageBuffer(1024' 4);  				byte[] hardwarePixelBuffer = AATextureImage.GetBuffer();  				for (int y = 0; y < 4; y++)  				{  					byte alpha = 0;  					for (int x = 0; x < 1024; x++)  					{  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 0] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 1] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 2] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 3] = alpha;  						alpha = 255;  					}  				}  			}
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\RendererOpenGL.cs,CheckLineImageCache,The following statement contains a magic number: if (AATextureImage == null)  			{  				AATextureImage = new ImageBuffer(1024' 4);  				byte[] hardwarePixelBuffer = AATextureImage.GetBuffer();  				for (int y = 0; y < 4; y++)  				{  					byte alpha = 0;  					for (int x = 0; x < 1024; x++)  					{  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 0] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 1] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 2] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 3] = alpha;  						alpha = 255;  					}  				}  			}
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\RendererOpenGL.cs,CheckLineImageCache,The following statement contains a magic number: if (AATextureImage == null)  			{  				AATextureImage = new ImageBuffer(1024' 4);  				byte[] hardwarePixelBuffer = AATextureImage.GetBuffer();  				for (int y = 0; y < 4; y++)  				{  					byte alpha = 0;  					for (int x = 0; x < 1024; x++)  					{  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 0] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 1] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 2] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 3] = alpha;  						alpha = 255;  					}  				}  			}
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\RendererOpenGL.cs,CheckLineImageCache,The following statement contains a magic number: if (AATextureImage == null)  			{  				AATextureImage = new ImageBuffer(1024' 4);  				byte[] hardwarePixelBuffer = AATextureImage.GetBuffer();  				for (int y = 0; y < 4; y++)  				{  					byte alpha = 0;  					for (int x = 0; x < 1024; x++)  					{  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 0] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 1] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 2] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 3] = alpha;  						alpha = 255;  					}  				}  			}
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\RendererOpenGL.cs,CheckLineImageCache,The following statement contains a magic number: if (AATextureImage == null)  			{  				AATextureImage = new ImageBuffer(1024' 4);  				byte[] hardwarePixelBuffer = AATextureImage.GetBuffer();  				for (int y = 0; y < 4; y++)  				{  					byte alpha = 0;  					for (int x = 0; x < 1024; x++)  					{  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 0] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 1] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 2] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 3] = alpha;  						alpha = 255;  					}  				}  			}
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\RendererOpenGL.cs,CheckLineImageCache,The following statement contains a magic number: if (AATextureImage == null)  			{  				AATextureImage = new ImageBuffer(1024' 4);  				byte[] hardwarePixelBuffer = AATextureImage.GetBuffer();  				for (int y = 0; y < 4; y++)  				{  					byte alpha = 0;  					for (int x = 0; x < 1024; x++)  					{  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 0] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 1] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 2] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 3] = alpha;  						alpha = 255;  					}  				}  			}
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\RendererOpenGL.cs,CheckLineImageCache,The following statement contains a magic number: if (AATextureImage == null)  			{  				AATextureImage = new ImageBuffer(1024' 4);  				byte[] hardwarePixelBuffer = AATextureImage.GetBuffer();  				for (int y = 0; y < 4; y++)  				{  					byte alpha = 0;  					for (int x = 0; x < 1024; x++)  					{  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 0] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 1] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 2] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 3] = alpha;  						alpha = 255;  					}  				}  			}
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\RendererOpenGL.cs,CheckLineImageCache,The following statement contains a magic number: if (AATextureImage == null)  			{  				AATextureImage = new ImageBuffer(1024' 4);  				byte[] hardwarePixelBuffer = AATextureImage.GetBuffer();  				for (int y = 0; y < 4; y++)  				{  					byte alpha = 0;  					for (int x = 0; x < 1024; x++)  					{  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 0] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 1] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 2] = 255;  						hardwarePixelBuffer[(y * 1024 + x) * 4 + 3] = alpha;  						alpha = 255;  					}  				}  			}
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\RendererOpenGL.cs,DrawAALine,The following statement contains a magic number: Vector2 widthRightOffset = (end-start).GetPerpendicularRight().GetNormal() * halfWidth/2;
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\RendererOpenGL.cs,DrawAALineRounded,The following statement contains a magic number: Vector2 widthRightOffset = (end - start).GetPerpendicularRight().GetNormal() * halfWidth / 2;
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\RendererOpenGL.cs,DrawAALineRounded,The following statement contains a magic number: int numSegments = 5;
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\RendererOpenGL.cs,DrawAACircle,The following statement contains a magic number: int numSegments = 12;
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\RendererOpenGL.cs,Rectangle,The following statement contains a magic number: if (fastLeft == (int)fastLeft  				&& fastBottom == (int)fastBottom  				&& fastRight == (int)fastRight  				&& fastTop == (int)fastTop)  			{  				// FillRectangle will do the translation so use the original variables  				FillRectangle(left' bottom' right' bottom + 1' color);  				FillRectangle(left' top' right' top - 1' color);    				FillRectangle(left' bottom' left + 1' top' color);  				FillRectangle(right - 1' bottom' right' top' color);  			}  			else  #endif  			{  				RoundedRect rect = new RoundedRect(left + .5' bottom + .5' right - .5' top - .5' 0);  				Stroke rectOutline = new Stroke(rect' strokeWidth);    				Render(rectOutline' color);  			}
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\RendererOpenGL.cs,Rectangle,The following statement contains a magic number: if (fastLeft == (int)fastLeft  				&& fastBottom == (int)fastBottom  				&& fastRight == (int)fastRight  				&& fastTop == (int)fastTop)  			{  				// FillRectangle will do the translation so use the original variables  				FillRectangle(left' bottom' right' bottom + 1' color);  				FillRectangle(left' top' right' top - 1' color);    				FillRectangle(left' bottom' left + 1' top' color);  				FillRectangle(right - 1' bottom' right' top' color);  			}  			else  #endif  			{  				RoundedRect rect = new RoundedRect(left + .5' bottom + .5' right - .5' top - .5' 0);  				Stroke rectOutline = new Stroke(rect' strokeWidth);    				Render(rectOutline' color);  			}
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\RendererOpenGL.cs,Rectangle,The following statement contains a magic number: if (fastLeft == (int)fastLeft  				&& fastBottom == (int)fastBottom  				&& fastRight == (int)fastRight  				&& fastTop == (int)fastTop)  			{  				// FillRectangle will do the translation so use the original variables  				FillRectangle(left' bottom' right' bottom + 1' color);  				FillRectangle(left' top' right' top - 1' color);    				FillRectangle(left' bottom' left + 1' top' color);  				FillRectangle(right - 1' bottom' right' top' color);  			}  			else  #endif  			{  				RoundedRect rect = new RoundedRect(left + .5' bottom + .5' right - .5' top - .5' 0);  				Stroke rectOutline = new Stroke(rect' strokeWidth);    				Render(rectOutline' color);  			}
Magic Number,MatterHackers.RenderOpenGl,Graphics2DOpenGL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\RendererOpenGL.cs,Rectangle,The following statement contains a magic number: if (fastLeft == (int)fastLeft  				&& fastBottom == (int)fastBottom  				&& fastRight == (int)fastRight  				&& fastTop == (int)fastTop)  			{  				// FillRectangle will do the translation so use the original variables  				FillRectangle(left' bottom' right' bottom + 1' color);  				FillRectangle(left' top' right' top - 1' color);    				FillRectangle(left' bottom' left + 1' top' color);  				FillRectangle(right - 1' bottom' right' top' color);  			}  			else  #endif  			{  				RoundedRect rect = new RoundedRect(left + .5' bottom + .5' right - .5' top - .5' 0);  				Stroke rectOutline = new Stroke(rect' strokeWidth);    				Render(rectOutline' color);  			}
Magic Number,MatterHackers.RenderOpenGl,RenderCsgToGl,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderCsgToGl.cs,RenderToGlRecursive,The following statement contains a magic number: RGBA_Floats partColor = new RGBA_Floats(.8' .8' 1);
Magic Number,MatterHackers.RenderOpenGl,RenderCsgToGl,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderCsgToGl.cs,RenderToGlRecursive,The following statement contains a magic number: RGBA_Floats partColor = new RGBA_Floats(.8' .8' 1);
Magic Number,MatterHackers.RenderOpenGl,RenderCsgToGl,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderCsgToGl.cs,CreateBox,The following statement contains a magic number: Vertex[] verts = new Vertex[8];
Magic Number,MatterHackers.RenderOpenGl,RenderCsgToGl,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderCsgToGl.cs,CreateBox,The following statement contains a magic number: verts[2] = cube.CreateVertex(new Vector3(aabb.maxXYZ.x' aabb.maxXYZ.y' aabb.maxXYZ.z));
Magic Number,MatterHackers.RenderOpenGl,RenderCsgToGl,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderCsgToGl.cs,CreateBox,The following statement contains a magic number: verts[3] = cube.CreateVertex(new Vector3(aabb.minXYZ.x' aabb.maxXYZ.y' aabb.maxXYZ.z));
Magic Number,MatterHackers.RenderOpenGl,RenderCsgToGl,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderCsgToGl.cs,CreateBox,The following statement contains a magic number: verts[4] = cube.CreateVertex(new Vector3(aabb.minXYZ.x' aabb.minXYZ.y' aabb.minXYZ.z));
Magic Number,MatterHackers.RenderOpenGl,RenderCsgToGl,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderCsgToGl.cs,CreateBox,The following statement contains a magic number: verts[5] = cube.CreateVertex(new Vector3(aabb.maxXYZ.x' aabb.minXYZ.y' aabb.minXYZ.z));
Magic Number,MatterHackers.RenderOpenGl,RenderCsgToGl,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderCsgToGl.cs,CreateBox,The following statement contains a magic number: verts[6] = cube.CreateVertex(new Vector3(aabb.maxXYZ.x' aabb.maxXYZ.y' aabb.minXYZ.z));
Magic Number,MatterHackers.RenderOpenGl,RenderCsgToGl,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderCsgToGl.cs,CreateBox,The following statement contains a magic number: verts[7] = cube.CreateVertex(new Vector3(aabb.minXYZ.x' aabb.maxXYZ.y' aabb.minXYZ.z));
Magic Number,MatterHackers.RenderOpenGl,RenderCsgToGl,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderCsgToGl.cs,CreateBox,The following statement contains a magic number: cube.CreateFace(new Vertex[] { verts[0]' verts[1]' verts[2]' verts[3] });
Magic Number,MatterHackers.RenderOpenGl,RenderCsgToGl,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderCsgToGl.cs,CreateBox,The following statement contains a magic number: cube.CreateFace(new Vertex[] { verts[0]' verts[1]' verts[2]' verts[3] });
Magic Number,MatterHackers.RenderOpenGl,RenderCsgToGl,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderCsgToGl.cs,CreateBox,The following statement contains a magic number: cube.CreateFace(new Vertex[] { verts[4]' verts[0]' verts[3]' verts[7] });
Magic Number,MatterHackers.RenderOpenGl,RenderCsgToGl,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderCsgToGl.cs,CreateBox,The following statement contains a magic number: cube.CreateFace(new Vertex[] { verts[4]' verts[0]' verts[3]' verts[7] });
Magic Number,MatterHackers.RenderOpenGl,RenderCsgToGl,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderCsgToGl.cs,CreateBox,The following statement contains a magic number: cube.CreateFace(new Vertex[] { verts[4]' verts[0]' verts[3]' verts[7] });
Magic Number,MatterHackers.RenderOpenGl,RenderCsgToGl,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderCsgToGl.cs,CreateBox,The following statement contains a magic number: cube.CreateFace(new Vertex[] { verts[1]' verts[5]' verts[6]' verts[2] });
Magic Number,MatterHackers.RenderOpenGl,RenderCsgToGl,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderCsgToGl.cs,CreateBox,The following statement contains a magic number: cube.CreateFace(new Vertex[] { verts[1]' verts[5]' verts[6]' verts[2] });
Magic Number,MatterHackers.RenderOpenGl,RenderCsgToGl,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderCsgToGl.cs,CreateBox,The following statement contains a magic number: cube.CreateFace(new Vertex[] { verts[1]' verts[5]' verts[6]' verts[2] });
Magic Number,MatterHackers.RenderOpenGl,RenderCsgToGl,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderCsgToGl.cs,CreateBox,The following statement contains a magic number: cube.CreateFace(new Vertex[] { verts[4]' verts[7]' verts[6]' verts[5] });
Magic Number,MatterHackers.RenderOpenGl,RenderCsgToGl,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderCsgToGl.cs,CreateBox,The following statement contains a magic number: cube.CreateFace(new Vertex[] { verts[4]' verts[7]' verts[6]' verts[5] });
Magic Number,MatterHackers.RenderOpenGl,RenderCsgToGl,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderCsgToGl.cs,CreateBox,The following statement contains a magic number: cube.CreateFace(new Vertex[] { verts[4]' verts[7]' verts[6]' verts[5] });
Magic Number,MatterHackers.RenderOpenGl,RenderCsgToGl,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderCsgToGl.cs,CreateBox,The following statement contains a magic number: cube.CreateFace(new Vertex[] { verts[4]' verts[7]' verts[6]' verts[5] });
Magic Number,MatterHackers.RenderOpenGl,RenderCsgToGl,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderCsgToGl.cs,CreateBox,The following statement contains a magic number: cube.CreateFace(new Vertex[] { verts[3]' verts[2]' verts[6]' verts[7] });
Magic Number,MatterHackers.RenderOpenGl,RenderCsgToGl,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderCsgToGl.cs,CreateBox,The following statement contains a magic number: cube.CreateFace(new Vertex[] { verts[3]' verts[2]' verts[6]' verts[7] });
Magic Number,MatterHackers.RenderOpenGl,RenderCsgToGl,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderCsgToGl.cs,CreateBox,The following statement contains a magic number: cube.CreateFace(new Vertex[] { verts[3]' verts[2]' verts[6]' verts[7] });
Magic Number,MatterHackers.RenderOpenGl,RenderCsgToGl,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderCsgToGl.cs,CreateBox,The following statement contains a magic number: cube.CreateFace(new Vertex[] { verts[3]' verts[2]' verts[6]' verts[7] });
Magic Number,MatterHackers.RenderOpenGl,RenderCsgToGl,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderCsgToGl.cs,CreateBox,The following statement contains a magic number: cube.CreateFace(new Vertex[] { verts[4]' verts[5]' verts[1]' verts[0] });
Magic Number,MatterHackers.RenderOpenGl,RenderCsgToGl,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderCsgToGl.cs,CreateBox,The following statement contains a magic number: cube.CreateFace(new Vertex[] { verts[4]' verts[5]' verts[1]' verts[0] });
Magic Number,MatterHackers.RenderOpenGl,RenderCsgToGl,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderCsgToGl.cs,RenderToGlRecursive,The following statement contains a magic number: RGBA_Floats partColor = new RGBA_Floats(.8' .8' 1);
Magic Number,MatterHackers.RenderOpenGl,RenderCsgToGl,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderCsgToGl.cs,RenderToGlRecursive,The following statement contains a magic number: RGBA_Floats partColor = new RGBA_Floats(.8' .8' 1);
Magic Number,MatterHackers.RenderOpenGl,RenderCsgToGl,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderCsgToGl.cs,CreateCylinder,The following statement contains a magic number: int count = 20;
Magic Number,MatterHackers.RenderOpenGl,RenderCsgToGl,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderCsgToGl.cs,CreateCylinder,The following statement contains a magic number: for (int i = 0; i < count; i++)  			{  				Vector2 bottomRadialPos = Vector2.Rotate(new Vector2(cylinderToMeasure.Radius1' 0)' MathHelper.Tau * i / 20);  				Vertex bottomVertex = cylinder.CreateVertex(new Vector3(bottomRadialPos.x' bottomRadialPos.y' -cylinderToMeasure.Height / 2));  				bottomVerts.Add(bottomVertex);  				Vector2 topRadialPos = Vector2.Rotate(new Vector2(cylinderToMeasure.Radius1' 0)' MathHelper.Tau * i / 20);  				Vertex topVertex = cylinder.CreateVertex(new Vector3(topRadialPos.x' topRadialPos.y' cylinderToMeasure.Height / 2));  				topVerts.Add(topVertex);  			}
Magic Number,MatterHackers.RenderOpenGl,RenderCsgToGl,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderCsgToGl.cs,CreateCylinder,The following statement contains a magic number: for (int i = 0; i < count; i++)  			{  				Vector2 bottomRadialPos = Vector2.Rotate(new Vector2(cylinderToMeasure.Radius1' 0)' MathHelper.Tau * i / 20);  				Vertex bottomVertex = cylinder.CreateVertex(new Vector3(bottomRadialPos.x' bottomRadialPos.y' -cylinderToMeasure.Height / 2));  				bottomVerts.Add(bottomVertex);  				Vector2 topRadialPos = Vector2.Rotate(new Vector2(cylinderToMeasure.Radius1' 0)' MathHelper.Tau * i / 20);  				Vertex topVertex = cylinder.CreateVertex(new Vector3(topRadialPos.x' topRadialPos.y' cylinderToMeasure.Height / 2));  				topVerts.Add(topVertex);  			}
Magic Number,MatterHackers.RenderOpenGl,RenderCsgToGl,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderCsgToGl.cs,CreateCylinder,The following statement contains a magic number: for (int i = 0; i < count; i++)  			{  				Vector2 bottomRadialPos = Vector2.Rotate(new Vector2(cylinderToMeasure.Radius1' 0)' MathHelper.Tau * i / 20);  				Vertex bottomVertex = cylinder.CreateVertex(new Vector3(bottomRadialPos.x' bottomRadialPos.y' -cylinderToMeasure.Height / 2));  				bottomVerts.Add(bottomVertex);  				Vector2 topRadialPos = Vector2.Rotate(new Vector2(cylinderToMeasure.Radius1' 0)' MathHelper.Tau * i / 20);  				Vertex topVertex = cylinder.CreateVertex(new Vector3(topRadialPos.x' topRadialPos.y' cylinderToMeasure.Height / 2));  				topVerts.Add(topVertex);  			}
Magic Number,MatterHackers.RenderOpenGl,RenderCsgToGl,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderCsgToGl.cs,CreateCylinder,The following statement contains a magic number: for (int i = 0; i < count; i++)  			{  				Vector2 bottomRadialPos = Vector2.Rotate(new Vector2(cylinderToMeasure.Radius1' 0)' MathHelper.Tau * i / 20);  				Vertex bottomVertex = cylinder.CreateVertex(new Vector3(bottomRadialPos.x' bottomRadialPos.y' -cylinderToMeasure.Height / 2));  				bottomVerts.Add(bottomVertex);  				Vector2 topRadialPos = Vector2.Rotate(new Vector2(cylinderToMeasure.Radius1' 0)' MathHelper.Tau * i / 20);  				Vertex topVertex = cylinder.CreateVertex(new Vector3(topRadialPos.x' topRadialPos.y' cylinderToMeasure.Height / 2));  				topVerts.Add(topVertex);  			}
Magic Number,MatterHackers.RenderOpenGl,RenderCsgToGl,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderCsgToGl.cs,RenderToGlRecursive,The following statement contains a magic number: RGBA_Floats partColor = new RGBA_Floats(.8' .8' 1);
Magic Number,MatterHackers.RenderOpenGl,RenderCsgToGl,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderCsgToGl.cs,RenderToGlRecursive,The following statement contains a magic number: RGBA_Floats partColor = new RGBA_Floats(.8' .8' 1);
Magic Number,MatterHackers.RenderOpenGl,AARenderToGLTesselator,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\AARenderToGLTesselator.cs,DrawNonAATriangle,The following statement contains a magic number: GL.TexCoord2(.2' .25);
Magic Number,MatterHackers.RenderOpenGl,AARenderToGLTesselator,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\AARenderToGLTesselator.cs,DrawNonAATriangle,The following statement contains a magic number: GL.TexCoord2(.2' .25);
Magic Number,MatterHackers.RenderOpenGl,AARenderToGLTesselator,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\AARenderToGLTesselator.cs,DrawNonAATriangle,The following statement contains a magic number: GL.TexCoord2(.2' .75);
Magic Number,MatterHackers.RenderOpenGl,AARenderToGLTesselator,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\AARenderToGLTesselator.cs,DrawNonAATriangle,The following statement contains a magic number: GL.TexCoord2(.2' .75);
Magic Number,MatterHackers.RenderOpenGl,AARenderToGLTesselator,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\AARenderToGLTesselator.cs,DrawNonAATriangle,The following statement contains a magic number: GL.TexCoord2(.9' .5);
Magic Number,MatterHackers.RenderOpenGl,AARenderToGLTesselator,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\AARenderToGLTesselator.cs,DrawNonAATriangle,The following statement contains a magic number: GL.TexCoord2(.9' .5);
Magic Number,MatterHackers.RenderOpenGl,AARenderToGLTesselator,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\AARenderToGLTesselator.cs,Draw1EdgeTriangle,The following statement contains a magic number: Vector2 texP0 = new Vector2(1 / 1023.0' .25);
Magic Number,MatterHackers.RenderOpenGl,AARenderToGLTesselator,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\AARenderToGLTesselator.cs,Draw1EdgeTriangle,The following statement contains a magic number: Vector2 texP0 = new Vector2(1 / 1023.0' .25);
Magic Number,MatterHackers.RenderOpenGl,AARenderToGLTesselator,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\AARenderToGLTesselator.cs,Draw1EdgeTriangle,The following statement contains a magic number: Vector2 texP1 = new Vector2(1 / 1023.0' .75);
Magic Number,MatterHackers.RenderOpenGl,AARenderToGLTesselator,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\AARenderToGLTesselator.cs,Draw1EdgeTriangle,The following statement contains a magic number: Vector2 texP1 = new Vector2(1 / 1023.0' .75);
Magic Number,MatterHackers.RenderOpenGl,AARenderToGLTesselator,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\AARenderToGLTesselator.cs,Draw1EdgeTriangle,The following statement contains a magic number: Vector2 texP2 = new Vector2((1 + edgeDotP3) / 1023.0' .25);
Magic Number,MatterHackers.RenderOpenGl,AARenderToGLTesselator,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\AARenderToGLTesselator.cs,Draw1EdgeTriangle,The following statement contains a magic number: Vector2 texP2 = new Vector2((1 + edgeDotP3) / 1023.0' .25);
Magic Number,MatterHackers.RenderOpenGl,AARenderToGLTesselator,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\AARenderToGLTesselator.cs,Draw1EdgeTriangle,The following statement contains a magic number: Vector2 texEdgeP0Offset = new Vector2(0' .25);
Magic Number,MatterHackers.RenderOpenGl,AARenderToGLTesselator,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\AARenderToGLTesselator.cs,Draw1EdgeTriangle,The following statement contains a magic number: Vector2 texEdgeP1Offset = new Vector2(0' .75);
Magic Number,MatterHackers.RenderOpenGl,AARenderToGLTesselator,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\AARenderToGLTesselator.cs,Draw2EdgeTriangle,The following statement contains a magic number: centerPoint /= 3;
Magic Number,MatterHackers.RenderOpenGl,AARenderToGLTesselator,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\AARenderToGLTesselator.cs,Draw3EdgeTriangle,The following statement contains a magic number: centerPoint /= 3;
Magic Number,MatterHackers.RenderOpenGl,AARenderToGLTesselator,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\AARenderToGLTesselator.cs,RenderLastToGL,The following statement contains a magic number: for (int i = 0; i < numIndicies; i += 3)  			{  				Vector2 v0 = VerticesCache[IndicesCache[i + 0].Index].Position;  				Vector2 v1 = VerticesCache[IndicesCache[i + 1].Index].Position;  				Vector2 v2 = VerticesCache[IndicesCache[i + 2].Index].Position;  				if (v0 == v1 || v1 == v2 || v2 == v0)  				{  					continue;  				}    				int e0 = IndicesCache[i + 0].IsEdge ? 1 : 0;  				int e1 = IndicesCache[i + 1].IsEdge ? 1 : 0;  				int e2 = IndicesCache[i + 2].IsEdge ? 1 : 0;  				switch (e0 + e1 + e2)  				{  					case 0:  						DrawNonAATriangle(v0' v1' v2);  						break;    					case 1:  						if (e0 == 1)  						{  							Draw1EdgeTriangle(v0' v1' v2);  						}  						else if (e1 == 1)  						{  							Draw1EdgeTriangle(v1' v2' v0);  						}  						else  						{  							Draw1EdgeTriangle(v2' v0' v1);  						}  						break;    					case 2:  						if (e0 == 1)  						{  							if (e1 == 1)  							{  								Draw2EdgeTriangle(v0' v1' v2);  							}  							else  							{  								Draw2EdgeTriangle(v2' v0' v1);  							}  						}  						else  						{  							Draw2EdgeTriangle(v1' v2' v0);  						}  						break;    					case 3:  						Draw3EdgeTriangle(v0' v1' v2);  						break;  				}  			}
Magic Number,MatterHackers.RenderOpenGl,AARenderToGLTesselator,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\AARenderToGLTesselator.cs,RenderLastToGL,The following statement contains a magic number: for (int i = 0; i < numIndicies; i += 3)  			{  				Vector2 v0 = VerticesCache[IndicesCache[i + 0].Index].Position;  				Vector2 v1 = VerticesCache[IndicesCache[i + 1].Index].Position;  				Vector2 v2 = VerticesCache[IndicesCache[i + 2].Index].Position;  				if (v0 == v1 || v1 == v2 || v2 == v0)  				{  					continue;  				}    				int e0 = IndicesCache[i + 0].IsEdge ? 1 : 0;  				int e1 = IndicesCache[i + 1].IsEdge ? 1 : 0;  				int e2 = IndicesCache[i + 2].IsEdge ? 1 : 0;  				switch (e0 + e1 + e2)  				{  					case 0:  						DrawNonAATriangle(v0' v1' v2);  						break;    					case 1:  						if (e0 == 1)  						{  							Draw1EdgeTriangle(v0' v1' v2);  						}  						else if (e1 == 1)  						{  							Draw1EdgeTriangle(v1' v2' v0);  						}  						else  						{  							Draw1EdgeTriangle(v2' v0' v1);  						}  						break;    					case 2:  						if (e0 == 1)  						{  							if (e1 == 1)  							{  								Draw2EdgeTriangle(v0' v1' v2);  							}  							else  							{  								Draw2EdgeTriangle(v2' v0' v1);  							}  						}  						else  						{  							Draw2EdgeTriangle(v1' v2' v0);  						}  						break;    					case 3:  						Draw3EdgeTriangle(v0' v1' v2);  						break;  				}  			}
Magic Number,MatterHackers.RenderOpenGl,AARenderToGLTesselator,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\AARenderToGLTesselator.cs,RenderLastToGL,The following statement contains a magic number: for (int i = 0; i < numIndicies; i += 3)  			{  				Vector2 v0 = VerticesCache[IndicesCache[i + 0].Index].Position;  				Vector2 v1 = VerticesCache[IndicesCache[i + 1].Index].Position;  				Vector2 v2 = VerticesCache[IndicesCache[i + 2].Index].Position;  				if (v0 == v1 || v1 == v2 || v2 == v0)  				{  					continue;  				}    				int e0 = IndicesCache[i + 0].IsEdge ? 1 : 0;  				int e1 = IndicesCache[i + 1].IsEdge ? 1 : 0;  				int e2 = IndicesCache[i + 2].IsEdge ? 1 : 0;  				switch (e0 + e1 + e2)  				{  					case 0:  						DrawNonAATriangle(v0' v1' v2);  						break;    					case 1:  						if (e0 == 1)  						{  							Draw1EdgeTriangle(v0' v1' v2);  						}  						else if (e1 == 1)  						{  							Draw1EdgeTriangle(v1' v2' v0);  						}  						else  						{  							Draw1EdgeTriangle(v2' v0' v1);  						}  						break;    					case 2:  						if (e0 == 1)  						{  							if (e1 == 1)  							{  								Draw2EdgeTriangle(v0' v1' v2);  							}  							else  							{  								Draw2EdgeTriangle(v2' v0' v1);  							}  						}  						else  						{  							Draw2EdgeTriangle(v1' v2' v0);  						}  						break;    					case 3:  						Draw3EdgeTriangle(v0' v1' v2);  						break;  				}  			}
Magic Number,MatterHackers.RenderOpenGl,AARenderToGLTesselator,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\AARenderToGLTesselator.cs,RenderLastToGL,The following statement contains a magic number: for (int i = 0; i < numIndicies; i += 3)  			{  				Vector2 v0 = VerticesCache[IndicesCache[i + 0].Index].Position;  				Vector2 v1 = VerticesCache[IndicesCache[i + 1].Index].Position;  				Vector2 v2 = VerticesCache[IndicesCache[i + 2].Index].Position;  				if (v0 == v1 || v1 == v2 || v2 == v0)  				{  					continue;  				}    				int e0 = IndicesCache[i + 0].IsEdge ? 1 : 0;  				int e1 = IndicesCache[i + 1].IsEdge ? 1 : 0;  				int e2 = IndicesCache[i + 2].IsEdge ? 1 : 0;  				switch (e0 + e1 + e2)  				{  					case 0:  						DrawNonAATriangle(v0' v1' v2);  						break;    					case 1:  						if (e0 == 1)  						{  							Draw1EdgeTriangle(v0' v1' v2);  						}  						else if (e1 == 1)  						{  							Draw1EdgeTriangle(v1' v2' v0);  						}  						else  						{  							Draw1EdgeTriangle(v2' v0' v1);  						}  						break;    					case 2:  						if (e0 == 1)  						{  							if (e1 == 1)  							{  								Draw2EdgeTriangle(v0' v1' v2);  							}  							else  							{  								Draw2EdgeTriangle(v2' v0' v1);  							}  						}  						else  						{  							Draw2EdgeTriangle(v1' v2' v0);  						}  						break;    					case 3:  						Draw3EdgeTriangle(v0' v1' v2);  						break;  				}  			}
Magic Number,MatterHackers.RenderOpenGl,AARenderToGLTesselator,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\AARenderToGLTesselator.cs,RenderLastToGL,The following statement contains a magic number: for (int i = 0; i < numIndicies; i += 3)  			{  				Vector2 v0 = VerticesCache[IndicesCache[i + 0].Index].Position;  				Vector2 v1 = VerticesCache[IndicesCache[i + 1].Index].Position;  				Vector2 v2 = VerticesCache[IndicesCache[i + 2].Index].Position;  				if (v0 == v1 || v1 == v2 || v2 == v0)  				{  					continue;  				}    				int e0 = IndicesCache[i + 0].IsEdge ? 1 : 0;  				int e1 = IndicesCache[i + 1].IsEdge ? 1 : 0;  				int e2 = IndicesCache[i + 2].IsEdge ? 1 : 0;  				switch (e0 + e1 + e2)  				{  					case 0:  						DrawNonAATriangle(v0' v1' v2);  						break;    					case 1:  						if (e0 == 1)  						{  							Draw1EdgeTriangle(v0' v1' v2);  						}  						else if (e1 == 1)  						{  							Draw1EdgeTriangle(v1' v2' v0);  						}  						else  						{  							Draw1EdgeTriangle(v2' v0' v1);  						}  						break;    					case 2:  						if (e0 == 1)  						{  							if (e1 == 1)  							{  								Draw2EdgeTriangle(v0' v1' v2);  							}  							else  							{  								Draw2EdgeTriangle(v2' v0' v1);  							}  						}  						else  						{  							Draw2EdgeTriangle(v1' v2' v0);  						}  						break;    					case 3:  						Draw3EdgeTriangle(v0' v1' v2);  						break;  				}  			}
Magic Number,MatterHackers.RenderOpenGl,RenderToGLTesselator,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\RenderToGLTesselator.cs,AddVertex,The following statement contains a magic number: double[] coords = new double[2];
Magic Number,MatterHackers.RenderOpenGl,RenderMeshToGl,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderMeshToGl.cs,DrawToGL,The following statement contains a magic number: for (int i = 0; i < glMeshPlugin.subMeshs.Count; i++)  			{  				SubTriangleMesh subMesh = glMeshPlugin.subMeshs[i];  				// Make sure the GLMeshPlugin has a reference to hold onto the image so it does not go away before this.  				if (subMesh.texture != null)  				{  					ImageGlPlugin glPlugin = ImageGlPlugin.GetImageGlPlugin(subMesh.texture' true);  					GL.Enable(EnableCap.Texture2D);  					GL.BindTexture(TextureTarget.Texture2D' glPlugin.GLTextureHandle);  					GL.EnableClientState(ArrayCap.TextureCoordArray);  				}  				else  				{  					GL.Disable(EnableCap.Texture2D);  					GL.DisableClientState(ArrayCap.TextureCoordArray);  				}    #if true  				GL.EnableClientState(ArrayCap.NormalArray);  				GL.EnableClientState(ArrayCap.VertexArray);  				unsafe  				{  					fixed (VertexTextureData* pTextureData = subMesh.textrueData.Array)  					{  						fixed (VertexNormalData* pNormalData = subMesh.normalData.Array)  						{  							fixed (VertexPositionData* pPosition = subMesh.positionData.Array)  							{  								GL.TexCoordPointer(2' TexCordPointerType.Float' 0' new IntPtr(pTextureData));  								GL.NormalPointer(NormalPointerType.Float' 0' new IntPtr(pNormalData));  								GL.VertexPointer(3' VertexPointerType.Float' 0' new IntPtr(pPosition));  								GL.DrawArrays(BeginMode.Triangles' 0' subMesh.positionData.Count);  							}  						}  					}  				}  #else                  GL.InterleavedArrays(InterleavedArrayFormat.T2fN3fV3f' 0' subMesh.vertexDatas.Array);                  if (subMesh.texture != null)                  {                      //GL.TexCoordPointer(2' TexCoordPointerType.Float' VertexData.Stride' subMesh.vertexDatas.Array);                      //GL.EnableClientState(ArrayCap.TextureCoordArray);                  }                  else                  {                      GL.DisableClientState(ArrayCap.TextureCoordArray);                  }  #endif    				GL.DisableClientState(ArrayCap.NormalArray);  				GL.DisableClientState(ArrayCap.VertexArray);  				GL.DisableClientState(ArrayCap.TextureCoordArray);    				GL.TexCoordPointer(2' TexCordPointerType.Float' 0' new IntPtr(0));  				GL.NormalPointer(NormalPointerType.Float' 0' new IntPtr(0));  				GL.VertexPointer(3' VertexPointerType.Float' 0' new IntPtr(0));    				if (subMesh.texture != null)  				{  					GL.DisableClientState(ArrayCap.TextureCoordArray);  				}  			}
Magic Number,MatterHackers.RenderOpenGl,RenderMeshToGl,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderMeshToGl.cs,DrawToGL,The following statement contains a magic number: for (int i = 0; i < glMeshPlugin.subMeshs.Count; i++)  			{  				SubTriangleMesh subMesh = glMeshPlugin.subMeshs[i];  				// Make sure the GLMeshPlugin has a reference to hold onto the image so it does not go away before this.  				if (subMesh.texture != null)  				{  					ImageGlPlugin glPlugin = ImageGlPlugin.GetImageGlPlugin(subMesh.texture' true);  					GL.Enable(EnableCap.Texture2D);  					GL.BindTexture(TextureTarget.Texture2D' glPlugin.GLTextureHandle);  					GL.EnableClientState(ArrayCap.TextureCoordArray);  				}  				else  				{  					GL.Disable(EnableCap.Texture2D);  					GL.DisableClientState(ArrayCap.TextureCoordArray);  				}    #if true  				GL.EnableClientState(ArrayCap.NormalArray);  				GL.EnableClientState(ArrayCap.VertexArray);  				unsafe  				{  					fixed (VertexTextureData* pTextureData = subMesh.textrueData.Array)  					{  						fixed (VertexNormalData* pNormalData = subMesh.normalData.Array)  						{  							fixed (VertexPositionData* pPosition = subMesh.positionData.Array)  							{  								GL.TexCoordPointer(2' TexCordPointerType.Float' 0' new IntPtr(pTextureData));  								GL.NormalPointer(NormalPointerType.Float' 0' new IntPtr(pNormalData));  								GL.VertexPointer(3' VertexPointerType.Float' 0' new IntPtr(pPosition));  								GL.DrawArrays(BeginMode.Triangles' 0' subMesh.positionData.Count);  							}  						}  					}  				}  #else                  GL.InterleavedArrays(InterleavedArrayFormat.T2fN3fV3f' 0' subMesh.vertexDatas.Array);                  if (subMesh.texture != null)                  {                      //GL.TexCoordPointer(2' TexCoordPointerType.Float' VertexData.Stride' subMesh.vertexDatas.Array);                      //GL.EnableClientState(ArrayCap.TextureCoordArray);                  }                  else                  {                      GL.DisableClientState(ArrayCap.TextureCoordArray);                  }  #endif    				GL.DisableClientState(ArrayCap.NormalArray);  				GL.DisableClientState(ArrayCap.VertexArray);  				GL.DisableClientState(ArrayCap.TextureCoordArray);    				GL.TexCoordPointer(2' TexCordPointerType.Float' 0' new IntPtr(0));  				GL.NormalPointer(NormalPointerType.Float' 0' new IntPtr(0));  				GL.VertexPointer(3' VertexPointerType.Float' 0' new IntPtr(0));    				if (subMesh.texture != null)  				{  					GL.DisableClientState(ArrayCap.TextureCoordArray);  				}  			}
Magic Number,MatterHackers.RenderOpenGl,RenderMeshToGl,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderMeshToGl.cs,DrawToGL,The following statement contains a magic number: for (int i = 0; i < glMeshPlugin.subMeshs.Count; i++)  			{  				SubTriangleMesh subMesh = glMeshPlugin.subMeshs[i];  				// Make sure the GLMeshPlugin has a reference to hold onto the image so it does not go away before this.  				if (subMesh.texture != null)  				{  					ImageGlPlugin glPlugin = ImageGlPlugin.GetImageGlPlugin(subMesh.texture' true);  					GL.Enable(EnableCap.Texture2D);  					GL.BindTexture(TextureTarget.Texture2D' glPlugin.GLTextureHandle);  					GL.EnableClientState(ArrayCap.TextureCoordArray);  				}  				else  				{  					GL.Disable(EnableCap.Texture2D);  					GL.DisableClientState(ArrayCap.TextureCoordArray);  				}    #if true  				GL.EnableClientState(ArrayCap.NormalArray);  				GL.EnableClientState(ArrayCap.VertexArray);  				unsafe  				{  					fixed (VertexTextureData* pTextureData = subMesh.textrueData.Array)  					{  						fixed (VertexNormalData* pNormalData = subMesh.normalData.Array)  						{  							fixed (VertexPositionData* pPosition = subMesh.positionData.Array)  							{  								GL.TexCoordPointer(2' TexCordPointerType.Float' 0' new IntPtr(pTextureData));  								GL.NormalPointer(NormalPointerType.Float' 0' new IntPtr(pNormalData));  								GL.VertexPointer(3' VertexPointerType.Float' 0' new IntPtr(pPosition));  								GL.DrawArrays(BeginMode.Triangles' 0' subMesh.positionData.Count);  							}  						}  					}  				}  #else                  GL.InterleavedArrays(InterleavedArrayFormat.T2fN3fV3f' 0' subMesh.vertexDatas.Array);                  if (subMesh.texture != null)                  {                      //GL.TexCoordPointer(2' TexCoordPointerType.Float' VertexData.Stride' subMesh.vertexDatas.Array);                      //GL.EnableClientState(ArrayCap.TextureCoordArray);                  }                  else                  {                      GL.DisableClientState(ArrayCap.TextureCoordArray);                  }  #endif    				GL.DisableClientState(ArrayCap.NormalArray);  				GL.DisableClientState(ArrayCap.VertexArray);  				GL.DisableClientState(ArrayCap.TextureCoordArray);    				GL.TexCoordPointer(2' TexCordPointerType.Float' 0' new IntPtr(0));  				GL.NormalPointer(NormalPointerType.Float' 0' new IntPtr(0));  				GL.VertexPointer(3' VertexPointerType.Float' 0' new IntPtr(0));    				if (subMesh.texture != null)  				{  					GL.DisableClientState(ArrayCap.TextureCoordArray);  				}  			}
Magic Number,MatterHackers.RenderOpenGl,RenderMeshToGl,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderMeshToGl.cs,DrawToGL,The following statement contains a magic number: for (int i = 0; i < glMeshPlugin.subMeshs.Count; i++)  			{  				SubTriangleMesh subMesh = glMeshPlugin.subMeshs[i];  				// Make sure the GLMeshPlugin has a reference to hold onto the image so it does not go away before this.  				if (subMesh.texture != null)  				{  					ImageGlPlugin glPlugin = ImageGlPlugin.GetImageGlPlugin(subMesh.texture' true);  					GL.Enable(EnableCap.Texture2D);  					GL.BindTexture(TextureTarget.Texture2D' glPlugin.GLTextureHandle);  					GL.EnableClientState(ArrayCap.TextureCoordArray);  				}  				else  				{  					GL.Disable(EnableCap.Texture2D);  					GL.DisableClientState(ArrayCap.TextureCoordArray);  				}    #if true  				GL.EnableClientState(ArrayCap.NormalArray);  				GL.EnableClientState(ArrayCap.VertexArray);  				unsafe  				{  					fixed (VertexTextureData* pTextureData = subMesh.textrueData.Array)  					{  						fixed (VertexNormalData* pNormalData = subMesh.normalData.Array)  						{  							fixed (VertexPositionData* pPosition = subMesh.positionData.Array)  							{  								GL.TexCoordPointer(2' TexCordPointerType.Float' 0' new IntPtr(pTextureData));  								GL.NormalPointer(NormalPointerType.Float' 0' new IntPtr(pNormalData));  								GL.VertexPointer(3' VertexPointerType.Float' 0' new IntPtr(pPosition));  								GL.DrawArrays(BeginMode.Triangles' 0' subMesh.positionData.Count);  							}  						}  					}  				}  #else                  GL.InterleavedArrays(InterleavedArrayFormat.T2fN3fV3f' 0' subMesh.vertexDatas.Array);                  if (subMesh.texture != null)                  {                      //GL.TexCoordPointer(2' TexCoordPointerType.Float' VertexData.Stride' subMesh.vertexDatas.Array);                      //GL.EnableClientState(ArrayCap.TextureCoordArray);                  }                  else                  {                      GL.DisableClientState(ArrayCap.TextureCoordArray);                  }  #endif    				GL.DisableClientState(ArrayCap.NormalArray);  				GL.DisableClientState(ArrayCap.VertexArray);  				GL.DisableClientState(ArrayCap.TextureCoordArray);    				GL.TexCoordPointer(2' TexCordPointerType.Float' 0' new IntPtr(0));  				GL.NormalPointer(NormalPointerType.Float' 0' new IntPtr(0));  				GL.VertexPointer(3' VertexPointerType.Float' 0' new IntPtr(0));    				if (subMesh.texture != null)  				{  					GL.DisableClientState(ArrayCap.TextureCoordArray);  				}  			}
Magic Number,MatterHackers.RenderOpenGl,RenderMeshToGl,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderMeshToGl.cs,DrawWithWireOverlay,The following statement contains a magic number: GL.Color4(0' 0' 0' 255);
Magic Number,MatterHackers.RenderOpenGl,RenderMeshToGl,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderMeshToGl.cs,DrawWithWireOverlay,The following statement contains a magic number: if (renderType == RenderTypes.Outlines)  			{  				glWireMeshPlugin = GLMeshWirePlugin.Get(meshToRender' MathHelper.Tau / 8);  			}  			else  			{  				glWireMeshPlugin = GLMeshWirePlugin.Get(meshToRender);  			}
Magic Number,MatterHackers.RenderOpenGl,RenderMeshToGl,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderMeshToGl.cs,DrawWithWireOverlay,The following statement contains a magic number: unsafe  			{  				fixed (WireVertexData* pv = edegLines.Array)  				{  					GL.VertexPointer(3' VertexPointerType.Float' 0' new IntPtr(pv));  					GL.DrawArrays(BeginMode.Lines' 0' edegLines.Count);  				}  			}
Duplicate Code,MatterHackers.RenderOpenGl.OpenGl,GL,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\GL.cs,BufferData,The method contains a code clone-set at the following line numbers (starting from the method definition): ((8' 41)' (47' 80))
Missing Default,MatterHackers.RenderOpenGl,AARenderToGLTesselator,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\AARenderToGLTesselator.cs,RenderLastToGL,The following switch statement is missing a default case: switch (e0 + e1 + e2)  				{  					case 0:  						DrawNonAATriangle(v0' v1' v2);  						break;    					case 1:  						if (e0 == 1)  						{  							Draw1EdgeTriangle(v0' v1' v2);  						}  						else if (e1 == 1)  						{  							Draw1EdgeTriangle(v1' v2' v0);  						}  						else  						{  							Draw1EdgeTriangle(v2' v0' v1);  						}  						break;    					case 2:  						if (e0 == 1)  						{  							if (e1 == 1)  							{  								Draw2EdgeTriangle(v0' v1' v2);  							}  							else  							{  								Draw2EdgeTriangle(v2' v0' v1);  							}  						}  						else  						{  							Draw2EdgeTriangle(v1' v2' v0);  						}  						break;    					case 3:  						Draw3EdgeTriangle(v0' v1' v2);  						break;  				}
Missing Default,MatterHackers.RenderOpenGl,RenderToGLTesselator,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\Renderer\RenderToGLTesselator.cs,BeginCallBack,The following switch statement is missing a default case: switch (type)  			{  				case Tesselator.TriangleListType.Triangles:  					GL.Begin(BeginMode.Triangles);  					break;    				case Tesselator.TriangleListType.TriangleFan:  					GL.Begin(BeginMode.TriangleFan);  					break;    				case Tesselator.TriangleListType.TriangleStrip:  					GL.Begin(BeginMode.TriangleStrip);  					break;  			}
Missing Default,MatterHackers.RenderOpenGl,RenderMeshToGl,C:\repos\MatterHackers_agg-sharp\RenderOpenGl\RenderMeshToGl.cs,Render,The following switch statement is missing a default case: switch (renderType)  				{  					case RenderTypes.Hidden:  						break;    					case RenderTypes.Shaded:  						DrawToGL(meshToRender);  						break;    					case RenderTypes.Polygons:  					case RenderTypes.Outlines:  						DrawWithWireOverlay(meshToRender' renderType);  						break;  				}
