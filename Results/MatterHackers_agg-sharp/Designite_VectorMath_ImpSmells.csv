Implementation smell,Namespace,Class,File,Method,Description
Complex Method,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,Invert,Cyclomatic complexity of the method is 16
Long Parameter List,MatterHackers.VectorMath,Vector3Float,C:\repos\MatterHackers_agg-sharp\VectorMath\Vector3Float.cs,BaryCentric,The method has 5 parameters. Parameters: a' b' c' u' v
Long Parameter List,MatterHackers.VectorMath,Vector3Float,C:\repos\MatterHackers_agg-sharp\VectorMath\Vector3Float.cs,BaryCentric,The method has 6 parameters. Parameters: a' b' c' u' v' result
Long Parameter List,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,Matrix4X4,The method has 16 parameters. Parameters: m00' m01' m02' m03' m10' m11' m12' m13' m20' m21' m22' m23' m30' m31' m32' m33
Long Parameter List,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,CreateOrthographic,The method has 5 parameters. Parameters: width' height' zNear' zFar' result
Long Parameter List,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,CreateOrthographicOffCenter,The method has 7 parameters. Parameters: left' right' bottom' top' zNear' zFar' result
Long Parameter List,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,CreateOrthographicOffCenter,The method has 6 parameters. Parameters: left' right' bottom' top' zNear' zFar
Long Parameter List,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,CreatePerspectiveFieldOfView,The method has 5 parameters. Parameters: fovYRadians' aspectWidthOverHeight' zNear' zFar' result
Long Parameter List,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,CreatePerspectiveOffCenter,The method has 7 parameters. Parameters: left' right' bottom' top' zNear' zFar' result
Long Parameter List,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,CreatePerspectiveOffCenter,The method has 6 parameters. Parameters: left' right' bottom' top' zNear' zFar
Long Parameter List,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,LookAt,The method has 9 parameters. Parameters: eyeX' eyeY' eyeZ' targetX' targetY' targetZ' upX' upY' upZ
Long Parameter List,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,Frustum,The method has 6 parameters. Parameters: left' right' bottom' top' near' far
Long Parameter List,MatterHackers.VectorMath,Ray,C:\repos\MatterHackers_agg-sharp\VectorMath\Ray.cs,Ray,The method has 5 parameters. Parameters: origin' directionNormal' minDistanceToConsider' maxDistanceToConsider' intersectionType
Long Parameter List,MatterHackers.VectorMath,Vector2,C:\repos\MatterHackers_agg-sharp\VectorMath\Vector2.cs,BaryCentric,The method has 5 parameters. Parameters: a' b' c' u' v
Long Parameter List,MatterHackers.VectorMath,Vector2,C:\repos\MatterHackers_agg-sharp\VectorMath\Vector2.cs,BaryCentric,The method has 6 parameters. Parameters: a' b' c' u' v' result
Long Parameter List,MatterHackers.VectorMath,Vector3,C:\repos\MatterHackers_agg-sharp\VectorMath\Vector3.cs,BaryCentric,The method has 5 parameters. Parameters: a' b' c' u' v
Long Parameter List,MatterHackers.VectorMath,Vector3,C:\repos\MatterHackers_agg-sharp\VectorMath\Vector3.cs,BaryCentric,The method has 6 parameters. Parameters: a' b' c' u' v' result
Long Parameter List,MatterHackers.VectorMath,Vector4,C:\repos\MatterHackers_agg-sharp\VectorMath\Vector4.cs,BaryCentric,The method has 5 parameters. Parameters: a' b' c' u' v
Long Parameter List,MatterHackers.VectorMath,Vector4,C:\repos\MatterHackers_agg-sharp\VectorMath\Vector4.cs,BaryCentric,The method has 6 parameters. Parameters: a' b' c' u' v' result
Long Statement,MatterHackers.VectorMath,PlaneFloat,C:\repos\MatterHackers_agg-sharp\VectorMath\PlaneFloat.cs,GetDistanceToIntersection,The length of the statement  "			return (distanceToPlaneFromOrigin - Vector3Float.Dot(planeNormal' new Vector3Float(ray.origin))) / normalDotRayDirection; " is 121.
Long Statement,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,CreateFromAxisAngle,The length of the statement  "			result = new Matrix4X4(t * axis.x * axis.x + cos' t * axis.x * axis.y - sin * axis.z' t * axis.x * axis.z + sin * axis.y' 0.0' " is 126.
Long Statement,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,CreateRotation,The length of the statement  "			result.Row0 = new Vector4(t * axis.x * axis.x + cos' t * axis.x * axis.y - sin * axis.z' t * axis.x * axis.z + sin * axis.y' 0.0); " is 130.
Long Statement,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,CreateRotation,The length of the statement  "			result.Row1 = new Vector4(t * axis.x * axis.y + sin * axis.z' t * axis.y * axis.y + cos' t * axis.y * axis.z - sin * axis.x' 0.0); " is 130.
Long Statement,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,CreateRotation,The length of the statement  "			result.Row2 = new Vector4(t * axis.x * axis.z - sin * axis.y' t * axis.y * axis.z + sin * axis.x' t * axis.z * axis.z + cos' 0.0); " is 130.
Long Statement,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,LookAt,The length of the statement  "			// There are lots of examples of look at code on the internet that don't do all these normalizes and also find the position " is 123.
Long Statement,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,LookAt,The length of the statement  "			// through several dot products.  The problem with them is that they have a bit of error in that all the vectors arn't normal and need to be. " is 141.
Long Statement,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetAsFloatArray,The length of the statement  "			contents[8] = (float)Row2[0]; contents[9] = (float)Row2[1]; contents[10] = (float)Row2[2]; contents[11] = (float)Row2[3]; " is 121.
Long Statement,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetAsFloatArray,The length of the statement  "			contents[12] = (float)Row3[0]; contents[13] = (float)Row3[1]; contents[14] = (float)Row3[2]; contents[15] = (float)Row3[3]; " is 123.
Long Statement,MatterHackers.VectorMath,Ray,C:\repos\MatterHackers_agg-sharp\VectorMath\Ray.cs,Intersection,The length of the statement  "			bool withinDistanceToConsider = (minDistFound < ray.maxDistanceToConsider) && (maxDistFound > ray.minDistanceToConsider); " is 121.
Complex Conditional,MatterHackers.VectorMath,AxisAlignedBoundingBox,C:\repos\MatterHackers_agg-sharp\VectorMath\AxisAlignedBoundingBox.cs,Contains,The conditional expression  "this.minXYZ.x <= bounds.minXYZ.x  				&& this.maxXYZ.x >= bounds.maxXYZ.x  				&& this.minXYZ.y <= bounds.minXYZ.y  				&& this.maxXYZ.y >= bounds.maxXYZ.y  				&& this.minXYZ.z <= bounds.minXYZ.z  				&& this.maxXYZ.z >= bounds.maxXYZ.z"  is complex.
Complex Conditional,MatterHackers.VectorMath,Plane,C:\repos\MatterHackers_agg-sharp\VectorMath\Plane.cs,LineHitPlane,The conditional expression  "(distanceToStartFromOrigin < 0 && distanceToEndFromOrigin > 0)  				|| (distanceToStartFromOrigin > 0 && distanceToEndFromOrigin < 0)"  is complex.
Complex Conditional,MatterHackers.VectorMath,Vector3Float,C:\repos\MatterHackers_agg-sharp\VectorMath\Vector3Float.cs,Equals,The conditional expression  "(x < OtherVector.x + ErrorValue && x > OtherVector.x - ErrorValue) &&  				(y < OtherVector.y + ErrorValue && y > OtherVector.y - ErrorValue) &&  				(z < OtherVector.z + ErrorValue && z > OtherVector.z - ErrorValue)"  is complex.
Complex Conditional,MatterHackers.VectorMath,Vector2,C:\repos\MatterHackers_agg-sharp\VectorMath\Vector2.cs,Equals,The conditional expression  "(x < other.x + errorRange && x > other.x - errorRange) &&  				(y < other.y + errorRange && y > other.y - errorRange)"  is complex.
Complex Conditional,MatterHackers.VectorMath,Vector3,C:\repos\MatterHackers_agg-sharp\VectorMath\Vector3.cs,Equals,The conditional expression  "(x < OtherVector.x + ErrorValue && x > OtherVector.x - ErrorValue) &&  				(y < OtherVector.y + ErrorValue && y > OtherVector.y - ErrorValue) &&  				(z < OtherVector.z + ErrorValue && z > OtherVector.z - ErrorValue)"  is complex.
Magic Number,MatterHackers.VectorMath,AxisAlignedBoundingBox,C:\repos\MatterHackers_agg-sharp\VectorMath\AxisAlignedBoundingBox.cs,NewTransformed,The following statement contains a magic number: Vector3[] boundsVerts = new Vector3[8];
Magic Number,MatterHackers.VectorMath,AxisAlignedBoundingBox,C:\repos\MatterHackers_agg-sharp\VectorMath\AxisAlignedBoundingBox.cs,NewTransformed,The following statement contains a magic number: boundsVerts[0] = new Vector3(this[0][0]' this[0][1]' this[0][2]);
Magic Number,MatterHackers.VectorMath,AxisAlignedBoundingBox,C:\repos\MatterHackers_agg-sharp\VectorMath\AxisAlignedBoundingBox.cs,NewTransformed,The following statement contains a magic number: boundsVerts[1] = new Vector3(this[0][0]' this[0][1]' this[1][2]);
Magic Number,MatterHackers.VectorMath,AxisAlignedBoundingBox,C:\repos\MatterHackers_agg-sharp\VectorMath\AxisAlignedBoundingBox.cs,NewTransformed,The following statement contains a magic number: boundsVerts[2] = new Vector3(this[0][0]' this[1][1]' this[0][2]);
Magic Number,MatterHackers.VectorMath,AxisAlignedBoundingBox,C:\repos\MatterHackers_agg-sharp\VectorMath\AxisAlignedBoundingBox.cs,NewTransformed,The following statement contains a magic number: boundsVerts[2] = new Vector3(this[0][0]' this[1][1]' this[0][2]);
Magic Number,MatterHackers.VectorMath,AxisAlignedBoundingBox,C:\repos\MatterHackers_agg-sharp\VectorMath\AxisAlignedBoundingBox.cs,NewTransformed,The following statement contains a magic number: boundsVerts[3] = new Vector3(this[0][0]' this[1][1]' this[1][2]);
Magic Number,MatterHackers.VectorMath,AxisAlignedBoundingBox,C:\repos\MatterHackers_agg-sharp\VectorMath\AxisAlignedBoundingBox.cs,NewTransformed,The following statement contains a magic number: boundsVerts[3] = new Vector3(this[0][0]' this[1][1]' this[1][2]);
Magic Number,MatterHackers.VectorMath,AxisAlignedBoundingBox,C:\repos\MatterHackers_agg-sharp\VectorMath\AxisAlignedBoundingBox.cs,NewTransformed,The following statement contains a magic number: boundsVerts[4] = new Vector3(this[1][0]' this[0][1]' this[0][2]);
Magic Number,MatterHackers.VectorMath,AxisAlignedBoundingBox,C:\repos\MatterHackers_agg-sharp\VectorMath\AxisAlignedBoundingBox.cs,NewTransformed,The following statement contains a magic number: boundsVerts[4] = new Vector3(this[1][0]' this[0][1]' this[0][2]);
Magic Number,MatterHackers.VectorMath,AxisAlignedBoundingBox,C:\repos\MatterHackers_agg-sharp\VectorMath\AxisAlignedBoundingBox.cs,NewTransformed,The following statement contains a magic number: boundsVerts[5] = new Vector3(this[1][0]' this[0][1]' this[1][2]);
Magic Number,MatterHackers.VectorMath,AxisAlignedBoundingBox,C:\repos\MatterHackers_agg-sharp\VectorMath\AxisAlignedBoundingBox.cs,NewTransformed,The following statement contains a magic number: boundsVerts[5] = new Vector3(this[1][0]' this[0][1]' this[1][2]);
Magic Number,MatterHackers.VectorMath,AxisAlignedBoundingBox,C:\repos\MatterHackers_agg-sharp\VectorMath\AxisAlignedBoundingBox.cs,NewTransformed,The following statement contains a magic number: boundsVerts[6] = new Vector3(this[1][0]' this[1][1]' this[0][2]);
Magic Number,MatterHackers.VectorMath,AxisAlignedBoundingBox,C:\repos\MatterHackers_agg-sharp\VectorMath\AxisAlignedBoundingBox.cs,NewTransformed,The following statement contains a magic number: boundsVerts[6] = new Vector3(this[1][0]' this[1][1]' this[0][2]);
Magic Number,MatterHackers.VectorMath,AxisAlignedBoundingBox,C:\repos\MatterHackers_agg-sharp\VectorMath\AxisAlignedBoundingBox.cs,NewTransformed,The following statement contains a magic number: boundsVerts[7] = new Vector3(this[1][0]' this[1][1]' this[1][2]);
Magic Number,MatterHackers.VectorMath,AxisAlignedBoundingBox,C:\repos\MatterHackers_agg-sharp\VectorMath\AxisAlignedBoundingBox.cs,NewTransformed,The following statement contains a magic number: boundsVerts[7] = new Vector3(this[1][0]' this[1][1]' this[1][2]);
Magic Number,MatterHackers.VectorMath,AxisAlignedBoundingBox,C:\repos\MatterHackers_agg-sharp\VectorMath\AxisAlignedBoundingBox.cs,NewTransformed,The following statement contains a magic number: for (int i = 0; i < 8; i++)  			{  				newMin.x = Math.Min(newMin.x' boundsVerts[i].x);  				newMin.y = Math.Min(newMin.y' boundsVerts[i].y);  				newMin.z = Math.Min(newMin.z' boundsVerts[i].z);    				newMax.x = Math.Max(newMax.x' boundsVerts[i].x);  				newMax.y = Math.Max(newMax.y' boundsVerts[i].y);  				newMax.z = Math.Max(newMax.z' boundsVerts[i].z);  			}
Magic Number,MatterHackers.VectorMath,AxisAlignedBoundingBox,C:\repos\MatterHackers_agg-sharp\VectorMath\AxisAlignedBoundingBox.cs,GetBottomCorner,The following statement contains a magic number: switch(quadrantIndex)  			{  				case 0:  					return new Vector3(maxXYZ.x' maxXYZ.y' minXYZ.z);    				case 1:  					return new Vector3(minXYZ.x' maxXYZ.y' minXYZ.z);    				case 2:  					return new Vector3(minXYZ.x' minXYZ.y' minXYZ.z);    				case 3:  					return new Vector3(maxXYZ.x' minXYZ.y' minXYZ.z);  			}
Magic Number,MatterHackers.VectorMath,AxisAlignedBoundingBox,C:\repos\MatterHackers_agg-sharp\VectorMath\AxisAlignedBoundingBox.cs,GetBottomCorner,The following statement contains a magic number: switch(quadrantIndex)  			{  				case 0:  					return new Vector3(maxXYZ.x' maxXYZ.y' minXYZ.z);    				case 1:  					return new Vector3(minXYZ.x' maxXYZ.y' minXYZ.z);    				case 2:  					return new Vector3(minXYZ.x' minXYZ.y' minXYZ.z);    				case 3:  					return new Vector3(maxXYZ.x' minXYZ.y' minXYZ.z);  			}
Magic Number,MatterHackers.VectorMath,AxisAlignedBoundingBox,C:\repos\MatterHackers_agg-sharp\VectorMath\AxisAlignedBoundingBox.cs,GetTopCorner,The following statement contains a magic number: switch (quadrantIndex)  			{  				case 0:  					return new Vector3(maxXYZ.x' maxXYZ.y' maxXYZ.z);    				case 1:  					return new Vector3(minXYZ.x' maxXYZ.y' maxXYZ.z);    				case 2:  					return new Vector3(minXYZ.x' minXYZ.y' maxXYZ.z);    				case 3:  					return new Vector3(maxXYZ.x' minXYZ.y' maxXYZ.z);  			}
Magic Number,MatterHackers.VectorMath,AxisAlignedBoundingBox,C:\repos\MatterHackers_agg-sharp\VectorMath\AxisAlignedBoundingBox.cs,GetTopCorner,The following statement contains a magic number: switch (quadrantIndex)  			{  				case 0:  					return new Vector3(maxXYZ.x' maxXYZ.y' maxXYZ.z);    				case 1:  					return new Vector3(minXYZ.x' maxXYZ.y' maxXYZ.z);    				case 2:  					return new Vector3(minXYZ.x' minXYZ.y' maxXYZ.z);    				case 3:  					return new Vector3(maxXYZ.x' minXYZ.y' maxXYZ.z);  			}
Magic Number,MatterHackers.VectorMath,AxisAlignedBoundingBox,C:\repos\MatterHackers_agg-sharp\VectorMath\AxisAlignedBoundingBox.cs,GetIntersectCost,The following statement contains a magic number: return 132;
Magic Number,MatterHackers.VectorMath,AxisAlignedBoundingBox,C:\repos\MatterHackers_agg-sharp\VectorMath\AxisAlignedBoundingBox.cs,GetCenter,The following statement contains a magic number: return (minXYZ + maxXYZ) * .5;
Magic Number,MatterHackers.VectorMath,AxisAlignedBoundingBox,C:\repos\MatterHackers_agg-sharp\VectorMath\AxisAlignedBoundingBox.cs,GetCenterX,The following statement contains a magic number: return (minXYZ.x + maxXYZ.x) * .5;
Magic Number,MatterHackers.VectorMath,AxisAlignedBoundingBox,C:\repos\MatterHackers_agg-sharp\VectorMath\AxisAlignedBoundingBox.cs,GetSurfaceArea,The following statement contains a magic number: if (surfaceAreaCache == 0)  			{  				double frontAndBack = (maxXYZ.x - minXYZ.x) * (maxXYZ.z - minXYZ.z) * 2;  				double leftAndRight = (maxXYZ.y - minXYZ.y) * (maxXYZ.z - minXYZ.z) * 2;  				double topAndBottom = (maxXYZ.x - minXYZ.x) * (maxXYZ.y - minXYZ.y) * 2;  				surfaceAreaCache = frontAndBack + leftAndRight + topAndBottom;  			}
Magic Number,MatterHackers.VectorMath,AxisAlignedBoundingBox,C:\repos\MatterHackers_agg-sharp\VectorMath\AxisAlignedBoundingBox.cs,GetSurfaceArea,The following statement contains a magic number: if (surfaceAreaCache == 0)  			{  				double frontAndBack = (maxXYZ.x - minXYZ.x) * (maxXYZ.z - minXYZ.z) * 2;  				double leftAndRight = (maxXYZ.y - minXYZ.y) * (maxXYZ.z - minXYZ.z) * 2;  				double topAndBottom = (maxXYZ.x - minXYZ.x) * (maxXYZ.y - minXYZ.y) * 2;  				surfaceAreaCache = frontAndBack + leftAndRight + topAndBottom;  			}
Magic Number,MatterHackers.VectorMath,AxisAlignedBoundingBox,C:\repos\MatterHackers_agg-sharp\VectorMath\AxisAlignedBoundingBox.cs,GetSurfaceArea,The following statement contains a magic number: if (surfaceAreaCache == 0)  			{  				double frontAndBack = (maxXYZ.x - minXYZ.x) * (maxXYZ.z - minXYZ.z) * 2;  				double leftAndRight = (maxXYZ.y - minXYZ.y) * (maxXYZ.z - minXYZ.z) * 2;  				double topAndBottom = (maxXYZ.x - minXYZ.x) * (maxXYZ.y - minXYZ.y) * 2;  				surfaceAreaCache = frontAndBack + leftAndRight + topAndBottom;  			}
Magic Number,MatterHackers.VectorMath,Vector3Float,C:\repos\MatterHackers_agg-sharp\VectorMath\Vector3Float.cs,Vector3Float,The following statement contains a magic number: z = floatArray[2];
Magic Number,MatterHackers.VectorMath,MathHelper,C:\repos\MatterHackers_agg-sharp\VectorMath\MathHelper.cs,NextPowerOfTwo,The following statement contains a magic number: return (long)System.Math.Pow(2' System.Math.Ceiling(System.Math.Log((double)n' 2)));
Magic Number,MatterHackers.VectorMath,MathHelper,C:\repos\MatterHackers_agg-sharp\VectorMath\MathHelper.cs,NextPowerOfTwo,The following statement contains a magic number: return (long)System.Math.Pow(2' System.Math.Ceiling(System.Math.Log((double)n' 2)));
Magic Number,MatterHackers.VectorMath,MathHelper,C:\repos\MatterHackers_agg-sharp\VectorMath\MathHelper.cs,NextPowerOfTwo,The following statement contains a magic number: return (int)System.Math.Pow(2' System.Math.Ceiling(System.Math.Log((double)n' 2)));
Magic Number,MatterHackers.VectorMath,MathHelper,C:\repos\MatterHackers_agg-sharp\VectorMath\MathHelper.cs,NextPowerOfTwo,The following statement contains a magic number: return (int)System.Math.Pow(2' System.Math.Ceiling(System.Math.Log((double)n' 2)));
Magic Number,MatterHackers.VectorMath,MathHelper,C:\repos\MatterHackers_agg-sharp\VectorMath\MathHelper.cs,NextPowerOfTwo,The following statement contains a magic number: return (float)System.Math.Pow(2' System.Math.Ceiling(System.Math.Log((double)n' 2)));
Magic Number,MatterHackers.VectorMath,MathHelper,C:\repos\MatterHackers_agg-sharp\VectorMath\MathHelper.cs,NextPowerOfTwo,The following statement contains a magic number: return (float)System.Math.Pow(2' System.Math.Ceiling(System.Math.Log((double)n' 2)));
Magic Number,MatterHackers.VectorMath,MathHelper,C:\repos\MatterHackers_agg-sharp\VectorMath\MathHelper.cs,NextPowerOfTwo,The following statement contains a magic number: return System.Math.Pow(2' System.Math.Ceiling(System.Math.Log((double)n' 2)));
Magic Number,MatterHackers.VectorMath,MathHelper,C:\repos\MatterHackers_agg-sharp\VectorMath\MathHelper.cs,NextPowerOfTwo,The following statement contains a magic number: return System.Math.Pow(2' System.Math.Ceiling(System.Math.Log((double)n' 2)));
Magic Number,MatterHackers.VectorMath,MathHelper,C:\repos\MatterHackers_agg-sharp\VectorMath\MathHelper.cs,GetDeltaAngle,The following statement contains a magic number: if (DeltaAngle > Tau / 2)  			{  				DeltaAngle -= Tau;  			}
Magic Number,MatterHackers.VectorMath,MathHelper,C:\repos\MatterHackers_agg-sharp\VectorMath\MathHelper.cs,GetDeltaAngle,The following statement contains a magic number: if (DeltaAngle < -Tau / 2)  			{  				DeltaAngle += Tau;  			}
Magic Number,MatterHackers.VectorMath,MathHelper,C:\repos\MatterHackers_agg-sharp\VectorMath\MathHelper.cs,InchesToMm,The following statement contains a magic number: return inches * 25.4;
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,Matrix4X4,The following statement contains a magic number: Row0 = new Vector4(double16[0]' double16[1]' double16[2]' double16[3]);
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,Matrix4X4,The following statement contains a magic number: Row0 = new Vector4(double16[0]' double16[1]' double16[2]' double16[3]);
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,Matrix4X4,The following statement contains a magic number: Row1 = new Vector4(double16[4]' double16[5]' double16[6]' double16[7]);
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,Matrix4X4,The following statement contains a magic number: Row1 = new Vector4(double16[4]' double16[5]' double16[6]' double16[7]);
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,Matrix4X4,The following statement contains a magic number: Row1 = new Vector4(double16[4]' double16[5]' double16[6]' double16[7]);
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,Matrix4X4,The following statement contains a magic number: Row1 = new Vector4(double16[4]' double16[5]' double16[6]' double16[7]);
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,Matrix4X4,The following statement contains a magic number: Row2 = new Vector4(double16[8]' double16[9]' double16[10]' double16[11]);
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,Matrix4X4,The following statement contains a magic number: Row2 = new Vector4(double16[8]' double16[9]' double16[10]' double16[11]);
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,Matrix4X4,The following statement contains a magic number: Row2 = new Vector4(double16[8]' double16[9]' double16[10]' double16[11]);
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,Matrix4X4,The following statement contains a magic number: Row2 = new Vector4(double16[8]' double16[9]' double16[10]' double16[11]);
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,Matrix4X4,The following statement contains a magic number: Row3 = new Vector4(double16[12]' double16[13]' double16[14]' double16[15]);
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,Matrix4X4,The following statement contains a magic number: Row3 = new Vector4(double16[12]' double16[13]' double16[14]' double16[15]);
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,Matrix4X4,The following statement contains a magic number: Row3 = new Vector4(double16[12]' double16[13]' double16[14]' double16[15]);
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,Matrix4X4,The following statement contains a magic number: Row3 = new Vector4(double16[12]' double16[13]' double16[14]' double16[15]);
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetRotation,The following statement contains a magic number: if (tr > 0)  			{  				double S = Math.Sqrt(tr + 1.0) * 2; // S=4*qw  				rotation.W = 0.25 * S;  				rotation.X = (M32 - M23) / S;  				rotation.Y = (M13 - M31) / S;  				rotation.Z = (M21 - M12) / S;  			}  			else if ((M11 > M22) & (M11 > M33))  			{  				double S = Math.Sqrt(1.0 + M11 - M22 - M33) * 2; // S=4*qx  				rotation.W = (M32 - M23) / S;  				rotation.X = 0.25 * S;  				rotation.Y = (M12 + M21) / S;  				rotation.Z = (M13 + M31) / S;  			}  			else if (M22 > M33)  			{  				double S = Math.Sqrt(1.0 + M22 - M11 - M33) * 2; // S=4*qy  				rotation.W = (M13 - M31) / S;  				rotation.X = (M12 + M21) / S;  				rotation.Y = 0.25 * S;  				rotation.Z = (M23 + M32) / S;  			}  			else  			{  				double S = Math.Sqrt(1.0 + M33 - M11 - M22) * 2; // S=4*qz  				rotation.W = (M21 - M12) / S;  				rotation.X = (M13 + M31) / S;  				rotation.Y = (M23 + M32) / S;  				rotation.Z = 0.25 * S;  			}
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetRotation,The following statement contains a magic number: if (tr > 0)  			{  				double S = Math.Sqrt(tr + 1.0) * 2; // S=4*qw  				rotation.W = 0.25 * S;  				rotation.X = (M32 - M23) / S;  				rotation.Y = (M13 - M31) / S;  				rotation.Z = (M21 - M12) / S;  			}  			else if ((M11 > M22) & (M11 > M33))  			{  				double S = Math.Sqrt(1.0 + M11 - M22 - M33) * 2; // S=4*qx  				rotation.W = (M32 - M23) / S;  				rotation.X = 0.25 * S;  				rotation.Y = (M12 + M21) / S;  				rotation.Z = (M13 + M31) / S;  			}  			else if (M22 > M33)  			{  				double S = Math.Sqrt(1.0 + M22 - M11 - M33) * 2; // S=4*qy  				rotation.W = (M13 - M31) / S;  				rotation.X = (M12 + M21) / S;  				rotation.Y = 0.25 * S;  				rotation.Z = (M23 + M32) / S;  			}  			else  			{  				double S = Math.Sqrt(1.0 + M33 - M11 - M22) * 2; // S=4*qz  				rotation.W = (M21 - M12) / S;  				rotation.X = (M13 + M31) / S;  				rotation.Y = (M23 + M32) / S;  				rotation.Z = 0.25 * S;  			}
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetRotation,The following statement contains a magic number: if (tr > 0)  			{  				double S = Math.Sqrt(tr + 1.0) * 2; // S=4*qw  				rotation.W = 0.25 * S;  				rotation.X = (M32 - M23) / S;  				rotation.Y = (M13 - M31) / S;  				rotation.Z = (M21 - M12) / S;  			}  			else if ((M11 > M22) & (M11 > M33))  			{  				double S = Math.Sqrt(1.0 + M11 - M22 - M33) * 2; // S=4*qx  				rotation.W = (M32 - M23) / S;  				rotation.X = 0.25 * S;  				rotation.Y = (M12 + M21) / S;  				rotation.Z = (M13 + M31) / S;  			}  			else if (M22 > M33)  			{  				double S = Math.Sqrt(1.0 + M22 - M11 - M33) * 2; // S=4*qy  				rotation.W = (M13 - M31) / S;  				rotation.X = (M12 + M21) / S;  				rotation.Y = 0.25 * S;  				rotation.Z = (M23 + M32) / S;  			}  			else  			{  				double S = Math.Sqrt(1.0 + M33 - M11 - M22) * 2; // S=4*qz  				rotation.W = (M21 - M12) / S;  				rotation.X = (M13 + M31) / S;  				rotation.Y = (M23 + M32) / S;  				rotation.Z = 0.25 * S;  			}
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetRotation,The following statement contains a magic number: if (tr > 0)  			{  				double S = Math.Sqrt(tr + 1.0) * 2; // S=4*qw  				rotation.W = 0.25 * S;  				rotation.X = (M32 - M23) / S;  				rotation.Y = (M13 - M31) / S;  				rotation.Z = (M21 - M12) / S;  			}  			else if ((M11 > M22) & (M11 > M33))  			{  				double S = Math.Sqrt(1.0 + M11 - M22 - M33) * 2; // S=4*qx  				rotation.W = (M32 - M23) / S;  				rotation.X = 0.25 * S;  				rotation.Y = (M12 + M21) / S;  				rotation.Z = (M13 + M31) / S;  			}  			else if (M22 > M33)  			{  				double S = Math.Sqrt(1.0 + M22 - M11 - M33) * 2; // S=4*qy  				rotation.W = (M13 - M31) / S;  				rotation.X = (M12 + M21) / S;  				rotation.Y = 0.25 * S;  				rotation.Z = (M23 + M32) / S;  			}  			else  			{  				double S = Math.Sqrt(1.0 + M33 - M11 - M22) * 2; // S=4*qz  				rotation.W = (M21 - M12) / S;  				rotation.X = (M13 + M31) / S;  				rotation.Y = (M23 + M32) / S;  				rotation.Z = 0.25 * S;  			}
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetRotation,The following statement contains a magic number: if (tr > 0)  			{  				double S = Math.Sqrt(tr + 1.0) * 2; // S=4*qw  				rotation.W = 0.25 * S;  				rotation.X = (M32 - M23) / S;  				rotation.Y = (M13 - M31) / S;  				rotation.Z = (M21 - M12) / S;  			}  			else if ((M11 > M22) & (M11 > M33))  			{  				double S = Math.Sqrt(1.0 + M11 - M22 - M33) * 2; // S=4*qx  				rotation.W = (M32 - M23) / S;  				rotation.X = 0.25 * S;  				rotation.Y = (M12 + M21) / S;  				rotation.Z = (M13 + M31) / S;  			}  			else if (M22 > M33)  			{  				double S = Math.Sqrt(1.0 + M22 - M11 - M33) * 2; // S=4*qy  				rotation.W = (M13 - M31) / S;  				rotation.X = (M12 + M21) / S;  				rotation.Y = 0.25 * S;  				rotation.Z = (M23 + M32) / S;  			}  			else  			{  				double S = Math.Sqrt(1.0 + M33 - M11 - M22) * 2; // S=4*qz  				rotation.W = (M21 - M12) / S;  				rotation.X = (M13 + M31) / S;  				rotation.Y = (M23 + M32) / S;  				rotation.Z = 0.25 * S;  			}
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetRotation,The following statement contains a magic number: if (tr > 0)  			{  				double S = Math.Sqrt(tr + 1.0) * 2; // S=4*qw  				rotation.W = 0.25 * S;  				rotation.X = (M32 - M23) / S;  				rotation.Y = (M13 - M31) / S;  				rotation.Z = (M21 - M12) / S;  			}  			else if ((M11 > M22) & (M11 > M33))  			{  				double S = Math.Sqrt(1.0 + M11 - M22 - M33) * 2; // S=4*qx  				rotation.W = (M32 - M23) / S;  				rotation.X = 0.25 * S;  				rotation.Y = (M12 + M21) / S;  				rotation.Z = (M13 + M31) / S;  			}  			else if (M22 > M33)  			{  				double S = Math.Sqrt(1.0 + M22 - M11 - M33) * 2; // S=4*qy  				rotation.W = (M13 - M31) / S;  				rotation.X = (M12 + M21) / S;  				rotation.Y = 0.25 * S;  				rotation.Z = (M23 + M32) / S;  			}  			else  			{  				double S = Math.Sqrt(1.0 + M33 - M11 - M22) * 2; // S=4*qz  				rotation.W = (M21 - M12) / S;  				rotation.X = (M13 + M31) / S;  				rotation.Y = (M23 + M32) / S;  				rotation.Z = 0.25 * S;  			}
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetRotation,The following statement contains a magic number: if (tr > 0)  			{  				double S = Math.Sqrt(tr + 1.0) * 2; // S=4*qw  				rotation.W = 0.25 * S;  				rotation.X = (M32 - M23) / S;  				rotation.Y = (M13 - M31) / S;  				rotation.Z = (M21 - M12) / S;  			}  			else if ((M11 > M22) & (M11 > M33))  			{  				double S = Math.Sqrt(1.0 + M11 - M22 - M33) * 2; // S=4*qx  				rotation.W = (M32 - M23) / S;  				rotation.X = 0.25 * S;  				rotation.Y = (M12 + M21) / S;  				rotation.Z = (M13 + M31) / S;  			}  			else if (M22 > M33)  			{  				double S = Math.Sqrt(1.0 + M22 - M11 - M33) * 2; // S=4*qy  				rotation.W = (M13 - M31) / S;  				rotation.X = (M12 + M21) / S;  				rotation.Y = 0.25 * S;  				rotation.Z = (M23 + M32) / S;  			}  			else  			{  				double S = Math.Sqrt(1.0 + M33 - M11 - M22) * 2; // S=4*qz  				rotation.W = (M21 - M12) / S;  				rotation.X = (M13 + M31) / S;  				rotation.Y = (M23 + M32) / S;  				rotation.Z = 0.25 * S;  			}
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetRotation,The following statement contains a magic number: if (tr > 0)  			{  				double S = Math.Sqrt(tr + 1.0) * 2; // S=4*qw  				rotation.W = 0.25 * S;  				rotation.X = (M32 - M23) / S;  				rotation.Y = (M13 - M31) / S;  				rotation.Z = (M21 - M12) / S;  			}  			else if ((M11 > M22) & (M11 > M33))  			{  				double S = Math.Sqrt(1.0 + M11 - M22 - M33) * 2; // S=4*qx  				rotation.W = (M32 - M23) / S;  				rotation.X = 0.25 * S;  				rotation.Y = (M12 + M21) / S;  				rotation.Z = (M13 + M31) / S;  			}  			else if (M22 > M33)  			{  				double S = Math.Sqrt(1.0 + M22 - M11 - M33) * 2; // S=4*qy  				rotation.W = (M13 - M31) / S;  				rotation.X = (M12 + M21) / S;  				rotation.Y = 0.25 * S;  				rotation.Z = (M23 + M32) / S;  			}  			else  			{  				double S = Math.Sqrt(1.0 + M33 - M11 - M22) * 2; // S=4*qz  				rotation.W = (M21 - M12) / S;  				rotation.X = (M13 + M31) / S;  				rotation.Y = (M23 + M32) / S;  				rotation.Z = 0.25 * S;  			}
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,CreateOrthographic,The following statement contains a magic number: CreateOrthographicOffCenter(-width / 2' width / 2' -height / 2' height / 2' zNear' zFar' out result);
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,CreateOrthographic,The following statement contains a magic number: CreateOrthographicOffCenter(-width / 2' width / 2' -height / 2' height / 2' zNear' zFar' out result);
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,CreateOrthographic,The following statement contains a magic number: CreateOrthographicOffCenter(-width / 2' width / 2' -height / 2' height / 2' zNear' zFar' out result);
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,CreateOrthographic,The following statement contains a magic number: CreateOrthographicOffCenter(-width / 2' width / 2' -height / 2' height / 2' zNear' zFar' out result);
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,CreateOrthographic,The following statement contains a magic number: CreateOrthographicOffCenter(-width / 2' width / 2' -height / 2' height / 2' zNear' zFar' out result);
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,CreateOrthographic,The following statement contains a magic number: CreateOrthographicOffCenter(-width / 2' width / 2' -height / 2' height / 2' zNear' zFar' out result);
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,CreateOrthographic,The following statement contains a magic number: CreateOrthographicOffCenter(-width / 2' width / 2' -height / 2' height / 2' zNear' zFar' out result);
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,CreateOrthographic,The following statement contains a magic number: CreateOrthographicOffCenter(-width / 2' width / 2' -height / 2' height / 2' zNear' zFar' out result);
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,CreateOrthographicOffCenter,The following statement contains a magic number: result.M11 = 2 * invRL;
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,CreateOrthographicOffCenter,The following statement contains a magic number: result.M22 = 2 * invTB;
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,CreateOrthographicOffCenter,The following statement contains a magic number: result.M33 = -2 * invFN;
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,CreatePerspectiveFieldOfView,The following statement contains a magic number: double yMax = zNear * System.Math.Tan(0.5 * fovYRadians);
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,CreatePerspectiveOffCenter,The following statement contains a magic number: double x = (2.0 * zNear) / (right - left);
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,CreatePerspectiveOffCenter,The following statement contains a magic number: double y = (2.0 * zNear) / (top - bottom);
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,CreatePerspectiveOffCenter,The following statement contains a magic number: double d = -(2.0 * zFar * zNear) / (zFar - zNear);
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,Frustum,The following statement contains a magic number: return new Matrix4X4(new Vector4(2.0 * near * invRL' 0.0' 0.0' 0.0)'  							   new Vector4(0.0' 2.0 * near * invTB' 0.0' 0.0)'  							   new Vector4((right + left) * invRL' (top + bottom) * invTB' -(far + near) * invFN' -1.0)'  							   new Vector4(0.0' 0.0' -2.0 * far * near * invFN' 0.0));
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,Frustum,The following statement contains a magic number: return new Matrix4X4(new Vector4(2.0 * near * invRL' 0.0' 0.0' 0.0)'  							   new Vector4(0.0' 2.0 * near * invTB' 0.0' 0.0)'  							   new Vector4((right + left) * invRL' (top + bottom) * invTB' -(far + near) * invFN' -1.0)'  							   new Vector4(0.0' 0.0' -2.0 * far * near * invFN' 0.0));
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,Frustum,The following statement contains a magic number: return new Matrix4X4(new Vector4(2.0 * near * invRL' 0.0' 0.0' 0.0)'  							   new Vector4(0.0' 2.0 * near * invTB' 0.0' 0.0)'  							   new Vector4((right + left) * invRL' (top + bottom) * invTB' -(far + near) * invFN' -1.0)'  							   new Vector4(0.0' 0.0' -2.0 * far * near * invFN' 0.0));
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,Invert,The following statement contains a magic number: for (int i = 0; i < 4; i++)  			{  				// Find the largest pivot value  				double maxPivot = 0.0;  				for (int j = 0; j < 4; j++)  				{  					if (pivotIdx[j] != 0)  					{  						for (int k = 0; k < 4; ++k)  						{  							if (pivotIdx[k] == -1)  							{  								double absVal = System.Math.Abs(inverse[j' k]);  								if (absVal > maxPivot)  								{  									maxPivot = absVal;  									irow = j;  									icol = k;  								}  							}  							else if (pivotIdx[k] > 0)  							{  								return mat;  							}  						}  					}  				}    				++(pivotIdx[icol]);    				// Swap rows over so pivot is on diagonal  				if (irow != icol)  				{  					for (int k = 0; k < 4; ++k)  					{  						double f = inverse[irow' k];  						inverse[irow' k] = inverse[icol' k];  						inverse[icol' k] = f;  					}  				}    				rowIdx[i] = irow;  				colIdx[i] = icol;    				double pivot = inverse[icol' icol];  				// check for singular matrix  				if (pivot == 0.0)  				{  					throw new InvalidOperationException("Matrix is singular and cannot be inverted.");  					//return mat;  				}    				// Scale row so it has a unit diagonal  				double oneOverPivot = 1.0 / pivot;  				inverse[icol' icol] = 1.0;  				for (int k = 0; k < 4; ++k)  					inverse[icol' k] *= oneOverPivot;    				// Do elimination of non-diagonal elements  				for (int j = 0; j < 4; ++j)  				{  					// check this isn't on the diagonal  					if (icol != j)  					{  						double f = inverse[j' icol];  						inverse[j' icol] = 0.0;  						for (int k = 0; k < 4; ++k)  							inverse[j' k] -= inverse[icol' k] * f;  					}  				}  			}
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,Invert,The following statement contains a magic number: for (int i = 0; i < 4; i++)  			{  				// Find the largest pivot value  				double maxPivot = 0.0;  				for (int j = 0; j < 4; j++)  				{  					if (pivotIdx[j] != 0)  					{  						for (int k = 0; k < 4; ++k)  						{  							if (pivotIdx[k] == -1)  							{  								double absVal = System.Math.Abs(inverse[j' k]);  								if (absVal > maxPivot)  								{  									maxPivot = absVal;  									irow = j;  									icol = k;  								}  							}  							else if (pivotIdx[k] > 0)  							{  								return mat;  							}  						}  					}  				}    				++(pivotIdx[icol]);    				// Swap rows over so pivot is on diagonal  				if (irow != icol)  				{  					for (int k = 0; k < 4; ++k)  					{  						double f = inverse[irow' k];  						inverse[irow' k] = inverse[icol' k];  						inverse[icol' k] = f;  					}  				}    				rowIdx[i] = irow;  				colIdx[i] = icol;    				double pivot = inverse[icol' icol];  				// check for singular matrix  				if (pivot == 0.0)  				{  					throw new InvalidOperationException("Matrix is singular and cannot be inverted.");  					//return mat;  				}    				// Scale row so it has a unit diagonal  				double oneOverPivot = 1.0 / pivot;  				inverse[icol' icol] = 1.0;  				for (int k = 0; k < 4; ++k)  					inverse[icol' k] *= oneOverPivot;    				// Do elimination of non-diagonal elements  				for (int j = 0; j < 4; ++j)  				{  					// check this isn't on the diagonal  					if (icol != j)  					{  						double f = inverse[j' icol];  						inverse[j' icol] = 0.0;  						for (int k = 0; k < 4; ++k)  							inverse[j' k] -= inverse[icol' k] * f;  					}  				}  			}
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,Invert,The following statement contains a magic number: for (int i = 0; i < 4; i++)  			{  				// Find the largest pivot value  				double maxPivot = 0.0;  				for (int j = 0; j < 4; j++)  				{  					if (pivotIdx[j] != 0)  					{  						for (int k = 0; k < 4; ++k)  						{  							if (pivotIdx[k] == -1)  							{  								double absVal = System.Math.Abs(inverse[j' k]);  								if (absVal > maxPivot)  								{  									maxPivot = absVal;  									irow = j;  									icol = k;  								}  							}  							else if (pivotIdx[k] > 0)  							{  								return mat;  							}  						}  					}  				}    				++(pivotIdx[icol]);    				// Swap rows over so pivot is on diagonal  				if (irow != icol)  				{  					for (int k = 0; k < 4; ++k)  					{  						double f = inverse[irow' k];  						inverse[irow' k] = inverse[icol' k];  						inverse[icol' k] = f;  					}  				}    				rowIdx[i] = irow;  				colIdx[i] = icol;    				double pivot = inverse[icol' icol];  				// check for singular matrix  				if (pivot == 0.0)  				{  					throw new InvalidOperationException("Matrix is singular and cannot be inverted.");  					//return mat;  				}    				// Scale row so it has a unit diagonal  				double oneOverPivot = 1.0 / pivot;  				inverse[icol' icol] = 1.0;  				for (int k = 0; k < 4; ++k)  					inverse[icol' k] *= oneOverPivot;    				// Do elimination of non-diagonal elements  				for (int j = 0; j < 4; ++j)  				{  					// check this isn't on the diagonal  					if (icol != j)  					{  						double f = inverse[j' icol];  						inverse[j' icol] = 0.0;  						for (int k = 0; k < 4; ++k)  							inverse[j' k] -= inverse[icol' k] * f;  					}  				}  			}
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,Invert,The following statement contains a magic number: for (int i = 0; i < 4; i++)  			{  				// Find the largest pivot value  				double maxPivot = 0.0;  				for (int j = 0; j < 4; j++)  				{  					if (pivotIdx[j] != 0)  					{  						for (int k = 0; k < 4; ++k)  						{  							if (pivotIdx[k] == -1)  							{  								double absVal = System.Math.Abs(inverse[j' k]);  								if (absVal > maxPivot)  								{  									maxPivot = absVal;  									irow = j;  									icol = k;  								}  							}  							else if (pivotIdx[k] > 0)  							{  								return mat;  							}  						}  					}  				}    				++(pivotIdx[icol]);    				// Swap rows over so pivot is on diagonal  				if (irow != icol)  				{  					for (int k = 0; k < 4; ++k)  					{  						double f = inverse[irow' k];  						inverse[irow' k] = inverse[icol' k];  						inverse[icol' k] = f;  					}  				}    				rowIdx[i] = irow;  				colIdx[i] = icol;    				double pivot = inverse[icol' icol];  				// check for singular matrix  				if (pivot == 0.0)  				{  					throw new InvalidOperationException("Matrix is singular and cannot be inverted.");  					//return mat;  				}    				// Scale row so it has a unit diagonal  				double oneOverPivot = 1.0 / pivot;  				inverse[icol' icol] = 1.0;  				for (int k = 0; k < 4; ++k)  					inverse[icol' k] *= oneOverPivot;    				// Do elimination of non-diagonal elements  				for (int j = 0; j < 4; ++j)  				{  					// check this isn't on the diagonal  					if (icol != j)  					{  						double f = inverse[j' icol];  						inverse[j' icol] = 0.0;  						for (int k = 0; k < 4; ++k)  							inverse[j' k] -= inverse[icol' k] * f;  					}  				}  			}
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,Invert,The following statement contains a magic number: for (int i = 0; i < 4; i++)  			{  				// Find the largest pivot value  				double maxPivot = 0.0;  				for (int j = 0; j < 4; j++)  				{  					if (pivotIdx[j] != 0)  					{  						for (int k = 0; k < 4; ++k)  						{  							if (pivotIdx[k] == -1)  							{  								double absVal = System.Math.Abs(inverse[j' k]);  								if (absVal > maxPivot)  								{  									maxPivot = absVal;  									irow = j;  									icol = k;  								}  							}  							else if (pivotIdx[k] > 0)  							{  								return mat;  							}  						}  					}  				}    				++(pivotIdx[icol]);    				// Swap rows over so pivot is on diagonal  				if (irow != icol)  				{  					for (int k = 0; k < 4; ++k)  					{  						double f = inverse[irow' k];  						inverse[irow' k] = inverse[icol' k];  						inverse[icol' k] = f;  					}  				}    				rowIdx[i] = irow;  				colIdx[i] = icol;    				double pivot = inverse[icol' icol];  				// check for singular matrix  				if (pivot == 0.0)  				{  					throw new InvalidOperationException("Matrix is singular and cannot be inverted.");  					//return mat;  				}    				// Scale row so it has a unit diagonal  				double oneOverPivot = 1.0 / pivot;  				inverse[icol' icol] = 1.0;  				for (int k = 0; k < 4; ++k)  					inverse[icol' k] *= oneOverPivot;    				// Do elimination of non-diagonal elements  				for (int j = 0; j < 4; ++j)  				{  					// check this isn't on the diagonal  					if (icol != j)  					{  						double f = inverse[j' icol];  						inverse[j' icol] = 0.0;  						for (int k = 0; k < 4; ++k)  							inverse[j' k] -= inverse[icol' k] * f;  					}  				}  			}
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,Invert,The following statement contains a magic number: for (int i = 0; i < 4; i++)  			{  				// Find the largest pivot value  				double maxPivot = 0.0;  				for (int j = 0; j < 4; j++)  				{  					if (pivotIdx[j] != 0)  					{  						for (int k = 0; k < 4; ++k)  						{  							if (pivotIdx[k] == -1)  							{  								double absVal = System.Math.Abs(inverse[j' k]);  								if (absVal > maxPivot)  								{  									maxPivot = absVal;  									irow = j;  									icol = k;  								}  							}  							else if (pivotIdx[k] > 0)  							{  								return mat;  							}  						}  					}  				}    				++(pivotIdx[icol]);    				// Swap rows over so pivot is on diagonal  				if (irow != icol)  				{  					for (int k = 0; k < 4; ++k)  					{  						double f = inverse[irow' k];  						inverse[irow' k] = inverse[icol' k];  						inverse[icol' k] = f;  					}  				}    				rowIdx[i] = irow;  				colIdx[i] = icol;    				double pivot = inverse[icol' icol];  				// check for singular matrix  				if (pivot == 0.0)  				{  					throw new InvalidOperationException("Matrix is singular and cannot be inverted.");  					//return mat;  				}    				// Scale row so it has a unit diagonal  				double oneOverPivot = 1.0 / pivot;  				inverse[icol' icol] = 1.0;  				for (int k = 0; k < 4; ++k)  					inverse[icol' k] *= oneOverPivot;    				// Do elimination of non-diagonal elements  				for (int j = 0; j < 4; ++j)  				{  					// check this isn't on the diagonal  					if (icol != j)  					{  						double f = inverse[j' icol];  						inverse[j' icol] = 0.0;  						for (int k = 0; k < 4; ++k)  							inverse[j' k] -= inverse[icol' k] * f;  					}  				}  			}
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,Invert,The following statement contains a magic number: for (int i = 0; i < 4; i++)  			{  				// Find the largest pivot value  				double maxPivot = 0.0;  				for (int j = 0; j < 4; j++)  				{  					if (pivotIdx[j] != 0)  					{  						for (int k = 0; k < 4; ++k)  						{  							if (pivotIdx[k] == -1)  							{  								double absVal = System.Math.Abs(inverse[j' k]);  								if (absVal > maxPivot)  								{  									maxPivot = absVal;  									irow = j;  									icol = k;  								}  							}  							else if (pivotIdx[k] > 0)  							{  								return mat;  							}  						}  					}  				}    				++(pivotIdx[icol]);    				// Swap rows over so pivot is on diagonal  				if (irow != icol)  				{  					for (int k = 0; k < 4; ++k)  					{  						double f = inverse[irow' k];  						inverse[irow' k] = inverse[icol' k];  						inverse[icol' k] = f;  					}  				}    				rowIdx[i] = irow;  				colIdx[i] = icol;    				double pivot = inverse[icol' icol];  				// check for singular matrix  				if (pivot == 0.0)  				{  					throw new InvalidOperationException("Matrix is singular and cannot be inverted.");  					//return mat;  				}    				// Scale row so it has a unit diagonal  				double oneOverPivot = 1.0 / pivot;  				inverse[icol' icol] = 1.0;  				for (int k = 0; k < 4; ++k)  					inverse[icol' k] *= oneOverPivot;    				// Do elimination of non-diagonal elements  				for (int j = 0; j < 4; ++j)  				{  					// check this isn't on the diagonal  					if (icol != j)  					{  						double f = inverse[j' icol];  						inverse[j' icol] = 0.0;  						for (int k = 0; k < 4; ++k)  							inverse[j' k] -= inverse[icol' k] * f;  					}  				}  			}
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,Invert,The following statement contains a magic number: for (int j = 3; j >= 0; --j)  			{  				int ir = rowIdx[j];  				int ic = colIdx[j];  				for (int k = 0; k < 4; ++k)  				{  					double f = inverse[k' ir];  					inverse[k' ir] = inverse[k' ic];  					inverse[k' ic] = f;  				}  			}
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,Invert,The following statement contains a magic number: for (int j = 3; j >= 0; --j)  			{  				int ir = rowIdx[j];  				int ic = colIdx[j];  				for (int k = 0; k < 4; ++k)  				{  					double f = inverse[k' ir];  					inverse[k' ir] = inverse[k' ic];  					inverse[k' ic] = f;  				}  			}
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,Invert,The following statement contains a magic number: mat.Row0 = new Vector4(inverse[0' 0]' inverse[0' 1]' inverse[0' 2]' inverse[0' 3]);
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,Invert,The following statement contains a magic number: mat.Row0 = new Vector4(inverse[0' 0]' inverse[0' 1]' inverse[0' 2]' inverse[0' 3]);
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,Invert,The following statement contains a magic number: mat.Row1 = new Vector4(inverse[1' 0]' inverse[1' 1]' inverse[1' 2]' inverse[1' 3]);
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,Invert,The following statement contains a magic number: mat.Row1 = new Vector4(inverse[1' 0]' inverse[1' 1]' inverse[1' 2]' inverse[1' 3]);
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,Invert,The following statement contains a magic number: mat.Row2 = new Vector4(inverse[2' 0]' inverse[2' 1]' inverse[2' 2]' inverse[2' 3]);
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,Invert,The following statement contains a magic number: mat.Row2 = new Vector4(inverse[2' 0]' inverse[2' 1]' inverse[2' 2]' inverse[2' 3]);
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,Invert,The following statement contains a magic number: mat.Row2 = new Vector4(inverse[2' 0]' inverse[2' 1]' inverse[2' 2]' inverse[2' 3]);
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,Invert,The following statement contains a magic number: mat.Row2 = new Vector4(inverse[2' 0]' inverse[2' 1]' inverse[2' 2]' inverse[2' 3]);
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,Invert,The following statement contains a magic number: mat.Row2 = new Vector4(inverse[2' 0]' inverse[2' 1]' inverse[2' 2]' inverse[2' 3]);
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,Invert,The following statement contains a magic number: mat.Row2 = new Vector4(inverse[2' 0]' inverse[2' 1]' inverse[2' 2]' inverse[2' 3]);
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,Invert,The following statement contains a magic number: mat.Row3 = new Vector4(inverse[3' 0]' inverse[3' 1]' inverse[3' 2]' inverse[3' 3]);
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,Invert,The following statement contains a magic number: mat.Row3 = new Vector4(inverse[3' 0]' inverse[3' 1]' inverse[3' 2]' inverse[3' 3]);
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,Invert,The following statement contains a magic number: mat.Row3 = new Vector4(inverse[3' 0]' inverse[3' 1]' inverse[3' 2]' inverse[3' 3]);
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,Invert,The following statement contains a magic number: mat.Row3 = new Vector4(inverse[3' 0]' inverse[3' 1]' inverse[3' 2]' inverse[3' 3]);
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,Invert,The following statement contains a magic number: mat.Row3 = new Vector4(inverse[3' 0]' inverse[3' 1]' inverse[3' 2]' inverse[3' 3]);
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,Invert,The following statement contains a magic number: mat.Row3 = new Vector4(inverse[3' 0]' inverse[3' 1]' inverse[3' 2]' inverse[3' 3]);
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetAsFloatArray,The following statement contains a magic number: float[] contents = new float[16];
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetAsFloatArray,The following statement contains a magic number: contents[2] = (float)Row0[2];
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetAsFloatArray,The following statement contains a magic number: contents[2] = (float)Row0[2];
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetAsFloatArray,The following statement contains a magic number: contents[3] = (float)Row0[3];
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetAsFloatArray,The following statement contains a magic number: contents[3] = (float)Row0[3];
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetAsFloatArray,The following statement contains a magic number: contents[4] = (float)Row1[0];
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetAsFloatArray,The following statement contains a magic number: contents[5] = (float)Row1[1];
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetAsFloatArray,The following statement contains a magic number: contents[6] = (float)Row1[2];
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetAsFloatArray,The following statement contains a magic number: contents[6] = (float)Row1[2];
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetAsFloatArray,The following statement contains a magic number: contents[7] = (float)Row1[3];
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetAsFloatArray,The following statement contains a magic number: contents[7] = (float)Row1[3];
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetAsFloatArray,The following statement contains a magic number: contents[8] = (float)Row2[0];
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetAsFloatArray,The following statement contains a magic number: contents[9] = (float)Row2[1];
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetAsFloatArray,The following statement contains a magic number: contents[10] = (float)Row2[2];
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetAsFloatArray,The following statement contains a magic number: contents[10] = (float)Row2[2];
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetAsFloatArray,The following statement contains a magic number: contents[11] = (float)Row2[3];
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetAsFloatArray,The following statement contains a magic number: contents[11] = (float)Row2[3];
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetAsFloatArray,The following statement contains a magic number: contents[12] = (float)Row3[0];
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetAsFloatArray,The following statement contains a magic number: contents[13] = (float)Row3[1];
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetAsFloatArray,The following statement contains a magic number: contents[14] = (float)Row3[2];
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetAsFloatArray,The following statement contains a magic number: contents[14] = (float)Row3[2];
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetAsFloatArray,The following statement contains a magic number: contents[15] = (float)Row3[3];
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetAsFloatArray,The following statement contains a magic number: contents[15] = (float)Row3[3];
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetAsDoubleArray,The following statement contains a magic number: double[] contents = new double[16];
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetAsDoubleArray,The following statement contains a magic number: contents[2] = Row0[2];
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetAsDoubleArray,The following statement contains a magic number: contents[2] = Row0[2];
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetAsDoubleArray,The following statement contains a magic number: contents[3] = Row0[3];
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetAsDoubleArray,The following statement contains a magic number: contents[3] = Row0[3];
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetAsDoubleArray,The following statement contains a magic number: contents[4] = Row1[0];
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetAsDoubleArray,The following statement contains a magic number: contents[5] = Row1[1];
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetAsDoubleArray,The following statement contains a magic number: contents[6] = Row1[2];
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetAsDoubleArray,The following statement contains a magic number: contents[6] = Row1[2];
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetAsDoubleArray,The following statement contains a magic number: contents[7] = Row1[3];
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetAsDoubleArray,The following statement contains a magic number: contents[7] = Row1[3];
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetAsDoubleArray,The following statement contains a magic number: contents[8] = Row2[0];
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetAsDoubleArray,The following statement contains a magic number: contents[9] = Row2[1];
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetAsDoubleArray,The following statement contains a magic number: contents[10] = Row2[2];
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetAsDoubleArray,The following statement contains a magic number: contents[10] = Row2[2];
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetAsDoubleArray,The following statement contains a magic number: contents[11] = Row2[3];
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetAsDoubleArray,The following statement contains a magic number: contents[11] = Row2[3];
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetAsDoubleArray,The following statement contains a magic number: contents[12] = Row3[0];
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetAsDoubleArray,The following statement contains a magic number: contents[13] = Row3[1];
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetAsDoubleArray,The following statement contains a magic number: contents[14] = Row3[2];
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetAsDoubleArray,The following statement contains a magic number: contents[14] = Row3[2];
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetAsDoubleArray,The following statement contains a magic number: contents[15] = Row3[3];
Magic Number,MatterHackers.VectorMath,Matrix4X4,C:\repos\MatterHackers_agg-sharp\VectorMath\Matrix4x4.cs,GetAsDoubleArray,The following statement contains a magic number: contents[15] = Row3[3];
Magic Number,MatterHackers.VectorMath,Quaternion,C:\repos\MatterHackers_agg-sharp\VectorMath\Quaternion.cs,Quaternion,The following statement contains a magic number: this.w = Math.Sqrt(Math.Pow(startingDirection.Length' 2) * Math.Pow(endingDirection.Length' 2)) + Vector3.Dot(startingDirection' endingDirection);
Magic Number,MatterHackers.VectorMath,Quaternion,C:\repos\MatterHackers_agg-sharp\VectorMath\Quaternion.cs,Quaternion,The following statement contains a magic number: this.w = Math.Sqrt(Math.Pow(startingDirection.Length' 2) * Math.Pow(endingDirection.Length' 2)) + Vector3.Dot(startingDirection' endingDirection);
Magic Number,MatterHackers.VectorMath,Ray,C:\repos\MatterHackers_agg-sharp\VectorMath\Ray.cs,Ray,The following statement contains a magic number: sign[2] = (oneOverDirection.z < 0) ? Sign.negative : Sign.positive;
Magic Number,MatterHackers.VectorMath,Ray,C:\repos\MatterHackers_agg-sharp\VectorMath\Ray.cs,Ray,The following statement contains a magic number: sign[2] = rayToCopy.sign[2];
Magic Number,MatterHackers.VectorMath,Ray,C:\repos\MatterHackers_agg-sharp\VectorMath\Ray.cs,Ray,The following statement contains a magic number: sign[2] = rayToCopy.sign[2];
Magic Number,MatterHackers.VectorMath,Ray,C:\repos\MatterHackers_agg-sharp\VectorMath\Ray.cs,Intersection,The following statement contains a magic number: double minDistToZ = (bounds[(int)ray.sign[2]].z - ray.origin.z) * ray.oneOverDirection.z;
Magic Number,MatterHackers.VectorMath,Ray,C:\repos\MatterHackers_agg-sharp\VectorMath\Ray.cs,Intersection,The following statement contains a magic number: double maxDistToZ = (bounds[1 - (int)ray.sign[2]].z - ray.origin.z) * ray.oneOverDirection.z;
Magic Number,MatterHackers.VectorMath,TrackBallController,C:\repos\MatterHackers_agg-sharp\VectorMath\TrackBallController.cs,OnMouseMove,The following statement contains a magic number: switch (currentTrackingType)  			{  				case MouseDownType.Rotation:  					activeRotationQuaternion = Quaternion.Identity;  					//Map the point to the sphere  					MapToSphere(mousePosition' out rotationCurrent);    					//Return the quaternion equivalent to the rotation  					//Compute the vector perpendicular to the begin and end vectors  					Vector3 Perp = Vector3.Cross(rotationStart' rotationCurrent);    					//Compute the length of the perpendicular vector  					if (Perp.Length > Epsilon)  					{  						//if its non-zero  						//We're ok' so return the perpendicular vector as the transform after all  						activeRotationQuaternion.X = Perp.x;  						activeRotationQuaternion.Y = Perp.y;  						activeRotationQuaternion.Z = Perp.z;  						//In the quaternion values' w is cosine (theta / 2)' where theta is the rotation angle  						activeRotationQuaternion.W = Vector3.Dot(rotationStart' rotationCurrent);  						OnTransformChanged(null);  					}  					break;    				case MouseDownType.Translation:  					{  						Vector2 mouseDelta = mousePosition - lastTranslationMousePosition;  						Vector2 scaledDelta = mouseDelta / screenCenter.x * 4.75;  						Vector3 offset = new Vector3(scaledDelta.x' scaledDelta.y' 0);  						offset = Vector3.TransformPosition(offset' Matrix4X4.Invert(CurrentRotation));  						offset = Vector3.TransformPosition(offset' localToScreenTransform);  						currentTranslationMatrix = currentTranslationMatrix * Matrix4X4.CreateTranslation(offset);  						lastTranslationMousePosition = mousePosition;  						OnTransformChanged(null);  					}  					break;    				case MouseDownType.Scale:  					{  						Vector2 mouseDelta = mousePosition - lastScaleMousePosition;  						double zoomDelta = 1;  						if (mouseDelta.y < 0)  						{  							zoomDelta = 1 - (-1 * mouseDelta.y / 100);  						}  						else if (mouseDelta.y > 0)  						{  							zoomDelta = 1 + (1 * mouseDelta.y / 100);  						}  						Scale = Scale * zoomDelta;  						lastScaleMousePosition = mousePosition;  						OnTransformChanged(null);  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.VectorMath,TrackBallController,C:\repos\MatterHackers_agg-sharp\VectorMath\TrackBallController.cs,OnMouseMove,The following statement contains a magic number: switch (currentTrackingType)  			{  				case MouseDownType.Rotation:  					activeRotationQuaternion = Quaternion.Identity;  					//Map the point to the sphere  					MapToSphere(mousePosition' out rotationCurrent);    					//Return the quaternion equivalent to the rotation  					//Compute the vector perpendicular to the begin and end vectors  					Vector3 Perp = Vector3.Cross(rotationStart' rotationCurrent);    					//Compute the length of the perpendicular vector  					if (Perp.Length > Epsilon)  					{  						//if its non-zero  						//We're ok' so return the perpendicular vector as the transform after all  						activeRotationQuaternion.X = Perp.x;  						activeRotationQuaternion.Y = Perp.y;  						activeRotationQuaternion.Z = Perp.z;  						//In the quaternion values' w is cosine (theta / 2)' where theta is the rotation angle  						activeRotationQuaternion.W = Vector3.Dot(rotationStart' rotationCurrent);  						OnTransformChanged(null);  					}  					break;    				case MouseDownType.Translation:  					{  						Vector2 mouseDelta = mousePosition - lastTranslationMousePosition;  						Vector2 scaledDelta = mouseDelta / screenCenter.x * 4.75;  						Vector3 offset = new Vector3(scaledDelta.x' scaledDelta.y' 0);  						offset = Vector3.TransformPosition(offset' Matrix4X4.Invert(CurrentRotation));  						offset = Vector3.TransformPosition(offset' localToScreenTransform);  						currentTranslationMatrix = currentTranslationMatrix * Matrix4X4.CreateTranslation(offset);  						lastTranslationMousePosition = mousePosition;  						OnTransformChanged(null);  					}  					break;    				case MouseDownType.Scale:  					{  						Vector2 mouseDelta = mousePosition - lastScaleMousePosition;  						double zoomDelta = 1;  						if (mouseDelta.y < 0)  						{  							zoomDelta = 1 - (-1 * mouseDelta.y / 100);  						}  						else if (mouseDelta.y > 0)  						{  							zoomDelta = 1 + (1 * mouseDelta.y / 100);  						}  						Scale = Scale * zoomDelta;  						lastScaleMousePosition = mousePosition;  						OnTransformChanged(null);  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.VectorMath,TrackBallController,C:\repos\MatterHackers_agg-sharp\VectorMath\TrackBallController.cs,OnMouseMove,The following statement contains a magic number: switch (currentTrackingType)  			{  				case MouseDownType.Rotation:  					activeRotationQuaternion = Quaternion.Identity;  					//Map the point to the sphere  					MapToSphere(mousePosition' out rotationCurrent);    					//Return the quaternion equivalent to the rotation  					//Compute the vector perpendicular to the begin and end vectors  					Vector3 Perp = Vector3.Cross(rotationStart' rotationCurrent);    					//Compute the length of the perpendicular vector  					if (Perp.Length > Epsilon)  					{  						//if its non-zero  						//We're ok' so return the perpendicular vector as the transform after all  						activeRotationQuaternion.X = Perp.x;  						activeRotationQuaternion.Y = Perp.y;  						activeRotationQuaternion.Z = Perp.z;  						//In the quaternion values' w is cosine (theta / 2)' where theta is the rotation angle  						activeRotationQuaternion.W = Vector3.Dot(rotationStart' rotationCurrent);  						OnTransformChanged(null);  					}  					break;    				case MouseDownType.Translation:  					{  						Vector2 mouseDelta = mousePosition - lastTranslationMousePosition;  						Vector2 scaledDelta = mouseDelta / screenCenter.x * 4.75;  						Vector3 offset = new Vector3(scaledDelta.x' scaledDelta.y' 0);  						offset = Vector3.TransformPosition(offset' Matrix4X4.Invert(CurrentRotation));  						offset = Vector3.TransformPosition(offset' localToScreenTransform);  						currentTranslationMatrix = currentTranslationMatrix * Matrix4X4.CreateTranslation(offset);  						lastTranslationMousePosition = mousePosition;  						OnTransformChanged(null);  					}  					break;    				case MouseDownType.Scale:  					{  						Vector2 mouseDelta = mousePosition - lastScaleMousePosition;  						double zoomDelta = 1;  						if (mouseDelta.y < 0)  						{  							zoomDelta = 1 - (-1 * mouseDelta.y / 100);  						}  						else if (mouseDelta.y > 0)  						{  							zoomDelta = 1 + (1 * mouseDelta.y / 100);  						}  						Scale = Scale * zoomDelta;  						lastScaleMousePosition = mousePosition;  						OnTransformChanged(null);  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.VectorMath,TrackBallController,C:\repos\MatterHackers_agg-sharp\VectorMath\TrackBallController.cs,OnMouseWheel,The following statement contains a magic number: if (wheelDelta > 0)  			{  				zoomDelta = 1.2;  			}  			else if (wheelDelta < 0)  			{  				zoomDelta = .8;  			}
Magic Number,MatterHackers.VectorMath,TrackBallController,C:\repos\MatterHackers_agg-sharp\VectorMath\TrackBallController.cs,OnMouseWheel,The following statement contains a magic number: if (wheelDelta > 0)  			{  				zoomDelta = 1.2;  			}  			else if (wheelDelta < 0)  			{  				zoomDelta = .8;  			}
Magic Number,MatterHackers.VectorMath,Vector3,C:\repos\MatterHackers_agg-sharp\VectorMath\Vector3.cs,Vector3,The following statement contains a magic number: z = doubleArray[2];
Magic Number,MatterHackers.VectorMath,Vector3,C:\repos\MatterHackers_agg-sharp\VectorMath\Vector3.cs,GetPerpendicular,The following statement contains a magic number: if (!Collinear(a' b' Zero))  			{  				return Vector3.Cross(a' b);  			}  			else  			{  				Vector3 zOne = new Vector3(0' 0' 100000);  				if (!Collinear(a' b' zOne))  				{  					return Vector3.Cross(a - zOne' b - zOne);  				}  				else  				{  					Vector3 xOne = new Vector3(1000000' 0' 0);  					return Vector3.Cross(a - xOne' b - xOne);  				}  			}
Magic Number,MatterHackers.VectorMath,Vector3,C:\repos\MatterHackers_agg-sharp\VectorMath\Vector3.cs,GetPerpendicular,The following statement contains a magic number: if (!Collinear(a' b' Zero))  			{  				return Vector3.Cross(a' b);  			}  			else  			{  				Vector3 zOne = new Vector3(0' 0' 100000);  				if (!Collinear(a' b' zOne))  				{  					return Vector3.Cross(a - zOne' b - zOne);  				}  				else  				{  					Vector3 xOne = new Vector3(1000000' 0' 0);  					return Vector3.Cross(a - xOne' b - xOne);  				}  			}
Magic Number,MatterHackers.VectorMath,Vector3,C:\repos\MatterHackers_agg-sharp\VectorMath\Vector3.cs,Transform,The following statement contains a magic number: Vector3.Multiply(ref temp' 2' out temp);
Missing Default,MatterHackers.VectorMath,AxisAlignedBoundingBox,C:\repos\MatterHackers_agg-sharp\VectorMath\AxisAlignedBoundingBox.cs,GetBottomCorner,The following switch statement is missing a default case: switch(quadrantIndex)  			{  				case 0:  					return new Vector3(maxXYZ.x' maxXYZ.y' minXYZ.z);    				case 1:  					return new Vector3(minXYZ.x' maxXYZ.y' minXYZ.z);    				case 2:  					return new Vector3(minXYZ.x' minXYZ.y' minXYZ.z);    				case 3:  					return new Vector3(maxXYZ.x' minXYZ.y' minXYZ.z);  			}
Missing Default,MatterHackers.VectorMath,AxisAlignedBoundingBox,C:\repos\MatterHackers_agg-sharp\VectorMath\AxisAlignedBoundingBox.cs,GetTopCorner,The following switch statement is missing a default case: switch (quadrantIndex)  			{  				case 0:  					return new Vector3(maxXYZ.x' maxXYZ.y' maxXYZ.z);    				case 1:  					return new Vector3(minXYZ.x' maxXYZ.y' maxXYZ.z);    				case 2:  					return new Vector3(minXYZ.x' minXYZ.y' maxXYZ.z);    				case 3:  					return new Vector3(maxXYZ.x' minXYZ.y' maxXYZ.z);  			}
