Implementation smell,Namespace,Class,File,Method,Description
Complex Method,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateOrientationAtAllFeatures,Cyclomatic complexity of the method is 15
Complex Method,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,MergeResponsesThatAreSameFeatures,Cyclomatic complexity of the method is 10
Complex Method,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindSubPixelPositions,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindChessBoardLines,Cyclomatic complexity of the method is 19
Complex Method,MatterHackers.Rectification,LensDistortionMapping,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\LensDistortionMapping.cs,GetDistorted,Cyclomatic complexity of the method is 9
Long Parameter List,MatterHackers.Rectification,ChessboardConnections,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,ChessboardConnections,The method has 5 parameters. Parameters: item' leftConnection' rightConnection' bottomConnection' topConnection
Long Parameter List,MatterHackers.Rectification,LensDistortionMapping,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\LensDistortionMapping.cs,LensDistortionMapping,The method has 10 parameters. Parameters: distortedWidth' distortedHeight' k1_RadialDistortion' k2_RadialDistortion' k3_RadialDistortion' distortionCenter' p1_TangentialDistortion' p2_TangentialDistortion' offsetToFitCorrectedImage' scallToFitCorrectedImage
Long Identifier,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindChessBoardLines,The length of the parameter numNeighborsThatCouldBeOnChessboard is 35.
Long Identifier,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindChessBoardLines,The length of the parameter countOfNeighborsWith4Neighbors is 30.
Long Identifier,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,,The length of the parameter bilinearDistortedToRectifideOffsetTable is 39.
Long Statement,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateOrientationAtAllFeatures,The length of the statement  "                    for (int extraAngleToCheckIndex = angleToCheckIndex - 1; extraAngleToCheckIndex <= angleToCheckIndex + 1; extraAngleToCheckIndex++) " is 131.
Long Statement,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateSumResponseAtAllPixels,The length of the statement  "                            (buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex]] + buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex + 8]]) " is 123.
Long Statement,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateSumResponseAtAllPixels,The length of the statement  "                            (buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex + 4]] + buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex + 12]]); " is 129.
Long Statement,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateSumResponseAtAllPixels,The length of the statement  "                    int centerMeanTotal = buffer[byteOffset - 1] + buffer[byteOffset + 1] + buffer[byteOffset - width] + buffer[byteOffset - width]; " is 128.
Long Statement,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindChessBoardLines,The length of the statement  "                        item.chessboardConnections = new ChessboardConnections(sortedList[0]' sortedList[1]' sortedList[2]' sortedList[3]' sortedList[4]); " is 130.
Long Statement,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The length of the statement  "                        bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0; " is 128.
Long Statement,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The length of the statement  "                        bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1; " is 128.
Long Statement,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The length of the statement  "                        bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0; " is 128.
Long Statement,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The length of the statement  "                        bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1; " is 128.
Long Statement,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The length of the statement  "            if (distortedImage.Width != width || distortedImage.Height != height || rectifideImage.Width != width || rectifideImage.Height != height) " is 137.
Long Statement,MatterHackers.Rectification,LensDistortionMapping,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\LensDistortionMapping.cs,GetCorrected,The length of the statement  "            corrected = distortedAtOrigin * (1 + k1_RadialDistortion * radiusSquared + k2_RadialDistortion * radiusToFourth + k3_RadialDistortion * radiusToSixth); " is 151.
Long Statement,MatterHackers.Rectification,LensDistortionMapping,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\LensDistortionMapping.cs,GetCorrected,The length of the statement  "            corrected.x += 2 * p1_TangentialDistortion * distortedAtOrigin.x * distortedAtOrigin.y + p2_TangentialDistortion * (radiusSquared + 2 * distortedAtOrigin.x * distortedAtOrigin.x); " is 179.
Long Statement,MatterHackers.Rectification,LensDistortionMapping,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\LensDistortionMapping.cs,GetCorrected,The length of the statement  "            corrected.y += 2 * p2_TangentialDistortion * distortedAtOrigin.x * distortedAtOrigin.y + p1_TangentialDistortion * (radiusSquared + 2 * distortedAtOrigin.y * distortedAtOrigin.y); " is 179.
Complex Conditional,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The conditional expression  "correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1"  is complex.
Complex Conditional,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The conditional expression  "distortedImage.Width != width || distortedImage.Height != height || rectifideImage.Width != width || rectifideImage.Height != height"  is complex.
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,DrawDebug,The following statement contains a magic number: Vector2 start = new Vector2(10' 0);
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,DrawDebug,The following statement contains a magic number: start.Rotate(validResponse.orientation * MathHelper.DegreesToRadians(22.5));
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,DrawDebug,The following statement contains a magic number: graphics2D.Circle(validResponse.position' 2' RGBA_Bytes.Red);
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,DrawDebug,The following statement contains a magic number: Ellipse elipse = new Ellipse(validResponse.position' 10);
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateOrientationAtAllFeatures,The following statement contains a magic number: check0 += 16;
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateOrientationAtAllFeatures,The following statement contains a magic number: check0 -= 16;
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateOrientationAtAllFeatures,The following statement contains a magic number: check0 > 15
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateOrientationAtAllFeatures,The following statement contains a magic number: int check1 = extraAngleToCheckIndex + 8;
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateOrientationAtAllFeatures,The following statement contains a magic number: check1 += 16;
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateOrientationAtAllFeatures,The following statement contains a magic number: check1 -= 16;
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateOrientationAtAllFeatures,The following statement contains a magic number: check1 > 15
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateOrientationAtAllFeatures,The following statement contains a magic number: int check2 = extraAngleToCheckIndex + 4;
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateOrientationAtAllFeatures,The following statement contains a magic number: check2 += 16;
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateOrientationAtAllFeatures,The following statement contains a magic number: check2 -= 16;
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateOrientationAtAllFeatures,The following statement contains a magic number: check2 > 15
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateOrientationAtAllFeatures,The following statement contains a magic number: int check3 = extraAngleToCheckIndex + 12;
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateOrientationAtAllFeatures,The following statement contains a magic number: check3 += 16;
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateOrientationAtAllFeatures,The following statement contains a magic number: check3 -= 16;
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateOrientationAtAllFeatures,The following statement contains a magic number: check3 > 15
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateOrientationAtAllFeatures,The following statement contains a magic number: angleToCheckIndex < 4
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateSumResponseAtAllPixels,The following statement contains a magic number: int sum =                               (buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex]] + buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex + 8]])                              -                              (buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex + 4]] + buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex + 12]]);
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateSumResponseAtAllPixels,The following statement contains a magic number: int sum =                               (buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex]] + buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex + 8]])                              -                              (buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex + 4]] + buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex + 12]]);
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateSumResponseAtAllPixels,The following statement contains a magic number: int sum =                               (buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex]] + buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex + 8]])                              -                              (buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex + 4]] + buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex + 12]]);
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateSumResponseAtAllPixels,The following statement contains a magic number: angleToCheckIndex < 4
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateSumResponseAtAllPixels,The following statement contains a magic number: int oppositeValue = buffer[byteOffset + byteOffsetToPixel[diffCheck + 8]];
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateSumResponseAtAllPixels,The following statement contains a magic number: diffCheck < 8
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateSumResponseAtAllPixels,The following statement contains a magic number: int neighborMean = (neighborMeanTotal + 8) / 16;
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateSumResponseAtAllPixels,The following statement contains a magic number: int neighborMean = (neighborMeanTotal + 8) / 16;
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateSumResponseAtAllPixels,The following statement contains a magic number: int centerMean = (centerMeanTotal + 2) / 4;
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateSumResponseAtAllPixels,The following statement contains a magic number: int centerMean = (centerMeanTotal + 2) / 4;
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,MergeResponsesThatAreSameFeatures,The following statement contains a magic number: int dist = 5;
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,MergeResponsesThatAreSameFeatures,The following statement contains a magic number: numFeaturesFound < 2
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindSubPixelPositions,The following statement contains a magic number: int centerXInt = (int)(position.x + .5);
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindSubPixelPositions,The following statement contains a magic number: int centerYInt = (int)(position.y + .5);
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindSubPixelPositions,The following statement contains a magic number: double center = (max - min) / 2 + min;
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindSubPixelPositions,The following statement contains a magic number: double maxRange = (max - min) / 4;
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindSubPixelPositions,The following statement contains a magic number: double distScalling = Math.Min(1' Math.Max(0' 1 - ((new Vector2(x' y) - position).Length - 3) / 2));
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindSubPixelPositions,The following statement contains a magic number: double distScalling = Math.Min(1' Math.Max(0' 1 - ((new Vector2(x' y) - position).Length - 3) / 2));
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindChessBoardLines,The following statement contains a magic number: delta > 2 && delta < 5
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindChessBoardLines,The following statement contains a magic number: delta > 2 && delta < 5
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindChessBoardLines,The following statement contains a magic number: j < 5
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindChessBoardLines,The following statement contains a magic number: numThatAreValid < 2
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindChessBoardLines,The following statement contains a magic number: sortedList.Count > 5
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindChessBoardLines,The following statement contains a magic number: delta > 2 && delta < 5
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindChessBoardLines,The following statement contains a magic number: delta > 2 && delta < 5
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindChessBoardLines,The following statement contains a magic number: i < 5
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindChessBoardLines,The following statement contains a magic number: item.has4ChessboardNeighbors = (numNeighborsThatCouldBeOnChessboard == 4);
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindChessBoardLines,The following statement contains a magic number: item.chessboardConnections = new ChessboardConnections(sortedList[0]' sortedList[1]' sortedList[2]' sortedList[3]' sortedList[4]);
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindChessBoardLines,The following statement contains a magic number: item.chessboardConnections = new ChessboardConnections(sortedList[0]' sortedList[1]' sortedList[2]' sortedList[3]' sortedList[4]);
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindChessBoardLines,The following statement contains a magic number: item.chessboardConnections = new ChessboardConnections(sortedList[0]' sortedList[1]' sortedList[2]' sortedList[3]' sortedList[4]);
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindChessBoardLines,The following statement contains a magic number: i < 5
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindChessBoardLines,The following statement contains a magic number: countOfNeighborsWith4Neighbors == 2
Magic Number,MatterHackers.Rectification,ChessBoardDetector,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindChessBoardLines,The following statement contains a magic number: validResponsesBotomToTopList.Count > 5
Magic Number,MatterHackers.Rectification,ChessboardConnections,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,Render,The following statement contains a magic number: Ellipse elipse = new Ellipse(item.position' 10);
Magic Number,MatterHackers.Rectification,ChessboardConnections,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,Render,The following statement contains a magic number: graphics2D.Render(new Stroke(elipse' 3)' RGBA_Bytes.Red);
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ImageCorrection,The following statement contains a magic number: bilinearDistortedToRectifideOffsetTable = new int[width * height * 4];
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ImageCorrection,The following statement contains a magic number: bilinearWeightTable = new int[width * height * 4];
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: distortedImage.BitDepth != 32 || rectifideImage.BitDepth != 32
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: distortedImage.BitDepth != 32 || rectifideImage.BitDepth != 32
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: int rectifedBufferIndex = i * 4;
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 0] * 4;
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 0] * 4;
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: int weight = bilinearWeightTable[i * 4 + 0];
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: int blue = distortedBuffer[pixelOffset + 2] * weight;
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 1] * 4;
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 1] * 4;
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: weight = bilinearWeightTable[i * 4 + 1];
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: blue += distortedBuffer[pixelOffset + 2] * weight;
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 2] * 4;
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 2] * 4;
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 2] * 4;
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: weight = bilinearWeightTable[i * 4 + 2];
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: weight = bilinearWeightTable[i * 4 + 2];
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: blue += distortedBuffer[pixelOffset + 2] * weight;
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 3] * 4;
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 3] * 4;
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 3] * 4;
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: weight = bilinearWeightTable[i * 4 + 3];
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: weight = bilinearWeightTable[i * 4 + 3];
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: blue += distortedBuffer[pixelOffset + 2] * weight;
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: rectifideBuffer[rectifedBufferIndex + 2] = (byte)(blue / blendFractionDenominator);
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: rectifideBuffer[rectifedBufferIndex + 3] = 255;
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: rectifideBuffer[rectifedBufferIndex + 3] = 255;
Magic Number,MatterHackers.Rectification,ImageCorrection,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: i < bilinearDistortedToRectifideOffsetTable.Length / 4
Magic Number,MatterHackers.Rectification,LensDistortionMapping,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\LensDistortionMapping.cs,GetDistorted,The following statement contains a magic number: Vector2 minDistorted = corrected - new Vector2(256' 256);
Magic Number,MatterHackers.Rectification,LensDistortionMapping,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\LensDistortionMapping.cs,GetDistorted,The following statement contains a magic number: Vector2 minDistorted = corrected - new Vector2(256' 256);
Magic Number,MatterHackers.Rectification,LensDistortionMapping,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\LensDistortionMapping.cs,GetDistorted,The following statement contains a magic number: Vector2 maxDistorted = corrected + new Vector2(256' 256);
Magic Number,MatterHackers.Rectification,LensDistortionMapping,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\LensDistortionMapping.cs,GetDistorted,The following statement contains a magic number: Vector2 maxDistorted = corrected + new Vector2(256' 256);
Magic Number,MatterHackers.Rectification,LensDistortionMapping,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\LensDistortionMapping.cs,GetDistorted,The following statement contains a magic number: int numIterations = 64;
Magic Number,MatterHackers.Rectification,LensDistortionMapping,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\LensDistortionMapping.cs,GetDistorted,The following statement contains a magic number: xDist < .01 && yDist < .01
Magic Number,MatterHackers.Rectification,LensDistortionMapping,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\LensDistortionMapping.cs,GetDistorted,The following statement contains a magic number: xDist < .01 && yDist < .01
Magic Number,MatterHackers.Rectification,LensDistortionMapping,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\LensDistortionMapping.cs,AdjustPositionIteration,The following statement contains a magic number: valueToAdjust -= distance / 2;
Magic Number,MatterHackers.Rectification,DistortionTests,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\UnitTests.cs,TestTransforms,The following statement contains a magic number: LensDistortionMapping correction = new LensDistortionMapping(640' 480' k1_RadialDistortion: .000001);
Magic Number,MatterHackers.Rectification,DistortionTests,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\UnitTests.cs,TestTransforms,The following statement contains a magic number: LensDistortionMapping correction = new LensDistortionMapping(640' 480' k1_RadialDistortion: .000001);
Magic Number,MatterHackers.Rectification,DistortionTests,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\UnitTests.cs,TestTransforms,The following statement contains a magic number: LensDistortionMapping correction = new LensDistortionMapping(640' 480' k1_RadialDistortion: .000001);
Magic Number,MatterHackers.Rectification,DistortionTests,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\UnitTests.cs,TestTransforms,The following statement contains a magic number: CheckOne(correction' new Vector2(630' 470));
Magic Number,MatterHackers.Rectification,DistortionTests,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\UnitTests.cs,TestTransforms,The following statement contains a magic number: CheckOne(correction' new Vector2(630' 470));
Magic Number,MatterHackers.Rectification,DistortionTests,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\UnitTests.cs,TestTransforms,The following statement contains a magic number: CheckOne(correction' new Vector2(10' 20));
Magic Number,MatterHackers.Rectification,DistortionTests,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\UnitTests.cs,TestTransforms,The following statement contains a magic number: CheckOne(correction' new Vector2(10' 20));
Magic Number,MatterHackers.Rectification,DistortionTests,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\UnitTests.cs,TestTransforms,The following statement contains a magic number: CheckOne(correction' new Vector2(1' 2));
Magic Number,MatterHackers.Rectification,DistortionTests,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\UnitTests.cs,TestTransforms,The following statement contains a magic number: CheckOne(correction' new Vector2(320' 240));
Magic Number,MatterHackers.Rectification,DistortionTests,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\UnitTests.cs,TestTransforms,The following statement contains a magic number: CheckOne(correction' new Vector2(320' 240));
Magic Number,MatterHackers.Rectification,DistortionTests,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Rectification\UnitTests.cs,CheckOne,The following statement contains a magic number: Assert.IsTrue(distorted.Equals(redistorted' .05));
