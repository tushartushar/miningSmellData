Implementation smell,Namespace,Class,File,Method,Description
Complex Method,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateOrientationAtAllFeatures,Cyclomatic complexity of the method is 15
Complex Method,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,MergeResponsesThatAreSameFeatures,Cyclomatic complexity of the method is 10
Complex Method,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindSubPixelPositions,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindChessBoardLines,Cyclomatic complexity of the method is 19
Long Parameter List,MatterHackers.Rectification,ChessboardConnections,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,ChessboardConnections,The method has 5 parameters. Parameters: item' leftConnection' rightConnection' bottomConnection' topConnection
Long Parameter List,MatterHackers.Rectification,LensDistortionMapping,C:\repos\MatterHackers_agg-sharp\Rectification\LensDistortionMapping.cs,LensDistortionMapping,The method has 10 parameters. Parameters: distortedWidth' distortedHeight' k1_RadialDistortion' k2_RadialDistortion' k3_RadialDistortion' distortionCenter' p1_TangentialDistortion' p2_TangentialDistortion' offsetToFitCorrectedImage' scallToFitCorrectedImage
Long Identifier,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindChessBoardLines,The length of the parameter numNeighborsThatCouldBeOnChessboard is 35.
Long Identifier,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindChessBoardLines,The length of the parameter countOfNeighborsWith4Neighbors is 30.
Long Identifier,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,,The length of the parameter bilinearDistortedToRectifideOffsetTable is 39.
Long Statement,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateOrientationAtAllFeatures,The length of the statement  "                    for (int extraAngleToCheckIndex = angleToCheckIndex - 1; extraAngleToCheckIndex <= angleToCheckIndex + 1; extraAngleToCheckIndex++) " is 131.
Long Statement,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateSumResponseAtAllPixels,The length of the statement  "                            (buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex]] + buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex + 8]]) " is 123.
Long Statement,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateSumResponseAtAllPixels,The length of the statement  "                            (buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex + 4]] + buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex + 12]]); " is 129.
Long Statement,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateSumResponseAtAllPixels,The length of the statement  "                    int centerMeanTotal = buffer[byteOffset - 1] + buffer[byteOffset + 1] + buffer[byteOffset - width] + buffer[byteOffset - width]; " is 128.
Long Statement,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindChessBoardLines,The length of the statement  "                        item.chessboardConnections = new ChessboardConnections(sortedList[0]' sortedList[1]' sortedList[2]' sortedList[3]' sortedList[4]); " is 130.
Long Statement,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The length of the statement  "                        bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0; " is 128.
Long Statement,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The length of the statement  "                        bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1; " is 128.
Long Statement,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The length of the statement  "                        bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0; " is 128.
Long Statement,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The length of the statement  "                        bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1; " is 128.
Long Statement,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The length of the statement  "            if (distortedImage.Width != width || distortedImage.Height != height || rectifideImage.Width != width || rectifideImage.Height != height) " is 137.
Long Statement,MatterHackers.Rectification,LensDistortionMapping,C:\repos\MatterHackers_agg-sharp\Rectification\LensDistortionMapping.cs,GetCorrected,The length of the statement  "            corrected = distortedAtOrigin * (1 + k1_RadialDistortion * radiusSquared + k2_RadialDistortion * radiusToFourth + k3_RadialDistortion * radiusToSixth); " is 151.
Long Statement,MatterHackers.Rectification,LensDistortionMapping,C:\repos\MatterHackers_agg-sharp\Rectification\LensDistortionMapping.cs,GetCorrected,The length of the statement  "            corrected.x += 2 * p1_TangentialDistortion * distortedAtOrigin.x * distortedAtOrigin.y + p2_TangentialDistortion * (radiusSquared + 2 * distortedAtOrigin.x * distortedAtOrigin.x); " is 179.
Long Statement,MatterHackers.Rectification,LensDistortionMapping,C:\repos\MatterHackers_agg-sharp\Rectification\LensDistortionMapping.cs,GetCorrected,The length of the statement  "            corrected.y += 2 * p2_TangentialDistortion * distortedAtOrigin.x * distortedAtOrigin.y + p1_TangentialDistortion * (radiusSquared + 2 * distortedAtOrigin.y * distortedAtOrigin.y); " is 179.
Complex Conditional,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The conditional expression  "correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1"  is complex.
Complex Conditional,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The conditional expression  "distortedImage.Width != width || distortedImage.Height != height || rectifideImage.Width != width || rectifideImage.Height != height"  is complex.
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,DrawDebug,The following statement contains a magic number: foreach (ValidResponseData validResponse in validResponsesBotomToTopList)              {                  if (validResponse.totalResponse > 0)                  {                      Vector2 start = new Vector2(10' 0);                      start.Rotate(validResponse.orientation * MathHelper.DegreesToRadians(22.5));                        graphics2D.Line(validResponse.position + start' validResponse.position - start' RGBA_Bytes.Green);                        graphics2D.Circle(validResponse.position' 2' RGBA_Bytes.Red);                        if (validResponse.has4ChessboardNeighbors)                      {                          Ellipse elipse = new Ellipse(validResponse.position' 10);                          graphics2D.Render(new Stroke(elipse' 1)' RGBA_Bytes.Red);                      }                        //graphics2D.Line(validResponse.position' prevValidResponse.position' RGBA_Bytes.Red);                        prevValidResponse = validResponse;                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,DrawDebug,The following statement contains a magic number: foreach (ValidResponseData validResponse in validResponsesBotomToTopList)              {                  if (validResponse.totalResponse > 0)                  {                      Vector2 start = new Vector2(10' 0);                      start.Rotate(validResponse.orientation * MathHelper.DegreesToRadians(22.5));                        graphics2D.Line(validResponse.position + start' validResponse.position - start' RGBA_Bytes.Green);                        graphics2D.Circle(validResponse.position' 2' RGBA_Bytes.Red);                        if (validResponse.has4ChessboardNeighbors)                      {                          Ellipse elipse = new Ellipse(validResponse.position' 10);                          graphics2D.Render(new Stroke(elipse' 1)' RGBA_Bytes.Red);                      }                        //graphics2D.Line(validResponse.position' prevValidResponse.position' RGBA_Bytes.Red);                        prevValidResponse = validResponse;                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,DrawDebug,The following statement contains a magic number: foreach (ValidResponseData validResponse in validResponsesBotomToTopList)              {                  if (validResponse.totalResponse > 0)                  {                      Vector2 start = new Vector2(10' 0);                      start.Rotate(validResponse.orientation * MathHelper.DegreesToRadians(22.5));                        graphics2D.Line(validResponse.position + start' validResponse.position - start' RGBA_Bytes.Green);                        graphics2D.Circle(validResponse.position' 2' RGBA_Bytes.Red);                        if (validResponse.has4ChessboardNeighbors)                      {                          Ellipse elipse = new Ellipse(validResponse.position' 10);                          graphics2D.Render(new Stroke(elipse' 1)' RGBA_Bytes.Red);                      }                        //graphics2D.Line(validResponse.position' prevValidResponse.position' RGBA_Bytes.Red);                        prevValidResponse = validResponse;                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,DrawDebug,The following statement contains a magic number: foreach (ValidResponseData validResponse in validResponsesBotomToTopList)              {                  if (validResponse.totalResponse > 0)                  {                      Vector2 start = new Vector2(10' 0);                      start.Rotate(validResponse.orientation * MathHelper.DegreesToRadians(22.5));                        graphics2D.Line(validResponse.position + start' validResponse.position - start' RGBA_Bytes.Green);                        graphics2D.Circle(validResponse.position' 2' RGBA_Bytes.Red);                        if (validResponse.has4ChessboardNeighbors)                      {                          Ellipse elipse = new Ellipse(validResponse.position' 10);                          graphics2D.Render(new Stroke(elipse' 1)' RGBA_Bytes.Red);                      }                        //graphics2D.Line(validResponse.position' prevValidResponse.position' RGBA_Bytes.Red);                        prevValidResponse = validResponse;                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateOrientationAtAllFeatures,The following statement contains a magic number: foreach (ValidResponseData validResponse in validResponsesBotomToTopList)              {                  if (validResponse.totalResponse <= 0)                  {                      throw new Exception("You should not have added a response below the threashold.");                  }                    int maxAbsSum = 0;                  int byteOffset = imageBuffer.GetBufferOffsetXY((int)validResponse.position.x' (int)validResponse.position.y);                  for (int angleToCheckIndex = 0; angleToCheckIndex < 4; angleToCheckIndex++)                  {                      int sum = 0;                      for (int extraAngleToCheckIndex = angleToCheckIndex - 1; extraAngleToCheckIndex <= angleToCheckIndex + 1; extraAngleToCheckIndex++)                      {                          int check0 = extraAngleToCheckIndex; if (check0 < 0) check0 += 16; if (check0 > 15) check0 -= 16;                          int check1 = extraAngleToCheckIndex + 8; if (check1 < 0) check1 += 16; if (check1 > 15) check1 -= 16;                          int check2 = extraAngleToCheckIndex + 4; if (check2 < 0) check2 += 16; if (check2 > 15) check2 -= 16;                          int check3 = extraAngleToCheckIndex + 12; if (check3 < 0) check3 += 16; if (check3 > 15) check3 -= 16;                          sum +=                              (buffer[byteOffset + byteOffsetToPixel[check0]] + buffer[byteOffset + byteOffsetToPixel[check1]])                              -                              (buffer[byteOffset + byteOffsetToPixel[check2]] + buffer[byteOffset + byteOffsetToPixel[check3]]);                      }                      int absSum = Math.Abs(sum);                      if (absSum > maxAbsSum)                      {                          maxAbsSum = absSum;                          if (sum > 0)                          {                              validResponse.orientation = angleToCheckIndex;                          }                          else                          {                              validResponse.orientation = (4 + angleToCheckIndex);                          }                      }                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateOrientationAtAllFeatures,The following statement contains a magic number: foreach (ValidResponseData validResponse in validResponsesBotomToTopList)              {                  if (validResponse.totalResponse <= 0)                  {                      throw new Exception("You should not have added a response below the threashold.");                  }                    int maxAbsSum = 0;                  int byteOffset = imageBuffer.GetBufferOffsetXY((int)validResponse.position.x' (int)validResponse.position.y);                  for (int angleToCheckIndex = 0; angleToCheckIndex < 4; angleToCheckIndex++)                  {                      int sum = 0;                      for (int extraAngleToCheckIndex = angleToCheckIndex - 1; extraAngleToCheckIndex <= angleToCheckIndex + 1; extraAngleToCheckIndex++)                      {                          int check0 = extraAngleToCheckIndex; if (check0 < 0) check0 += 16; if (check0 > 15) check0 -= 16;                          int check1 = extraAngleToCheckIndex + 8; if (check1 < 0) check1 += 16; if (check1 > 15) check1 -= 16;                          int check2 = extraAngleToCheckIndex + 4; if (check2 < 0) check2 += 16; if (check2 > 15) check2 -= 16;                          int check3 = extraAngleToCheckIndex + 12; if (check3 < 0) check3 += 16; if (check3 > 15) check3 -= 16;                          sum +=                              (buffer[byteOffset + byteOffsetToPixel[check0]] + buffer[byteOffset + byteOffsetToPixel[check1]])                              -                              (buffer[byteOffset + byteOffsetToPixel[check2]] + buffer[byteOffset + byteOffsetToPixel[check3]]);                      }                      int absSum = Math.Abs(sum);                      if (absSum > maxAbsSum)                      {                          maxAbsSum = absSum;                          if (sum > 0)                          {                              validResponse.orientation = angleToCheckIndex;                          }                          else                          {                              validResponse.orientation = (4 + angleToCheckIndex);                          }                      }                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateOrientationAtAllFeatures,The following statement contains a magic number: foreach (ValidResponseData validResponse in validResponsesBotomToTopList)              {                  if (validResponse.totalResponse <= 0)                  {                      throw new Exception("You should not have added a response below the threashold.");                  }                    int maxAbsSum = 0;                  int byteOffset = imageBuffer.GetBufferOffsetXY((int)validResponse.position.x' (int)validResponse.position.y);                  for (int angleToCheckIndex = 0; angleToCheckIndex < 4; angleToCheckIndex++)                  {                      int sum = 0;                      for (int extraAngleToCheckIndex = angleToCheckIndex - 1; extraAngleToCheckIndex <= angleToCheckIndex + 1; extraAngleToCheckIndex++)                      {                          int check0 = extraAngleToCheckIndex; if (check0 < 0) check0 += 16; if (check0 > 15) check0 -= 16;                          int check1 = extraAngleToCheckIndex + 8; if (check1 < 0) check1 += 16; if (check1 > 15) check1 -= 16;                          int check2 = extraAngleToCheckIndex + 4; if (check2 < 0) check2 += 16; if (check2 > 15) check2 -= 16;                          int check3 = extraAngleToCheckIndex + 12; if (check3 < 0) check3 += 16; if (check3 > 15) check3 -= 16;                          sum +=                              (buffer[byteOffset + byteOffsetToPixel[check0]] + buffer[byteOffset + byteOffsetToPixel[check1]])                              -                              (buffer[byteOffset + byteOffsetToPixel[check2]] + buffer[byteOffset + byteOffsetToPixel[check3]]);                      }                      int absSum = Math.Abs(sum);                      if (absSum > maxAbsSum)                      {                          maxAbsSum = absSum;                          if (sum > 0)                          {                              validResponse.orientation = angleToCheckIndex;                          }                          else                          {                              validResponse.orientation = (4 + angleToCheckIndex);                          }                      }                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateOrientationAtAllFeatures,The following statement contains a magic number: foreach (ValidResponseData validResponse in validResponsesBotomToTopList)              {                  if (validResponse.totalResponse <= 0)                  {                      throw new Exception("You should not have added a response below the threashold.");                  }                    int maxAbsSum = 0;                  int byteOffset = imageBuffer.GetBufferOffsetXY((int)validResponse.position.x' (int)validResponse.position.y);                  for (int angleToCheckIndex = 0; angleToCheckIndex < 4; angleToCheckIndex++)                  {                      int sum = 0;                      for (int extraAngleToCheckIndex = angleToCheckIndex - 1; extraAngleToCheckIndex <= angleToCheckIndex + 1; extraAngleToCheckIndex++)                      {                          int check0 = extraAngleToCheckIndex; if (check0 < 0) check0 += 16; if (check0 > 15) check0 -= 16;                          int check1 = extraAngleToCheckIndex + 8; if (check1 < 0) check1 += 16; if (check1 > 15) check1 -= 16;                          int check2 = extraAngleToCheckIndex + 4; if (check2 < 0) check2 += 16; if (check2 > 15) check2 -= 16;                          int check3 = extraAngleToCheckIndex + 12; if (check3 < 0) check3 += 16; if (check3 > 15) check3 -= 16;                          sum +=                              (buffer[byteOffset + byteOffsetToPixel[check0]] + buffer[byteOffset + byteOffsetToPixel[check1]])                              -                              (buffer[byteOffset + byteOffsetToPixel[check2]] + buffer[byteOffset + byteOffsetToPixel[check3]]);                      }                      int absSum = Math.Abs(sum);                      if (absSum > maxAbsSum)                      {                          maxAbsSum = absSum;                          if (sum > 0)                          {                              validResponse.orientation = angleToCheckIndex;                          }                          else                          {                              validResponse.orientation = (4 + angleToCheckIndex);                          }                      }                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateOrientationAtAllFeatures,The following statement contains a magic number: foreach (ValidResponseData validResponse in validResponsesBotomToTopList)              {                  if (validResponse.totalResponse <= 0)                  {                      throw new Exception("You should not have added a response below the threashold.");                  }                    int maxAbsSum = 0;                  int byteOffset = imageBuffer.GetBufferOffsetXY((int)validResponse.position.x' (int)validResponse.position.y);                  for (int angleToCheckIndex = 0; angleToCheckIndex < 4; angleToCheckIndex++)                  {                      int sum = 0;                      for (int extraAngleToCheckIndex = angleToCheckIndex - 1; extraAngleToCheckIndex <= angleToCheckIndex + 1; extraAngleToCheckIndex++)                      {                          int check0 = extraAngleToCheckIndex; if (check0 < 0) check0 += 16; if (check0 > 15) check0 -= 16;                          int check1 = extraAngleToCheckIndex + 8; if (check1 < 0) check1 += 16; if (check1 > 15) check1 -= 16;                          int check2 = extraAngleToCheckIndex + 4; if (check2 < 0) check2 += 16; if (check2 > 15) check2 -= 16;                          int check3 = extraAngleToCheckIndex + 12; if (check3 < 0) check3 += 16; if (check3 > 15) check3 -= 16;                          sum +=                              (buffer[byteOffset + byteOffsetToPixel[check0]] + buffer[byteOffset + byteOffsetToPixel[check1]])                              -                              (buffer[byteOffset + byteOffsetToPixel[check2]] + buffer[byteOffset + byteOffsetToPixel[check3]]);                      }                      int absSum = Math.Abs(sum);                      if (absSum > maxAbsSum)                      {                          maxAbsSum = absSum;                          if (sum > 0)                          {                              validResponse.orientation = angleToCheckIndex;                          }                          else                          {                              validResponse.orientation = (4 + angleToCheckIndex);                          }                      }                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateOrientationAtAllFeatures,The following statement contains a magic number: foreach (ValidResponseData validResponse in validResponsesBotomToTopList)              {                  if (validResponse.totalResponse <= 0)                  {                      throw new Exception("You should not have added a response below the threashold.");                  }                    int maxAbsSum = 0;                  int byteOffset = imageBuffer.GetBufferOffsetXY((int)validResponse.position.x' (int)validResponse.position.y);                  for (int angleToCheckIndex = 0; angleToCheckIndex < 4; angleToCheckIndex++)                  {                      int sum = 0;                      for (int extraAngleToCheckIndex = angleToCheckIndex - 1; extraAngleToCheckIndex <= angleToCheckIndex + 1; extraAngleToCheckIndex++)                      {                          int check0 = extraAngleToCheckIndex; if (check0 < 0) check0 += 16; if (check0 > 15) check0 -= 16;                          int check1 = extraAngleToCheckIndex + 8; if (check1 < 0) check1 += 16; if (check1 > 15) check1 -= 16;                          int check2 = extraAngleToCheckIndex + 4; if (check2 < 0) check2 += 16; if (check2 > 15) check2 -= 16;                          int check3 = extraAngleToCheckIndex + 12; if (check3 < 0) check3 += 16; if (check3 > 15) check3 -= 16;                          sum +=                              (buffer[byteOffset + byteOffsetToPixel[check0]] + buffer[byteOffset + byteOffsetToPixel[check1]])                              -                              (buffer[byteOffset + byteOffsetToPixel[check2]] + buffer[byteOffset + byteOffsetToPixel[check3]]);                      }                      int absSum = Math.Abs(sum);                      if (absSum > maxAbsSum)                      {                          maxAbsSum = absSum;                          if (sum > 0)                          {                              validResponse.orientation = angleToCheckIndex;                          }                          else                          {                              validResponse.orientation = (4 + angleToCheckIndex);                          }                      }                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateOrientationAtAllFeatures,The following statement contains a magic number: foreach (ValidResponseData validResponse in validResponsesBotomToTopList)              {                  if (validResponse.totalResponse <= 0)                  {                      throw new Exception("You should not have added a response below the threashold.");                  }                    int maxAbsSum = 0;                  int byteOffset = imageBuffer.GetBufferOffsetXY((int)validResponse.position.x' (int)validResponse.position.y);                  for (int angleToCheckIndex = 0; angleToCheckIndex < 4; angleToCheckIndex++)                  {                      int sum = 0;                      for (int extraAngleToCheckIndex = angleToCheckIndex - 1; extraAngleToCheckIndex <= angleToCheckIndex + 1; extraAngleToCheckIndex++)                      {                          int check0 = extraAngleToCheckIndex; if (check0 < 0) check0 += 16; if (check0 > 15) check0 -= 16;                          int check1 = extraAngleToCheckIndex + 8; if (check1 < 0) check1 += 16; if (check1 > 15) check1 -= 16;                          int check2 = extraAngleToCheckIndex + 4; if (check2 < 0) check2 += 16; if (check2 > 15) check2 -= 16;                          int check3 = extraAngleToCheckIndex + 12; if (check3 < 0) check3 += 16; if (check3 > 15) check3 -= 16;                          sum +=                              (buffer[byteOffset + byteOffsetToPixel[check0]] + buffer[byteOffset + byteOffsetToPixel[check1]])                              -                              (buffer[byteOffset + byteOffsetToPixel[check2]] + buffer[byteOffset + byteOffsetToPixel[check3]]);                      }                      int absSum = Math.Abs(sum);                      if (absSum > maxAbsSum)                      {                          maxAbsSum = absSum;                          if (sum > 0)                          {                              validResponse.orientation = angleToCheckIndex;                          }                          else                          {                              validResponse.orientation = (4 + angleToCheckIndex);                          }                      }                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateOrientationAtAllFeatures,The following statement contains a magic number: foreach (ValidResponseData validResponse in validResponsesBotomToTopList)              {                  if (validResponse.totalResponse <= 0)                  {                      throw new Exception("You should not have added a response below the threashold.");                  }                    int maxAbsSum = 0;                  int byteOffset = imageBuffer.GetBufferOffsetXY((int)validResponse.position.x' (int)validResponse.position.y);                  for (int angleToCheckIndex = 0; angleToCheckIndex < 4; angleToCheckIndex++)                  {                      int sum = 0;                      for (int extraAngleToCheckIndex = angleToCheckIndex - 1; extraAngleToCheckIndex <= angleToCheckIndex + 1; extraAngleToCheckIndex++)                      {                          int check0 = extraAngleToCheckIndex; if (check0 < 0) check0 += 16; if (check0 > 15) check0 -= 16;                          int check1 = extraAngleToCheckIndex + 8; if (check1 < 0) check1 += 16; if (check1 > 15) check1 -= 16;                          int check2 = extraAngleToCheckIndex + 4; if (check2 < 0) check2 += 16; if (check2 > 15) check2 -= 16;                          int check3 = extraAngleToCheckIndex + 12; if (check3 < 0) check3 += 16; if (check3 > 15) check3 -= 16;                          sum +=                              (buffer[byteOffset + byteOffsetToPixel[check0]] + buffer[byteOffset + byteOffsetToPixel[check1]])                              -                              (buffer[byteOffset + byteOffsetToPixel[check2]] + buffer[byteOffset + byteOffsetToPixel[check3]]);                      }                      int absSum = Math.Abs(sum);                      if (absSum > maxAbsSum)                      {                          maxAbsSum = absSum;                          if (sum > 0)                          {                              validResponse.orientation = angleToCheckIndex;                          }                          else                          {                              validResponse.orientation = (4 + angleToCheckIndex);                          }                      }                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateOrientationAtAllFeatures,The following statement contains a magic number: foreach (ValidResponseData validResponse in validResponsesBotomToTopList)              {                  if (validResponse.totalResponse <= 0)                  {                      throw new Exception("You should not have added a response below the threashold.");                  }                    int maxAbsSum = 0;                  int byteOffset = imageBuffer.GetBufferOffsetXY((int)validResponse.position.x' (int)validResponse.position.y);                  for (int angleToCheckIndex = 0; angleToCheckIndex < 4; angleToCheckIndex++)                  {                      int sum = 0;                      for (int extraAngleToCheckIndex = angleToCheckIndex - 1; extraAngleToCheckIndex <= angleToCheckIndex + 1; extraAngleToCheckIndex++)                      {                          int check0 = extraAngleToCheckIndex; if (check0 < 0) check0 += 16; if (check0 > 15) check0 -= 16;                          int check1 = extraAngleToCheckIndex + 8; if (check1 < 0) check1 += 16; if (check1 > 15) check1 -= 16;                          int check2 = extraAngleToCheckIndex + 4; if (check2 < 0) check2 += 16; if (check2 > 15) check2 -= 16;                          int check3 = extraAngleToCheckIndex + 12; if (check3 < 0) check3 += 16; if (check3 > 15) check3 -= 16;                          sum +=                              (buffer[byteOffset + byteOffsetToPixel[check0]] + buffer[byteOffset + byteOffsetToPixel[check1]])                              -                              (buffer[byteOffset + byteOffsetToPixel[check2]] + buffer[byteOffset + byteOffsetToPixel[check3]]);                      }                      int absSum = Math.Abs(sum);                      if (absSum > maxAbsSum)                      {                          maxAbsSum = absSum;                          if (sum > 0)                          {                              validResponse.orientation = angleToCheckIndex;                          }                          else                          {                              validResponse.orientation = (4 + angleToCheckIndex);                          }                      }                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateOrientationAtAllFeatures,The following statement contains a magic number: foreach (ValidResponseData validResponse in validResponsesBotomToTopList)              {                  if (validResponse.totalResponse <= 0)                  {                      throw new Exception("You should not have added a response below the threashold.");                  }                    int maxAbsSum = 0;                  int byteOffset = imageBuffer.GetBufferOffsetXY((int)validResponse.position.x' (int)validResponse.position.y);                  for (int angleToCheckIndex = 0; angleToCheckIndex < 4; angleToCheckIndex++)                  {                      int sum = 0;                      for (int extraAngleToCheckIndex = angleToCheckIndex - 1; extraAngleToCheckIndex <= angleToCheckIndex + 1; extraAngleToCheckIndex++)                      {                          int check0 = extraAngleToCheckIndex; if (check0 < 0) check0 += 16; if (check0 > 15) check0 -= 16;                          int check1 = extraAngleToCheckIndex + 8; if (check1 < 0) check1 += 16; if (check1 > 15) check1 -= 16;                          int check2 = extraAngleToCheckIndex + 4; if (check2 < 0) check2 += 16; if (check2 > 15) check2 -= 16;                          int check3 = extraAngleToCheckIndex + 12; if (check3 < 0) check3 += 16; if (check3 > 15) check3 -= 16;                          sum +=                              (buffer[byteOffset + byteOffsetToPixel[check0]] + buffer[byteOffset + byteOffsetToPixel[check1]])                              -                              (buffer[byteOffset + byteOffsetToPixel[check2]] + buffer[byteOffset + byteOffsetToPixel[check3]]);                      }                      int absSum = Math.Abs(sum);                      if (absSum > maxAbsSum)                      {                          maxAbsSum = absSum;                          if (sum > 0)                          {                              validResponse.orientation = angleToCheckIndex;                          }                          else                          {                              validResponse.orientation = (4 + angleToCheckIndex);                          }                      }                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateOrientationAtAllFeatures,The following statement contains a magic number: foreach (ValidResponseData validResponse in validResponsesBotomToTopList)              {                  if (validResponse.totalResponse <= 0)                  {                      throw new Exception("You should not have added a response below the threashold.");                  }                    int maxAbsSum = 0;                  int byteOffset = imageBuffer.GetBufferOffsetXY((int)validResponse.position.x' (int)validResponse.position.y);                  for (int angleToCheckIndex = 0; angleToCheckIndex < 4; angleToCheckIndex++)                  {                      int sum = 0;                      for (int extraAngleToCheckIndex = angleToCheckIndex - 1; extraAngleToCheckIndex <= angleToCheckIndex + 1; extraAngleToCheckIndex++)                      {                          int check0 = extraAngleToCheckIndex; if (check0 < 0) check0 += 16; if (check0 > 15) check0 -= 16;                          int check1 = extraAngleToCheckIndex + 8; if (check1 < 0) check1 += 16; if (check1 > 15) check1 -= 16;                          int check2 = extraAngleToCheckIndex + 4; if (check2 < 0) check2 += 16; if (check2 > 15) check2 -= 16;                          int check3 = extraAngleToCheckIndex + 12; if (check3 < 0) check3 += 16; if (check3 > 15) check3 -= 16;                          sum +=                              (buffer[byteOffset + byteOffsetToPixel[check0]] + buffer[byteOffset + byteOffsetToPixel[check1]])                              -                              (buffer[byteOffset + byteOffsetToPixel[check2]] + buffer[byteOffset + byteOffsetToPixel[check3]]);                      }                      int absSum = Math.Abs(sum);                      if (absSum > maxAbsSum)                      {                          maxAbsSum = absSum;                          if (sum > 0)                          {                              validResponse.orientation = angleToCheckIndex;                          }                          else                          {                              validResponse.orientation = (4 + angleToCheckIndex);                          }                      }                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateOrientationAtAllFeatures,The following statement contains a magic number: foreach (ValidResponseData validResponse in validResponsesBotomToTopList)              {                  if (validResponse.totalResponse <= 0)                  {                      throw new Exception("You should not have added a response below the threashold.");                  }                    int maxAbsSum = 0;                  int byteOffset = imageBuffer.GetBufferOffsetXY((int)validResponse.position.x' (int)validResponse.position.y);                  for (int angleToCheckIndex = 0; angleToCheckIndex < 4; angleToCheckIndex++)                  {                      int sum = 0;                      for (int extraAngleToCheckIndex = angleToCheckIndex - 1; extraAngleToCheckIndex <= angleToCheckIndex + 1; extraAngleToCheckIndex++)                      {                          int check0 = extraAngleToCheckIndex; if (check0 < 0) check0 += 16; if (check0 > 15) check0 -= 16;                          int check1 = extraAngleToCheckIndex + 8; if (check1 < 0) check1 += 16; if (check1 > 15) check1 -= 16;                          int check2 = extraAngleToCheckIndex + 4; if (check2 < 0) check2 += 16; if (check2 > 15) check2 -= 16;                          int check3 = extraAngleToCheckIndex + 12; if (check3 < 0) check3 += 16; if (check3 > 15) check3 -= 16;                          sum +=                              (buffer[byteOffset + byteOffsetToPixel[check0]] + buffer[byteOffset + byteOffsetToPixel[check1]])                              -                              (buffer[byteOffset + byteOffsetToPixel[check2]] + buffer[byteOffset + byteOffsetToPixel[check3]]);                      }                      int absSum = Math.Abs(sum);                      if (absSum > maxAbsSum)                      {                          maxAbsSum = absSum;                          if (sum > 0)                          {                              validResponse.orientation = angleToCheckIndex;                          }                          else                          {                              validResponse.orientation = (4 + angleToCheckIndex);                          }                      }                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateOrientationAtAllFeatures,The following statement contains a magic number: foreach (ValidResponseData validResponse in validResponsesBotomToTopList)              {                  if (validResponse.totalResponse <= 0)                  {                      throw new Exception("You should not have added a response below the threashold.");                  }                    int maxAbsSum = 0;                  int byteOffset = imageBuffer.GetBufferOffsetXY((int)validResponse.position.x' (int)validResponse.position.y);                  for (int angleToCheckIndex = 0; angleToCheckIndex < 4; angleToCheckIndex++)                  {                      int sum = 0;                      for (int extraAngleToCheckIndex = angleToCheckIndex - 1; extraAngleToCheckIndex <= angleToCheckIndex + 1; extraAngleToCheckIndex++)                      {                          int check0 = extraAngleToCheckIndex; if (check0 < 0) check0 += 16; if (check0 > 15) check0 -= 16;                          int check1 = extraAngleToCheckIndex + 8; if (check1 < 0) check1 += 16; if (check1 > 15) check1 -= 16;                          int check2 = extraAngleToCheckIndex + 4; if (check2 < 0) check2 += 16; if (check2 > 15) check2 -= 16;                          int check3 = extraAngleToCheckIndex + 12; if (check3 < 0) check3 += 16; if (check3 > 15) check3 -= 16;                          sum +=                              (buffer[byteOffset + byteOffsetToPixel[check0]] + buffer[byteOffset + byteOffsetToPixel[check1]])                              -                              (buffer[byteOffset + byteOffsetToPixel[check2]] + buffer[byteOffset + byteOffsetToPixel[check3]]);                      }                      int absSum = Math.Abs(sum);                      if (absSum > maxAbsSum)                      {                          maxAbsSum = absSum;                          if (sum > 0)                          {                              validResponse.orientation = angleToCheckIndex;                          }                          else                          {                              validResponse.orientation = (4 + angleToCheckIndex);                          }                      }                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateOrientationAtAllFeatures,The following statement contains a magic number: foreach (ValidResponseData validResponse in validResponsesBotomToTopList)              {                  if (validResponse.totalResponse <= 0)                  {                      throw new Exception("You should not have added a response below the threashold.");                  }                    int maxAbsSum = 0;                  int byteOffset = imageBuffer.GetBufferOffsetXY((int)validResponse.position.x' (int)validResponse.position.y);                  for (int angleToCheckIndex = 0; angleToCheckIndex < 4; angleToCheckIndex++)                  {                      int sum = 0;                      for (int extraAngleToCheckIndex = angleToCheckIndex - 1; extraAngleToCheckIndex <= angleToCheckIndex + 1; extraAngleToCheckIndex++)                      {                          int check0 = extraAngleToCheckIndex; if (check0 < 0) check0 += 16; if (check0 > 15) check0 -= 16;                          int check1 = extraAngleToCheckIndex + 8; if (check1 < 0) check1 += 16; if (check1 > 15) check1 -= 16;                          int check2 = extraAngleToCheckIndex + 4; if (check2 < 0) check2 += 16; if (check2 > 15) check2 -= 16;                          int check3 = extraAngleToCheckIndex + 12; if (check3 < 0) check3 += 16; if (check3 > 15) check3 -= 16;                          sum +=                              (buffer[byteOffset + byteOffsetToPixel[check0]] + buffer[byteOffset + byteOffsetToPixel[check1]])                              -                              (buffer[byteOffset + byteOffsetToPixel[check2]] + buffer[byteOffset + byteOffsetToPixel[check3]]);                      }                      int absSum = Math.Abs(sum);                      if (absSum > maxAbsSum)                      {                          maxAbsSum = absSum;                          if (sum > 0)                          {                              validResponse.orientation = angleToCheckIndex;                          }                          else                          {                              validResponse.orientation = (4 + angleToCheckIndex);                          }                      }                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateOrientationAtAllFeatures,The following statement contains a magic number: foreach (ValidResponseData validResponse in validResponsesBotomToTopList)              {                  if (validResponse.totalResponse <= 0)                  {                      throw new Exception("You should not have added a response below the threashold.");                  }                    int maxAbsSum = 0;                  int byteOffset = imageBuffer.GetBufferOffsetXY((int)validResponse.position.x' (int)validResponse.position.y);                  for (int angleToCheckIndex = 0; angleToCheckIndex < 4; angleToCheckIndex++)                  {                      int sum = 0;                      for (int extraAngleToCheckIndex = angleToCheckIndex - 1; extraAngleToCheckIndex <= angleToCheckIndex + 1; extraAngleToCheckIndex++)                      {                          int check0 = extraAngleToCheckIndex; if (check0 < 0) check0 += 16; if (check0 > 15) check0 -= 16;                          int check1 = extraAngleToCheckIndex + 8; if (check1 < 0) check1 += 16; if (check1 > 15) check1 -= 16;                          int check2 = extraAngleToCheckIndex + 4; if (check2 < 0) check2 += 16; if (check2 > 15) check2 -= 16;                          int check3 = extraAngleToCheckIndex + 12; if (check3 < 0) check3 += 16; if (check3 > 15) check3 -= 16;                          sum +=                              (buffer[byteOffset + byteOffsetToPixel[check0]] + buffer[byteOffset + byteOffsetToPixel[check1]])                              -                              (buffer[byteOffset + byteOffsetToPixel[check2]] + buffer[byteOffset + byteOffsetToPixel[check3]]);                      }                      int absSum = Math.Abs(sum);                      if (absSum > maxAbsSum)                      {                          maxAbsSum = absSum;                          if (sum > 0)                          {                              validResponse.orientation = angleToCheckIndex;                          }                          else                          {                              validResponse.orientation = (4 + angleToCheckIndex);                          }                      }                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateOrientationAtAllFeatures,The following statement contains a magic number: foreach (ValidResponseData validResponse in validResponsesBotomToTopList)              {                  if (validResponse.totalResponse <= 0)                  {                      throw new Exception("You should not have added a response below the threashold.");                  }                    int maxAbsSum = 0;                  int byteOffset = imageBuffer.GetBufferOffsetXY((int)validResponse.position.x' (int)validResponse.position.y);                  for (int angleToCheckIndex = 0; angleToCheckIndex < 4; angleToCheckIndex++)                  {                      int sum = 0;                      for (int extraAngleToCheckIndex = angleToCheckIndex - 1; extraAngleToCheckIndex <= angleToCheckIndex + 1; extraAngleToCheckIndex++)                      {                          int check0 = extraAngleToCheckIndex; if (check0 < 0) check0 += 16; if (check0 > 15) check0 -= 16;                          int check1 = extraAngleToCheckIndex + 8; if (check1 < 0) check1 += 16; if (check1 > 15) check1 -= 16;                          int check2 = extraAngleToCheckIndex + 4; if (check2 < 0) check2 += 16; if (check2 > 15) check2 -= 16;                          int check3 = extraAngleToCheckIndex + 12; if (check3 < 0) check3 += 16; if (check3 > 15) check3 -= 16;                          sum +=                              (buffer[byteOffset + byteOffsetToPixel[check0]] + buffer[byteOffset + byteOffsetToPixel[check1]])                              -                              (buffer[byteOffset + byteOffsetToPixel[check2]] + buffer[byteOffset + byteOffsetToPixel[check3]]);                      }                      int absSum = Math.Abs(sum);                      if (absSum > maxAbsSum)                      {                          maxAbsSum = absSum;                          if (sum > 0)                          {                              validResponse.orientation = angleToCheckIndex;                          }                          else                          {                              validResponse.orientation = (4 + angleToCheckIndex);                          }                      }                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateOrientationAtAllFeatures,The following statement contains a magic number: foreach (ValidResponseData validResponse in validResponsesBotomToTopList)              {                  if (validResponse.totalResponse <= 0)                  {                      throw new Exception("You should not have added a response below the threashold.");                  }                    int maxAbsSum = 0;                  int byteOffset = imageBuffer.GetBufferOffsetXY((int)validResponse.position.x' (int)validResponse.position.y);                  for (int angleToCheckIndex = 0; angleToCheckIndex < 4; angleToCheckIndex++)                  {                      int sum = 0;                      for (int extraAngleToCheckIndex = angleToCheckIndex - 1; extraAngleToCheckIndex <= angleToCheckIndex + 1; extraAngleToCheckIndex++)                      {                          int check0 = extraAngleToCheckIndex; if (check0 < 0) check0 += 16; if (check0 > 15) check0 -= 16;                          int check1 = extraAngleToCheckIndex + 8; if (check1 < 0) check1 += 16; if (check1 > 15) check1 -= 16;                          int check2 = extraAngleToCheckIndex + 4; if (check2 < 0) check2 += 16; if (check2 > 15) check2 -= 16;                          int check3 = extraAngleToCheckIndex + 12; if (check3 < 0) check3 += 16; if (check3 > 15) check3 -= 16;                          sum +=                              (buffer[byteOffset + byteOffsetToPixel[check0]] + buffer[byteOffset + byteOffsetToPixel[check1]])                              -                              (buffer[byteOffset + byteOffsetToPixel[check2]] + buffer[byteOffset + byteOffsetToPixel[check3]]);                      }                      int absSum = Math.Abs(sum);                      if (absSum > maxAbsSum)                      {                          maxAbsSum = absSum;                          if (sum > 0)                          {                              validResponse.orientation = angleToCheckIndex;                          }                          else                          {                              validResponse.orientation = (4 + angleToCheckIndex);                          }                      }                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateSumResponseAtAllPixels,The following statement contains a magic number: for (int y = trimPixels; y < height-trimPixels; y++)              {                  int byteOffset = imageBuffer.GetBufferOffsetXY(trimPixels' y);                  ValidResponseData[] totalResponseRow = allResponsesGrid.GetRow(y);                  for (int x = trimPixels; x < width - trimPixels; x++)                  {                      int sumResponse = 0;                      for (int angleToCheckIndex = 0; angleToCheckIndex < 4; angleToCheckIndex++)                      {                          int sum =                               (buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex]] + buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex + 8]])                              -                              (buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex + 4]] + buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex + 12]]);                          int absSum = Math.Abs(sum);                          sumResponse += absSum;                      }                      int neighborMeanTotal = 0;                      int diffResponse = 0;                      for (int diffCheck = 0; diffCheck < 8; diffCheck++)                      {                          int testValue = buffer[byteOffset + byteOffsetToPixel[diffCheck]];                          int oppositeValue = buffer[byteOffset + byteOffsetToPixel[diffCheck + 8]];                          diffResponse += Math.Abs(testValue - oppositeValue);                          neighborMeanTotal += testValue + oppositeValue;                      }                      int neighborMean = (neighborMeanTotal + 8) / 16;                        int centerMeanTotal = buffer[byteOffset - 1] + buffer[byteOffset + 1] + buffer[byteOffset - width] + buffer[byteOffset - width];                      int centerMean = (centerMeanTotal + 2) / 4;                      int absMeanResponse = Math.Abs(neighborMean - centerMean);                        ValidResponseData newResponse = new ValidResponseData();                      int totalResponse = sumResponse - diffResponse - absMeanResponse;                      if (totalResponse >= totalResponseThreshold)                      {                          newResponse.totalResponse = totalResponse;                          newResponse.position = new Vector2(x' y);                          newResponse.originalIndex = validResponsesBotomToTopList.Count;                          // we are scanning pixels bottom to top so they go in the list bottom to top                          validResponsesBotomToTopList.Add(newResponse);                      }                        totalResponseRow[x] = newResponse;                        byteOffset++;                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateSumResponseAtAllPixels,The following statement contains a magic number: for (int y = trimPixels; y < height-trimPixels; y++)              {                  int byteOffset = imageBuffer.GetBufferOffsetXY(trimPixels' y);                  ValidResponseData[] totalResponseRow = allResponsesGrid.GetRow(y);                  for (int x = trimPixels; x < width - trimPixels; x++)                  {                      int sumResponse = 0;                      for (int angleToCheckIndex = 0; angleToCheckIndex < 4; angleToCheckIndex++)                      {                          int sum =                               (buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex]] + buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex + 8]])                              -                              (buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex + 4]] + buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex + 12]]);                          int absSum = Math.Abs(sum);                          sumResponse += absSum;                      }                      int neighborMeanTotal = 0;                      int diffResponse = 0;                      for (int diffCheck = 0; diffCheck < 8; diffCheck++)                      {                          int testValue = buffer[byteOffset + byteOffsetToPixel[diffCheck]];                          int oppositeValue = buffer[byteOffset + byteOffsetToPixel[diffCheck + 8]];                          diffResponse += Math.Abs(testValue - oppositeValue);                          neighborMeanTotal += testValue + oppositeValue;                      }                      int neighborMean = (neighborMeanTotal + 8) / 16;                        int centerMeanTotal = buffer[byteOffset - 1] + buffer[byteOffset + 1] + buffer[byteOffset - width] + buffer[byteOffset - width];                      int centerMean = (centerMeanTotal + 2) / 4;                      int absMeanResponse = Math.Abs(neighborMean - centerMean);                        ValidResponseData newResponse = new ValidResponseData();                      int totalResponse = sumResponse - diffResponse - absMeanResponse;                      if (totalResponse >= totalResponseThreshold)                      {                          newResponse.totalResponse = totalResponse;                          newResponse.position = new Vector2(x' y);                          newResponse.originalIndex = validResponsesBotomToTopList.Count;                          // we are scanning pixels bottom to top so they go in the list bottom to top                          validResponsesBotomToTopList.Add(newResponse);                      }                        totalResponseRow[x] = newResponse;                        byteOffset++;                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateSumResponseAtAllPixels,The following statement contains a magic number: for (int y = trimPixels; y < height-trimPixels; y++)              {                  int byteOffset = imageBuffer.GetBufferOffsetXY(trimPixels' y);                  ValidResponseData[] totalResponseRow = allResponsesGrid.GetRow(y);                  for (int x = trimPixels; x < width - trimPixels; x++)                  {                      int sumResponse = 0;                      for (int angleToCheckIndex = 0; angleToCheckIndex < 4; angleToCheckIndex++)                      {                          int sum =                               (buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex]] + buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex + 8]])                              -                              (buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex + 4]] + buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex + 12]]);                          int absSum = Math.Abs(sum);                          sumResponse += absSum;                      }                      int neighborMeanTotal = 0;                      int diffResponse = 0;                      for (int diffCheck = 0; diffCheck < 8; diffCheck++)                      {                          int testValue = buffer[byteOffset + byteOffsetToPixel[diffCheck]];                          int oppositeValue = buffer[byteOffset + byteOffsetToPixel[diffCheck + 8]];                          diffResponse += Math.Abs(testValue - oppositeValue);                          neighborMeanTotal += testValue + oppositeValue;                      }                      int neighborMean = (neighborMeanTotal + 8) / 16;                        int centerMeanTotal = buffer[byteOffset - 1] + buffer[byteOffset + 1] + buffer[byteOffset - width] + buffer[byteOffset - width];                      int centerMean = (centerMeanTotal + 2) / 4;                      int absMeanResponse = Math.Abs(neighborMean - centerMean);                        ValidResponseData newResponse = new ValidResponseData();                      int totalResponse = sumResponse - diffResponse - absMeanResponse;                      if (totalResponse >= totalResponseThreshold)                      {                          newResponse.totalResponse = totalResponse;                          newResponse.position = new Vector2(x' y);                          newResponse.originalIndex = validResponsesBotomToTopList.Count;                          // we are scanning pixels bottom to top so they go in the list bottom to top                          validResponsesBotomToTopList.Add(newResponse);                      }                        totalResponseRow[x] = newResponse;                        byteOffset++;                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateSumResponseAtAllPixels,The following statement contains a magic number: for (int y = trimPixels; y < height-trimPixels; y++)              {                  int byteOffset = imageBuffer.GetBufferOffsetXY(trimPixels' y);                  ValidResponseData[] totalResponseRow = allResponsesGrid.GetRow(y);                  for (int x = trimPixels; x < width - trimPixels; x++)                  {                      int sumResponse = 0;                      for (int angleToCheckIndex = 0; angleToCheckIndex < 4; angleToCheckIndex++)                      {                          int sum =                               (buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex]] + buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex + 8]])                              -                              (buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex + 4]] + buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex + 12]]);                          int absSum = Math.Abs(sum);                          sumResponse += absSum;                      }                      int neighborMeanTotal = 0;                      int diffResponse = 0;                      for (int diffCheck = 0; diffCheck < 8; diffCheck++)                      {                          int testValue = buffer[byteOffset + byteOffsetToPixel[diffCheck]];                          int oppositeValue = buffer[byteOffset + byteOffsetToPixel[diffCheck + 8]];                          diffResponse += Math.Abs(testValue - oppositeValue);                          neighborMeanTotal += testValue + oppositeValue;                      }                      int neighborMean = (neighborMeanTotal + 8) / 16;                        int centerMeanTotal = buffer[byteOffset - 1] + buffer[byteOffset + 1] + buffer[byteOffset - width] + buffer[byteOffset - width];                      int centerMean = (centerMeanTotal + 2) / 4;                      int absMeanResponse = Math.Abs(neighborMean - centerMean);                        ValidResponseData newResponse = new ValidResponseData();                      int totalResponse = sumResponse - diffResponse - absMeanResponse;                      if (totalResponse >= totalResponseThreshold)                      {                          newResponse.totalResponse = totalResponse;                          newResponse.position = new Vector2(x' y);                          newResponse.originalIndex = validResponsesBotomToTopList.Count;                          // we are scanning pixels bottom to top so they go in the list bottom to top                          validResponsesBotomToTopList.Add(newResponse);                      }                        totalResponseRow[x] = newResponse;                        byteOffset++;                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateSumResponseAtAllPixels,The following statement contains a magic number: for (int y = trimPixels; y < height-trimPixels; y++)              {                  int byteOffset = imageBuffer.GetBufferOffsetXY(trimPixels' y);                  ValidResponseData[] totalResponseRow = allResponsesGrid.GetRow(y);                  for (int x = trimPixels; x < width - trimPixels; x++)                  {                      int sumResponse = 0;                      for (int angleToCheckIndex = 0; angleToCheckIndex < 4; angleToCheckIndex++)                      {                          int sum =                               (buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex]] + buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex + 8]])                              -                              (buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex + 4]] + buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex + 12]]);                          int absSum = Math.Abs(sum);                          sumResponse += absSum;                      }                      int neighborMeanTotal = 0;                      int diffResponse = 0;                      for (int diffCheck = 0; diffCheck < 8; diffCheck++)                      {                          int testValue = buffer[byteOffset + byteOffsetToPixel[diffCheck]];                          int oppositeValue = buffer[byteOffset + byteOffsetToPixel[diffCheck + 8]];                          diffResponse += Math.Abs(testValue - oppositeValue);                          neighborMeanTotal += testValue + oppositeValue;                      }                      int neighborMean = (neighborMeanTotal + 8) / 16;                        int centerMeanTotal = buffer[byteOffset - 1] + buffer[byteOffset + 1] + buffer[byteOffset - width] + buffer[byteOffset - width];                      int centerMean = (centerMeanTotal + 2) / 4;                      int absMeanResponse = Math.Abs(neighborMean - centerMean);                        ValidResponseData newResponse = new ValidResponseData();                      int totalResponse = sumResponse - diffResponse - absMeanResponse;                      if (totalResponse >= totalResponseThreshold)                      {                          newResponse.totalResponse = totalResponse;                          newResponse.position = new Vector2(x' y);                          newResponse.originalIndex = validResponsesBotomToTopList.Count;                          // we are scanning pixels bottom to top so they go in the list bottom to top                          validResponsesBotomToTopList.Add(newResponse);                      }                        totalResponseRow[x] = newResponse;                        byteOffset++;                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateSumResponseAtAllPixels,The following statement contains a magic number: for (int y = trimPixels; y < height-trimPixels; y++)              {                  int byteOffset = imageBuffer.GetBufferOffsetXY(trimPixels' y);                  ValidResponseData[] totalResponseRow = allResponsesGrid.GetRow(y);                  for (int x = trimPixels; x < width - trimPixels; x++)                  {                      int sumResponse = 0;                      for (int angleToCheckIndex = 0; angleToCheckIndex < 4; angleToCheckIndex++)                      {                          int sum =                               (buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex]] + buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex + 8]])                              -                              (buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex + 4]] + buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex + 12]]);                          int absSum = Math.Abs(sum);                          sumResponse += absSum;                      }                      int neighborMeanTotal = 0;                      int diffResponse = 0;                      for (int diffCheck = 0; diffCheck < 8; diffCheck++)                      {                          int testValue = buffer[byteOffset + byteOffsetToPixel[diffCheck]];                          int oppositeValue = buffer[byteOffset + byteOffsetToPixel[diffCheck + 8]];                          diffResponse += Math.Abs(testValue - oppositeValue);                          neighborMeanTotal += testValue + oppositeValue;                      }                      int neighborMean = (neighborMeanTotal + 8) / 16;                        int centerMeanTotal = buffer[byteOffset - 1] + buffer[byteOffset + 1] + buffer[byteOffset - width] + buffer[byteOffset - width];                      int centerMean = (centerMeanTotal + 2) / 4;                      int absMeanResponse = Math.Abs(neighborMean - centerMean);                        ValidResponseData newResponse = new ValidResponseData();                      int totalResponse = sumResponse - diffResponse - absMeanResponse;                      if (totalResponse >= totalResponseThreshold)                      {                          newResponse.totalResponse = totalResponse;                          newResponse.position = new Vector2(x' y);                          newResponse.originalIndex = validResponsesBotomToTopList.Count;                          // we are scanning pixels bottom to top so they go in the list bottom to top                          validResponsesBotomToTopList.Add(newResponse);                      }                        totalResponseRow[x] = newResponse;                        byteOffset++;                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateSumResponseAtAllPixels,The following statement contains a magic number: for (int y = trimPixels; y < height-trimPixels; y++)              {                  int byteOffset = imageBuffer.GetBufferOffsetXY(trimPixels' y);                  ValidResponseData[] totalResponseRow = allResponsesGrid.GetRow(y);                  for (int x = trimPixels; x < width - trimPixels; x++)                  {                      int sumResponse = 0;                      for (int angleToCheckIndex = 0; angleToCheckIndex < 4; angleToCheckIndex++)                      {                          int sum =                               (buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex]] + buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex + 8]])                              -                              (buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex + 4]] + buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex + 12]]);                          int absSum = Math.Abs(sum);                          sumResponse += absSum;                      }                      int neighborMeanTotal = 0;                      int diffResponse = 0;                      for (int diffCheck = 0; diffCheck < 8; diffCheck++)                      {                          int testValue = buffer[byteOffset + byteOffsetToPixel[diffCheck]];                          int oppositeValue = buffer[byteOffset + byteOffsetToPixel[diffCheck + 8]];                          diffResponse += Math.Abs(testValue - oppositeValue);                          neighborMeanTotal += testValue + oppositeValue;                      }                      int neighborMean = (neighborMeanTotal + 8) / 16;                        int centerMeanTotal = buffer[byteOffset - 1] + buffer[byteOffset + 1] + buffer[byteOffset - width] + buffer[byteOffset - width];                      int centerMean = (centerMeanTotal + 2) / 4;                      int absMeanResponse = Math.Abs(neighborMean - centerMean);                        ValidResponseData newResponse = new ValidResponseData();                      int totalResponse = sumResponse - diffResponse - absMeanResponse;                      if (totalResponse >= totalResponseThreshold)                      {                          newResponse.totalResponse = totalResponse;                          newResponse.position = new Vector2(x' y);                          newResponse.originalIndex = validResponsesBotomToTopList.Count;                          // we are scanning pixels bottom to top so they go in the list bottom to top                          validResponsesBotomToTopList.Add(newResponse);                      }                        totalResponseRow[x] = newResponse;                        byteOffset++;                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateSumResponseAtAllPixels,The following statement contains a magic number: for (int y = trimPixels; y < height-trimPixels; y++)              {                  int byteOffset = imageBuffer.GetBufferOffsetXY(trimPixels' y);                  ValidResponseData[] totalResponseRow = allResponsesGrid.GetRow(y);                  for (int x = trimPixels; x < width - trimPixels; x++)                  {                      int sumResponse = 0;                      for (int angleToCheckIndex = 0; angleToCheckIndex < 4; angleToCheckIndex++)                      {                          int sum =                               (buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex]] + buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex + 8]])                              -                              (buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex + 4]] + buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex + 12]]);                          int absSum = Math.Abs(sum);                          sumResponse += absSum;                      }                      int neighborMeanTotal = 0;                      int diffResponse = 0;                      for (int diffCheck = 0; diffCheck < 8; diffCheck++)                      {                          int testValue = buffer[byteOffset + byteOffsetToPixel[diffCheck]];                          int oppositeValue = buffer[byteOffset + byteOffsetToPixel[diffCheck + 8]];                          diffResponse += Math.Abs(testValue - oppositeValue);                          neighborMeanTotal += testValue + oppositeValue;                      }                      int neighborMean = (neighborMeanTotal + 8) / 16;                        int centerMeanTotal = buffer[byteOffset - 1] + buffer[byteOffset + 1] + buffer[byteOffset - width] + buffer[byteOffset - width];                      int centerMean = (centerMeanTotal + 2) / 4;                      int absMeanResponse = Math.Abs(neighborMean - centerMean);                        ValidResponseData newResponse = new ValidResponseData();                      int totalResponse = sumResponse - diffResponse - absMeanResponse;                      if (totalResponse >= totalResponseThreshold)                      {                          newResponse.totalResponse = totalResponse;                          newResponse.position = new Vector2(x' y);                          newResponse.originalIndex = validResponsesBotomToTopList.Count;                          // we are scanning pixels bottom to top so they go in the list bottom to top                          validResponsesBotomToTopList.Add(newResponse);                      }                        totalResponseRow[x] = newResponse;                        byteOffset++;                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateSumResponseAtAllPixels,The following statement contains a magic number: for (int y = trimPixels; y < height-trimPixels; y++)              {                  int byteOffset = imageBuffer.GetBufferOffsetXY(trimPixels' y);                  ValidResponseData[] totalResponseRow = allResponsesGrid.GetRow(y);                  for (int x = trimPixels; x < width - trimPixels; x++)                  {                      int sumResponse = 0;                      for (int angleToCheckIndex = 0; angleToCheckIndex < 4; angleToCheckIndex++)                      {                          int sum =                               (buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex]] + buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex + 8]])                              -                              (buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex + 4]] + buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex + 12]]);                          int absSum = Math.Abs(sum);                          sumResponse += absSum;                      }                      int neighborMeanTotal = 0;                      int diffResponse = 0;                      for (int diffCheck = 0; diffCheck < 8; diffCheck++)                      {                          int testValue = buffer[byteOffset + byteOffsetToPixel[diffCheck]];                          int oppositeValue = buffer[byteOffset + byteOffsetToPixel[diffCheck + 8]];                          diffResponse += Math.Abs(testValue - oppositeValue);                          neighborMeanTotal += testValue + oppositeValue;                      }                      int neighborMean = (neighborMeanTotal + 8) / 16;                        int centerMeanTotal = buffer[byteOffset - 1] + buffer[byteOffset + 1] + buffer[byteOffset - width] + buffer[byteOffset - width];                      int centerMean = (centerMeanTotal + 2) / 4;                      int absMeanResponse = Math.Abs(neighborMean - centerMean);                        ValidResponseData newResponse = new ValidResponseData();                      int totalResponse = sumResponse - diffResponse - absMeanResponse;                      if (totalResponse >= totalResponseThreshold)                      {                          newResponse.totalResponse = totalResponse;                          newResponse.position = new Vector2(x' y);                          newResponse.originalIndex = validResponsesBotomToTopList.Count;                          // we are scanning pixels bottom to top so they go in the list bottom to top                          validResponsesBotomToTopList.Add(newResponse);                      }                        totalResponseRow[x] = newResponse;                        byteOffset++;                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,CalculateSumResponseAtAllPixels,The following statement contains a magic number: for (int y = trimPixels; y < height-trimPixels; y++)              {                  int byteOffset = imageBuffer.GetBufferOffsetXY(trimPixels' y);                  ValidResponseData[] totalResponseRow = allResponsesGrid.GetRow(y);                  for (int x = trimPixels; x < width - trimPixels; x++)                  {                      int sumResponse = 0;                      for (int angleToCheckIndex = 0; angleToCheckIndex < 4; angleToCheckIndex++)                      {                          int sum =                               (buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex]] + buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex + 8]])                              -                              (buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex + 4]] + buffer[byteOffset + byteOffsetToPixel[angleToCheckIndex + 12]]);                          int absSum = Math.Abs(sum);                          sumResponse += absSum;                      }                      int neighborMeanTotal = 0;                      int diffResponse = 0;                      for (int diffCheck = 0; diffCheck < 8; diffCheck++)                      {                          int testValue = buffer[byteOffset + byteOffsetToPixel[diffCheck]];                          int oppositeValue = buffer[byteOffset + byteOffsetToPixel[diffCheck + 8]];                          diffResponse += Math.Abs(testValue - oppositeValue);                          neighborMeanTotal += testValue + oppositeValue;                      }                      int neighborMean = (neighborMeanTotal + 8) / 16;                        int centerMeanTotal = buffer[byteOffset - 1] + buffer[byteOffset + 1] + buffer[byteOffset - width] + buffer[byteOffset - width];                      int centerMean = (centerMeanTotal + 2) / 4;                      int absMeanResponse = Math.Abs(neighborMean - centerMean);                        ValidResponseData newResponse = new ValidResponseData();                      int totalResponse = sumResponse - diffResponse - absMeanResponse;                      if (totalResponse >= totalResponseThreshold)                      {                          newResponse.totalResponse = totalResponse;                          newResponse.position = new Vector2(x' y);                          newResponse.originalIndex = validResponsesBotomToTopList.Count;                          // we are scanning pixels bottom to top so they go in the list bottom to top                          validResponsesBotomToTopList.Add(newResponse);                      }                        totalResponseRow[x] = newResponse;                        byteOffset++;                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,MergeResponsesThatAreSameFeatures,The following statement contains a magic number: foreach (ValidResponseData validResponse in validResponsesBotomToTopList)              {                  if (validResponse.totalResponse <= 0)                  {                      continue;                  }                    int dist = 5;                  int yStart = Math.Max(0' (int)validResponse.position.y - dist);                  int yEnd = Math.Min(height - 1' (int)validResponse.position.y + dist);                  int numFeaturesFound = 1;                  int accumulatedTotalResponse = validResponse.totalResponse;                  Vector2 accumulatedPosition = validResponse.position * accumulatedTotalResponse;                  int accumulatedOrientation = validResponse.orientation * accumulatedTotalResponse;                  for (int y = yStart; y < yEnd; y++)                  {                      int xStart = Math.Max(0' (int)validResponse.position.x - dist);                      int xEnd = Math.Min(width - 1' (int)validResponse.position.x + dist);                      for (int x = xStart; x < xEnd; x++)                      {                          if (x == validResponse.position.x && y == validResponse.position.y)                          {                              continue;                          }                            ValidResponseData testResponse = allResponsesGrid.GetValue(x' y);                          if (testResponse != null && testResponse.totalResponse > 0)                          {                              numFeaturesFound++;                              int totalResponsOfTest = testResponse.totalResponse;                              testResponse.totalResponse = 0;                              accumulatedTotalResponse += totalResponsOfTest;                              accumulatedPosition += testResponse.position * totalResponsOfTest;                              accumulatedOrientation += testResponse.orientation * totalResponsOfTest;                          }                      }                  }                    if (numFeaturesFound < 2)                  {                      validResponse.totalResponse = 0;                  }                  else                  {                      validResponse.position = accumulatedPosition / accumulatedTotalResponse;                      validResponse.orientation = (int)((double)accumulatedOrientation / accumulatedTotalResponse + .5);                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,MergeResponsesThatAreSameFeatures,The following statement contains a magic number: foreach (ValidResponseData validResponse in validResponsesBotomToTopList)              {                  if (validResponse.totalResponse <= 0)                  {                      continue;                  }                    int dist = 5;                  int yStart = Math.Max(0' (int)validResponse.position.y - dist);                  int yEnd = Math.Min(height - 1' (int)validResponse.position.y + dist);                  int numFeaturesFound = 1;                  int accumulatedTotalResponse = validResponse.totalResponse;                  Vector2 accumulatedPosition = validResponse.position * accumulatedTotalResponse;                  int accumulatedOrientation = validResponse.orientation * accumulatedTotalResponse;                  for (int y = yStart; y < yEnd; y++)                  {                      int xStart = Math.Max(0' (int)validResponse.position.x - dist);                      int xEnd = Math.Min(width - 1' (int)validResponse.position.x + dist);                      for (int x = xStart; x < xEnd; x++)                      {                          if (x == validResponse.position.x && y == validResponse.position.y)                          {                              continue;                          }                            ValidResponseData testResponse = allResponsesGrid.GetValue(x' y);                          if (testResponse != null && testResponse.totalResponse > 0)                          {                              numFeaturesFound++;                              int totalResponsOfTest = testResponse.totalResponse;                              testResponse.totalResponse = 0;                              accumulatedTotalResponse += totalResponsOfTest;                              accumulatedPosition += testResponse.position * totalResponsOfTest;                              accumulatedOrientation += testResponse.orientation * totalResponsOfTest;                          }                      }                  }                    if (numFeaturesFound < 2)                  {                      validResponse.totalResponse = 0;                  }                  else                  {                      validResponse.position = accumulatedPosition / accumulatedTotalResponse;                      validResponse.orientation = (int)((double)accumulatedOrientation / accumulatedTotalResponse + .5);                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,MergeResponsesThatAreSameFeatures,The following statement contains a magic number: foreach (ValidResponseData validResponse in validResponsesBotomToTopList)              {                  if (validResponse.totalResponse <= 0)                  {                      continue;                  }                    int dist = 5;                  int yStart = Math.Max(0' (int)validResponse.position.y - dist);                  int yEnd = Math.Min(height - 1' (int)validResponse.position.y + dist);                  int numFeaturesFound = 1;                  int accumulatedTotalResponse = validResponse.totalResponse;                  Vector2 accumulatedPosition = validResponse.position * accumulatedTotalResponse;                  int accumulatedOrientation = validResponse.orientation * accumulatedTotalResponse;                  for (int y = yStart; y < yEnd; y++)                  {                      int xStart = Math.Max(0' (int)validResponse.position.x - dist);                      int xEnd = Math.Min(width - 1' (int)validResponse.position.x + dist);                      for (int x = xStart; x < xEnd; x++)                      {                          if (x == validResponse.position.x && y == validResponse.position.y)                          {                              continue;                          }                            ValidResponseData testResponse = allResponsesGrid.GetValue(x' y);                          if (testResponse != null && testResponse.totalResponse > 0)                          {                              numFeaturesFound++;                              int totalResponsOfTest = testResponse.totalResponse;                              testResponse.totalResponse = 0;                              accumulatedTotalResponse += totalResponsOfTest;                              accumulatedPosition += testResponse.position * totalResponsOfTest;                              accumulatedOrientation += testResponse.orientation * totalResponsOfTest;                          }                      }                  }                    if (numFeaturesFound < 2)                  {                      validResponse.totalResponse = 0;                  }                  else                  {                      validResponse.position = accumulatedPosition / accumulatedTotalResponse;                      validResponse.orientation = (int)((double)accumulatedOrientation / accumulatedTotalResponse + .5);                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindSubPixelPositions,The following statement contains a magic number: foreach (ValidResponseData validResponse in validResponsesBotomToTopList)              {                  Vector2 position = validResponse.position;                  int centerXInt = (int)(position.x + .5);                  int centerYInt = (int)(position.y + .5);                    int min = int.MaxValue;                  int max = int.MinValue;                  {                      for (int y = centerYInt - 5; y <= centerYInt + 5; y++)                      {                          int byteOffset = imageBuffer.GetBufferOffsetY(y);                          ValidResponseData[] totalResponseRow = allResponsesGrid.GetRow(y);                          for (int x = centerXInt - 5; x <= centerXInt + 5; x++)                          {                              int intensity = buffer[byteOffset + x];                              if (intensity < min) min = intensity;                              if (intensity > max) max = intensity;                          }                      }                  }                  double center = (max - min) / 2 + min;                  double maxRange = (max - min) / 4;                    {                      double weight = 0;                      Vector2 accumulatedPosition = Vector2.Zero;                      for (int y = centerYInt - 5; y <= centerYInt + 5; y++)                      {                          int byteOffset = imageBuffer.GetBufferOffsetY(y);                          ValidResponseData[] totalResponseRow = allResponsesGrid.GetRow(y);                          for (int x = centerXInt - 5; x <= centerXInt + 5; x++)                          {                              int value = buffer[byteOffset + x];                              double absDeltaFromCenter = Math.Abs(value - center);                              double contribution = 1 - (absDeltaFromCenter / maxRange);                              contribution = Math.Max(0' Math.Min(1' contribution));                              double distScalling = Math.Min(1' Math.Max(0' 1 - ((new Vector2(x' y) - position).Length - 3) / 2));                              contribution *= distScalling;                              weight += contribution;                              accumulatedPosition += new Vector2(x' y) * contribution;    #if SHOW_SUB_PIXEL_LOGIC                                  if(i==4) buffer[byteOffset + x] = (byte)(contribution * 255);  #endif                          }                      }                        validResponse.position = accumulatedPosition / weight;                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindSubPixelPositions,The following statement contains a magic number: foreach (ValidResponseData validResponse in validResponsesBotomToTopList)              {                  Vector2 position = validResponse.position;                  int centerXInt = (int)(position.x + .5);                  int centerYInt = (int)(position.y + .5);                    int min = int.MaxValue;                  int max = int.MinValue;                  {                      for (int y = centerYInt - 5; y <= centerYInt + 5; y++)                      {                          int byteOffset = imageBuffer.GetBufferOffsetY(y);                          ValidResponseData[] totalResponseRow = allResponsesGrid.GetRow(y);                          for (int x = centerXInt - 5; x <= centerXInt + 5; x++)                          {                              int intensity = buffer[byteOffset + x];                              if (intensity < min) min = intensity;                              if (intensity > max) max = intensity;                          }                      }                  }                  double center = (max - min) / 2 + min;                  double maxRange = (max - min) / 4;                    {                      double weight = 0;                      Vector2 accumulatedPosition = Vector2.Zero;                      for (int y = centerYInt - 5; y <= centerYInt + 5; y++)                      {                          int byteOffset = imageBuffer.GetBufferOffsetY(y);                          ValidResponseData[] totalResponseRow = allResponsesGrid.GetRow(y);                          for (int x = centerXInt - 5; x <= centerXInt + 5; x++)                          {                              int value = buffer[byteOffset + x];                              double absDeltaFromCenter = Math.Abs(value - center);                              double contribution = 1 - (absDeltaFromCenter / maxRange);                              contribution = Math.Max(0' Math.Min(1' contribution));                              double distScalling = Math.Min(1' Math.Max(0' 1 - ((new Vector2(x' y) - position).Length - 3) / 2));                              contribution *= distScalling;                              weight += contribution;                              accumulatedPosition += new Vector2(x' y) * contribution;    #if SHOW_SUB_PIXEL_LOGIC                                  if(i==4) buffer[byteOffset + x] = (byte)(contribution * 255);  #endif                          }                      }                        validResponse.position = accumulatedPosition / weight;                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindSubPixelPositions,The following statement contains a magic number: foreach (ValidResponseData validResponse in validResponsesBotomToTopList)              {                  Vector2 position = validResponse.position;                  int centerXInt = (int)(position.x + .5);                  int centerYInt = (int)(position.y + .5);                    int min = int.MaxValue;                  int max = int.MinValue;                  {                      for (int y = centerYInt - 5; y <= centerYInt + 5; y++)                      {                          int byteOffset = imageBuffer.GetBufferOffsetY(y);                          ValidResponseData[] totalResponseRow = allResponsesGrid.GetRow(y);                          for (int x = centerXInt - 5; x <= centerXInt + 5; x++)                          {                              int intensity = buffer[byteOffset + x];                              if (intensity < min) min = intensity;                              if (intensity > max) max = intensity;                          }                      }                  }                  double center = (max - min) / 2 + min;                  double maxRange = (max - min) / 4;                    {                      double weight = 0;                      Vector2 accumulatedPosition = Vector2.Zero;                      for (int y = centerYInt - 5; y <= centerYInt + 5; y++)                      {                          int byteOffset = imageBuffer.GetBufferOffsetY(y);                          ValidResponseData[] totalResponseRow = allResponsesGrid.GetRow(y);                          for (int x = centerXInt - 5; x <= centerXInt + 5; x++)                          {                              int value = buffer[byteOffset + x];                              double absDeltaFromCenter = Math.Abs(value - center);                              double contribution = 1 - (absDeltaFromCenter / maxRange);                              contribution = Math.Max(0' Math.Min(1' contribution));                              double distScalling = Math.Min(1' Math.Max(0' 1 - ((new Vector2(x' y) - position).Length - 3) / 2));                              contribution *= distScalling;                              weight += contribution;                              accumulatedPosition += new Vector2(x' y) * contribution;    #if SHOW_SUB_PIXEL_LOGIC                                  if(i==4) buffer[byteOffset + x] = (byte)(contribution * 255);  #endif                          }                      }                        validResponse.position = accumulatedPosition / weight;                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindSubPixelPositions,The following statement contains a magic number: foreach (ValidResponseData validResponse in validResponsesBotomToTopList)              {                  Vector2 position = validResponse.position;                  int centerXInt = (int)(position.x + .5);                  int centerYInt = (int)(position.y + .5);                    int min = int.MaxValue;                  int max = int.MinValue;                  {                      for (int y = centerYInt - 5; y <= centerYInt + 5; y++)                      {                          int byteOffset = imageBuffer.GetBufferOffsetY(y);                          ValidResponseData[] totalResponseRow = allResponsesGrid.GetRow(y);                          for (int x = centerXInt - 5; x <= centerXInt + 5; x++)                          {                              int intensity = buffer[byteOffset + x];                              if (intensity < min) min = intensity;                              if (intensity > max) max = intensity;                          }                      }                  }                  double center = (max - min) / 2 + min;                  double maxRange = (max - min) / 4;                    {                      double weight = 0;                      Vector2 accumulatedPosition = Vector2.Zero;                      for (int y = centerYInt - 5; y <= centerYInt + 5; y++)                      {                          int byteOffset = imageBuffer.GetBufferOffsetY(y);                          ValidResponseData[] totalResponseRow = allResponsesGrid.GetRow(y);                          for (int x = centerXInt - 5; x <= centerXInt + 5; x++)                          {                              int value = buffer[byteOffset + x];                              double absDeltaFromCenter = Math.Abs(value - center);                              double contribution = 1 - (absDeltaFromCenter / maxRange);                              contribution = Math.Max(0' Math.Min(1' contribution));                              double distScalling = Math.Min(1' Math.Max(0' 1 - ((new Vector2(x' y) - position).Length - 3) / 2));                              contribution *= distScalling;                              weight += contribution;                              accumulatedPosition += new Vector2(x' y) * contribution;    #if SHOW_SUB_PIXEL_LOGIC                                  if(i==4) buffer[byteOffset + x] = (byte)(contribution * 255);  #endif                          }                      }                        validResponse.position = accumulatedPosition / weight;                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindSubPixelPositions,The following statement contains a magic number: foreach (ValidResponseData validResponse in validResponsesBotomToTopList)              {                  Vector2 position = validResponse.position;                  int centerXInt = (int)(position.x + .5);                  int centerYInt = (int)(position.y + .5);                    int min = int.MaxValue;                  int max = int.MinValue;                  {                      for (int y = centerYInt - 5; y <= centerYInt + 5; y++)                      {                          int byteOffset = imageBuffer.GetBufferOffsetY(y);                          ValidResponseData[] totalResponseRow = allResponsesGrid.GetRow(y);                          for (int x = centerXInt - 5; x <= centerXInt + 5; x++)                          {                              int intensity = buffer[byteOffset + x];                              if (intensity < min) min = intensity;                              if (intensity > max) max = intensity;                          }                      }                  }                  double center = (max - min) / 2 + min;                  double maxRange = (max - min) / 4;                    {                      double weight = 0;                      Vector2 accumulatedPosition = Vector2.Zero;                      for (int y = centerYInt - 5; y <= centerYInt + 5; y++)                      {                          int byteOffset = imageBuffer.GetBufferOffsetY(y);                          ValidResponseData[] totalResponseRow = allResponsesGrid.GetRow(y);                          for (int x = centerXInt - 5; x <= centerXInt + 5; x++)                          {                              int value = buffer[byteOffset + x];                              double absDeltaFromCenter = Math.Abs(value - center);                              double contribution = 1 - (absDeltaFromCenter / maxRange);                              contribution = Math.Max(0' Math.Min(1' contribution));                              double distScalling = Math.Min(1' Math.Max(0' 1 - ((new Vector2(x' y) - position).Length - 3) / 2));                              contribution *= distScalling;                              weight += contribution;                              accumulatedPosition += new Vector2(x' y) * contribution;    #if SHOW_SUB_PIXEL_LOGIC                                  if(i==4) buffer[byteOffset + x] = (byte)(contribution * 255);  #endif                          }                      }                        validResponse.position = accumulatedPosition / weight;                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindSubPixelPositions,The following statement contains a magic number: foreach (ValidResponseData validResponse in validResponsesBotomToTopList)              {                  Vector2 position = validResponse.position;                  int centerXInt = (int)(position.x + .5);                  int centerYInt = (int)(position.y + .5);                    int min = int.MaxValue;                  int max = int.MinValue;                  {                      for (int y = centerYInt - 5; y <= centerYInt + 5; y++)                      {                          int byteOffset = imageBuffer.GetBufferOffsetY(y);                          ValidResponseData[] totalResponseRow = allResponsesGrid.GetRow(y);                          for (int x = centerXInt - 5; x <= centerXInt + 5; x++)                          {                              int intensity = buffer[byteOffset + x];                              if (intensity < min) min = intensity;                              if (intensity > max) max = intensity;                          }                      }                  }                  double center = (max - min) / 2 + min;                  double maxRange = (max - min) / 4;                    {                      double weight = 0;                      Vector2 accumulatedPosition = Vector2.Zero;                      for (int y = centerYInt - 5; y <= centerYInt + 5; y++)                      {                          int byteOffset = imageBuffer.GetBufferOffsetY(y);                          ValidResponseData[] totalResponseRow = allResponsesGrid.GetRow(y);                          for (int x = centerXInt - 5; x <= centerXInt + 5; x++)                          {                              int value = buffer[byteOffset + x];                              double absDeltaFromCenter = Math.Abs(value - center);                              double contribution = 1 - (absDeltaFromCenter / maxRange);                              contribution = Math.Max(0' Math.Min(1' contribution));                              double distScalling = Math.Min(1' Math.Max(0' 1 - ((new Vector2(x' y) - position).Length - 3) / 2));                              contribution *= distScalling;                              weight += contribution;                              accumulatedPosition += new Vector2(x' y) * contribution;    #if SHOW_SUB_PIXEL_LOGIC                                  if(i==4) buffer[byteOffset + x] = (byte)(contribution * 255);  #endif                          }                      }                        validResponse.position = accumulatedPosition / weight;                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindSubPixelPositions,The following statement contains a magic number: foreach (ValidResponseData validResponse in validResponsesBotomToTopList)              {                  Vector2 position = validResponse.position;                  int centerXInt = (int)(position.x + .5);                  int centerYInt = (int)(position.y + .5);                    int min = int.MaxValue;                  int max = int.MinValue;                  {                      for (int y = centerYInt - 5; y <= centerYInt + 5; y++)                      {                          int byteOffset = imageBuffer.GetBufferOffsetY(y);                          ValidResponseData[] totalResponseRow = allResponsesGrid.GetRow(y);                          for (int x = centerXInt - 5; x <= centerXInt + 5; x++)                          {                              int intensity = buffer[byteOffset + x];                              if (intensity < min) min = intensity;                              if (intensity > max) max = intensity;                          }                      }                  }                  double center = (max - min) / 2 + min;                  double maxRange = (max - min) / 4;                    {                      double weight = 0;                      Vector2 accumulatedPosition = Vector2.Zero;                      for (int y = centerYInt - 5; y <= centerYInt + 5; y++)                      {                          int byteOffset = imageBuffer.GetBufferOffsetY(y);                          ValidResponseData[] totalResponseRow = allResponsesGrid.GetRow(y);                          for (int x = centerXInt - 5; x <= centerXInt + 5; x++)                          {                              int value = buffer[byteOffset + x];                              double absDeltaFromCenter = Math.Abs(value - center);                              double contribution = 1 - (absDeltaFromCenter / maxRange);                              contribution = Math.Max(0' Math.Min(1' contribution));                              double distScalling = Math.Min(1' Math.Max(0' 1 - ((new Vector2(x' y) - position).Length - 3) / 2));                              contribution *= distScalling;                              weight += contribution;                              accumulatedPosition += new Vector2(x' y) * contribution;    #if SHOW_SUB_PIXEL_LOGIC                                  if(i==4) buffer[byteOffset + x] = (byte)(contribution * 255);  #endif                          }                      }                        validResponse.position = accumulatedPosition / weight;                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindSubPixelPositions,The following statement contains a magic number: foreach (ValidResponseData validResponse in validResponsesBotomToTopList)              {                  Vector2 position = validResponse.position;                  int centerXInt = (int)(position.x + .5);                  int centerYInt = (int)(position.y + .5);                    int min = int.MaxValue;                  int max = int.MinValue;                  {                      for (int y = centerYInt - 5; y <= centerYInt + 5; y++)                      {                          int byteOffset = imageBuffer.GetBufferOffsetY(y);                          ValidResponseData[] totalResponseRow = allResponsesGrid.GetRow(y);                          for (int x = centerXInt - 5; x <= centerXInt + 5; x++)                          {                              int intensity = buffer[byteOffset + x];                              if (intensity < min) min = intensity;                              if (intensity > max) max = intensity;                          }                      }                  }                  double center = (max - min) / 2 + min;                  double maxRange = (max - min) / 4;                    {                      double weight = 0;                      Vector2 accumulatedPosition = Vector2.Zero;                      for (int y = centerYInt - 5; y <= centerYInt + 5; y++)                      {                          int byteOffset = imageBuffer.GetBufferOffsetY(y);                          ValidResponseData[] totalResponseRow = allResponsesGrid.GetRow(y);                          for (int x = centerXInt - 5; x <= centerXInt + 5; x++)                          {                              int value = buffer[byteOffset + x];                              double absDeltaFromCenter = Math.Abs(value - center);                              double contribution = 1 - (absDeltaFromCenter / maxRange);                              contribution = Math.Max(0' Math.Min(1' contribution));                              double distScalling = Math.Min(1' Math.Max(0' 1 - ((new Vector2(x' y) - position).Length - 3) / 2));                              contribution *= distScalling;                              weight += contribution;                              accumulatedPosition += new Vector2(x' y) * contribution;    #if SHOW_SUB_PIXEL_LOGIC                                  if(i==4) buffer[byteOffset + x] = (byte)(contribution * 255);  #endif                          }                      }                        validResponse.position = accumulatedPosition / weight;                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindSubPixelPositions,The following statement contains a magic number: foreach (ValidResponseData validResponse in validResponsesBotomToTopList)              {                  Vector2 position = validResponse.position;                  int centerXInt = (int)(position.x + .5);                  int centerYInt = (int)(position.y + .5);                    int min = int.MaxValue;                  int max = int.MinValue;                  {                      for (int y = centerYInt - 5; y <= centerYInt + 5; y++)                      {                          int byteOffset = imageBuffer.GetBufferOffsetY(y);                          ValidResponseData[] totalResponseRow = allResponsesGrid.GetRow(y);                          for (int x = centerXInt - 5; x <= centerXInt + 5; x++)                          {                              int intensity = buffer[byteOffset + x];                              if (intensity < min) min = intensity;                              if (intensity > max) max = intensity;                          }                      }                  }                  double center = (max - min) / 2 + min;                  double maxRange = (max - min) / 4;                    {                      double weight = 0;                      Vector2 accumulatedPosition = Vector2.Zero;                      for (int y = centerYInt - 5; y <= centerYInt + 5; y++)                      {                          int byteOffset = imageBuffer.GetBufferOffsetY(y);                          ValidResponseData[] totalResponseRow = allResponsesGrid.GetRow(y);                          for (int x = centerXInt - 5; x <= centerXInt + 5; x++)                          {                              int value = buffer[byteOffset + x];                              double absDeltaFromCenter = Math.Abs(value - center);                              double contribution = 1 - (absDeltaFromCenter / maxRange);                              contribution = Math.Max(0' Math.Min(1' contribution));                              double distScalling = Math.Min(1' Math.Max(0' 1 - ((new Vector2(x' y) - position).Length - 3) / 2));                              contribution *= distScalling;                              weight += contribution;                              accumulatedPosition += new Vector2(x' y) * contribution;    #if SHOW_SUB_PIXEL_LOGIC                                  if(i==4) buffer[byteOffset + x] = (byte)(contribution * 255);  #endif                          }                      }                        validResponse.position = accumulatedPosition / weight;                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindSubPixelPositions,The following statement contains a magic number: foreach (ValidResponseData validResponse in validResponsesBotomToTopList)              {                  Vector2 position = validResponse.position;                  int centerXInt = (int)(position.x + .5);                  int centerYInt = (int)(position.y + .5);                    int min = int.MaxValue;                  int max = int.MinValue;                  {                      for (int y = centerYInt - 5; y <= centerYInt + 5; y++)                      {                          int byteOffset = imageBuffer.GetBufferOffsetY(y);                          ValidResponseData[] totalResponseRow = allResponsesGrid.GetRow(y);                          for (int x = centerXInt - 5; x <= centerXInt + 5; x++)                          {                              int intensity = buffer[byteOffset + x];                              if (intensity < min) min = intensity;                              if (intensity > max) max = intensity;                          }                      }                  }                  double center = (max - min) / 2 + min;                  double maxRange = (max - min) / 4;                    {                      double weight = 0;                      Vector2 accumulatedPosition = Vector2.Zero;                      for (int y = centerYInt - 5; y <= centerYInt + 5; y++)                      {                          int byteOffset = imageBuffer.GetBufferOffsetY(y);                          ValidResponseData[] totalResponseRow = allResponsesGrid.GetRow(y);                          for (int x = centerXInt - 5; x <= centerXInt + 5; x++)                          {                              int value = buffer[byteOffset + x];                              double absDeltaFromCenter = Math.Abs(value - center);                              double contribution = 1 - (absDeltaFromCenter / maxRange);                              contribution = Math.Max(0' Math.Min(1' contribution));                              double distScalling = Math.Min(1' Math.Max(0' 1 - ((new Vector2(x' y) - position).Length - 3) / 2));                              contribution *= distScalling;                              weight += contribution;                              accumulatedPosition += new Vector2(x' y) * contribution;    #if SHOW_SUB_PIXEL_LOGIC                                  if(i==4) buffer[byteOffset + x] = (byte)(contribution * 255);  #endif                          }                      }                        validResponse.position = accumulatedPosition / weight;                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindSubPixelPositions,The following statement contains a magic number: foreach (ValidResponseData validResponse in validResponsesBotomToTopList)              {                  Vector2 position = validResponse.position;                  int centerXInt = (int)(position.x + .5);                  int centerYInt = (int)(position.y + .5);                    int min = int.MaxValue;                  int max = int.MinValue;                  {                      for (int y = centerYInt - 5; y <= centerYInt + 5; y++)                      {                          int byteOffset = imageBuffer.GetBufferOffsetY(y);                          ValidResponseData[] totalResponseRow = allResponsesGrid.GetRow(y);                          for (int x = centerXInt - 5; x <= centerXInt + 5; x++)                          {                              int intensity = buffer[byteOffset + x];                              if (intensity < min) min = intensity;                              if (intensity > max) max = intensity;                          }                      }                  }                  double center = (max - min) / 2 + min;                  double maxRange = (max - min) / 4;                    {                      double weight = 0;                      Vector2 accumulatedPosition = Vector2.Zero;                      for (int y = centerYInt - 5; y <= centerYInt + 5; y++)                      {                          int byteOffset = imageBuffer.GetBufferOffsetY(y);                          ValidResponseData[] totalResponseRow = allResponsesGrid.GetRow(y);                          for (int x = centerXInt - 5; x <= centerXInt + 5; x++)                          {                              int value = buffer[byteOffset + x];                              double absDeltaFromCenter = Math.Abs(value - center);                              double contribution = 1 - (absDeltaFromCenter / maxRange);                              contribution = Math.Max(0' Math.Min(1' contribution));                              double distScalling = Math.Min(1' Math.Max(0' 1 - ((new Vector2(x' y) - position).Length - 3) / 2));                              contribution *= distScalling;                              weight += contribution;                              accumulatedPosition += new Vector2(x' y) * contribution;    #if SHOW_SUB_PIXEL_LOGIC                                  if(i==4) buffer[byteOffset + x] = (byte)(contribution * 255);  #endif                          }                      }                        validResponse.position = accumulatedPosition / weight;                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindSubPixelPositions,The following statement contains a magic number: foreach (ValidResponseData validResponse in validResponsesBotomToTopList)              {                  Vector2 position = validResponse.position;                  int centerXInt = (int)(position.x + .5);                  int centerYInt = (int)(position.y + .5);                    int min = int.MaxValue;                  int max = int.MinValue;                  {                      for (int y = centerYInt - 5; y <= centerYInt + 5; y++)                      {                          int byteOffset = imageBuffer.GetBufferOffsetY(y);                          ValidResponseData[] totalResponseRow = allResponsesGrid.GetRow(y);                          for (int x = centerXInt - 5; x <= centerXInt + 5; x++)                          {                              int intensity = buffer[byteOffset + x];                              if (intensity < min) min = intensity;                              if (intensity > max) max = intensity;                          }                      }                  }                  double center = (max - min) / 2 + min;                  double maxRange = (max - min) / 4;                    {                      double weight = 0;                      Vector2 accumulatedPosition = Vector2.Zero;                      for (int y = centerYInt - 5; y <= centerYInt + 5; y++)                      {                          int byteOffset = imageBuffer.GetBufferOffsetY(y);                          ValidResponseData[] totalResponseRow = allResponsesGrid.GetRow(y);                          for (int x = centerXInt - 5; x <= centerXInt + 5; x++)                          {                              int value = buffer[byteOffset + x];                              double absDeltaFromCenter = Math.Abs(value - center);                              double contribution = 1 - (absDeltaFromCenter / maxRange);                              contribution = Math.Max(0' Math.Min(1' contribution));                              double distScalling = Math.Min(1' Math.Max(0' 1 - ((new Vector2(x' y) - position).Length - 3) / 2));                              contribution *= distScalling;                              weight += contribution;                              accumulatedPosition += new Vector2(x' y) * contribution;    #if SHOW_SUB_PIXEL_LOGIC                                  if(i==4) buffer[byteOffset + x] = (byte)(contribution * 255);  #endif                          }                      }                        validResponse.position = accumulatedPosition / weight;                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindSubPixelPositions,The following statement contains a magic number: foreach (ValidResponseData validResponse in validResponsesBotomToTopList)              {                  Vector2 position = validResponse.position;                  int centerXInt = (int)(position.x + .5);                  int centerYInt = (int)(position.y + .5);                    int min = int.MaxValue;                  int max = int.MinValue;                  {                      for (int y = centerYInt - 5; y <= centerYInt + 5; y++)                      {                          int byteOffset = imageBuffer.GetBufferOffsetY(y);                          ValidResponseData[] totalResponseRow = allResponsesGrid.GetRow(y);                          for (int x = centerXInt - 5; x <= centerXInt + 5; x++)                          {                              int intensity = buffer[byteOffset + x];                              if (intensity < min) min = intensity;                              if (intensity > max) max = intensity;                          }                      }                  }                  double center = (max - min) / 2 + min;                  double maxRange = (max - min) / 4;                    {                      double weight = 0;                      Vector2 accumulatedPosition = Vector2.Zero;                      for (int y = centerYInt - 5; y <= centerYInt + 5; y++)                      {                          int byteOffset = imageBuffer.GetBufferOffsetY(y);                          ValidResponseData[] totalResponseRow = allResponsesGrid.GetRow(y);                          for (int x = centerXInt - 5; x <= centerXInt + 5; x++)                          {                              int value = buffer[byteOffset + x];                              double absDeltaFromCenter = Math.Abs(value - center);                              double contribution = 1 - (absDeltaFromCenter / maxRange);                              contribution = Math.Max(0' Math.Min(1' contribution));                              double distScalling = Math.Min(1' Math.Max(0' 1 - ((new Vector2(x' y) - position).Length - 3) / 2));                              contribution *= distScalling;                              weight += contribution;                              accumulatedPosition += new Vector2(x' y) * contribution;    #if SHOW_SUB_PIXEL_LOGIC                                  if(i==4) buffer[byteOffset + x] = (byte)(contribution * 255);  #endif                          }                      }                        validResponse.position = accumulatedPosition / weight;                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindSubPixelPositions,The following statement contains a magic number: foreach (ValidResponseData validResponse in validResponsesBotomToTopList)              {                  Vector2 position = validResponse.position;                  int centerXInt = (int)(position.x + .5);                  int centerYInt = (int)(position.y + .5);                    int min = int.MaxValue;                  int max = int.MinValue;                  {                      for (int y = centerYInt - 5; y <= centerYInt + 5; y++)                      {                          int byteOffset = imageBuffer.GetBufferOffsetY(y);                          ValidResponseData[] totalResponseRow = allResponsesGrid.GetRow(y);                          for (int x = centerXInt - 5; x <= centerXInt + 5; x++)                          {                              int intensity = buffer[byteOffset + x];                              if (intensity < min) min = intensity;                              if (intensity > max) max = intensity;                          }                      }                  }                  double center = (max - min) / 2 + min;                  double maxRange = (max - min) / 4;                    {                      double weight = 0;                      Vector2 accumulatedPosition = Vector2.Zero;                      for (int y = centerYInt - 5; y <= centerYInt + 5; y++)                      {                          int byteOffset = imageBuffer.GetBufferOffsetY(y);                          ValidResponseData[] totalResponseRow = allResponsesGrid.GetRow(y);                          for (int x = centerXInt - 5; x <= centerXInt + 5; x++)                          {                              int value = buffer[byteOffset + x];                              double absDeltaFromCenter = Math.Abs(value - center);                              double contribution = 1 - (absDeltaFromCenter / maxRange);                              contribution = Math.Max(0' Math.Min(1' contribution));                              double distScalling = Math.Min(1' Math.Max(0' 1 - ((new Vector2(x' y) - position).Length - 3) / 2));                              contribution *= distScalling;                              weight += contribution;                              accumulatedPosition += new Vector2(x' y) * contribution;    #if SHOW_SUB_PIXEL_LOGIC                                  if(i==4) buffer[byteOffset + x] = (byte)(contribution * 255);  #endif                          }                      }                        validResponse.position = accumulatedPosition / weight;                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindChessBoardLines,The following statement contains a magic number: for (int i = validResponsesBotomToTopList.Count - 1; i >= 0; i--)              {                  ValidResponseData checkItem = validResponsesBotomToTopList[i];                    sortedList.Sort(new SortOnDistance(checkItem.position));                    int numThatAreValid = 0;                  if (sortedList.Count > 5)                  {                      for (int j = 1; j < 5; j++)                      {                          ValidResponseData nextNearest = sortedList[j];                          if (nextNearest == checkItem)                          {                              continue;                          }                            int delta = Math.Abs(checkItem.orientation - nextNearest.orientation);                          if (delta > 2 && delta < 5)                          {                              numThatAreValid++;                          }                      }                        // find out if it has at least 2 valid connections next to it.                      if (numThatAreValid < 2)                      {                          validResponsesBotomToTopList.RemoveAt(i);                          sortedList = new List<ValidResponseData>(validResponsesBotomToTopList);                      }                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindChessBoardLines,The following statement contains a magic number: for (int i = validResponsesBotomToTopList.Count - 1; i >= 0; i--)              {                  ValidResponseData checkItem = validResponsesBotomToTopList[i];                    sortedList.Sort(new SortOnDistance(checkItem.position));                    int numThatAreValid = 0;                  if (sortedList.Count > 5)                  {                      for (int j = 1; j < 5; j++)                      {                          ValidResponseData nextNearest = sortedList[j];                          if (nextNearest == checkItem)                          {                              continue;                          }                            int delta = Math.Abs(checkItem.orientation - nextNearest.orientation);                          if (delta > 2 && delta < 5)                          {                              numThatAreValid++;                          }                      }                        // find out if it has at least 2 valid connections next to it.                      if (numThatAreValid < 2)                      {                          validResponsesBotomToTopList.RemoveAt(i);                          sortedList = new List<ValidResponseData>(validResponsesBotomToTopList);                      }                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindChessBoardLines,The following statement contains a magic number: for (int i = validResponsesBotomToTopList.Count - 1; i >= 0; i--)              {                  ValidResponseData checkItem = validResponsesBotomToTopList[i];                    sortedList.Sort(new SortOnDistance(checkItem.position));                    int numThatAreValid = 0;                  if (sortedList.Count > 5)                  {                      for (int j = 1; j < 5; j++)                      {                          ValidResponseData nextNearest = sortedList[j];                          if (nextNearest == checkItem)                          {                              continue;                          }                            int delta = Math.Abs(checkItem.orientation - nextNearest.orientation);                          if (delta > 2 && delta < 5)                          {                              numThatAreValid++;                          }                      }                        // find out if it has at least 2 valid connections next to it.                      if (numThatAreValid < 2)                      {                          validResponsesBotomToTopList.RemoveAt(i);                          sortedList = new List<ValidResponseData>(validResponsesBotomToTopList);                      }                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindChessBoardLines,The following statement contains a magic number: for (int i = validResponsesBotomToTopList.Count - 1; i >= 0; i--)              {                  ValidResponseData checkItem = validResponsesBotomToTopList[i];                    sortedList.Sort(new SortOnDistance(checkItem.position));                    int numThatAreValid = 0;                  if (sortedList.Count > 5)                  {                      for (int j = 1; j < 5; j++)                      {                          ValidResponseData nextNearest = sortedList[j];                          if (nextNearest == checkItem)                          {                              continue;                          }                            int delta = Math.Abs(checkItem.orientation - nextNearest.orientation);                          if (delta > 2 && delta < 5)                          {                              numThatAreValid++;                          }                      }                        // find out if it has at least 2 valid connections next to it.                      if (numThatAreValid < 2)                      {                          validResponsesBotomToTopList.RemoveAt(i);                          sortedList = new List<ValidResponseData>(validResponsesBotomToTopList);                      }                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindChessBoardLines,The following statement contains a magic number: for (int i = validResponsesBotomToTopList.Count - 1; i >= 0; i--)              {                  ValidResponseData checkItem = validResponsesBotomToTopList[i];                    sortedList.Sort(new SortOnDistance(checkItem.position));                    int numThatAreValid = 0;                  if (sortedList.Count > 5)                  {                      for (int j = 1; j < 5; j++)                      {                          ValidResponseData nextNearest = sortedList[j];                          if (nextNearest == checkItem)                          {                              continue;                          }                            int delta = Math.Abs(checkItem.orientation - nextNearest.orientation);                          if (delta > 2 && delta < 5)                          {                              numThatAreValid++;                          }                      }                        // find out if it has at least 2 valid connections next to it.                      if (numThatAreValid < 2)                      {                          validResponsesBotomToTopList.RemoveAt(i);                          sortedList = new List<ValidResponseData>(validResponsesBotomToTopList);                      }                  }              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindChessBoardLines,The following statement contains a magic number: if (validResponsesBotomToTopList.Count > 5)              {                  foreach (ValidResponseData item in validResponsesBotomToTopList)                  {                      sortedList.Sort(new SortOnDistance(item.position));                        int numNeighborsThatCouldBeOnChessboard = 0;                      for (int i = 1; i < 5; i++)                      {                          ValidResponseData nextNearest = sortedList[i];                          if (nextNearest == item)                          {                              continue;                          }                            int delta = Math.Abs(item.orientation - nextNearest.orientation);                          if (delta > 2 && delta < 5)                          {                              numNeighborsThatCouldBeOnChessboard++;                          }                      }                        item.has4ChessboardNeighbors = (numNeighborsThatCouldBeOnChessboard == 4);                      if (item.has4ChessboardNeighbors)                      {                          item.chessboardConnections = new ChessboardConnections(sortedList[0]' sortedList[1]' sortedList[2]' sortedList[3]' sortedList[4]);                      }                  }                    lowestCorrner = null;                  // find the lowest corner on the board                  foreach (ValidResponseData item in validResponsesBotomToTopList)                  {                      if (item.has4ChessboardNeighbors)                      {                          sortedList.Sort(new SortOnDistance(item.position));                            if (lowestCorrner == null)                          {                              int countOfNeighborsWith4Neighbors = 0;                              for (int i = 1; i < 5; i++)                              {                                  if (sortedList[i].has4ChessboardNeighbors)                                  {                                      countOfNeighborsWith4Neighbors++;                                  }                              }                                if (countOfNeighborsWith4Neighbors == 2)                              {                                  lowestCorrner = item.chessboardConnections;                              }                          }                      }                  }                    // now that we have the lowest corner find the rest of the chessboard from it              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindChessBoardLines,The following statement contains a magic number: if (validResponsesBotomToTopList.Count > 5)              {                  foreach (ValidResponseData item in validResponsesBotomToTopList)                  {                      sortedList.Sort(new SortOnDistance(item.position));                        int numNeighborsThatCouldBeOnChessboard = 0;                      for (int i = 1; i < 5; i++)                      {                          ValidResponseData nextNearest = sortedList[i];                          if (nextNearest == item)                          {                              continue;                          }                            int delta = Math.Abs(item.orientation - nextNearest.orientation);                          if (delta > 2 && delta < 5)                          {                              numNeighborsThatCouldBeOnChessboard++;                          }                      }                        item.has4ChessboardNeighbors = (numNeighborsThatCouldBeOnChessboard == 4);                      if (item.has4ChessboardNeighbors)                      {                          item.chessboardConnections = new ChessboardConnections(sortedList[0]' sortedList[1]' sortedList[2]' sortedList[3]' sortedList[4]);                      }                  }                    lowestCorrner = null;                  // find the lowest corner on the board                  foreach (ValidResponseData item in validResponsesBotomToTopList)                  {                      if (item.has4ChessboardNeighbors)                      {                          sortedList.Sort(new SortOnDistance(item.position));                            if (lowestCorrner == null)                          {                              int countOfNeighborsWith4Neighbors = 0;                              for (int i = 1; i < 5; i++)                              {                                  if (sortedList[i].has4ChessboardNeighbors)                                  {                                      countOfNeighborsWith4Neighbors++;                                  }                              }                                if (countOfNeighborsWith4Neighbors == 2)                              {                                  lowestCorrner = item.chessboardConnections;                              }                          }                      }                  }                    // now that we have the lowest corner find the rest of the chessboard from it              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindChessBoardLines,The following statement contains a magic number: if (validResponsesBotomToTopList.Count > 5)              {                  foreach (ValidResponseData item in validResponsesBotomToTopList)                  {                      sortedList.Sort(new SortOnDistance(item.position));                        int numNeighborsThatCouldBeOnChessboard = 0;                      for (int i = 1; i < 5; i++)                      {                          ValidResponseData nextNearest = sortedList[i];                          if (nextNearest == item)                          {                              continue;                          }                            int delta = Math.Abs(item.orientation - nextNearest.orientation);                          if (delta > 2 && delta < 5)                          {                              numNeighborsThatCouldBeOnChessboard++;                          }                      }                        item.has4ChessboardNeighbors = (numNeighborsThatCouldBeOnChessboard == 4);                      if (item.has4ChessboardNeighbors)                      {                          item.chessboardConnections = new ChessboardConnections(sortedList[0]' sortedList[1]' sortedList[2]' sortedList[3]' sortedList[4]);                      }                  }                    lowestCorrner = null;                  // find the lowest corner on the board                  foreach (ValidResponseData item in validResponsesBotomToTopList)                  {                      if (item.has4ChessboardNeighbors)                      {                          sortedList.Sort(new SortOnDistance(item.position));                            if (lowestCorrner == null)                          {                              int countOfNeighborsWith4Neighbors = 0;                              for (int i = 1; i < 5; i++)                              {                                  if (sortedList[i].has4ChessboardNeighbors)                                  {                                      countOfNeighborsWith4Neighbors++;                                  }                              }                                if (countOfNeighborsWith4Neighbors == 2)                              {                                  lowestCorrner = item.chessboardConnections;                              }                          }                      }                  }                    // now that we have the lowest corner find the rest of the chessboard from it              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindChessBoardLines,The following statement contains a magic number: if (validResponsesBotomToTopList.Count > 5)              {                  foreach (ValidResponseData item in validResponsesBotomToTopList)                  {                      sortedList.Sort(new SortOnDistance(item.position));                        int numNeighborsThatCouldBeOnChessboard = 0;                      for (int i = 1; i < 5; i++)                      {                          ValidResponseData nextNearest = sortedList[i];                          if (nextNearest == item)                          {                              continue;                          }                            int delta = Math.Abs(item.orientation - nextNearest.orientation);                          if (delta > 2 && delta < 5)                          {                              numNeighborsThatCouldBeOnChessboard++;                          }                      }                        item.has4ChessboardNeighbors = (numNeighborsThatCouldBeOnChessboard == 4);                      if (item.has4ChessboardNeighbors)                      {                          item.chessboardConnections = new ChessboardConnections(sortedList[0]' sortedList[1]' sortedList[2]' sortedList[3]' sortedList[4]);                      }                  }                    lowestCorrner = null;                  // find the lowest corner on the board                  foreach (ValidResponseData item in validResponsesBotomToTopList)                  {                      if (item.has4ChessboardNeighbors)                      {                          sortedList.Sort(new SortOnDistance(item.position));                            if (lowestCorrner == null)                          {                              int countOfNeighborsWith4Neighbors = 0;                              for (int i = 1; i < 5; i++)                              {                                  if (sortedList[i].has4ChessboardNeighbors)                                  {                                      countOfNeighborsWith4Neighbors++;                                  }                              }                                if (countOfNeighborsWith4Neighbors == 2)                              {                                  lowestCorrner = item.chessboardConnections;                              }                          }                      }                  }                    // now that we have the lowest corner find the rest of the chessboard from it              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindChessBoardLines,The following statement contains a magic number: if (validResponsesBotomToTopList.Count > 5)              {                  foreach (ValidResponseData item in validResponsesBotomToTopList)                  {                      sortedList.Sort(new SortOnDistance(item.position));                        int numNeighborsThatCouldBeOnChessboard = 0;                      for (int i = 1; i < 5; i++)                      {                          ValidResponseData nextNearest = sortedList[i];                          if (nextNearest == item)                          {                              continue;                          }                            int delta = Math.Abs(item.orientation - nextNearest.orientation);                          if (delta > 2 && delta < 5)                          {                              numNeighborsThatCouldBeOnChessboard++;                          }                      }                        item.has4ChessboardNeighbors = (numNeighborsThatCouldBeOnChessboard == 4);                      if (item.has4ChessboardNeighbors)                      {                          item.chessboardConnections = new ChessboardConnections(sortedList[0]' sortedList[1]' sortedList[2]' sortedList[3]' sortedList[4]);                      }                  }                    lowestCorrner = null;                  // find the lowest corner on the board                  foreach (ValidResponseData item in validResponsesBotomToTopList)                  {                      if (item.has4ChessboardNeighbors)                      {                          sortedList.Sort(new SortOnDistance(item.position));                            if (lowestCorrner == null)                          {                              int countOfNeighborsWith4Neighbors = 0;                              for (int i = 1; i < 5; i++)                              {                                  if (sortedList[i].has4ChessboardNeighbors)                                  {                                      countOfNeighborsWith4Neighbors++;                                  }                              }                                if (countOfNeighborsWith4Neighbors == 2)                              {                                  lowestCorrner = item.chessboardConnections;                              }                          }                      }                  }                    // now that we have the lowest corner find the rest of the chessboard from it              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindChessBoardLines,The following statement contains a magic number: if (validResponsesBotomToTopList.Count > 5)              {                  foreach (ValidResponseData item in validResponsesBotomToTopList)                  {                      sortedList.Sort(new SortOnDistance(item.position));                        int numNeighborsThatCouldBeOnChessboard = 0;                      for (int i = 1; i < 5; i++)                      {                          ValidResponseData nextNearest = sortedList[i];                          if (nextNearest == item)                          {                              continue;                          }                            int delta = Math.Abs(item.orientation - nextNearest.orientation);                          if (delta > 2 && delta < 5)                          {                              numNeighborsThatCouldBeOnChessboard++;                          }                      }                        item.has4ChessboardNeighbors = (numNeighborsThatCouldBeOnChessboard == 4);                      if (item.has4ChessboardNeighbors)                      {                          item.chessboardConnections = new ChessboardConnections(sortedList[0]' sortedList[1]' sortedList[2]' sortedList[3]' sortedList[4]);                      }                  }                    lowestCorrner = null;                  // find the lowest corner on the board                  foreach (ValidResponseData item in validResponsesBotomToTopList)                  {                      if (item.has4ChessboardNeighbors)                      {                          sortedList.Sort(new SortOnDistance(item.position));                            if (lowestCorrner == null)                          {                              int countOfNeighborsWith4Neighbors = 0;                              for (int i = 1; i < 5; i++)                              {                                  if (sortedList[i].has4ChessboardNeighbors)                                  {                                      countOfNeighborsWith4Neighbors++;                                  }                              }                                if (countOfNeighborsWith4Neighbors == 2)                              {                                  lowestCorrner = item.chessboardConnections;                              }                          }                      }                  }                    // now that we have the lowest corner find the rest of the chessboard from it              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindChessBoardLines,The following statement contains a magic number: if (validResponsesBotomToTopList.Count > 5)              {                  foreach (ValidResponseData item in validResponsesBotomToTopList)                  {                      sortedList.Sort(new SortOnDistance(item.position));                        int numNeighborsThatCouldBeOnChessboard = 0;                      for (int i = 1; i < 5; i++)                      {                          ValidResponseData nextNearest = sortedList[i];                          if (nextNearest == item)                          {                              continue;                          }                            int delta = Math.Abs(item.orientation - nextNearest.orientation);                          if (delta > 2 && delta < 5)                          {                              numNeighborsThatCouldBeOnChessboard++;                          }                      }                        item.has4ChessboardNeighbors = (numNeighborsThatCouldBeOnChessboard == 4);                      if (item.has4ChessboardNeighbors)                      {                          item.chessboardConnections = new ChessboardConnections(sortedList[0]' sortedList[1]' sortedList[2]' sortedList[3]' sortedList[4]);                      }                  }                    lowestCorrner = null;                  // find the lowest corner on the board                  foreach (ValidResponseData item in validResponsesBotomToTopList)                  {                      if (item.has4ChessboardNeighbors)                      {                          sortedList.Sort(new SortOnDistance(item.position));                            if (lowestCorrner == null)                          {                              int countOfNeighborsWith4Neighbors = 0;                              for (int i = 1; i < 5; i++)                              {                                  if (sortedList[i].has4ChessboardNeighbors)                                  {                                      countOfNeighborsWith4Neighbors++;                                  }                              }                                if (countOfNeighborsWith4Neighbors == 2)                              {                                  lowestCorrner = item.chessboardConnections;                              }                          }                      }                  }                    // now that we have the lowest corner find the rest of the chessboard from it              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindChessBoardLines,The following statement contains a magic number: if (validResponsesBotomToTopList.Count > 5)              {                  foreach (ValidResponseData item in validResponsesBotomToTopList)                  {                      sortedList.Sort(new SortOnDistance(item.position));                        int numNeighborsThatCouldBeOnChessboard = 0;                      for (int i = 1; i < 5; i++)                      {                          ValidResponseData nextNearest = sortedList[i];                          if (nextNearest == item)                          {                              continue;                          }                            int delta = Math.Abs(item.orientation - nextNearest.orientation);                          if (delta > 2 && delta < 5)                          {                              numNeighborsThatCouldBeOnChessboard++;                          }                      }                        item.has4ChessboardNeighbors = (numNeighborsThatCouldBeOnChessboard == 4);                      if (item.has4ChessboardNeighbors)                      {                          item.chessboardConnections = new ChessboardConnections(sortedList[0]' sortedList[1]' sortedList[2]' sortedList[3]' sortedList[4]);                      }                  }                    lowestCorrner = null;                  // find the lowest corner on the board                  foreach (ValidResponseData item in validResponsesBotomToTopList)                  {                      if (item.has4ChessboardNeighbors)                      {                          sortedList.Sort(new SortOnDistance(item.position));                            if (lowestCorrner == null)                          {                              int countOfNeighborsWith4Neighbors = 0;                              for (int i = 1; i < 5; i++)                              {                                  if (sortedList[i].has4ChessboardNeighbors)                                  {                                      countOfNeighborsWith4Neighbors++;                                  }                              }                                if (countOfNeighborsWith4Neighbors == 2)                              {                                  lowestCorrner = item.chessboardConnections;                              }                          }                      }                  }                    // now that we have the lowest corner find the rest of the chessboard from it              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindChessBoardLines,The following statement contains a magic number: if (validResponsesBotomToTopList.Count > 5)              {                  foreach (ValidResponseData item in validResponsesBotomToTopList)                  {                      sortedList.Sort(new SortOnDistance(item.position));                        int numNeighborsThatCouldBeOnChessboard = 0;                      for (int i = 1; i < 5; i++)                      {                          ValidResponseData nextNearest = sortedList[i];                          if (nextNearest == item)                          {                              continue;                          }                            int delta = Math.Abs(item.orientation - nextNearest.orientation);                          if (delta > 2 && delta < 5)                          {                              numNeighborsThatCouldBeOnChessboard++;                          }                      }                        item.has4ChessboardNeighbors = (numNeighborsThatCouldBeOnChessboard == 4);                      if (item.has4ChessboardNeighbors)                      {                          item.chessboardConnections = new ChessboardConnections(sortedList[0]' sortedList[1]' sortedList[2]' sortedList[3]' sortedList[4]);                      }                  }                    lowestCorrner = null;                  // find the lowest corner on the board                  foreach (ValidResponseData item in validResponsesBotomToTopList)                  {                      if (item.has4ChessboardNeighbors)                      {                          sortedList.Sort(new SortOnDistance(item.position));                            if (lowestCorrner == null)                          {                              int countOfNeighborsWith4Neighbors = 0;                              for (int i = 1; i < 5; i++)                              {                                  if (sortedList[i].has4ChessboardNeighbors)                                  {                                      countOfNeighborsWith4Neighbors++;                                  }                              }                                if (countOfNeighborsWith4Neighbors == 2)                              {                                  lowestCorrner = item.chessboardConnections;                              }                          }                      }                  }                    // now that we have the lowest corner find the rest of the chessboard from it              }
Magic Number,MatterHackers.Rectification,ChessBoardDetector,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,FindChessBoardLines,The following statement contains a magic number: if (validResponsesBotomToTopList.Count > 5)              {                  foreach (ValidResponseData item in validResponsesBotomToTopList)                  {                      sortedList.Sort(new SortOnDistance(item.position));                        int numNeighborsThatCouldBeOnChessboard = 0;                      for (int i = 1; i < 5; i++)                      {                          ValidResponseData nextNearest = sortedList[i];                          if (nextNearest == item)                          {                              continue;                          }                            int delta = Math.Abs(item.orientation - nextNearest.orientation);                          if (delta > 2 && delta < 5)                          {                              numNeighborsThatCouldBeOnChessboard++;                          }                      }                        item.has4ChessboardNeighbors = (numNeighborsThatCouldBeOnChessboard == 4);                      if (item.has4ChessboardNeighbors)                      {                          item.chessboardConnections = new ChessboardConnections(sortedList[0]' sortedList[1]' sortedList[2]' sortedList[3]' sortedList[4]);                      }                  }                    lowestCorrner = null;                  // find the lowest corner on the board                  foreach (ValidResponseData item in validResponsesBotomToTopList)                  {                      if (item.has4ChessboardNeighbors)                      {                          sortedList.Sort(new SortOnDistance(item.position));                            if (lowestCorrner == null)                          {                              int countOfNeighborsWith4Neighbors = 0;                              for (int i = 1; i < 5; i++)                              {                                  if (sortedList[i].has4ChessboardNeighbors)                                  {                                      countOfNeighborsWith4Neighbors++;                                  }                              }                                if (countOfNeighborsWith4Neighbors == 2)                              {                                  lowestCorrner = item.chessboardConnections;                              }                          }                      }                  }                    // now that we have the lowest corner find the rest of the chessboard from it              }
Magic Number,MatterHackers.Rectification,ChessboardConnections,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,Render,The following statement contains a magic number: if (item != null)                  {                      Ellipse elipse = new Ellipse(item.position' 10);                      graphics2D.Render(new Stroke(elipse' 3)' RGBA_Bytes.Red);                  }
Magic Number,MatterHackers.Rectification,ChessboardConnections,C:\repos\MatterHackers_agg-sharp\Rectification\ChessBoardDetector.cs,Render,The following statement contains a magic number: if (item != null)                  {                      Ellipse elipse = new Ellipse(item.position' 10);                      graphics2D.Render(new Stroke(elipse' 3)' RGBA_Bytes.Red);                  }
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ImageCorrection,The following statement contains a magic number: bilinearDistortedToRectifideOffsetTable = new int[width * height * 4];
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ImageCorrection,The following statement contains a magic number: bilinearWeightTable = new int[width * height * 4];
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,CreateInverseImageMappingCache,The following statement contains a magic number: System.Threading.Tasks.Parallel.For(0' height' y => //    #else              for (int y = 0; y < height; y++)  #endif              {                  for (int x = 0; x < width; x++)                  {                      int offsetToFirstPixelForBlend = y * width * 4 + x * 4;                        Vector2 distortedVector = new Vector2(x' y);                      Vector2 correctedVector = correctionForLens.GetDistorted(distortedVector);                      if (correctedVector.x < 0 || correctedVector.x >= width - 1 ||                          correctedVector.y < 0 || correctedVector.y >= height - 1)                      {                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = blendFractionDenominator;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = 0;                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = 0;                      }                      else                      {                          Point2D correctedPoint = new Point2D((int)correctedVector.x' (int)correctedVector.y);                          double xFraction = correctedVector.x - correctedPoint.x;                          double yFraction = correctedVector.y - correctedPoint.y;                          bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 0] = (correctedPoint.y + 0) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 0] = (int)(blendFractionDenominator * (1-xFraction)*(1-yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 1] = (correctedPoint.y + 0) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 1] = (int)(blendFractionDenominator * (xFraction) * (1 - yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 2] = (correctedPoint.y + 1) * width + correctedPoint.x + 0;                          bilinearWeightTable[y * width * 4 + x * 4 + 2] = (int)(blendFractionDenominator * (1 - xFraction) * (yFraction));                            bilinearDistortedToRectifideOffsetTable[offsetToFirstPixelForBlend + 3] = (correctedPoint.y + 1) * width + correctedPoint.x + 1;                          bilinearWeightTable[y * width * 4 + x * 4 + 3] = (int)(blendFractionDenominator * (xFraction) * (yFraction));                      }                  }              }  #if MULTI_THREAD  );
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: if (distortedImage.BitDepth != 32 || rectifideImage.BitDepth != 32)              {                  throw new ArgumentException("Both inputs must be 32 bit.");              }
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: if (distortedImage.BitDepth != 32 || rectifideImage.BitDepth != 32)              {                  throw new ArgumentException("Both inputs must be 32 bit.");              }
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: if (DoBilinearFilter)              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 0] * 4;                      int weight = bilinearWeightTable[i * 4 + 0];                      int red = distortedBuffer[pixelOffset + 0] * weight;                      int green = distortedBuffer[pixelOffset + 1] * weight;                      int blue = distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 1] * 4;                      weight = bilinearWeightTable[i * 4 + 1];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 2] * 4;                      weight = bilinearWeightTable[i * 4 + 2];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 3] * 4;                      weight = bilinearWeightTable[i * 4 + 3];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        rectifideBuffer[rectifedBufferIndex + 0] = (byte)(red / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)(green / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)(blue / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }              else              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4] * 4;                      int red = distortedBuffer[pixelOffset + 0]; ;                      int green = distortedBuffer[pixelOffset + 1];                      int blue = distortedBuffer[pixelOffset + 2];                      rectifideBuffer[rectifedBufferIndex + 0] = (byte)red;                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)green;                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)blue;                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: if (DoBilinearFilter)              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 0] * 4;                      int weight = bilinearWeightTable[i * 4 + 0];                      int red = distortedBuffer[pixelOffset + 0] * weight;                      int green = distortedBuffer[pixelOffset + 1] * weight;                      int blue = distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 1] * 4;                      weight = bilinearWeightTable[i * 4 + 1];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 2] * 4;                      weight = bilinearWeightTable[i * 4 + 2];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 3] * 4;                      weight = bilinearWeightTable[i * 4 + 3];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        rectifideBuffer[rectifedBufferIndex + 0] = (byte)(red / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)(green / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)(blue / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }              else              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4] * 4;                      int red = distortedBuffer[pixelOffset + 0]; ;                      int green = distortedBuffer[pixelOffset + 1];                      int blue = distortedBuffer[pixelOffset + 2];                      rectifideBuffer[rectifedBufferIndex + 0] = (byte)red;                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)green;                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)blue;                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: if (DoBilinearFilter)              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 0] * 4;                      int weight = bilinearWeightTable[i * 4 + 0];                      int red = distortedBuffer[pixelOffset + 0] * weight;                      int green = distortedBuffer[pixelOffset + 1] * weight;                      int blue = distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 1] * 4;                      weight = bilinearWeightTable[i * 4 + 1];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 2] * 4;                      weight = bilinearWeightTable[i * 4 + 2];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 3] * 4;                      weight = bilinearWeightTable[i * 4 + 3];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        rectifideBuffer[rectifedBufferIndex + 0] = (byte)(red / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)(green / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)(blue / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }              else              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4] * 4;                      int red = distortedBuffer[pixelOffset + 0]; ;                      int green = distortedBuffer[pixelOffset + 1];                      int blue = distortedBuffer[pixelOffset + 2];                      rectifideBuffer[rectifedBufferIndex + 0] = (byte)red;                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)green;                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)blue;                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: if (DoBilinearFilter)              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 0] * 4;                      int weight = bilinearWeightTable[i * 4 + 0];                      int red = distortedBuffer[pixelOffset + 0] * weight;                      int green = distortedBuffer[pixelOffset + 1] * weight;                      int blue = distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 1] * 4;                      weight = bilinearWeightTable[i * 4 + 1];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 2] * 4;                      weight = bilinearWeightTable[i * 4 + 2];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 3] * 4;                      weight = bilinearWeightTable[i * 4 + 3];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        rectifideBuffer[rectifedBufferIndex + 0] = (byte)(red / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)(green / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)(blue / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }              else              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4] * 4;                      int red = distortedBuffer[pixelOffset + 0]; ;                      int green = distortedBuffer[pixelOffset + 1];                      int blue = distortedBuffer[pixelOffset + 2];                      rectifideBuffer[rectifedBufferIndex + 0] = (byte)red;                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)green;                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)blue;                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: if (DoBilinearFilter)              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 0] * 4;                      int weight = bilinearWeightTable[i * 4 + 0];                      int red = distortedBuffer[pixelOffset + 0] * weight;                      int green = distortedBuffer[pixelOffset + 1] * weight;                      int blue = distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 1] * 4;                      weight = bilinearWeightTable[i * 4 + 1];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 2] * 4;                      weight = bilinearWeightTable[i * 4 + 2];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 3] * 4;                      weight = bilinearWeightTable[i * 4 + 3];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        rectifideBuffer[rectifedBufferIndex + 0] = (byte)(red / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)(green / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)(blue / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }              else              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4] * 4;                      int red = distortedBuffer[pixelOffset + 0]; ;                      int green = distortedBuffer[pixelOffset + 1];                      int blue = distortedBuffer[pixelOffset + 2];                      rectifideBuffer[rectifedBufferIndex + 0] = (byte)red;                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)green;                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)blue;                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: if (DoBilinearFilter)              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 0] * 4;                      int weight = bilinearWeightTable[i * 4 + 0];                      int red = distortedBuffer[pixelOffset + 0] * weight;                      int green = distortedBuffer[pixelOffset + 1] * weight;                      int blue = distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 1] * 4;                      weight = bilinearWeightTable[i * 4 + 1];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 2] * 4;                      weight = bilinearWeightTable[i * 4 + 2];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 3] * 4;                      weight = bilinearWeightTable[i * 4 + 3];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        rectifideBuffer[rectifedBufferIndex + 0] = (byte)(red / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)(green / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)(blue / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }              else              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4] * 4;                      int red = distortedBuffer[pixelOffset + 0]; ;                      int green = distortedBuffer[pixelOffset + 1];                      int blue = distortedBuffer[pixelOffset + 2];                      rectifideBuffer[rectifedBufferIndex + 0] = (byte)red;                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)green;                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)blue;                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: if (DoBilinearFilter)              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 0] * 4;                      int weight = bilinearWeightTable[i * 4 + 0];                      int red = distortedBuffer[pixelOffset + 0] * weight;                      int green = distortedBuffer[pixelOffset + 1] * weight;                      int blue = distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 1] * 4;                      weight = bilinearWeightTable[i * 4 + 1];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 2] * 4;                      weight = bilinearWeightTable[i * 4 + 2];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 3] * 4;                      weight = bilinearWeightTable[i * 4 + 3];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        rectifideBuffer[rectifedBufferIndex + 0] = (byte)(red / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)(green / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)(blue / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }              else              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4] * 4;                      int red = distortedBuffer[pixelOffset + 0]; ;                      int green = distortedBuffer[pixelOffset + 1];                      int blue = distortedBuffer[pixelOffset + 2];                      rectifideBuffer[rectifedBufferIndex + 0] = (byte)red;                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)green;                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)blue;                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: if (DoBilinearFilter)              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 0] * 4;                      int weight = bilinearWeightTable[i * 4 + 0];                      int red = distortedBuffer[pixelOffset + 0] * weight;                      int green = distortedBuffer[pixelOffset + 1] * weight;                      int blue = distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 1] * 4;                      weight = bilinearWeightTable[i * 4 + 1];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 2] * 4;                      weight = bilinearWeightTable[i * 4 + 2];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 3] * 4;                      weight = bilinearWeightTable[i * 4 + 3];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        rectifideBuffer[rectifedBufferIndex + 0] = (byte)(red / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)(green / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)(blue / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }              else              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4] * 4;                      int red = distortedBuffer[pixelOffset + 0]; ;                      int green = distortedBuffer[pixelOffset + 1];                      int blue = distortedBuffer[pixelOffset + 2];                      rectifideBuffer[rectifedBufferIndex + 0] = (byte)red;                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)green;                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)blue;                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: if (DoBilinearFilter)              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 0] * 4;                      int weight = bilinearWeightTable[i * 4 + 0];                      int red = distortedBuffer[pixelOffset + 0] * weight;                      int green = distortedBuffer[pixelOffset + 1] * weight;                      int blue = distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 1] * 4;                      weight = bilinearWeightTable[i * 4 + 1];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 2] * 4;                      weight = bilinearWeightTable[i * 4 + 2];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 3] * 4;                      weight = bilinearWeightTable[i * 4 + 3];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        rectifideBuffer[rectifedBufferIndex + 0] = (byte)(red / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)(green / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)(blue / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }              else              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4] * 4;                      int red = distortedBuffer[pixelOffset + 0]; ;                      int green = distortedBuffer[pixelOffset + 1];                      int blue = distortedBuffer[pixelOffset + 2];                      rectifideBuffer[rectifedBufferIndex + 0] = (byte)red;                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)green;                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)blue;                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: if (DoBilinearFilter)              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 0] * 4;                      int weight = bilinearWeightTable[i * 4 + 0];                      int red = distortedBuffer[pixelOffset + 0] * weight;                      int green = distortedBuffer[pixelOffset + 1] * weight;                      int blue = distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 1] * 4;                      weight = bilinearWeightTable[i * 4 + 1];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 2] * 4;                      weight = bilinearWeightTable[i * 4 + 2];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 3] * 4;                      weight = bilinearWeightTable[i * 4 + 3];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        rectifideBuffer[rectifedBufferIndex + 0] = (byte)(red / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)(green / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)(blue / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }              else              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4] * 4;                      int red = distortedBuffer[pixelOffset + 0]; ;                      int green = distortedBuffer[pixelOffset + 1];                      int blue = distortedBuffer[pixelOffset + 2];                      rectifideBuffer[rectifedBufferIndex + 0] = (byte)red;                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)green;                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)blue;                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: if (DoBilinearFilter)              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 0] * 4;                      int weight = bilinearWeightTable[i * 4 + 0];                      int red = distortedBuffer[pixelOffset + 0] * weight;                      int green = distortedBuffer[pixelOffset + 1] * weight;                      int blue = distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 1] * 4;                      weight = bilinearWeightTable[i * 4 + 1];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 2] * 4;                      weight = bilinearWeightTable[i * 4 + 2];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 3] * 4;                      weight = bilinearWeightTable[i * 4 + 3];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        rectifideBuffer[rectifedBufferIndex + 0] = (byte)(red / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)(green / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)(blue / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }              else              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4] * 4;                      int red = distortedBuffer[pixelOffset + 0]; ;                      int green = distortedBuffer[pixelOffset + 1];                      int blue = distortedBuffer[pixelOffset + 2];                      rectifideBuffer[rectifedBufferIndex + 0] = (byte)red;                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)green;                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)blue;                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: if (DoBilinearFilter)              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 0] * 4;                      int weight = bilinearWeightTable[i * 4 + 0];                      int red = distortedBuffer[pixelOffset + 0] * weight;                      int green = distortedBuffer[pixelOffset + 1] * weight;                      int blue = distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 1] * 4;                      weight = bilinearWeightTable[i * 4 + 1];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 2] * 4;                      weight = bilinearWeightTable[i * 4 + 2];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 3] * 4;                      weight = bilinearWeightTable[i * 4 + 3];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        rectifideBuffer[rectifedBufferIndex + 0] = (byte)(red / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)(green / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)(blue / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }              else              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4] * 4;                      int red = distortedBuffer[pixelOffset + 0]; ;                      int green = distortedBuffer[pixelOffset + 1];                      int blue = distortedBuffer[pixelOffset + 2];                      rectifideBuffer[rectifedBufferIndex + 0] = (byte)red;                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)green;                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)blue;                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: if (DoBilinearFilter)              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 0] * 4;                      int weight = bilinearWeightTable[i * 4 + 0];                      int red = distortedBuffer[pixelOffset + 0] * weight;                      int green = distortedBuffer[pixelOffset + 1] * weight;                      int blue = distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 1] * 4;                      weight = bilinearWeightTable[i * 4 + 1];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 2] * 4;                      weight = bilinearWeightTable[i * 4 + 2];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 3] * 4;                      weight = bilinearWeightTable[i * 4 + 3];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        rectifideBuffer[rectifedBufferIndex + 0] = (byte)(red / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)(green / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)(blue / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }              else              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4] * 4;                      int red = distortedBuffer[pixelOffset + 0]; ;                      int green = distortedBuffer[pixelOffset + 1];                      int blue = distortedBuffer[pixelOffset + 2];                      rectifideBuffer[rectifedBufferIndex + 0] = (byte)red;                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)green;                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)blue;                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: if (DoBilinearFilter)              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 0] * 4;                      int weight = bilinearWeightTable[i * 4 + 0];                      int red = distortedBuffer[pixelOffset + 0] * weight;                      int green = distortedBuffer[pixelOffset + 1] * weight;                      int blue = distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 1] * 4;                      weight = bilinearWeightTable[i * 4 + 1];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 2] * 4;                      weight = bilinearWeightTable[i * 4 + 2];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 3] * 4;                      weight = bilinearWeightTable[i * 4 + 3];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        rectifideBuffer[rectifedBufferIndex + 0] = (byte)(red / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)(green / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)(blue / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }              else              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4] * 4;                      int red = distortedBuffer[pixelOffset + 0]; ;                      int green = distortedBuffer[pixelOffset + 1];                      int blue = distortedBuffer[pixelOffset + 2];                      rectifideBuffer[rectifedBufferIndex + 0] = (byte)red;                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)green;                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)blue;                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: if (DoBilinearFilter)              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 0] * 4;                      int weight = bilinearWeightTable[i * 4 + 0];                      int red = distortedBuffer[pixelOffset + 0] * weight;                      int green = distortedBuffer[pixelOffset + 1] * weight;                      int blue = distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 1] * 4;                      weight = bilinearWeightTable[i * 4 + 1];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 2] * 4;                      weight = bilinearWeightTable[i * 4 + 2];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 3] * 4;                      weight = bilinearWeightTable[i * 4 + 3];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        rectifideBuffer[rectifedBufferIndex + 0] = (byte)(red / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)(green / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)(blue / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }              else              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4] * 4;                      int red = distortedBuffer[pixelOffset + 0]; ;                      int green = distortedBuffer[pixelOffset + 1];                      int blue = distortedBuffer[pixelOffset + 2];                      rectifideBuffer[rectifedBufferIndex + 0] = (byte)red;                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)green;                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)blue;                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: if (DoBilinearFilter)              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 0] * 4;                      int weight = bilinearWeightTable[i * 4 + 0];                      int red = distortedBuffer[pixelOffset + 0] * weight;                      int green = distortedBuffer[pixelOffset + 1] * weight;                      int blue = distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 1] * 4;                      weight = bilinearWeightTable[i * 4 + 1];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 2] * 4;                      weight = bilinearWeightTable[i * 4 + 2];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 3] * 4;                      weight = bilinearWeightTable[i * 4 + 3];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        rectifideBuffer[rectifedBufferIndex + 0] = (byte)(red / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)(green / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)(blue / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }              else              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4] * 4;                      int red = distortedBuffer[pixelOffset + 0]; ;                      int green = distortedBuffer[pixelOffset + 1];                      int blue = distortedBuffer[pixelOffset + 2];                      rectifideBuffer[rectifedBufferIndex + 0] = (byte)red;                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)green;                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)blue;                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: if (DoBilinearFilter)              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 0] * 4;                      int weight = bilinearWeightTable[i * 4 + 0];                      int red = distortedBuffer[pixelOffset + 0] * weight;                      int green = distortedBuffer[pixelOffset + 1] * weight;                      int blue = distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 1] * 4;                      weight = bilinearWeightTable[i * 4 + 1];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 2] * 4;                      weight = bilinearWeightTable[i * 4 + 2];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 3] * 4;                      weight = bilinearWeightTable[i * 4 + 3];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        rectifideBuffer[rectifedBufferIndex + 0] = (byte)(red / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)(green / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)(blue / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }              else              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4] * 4;                      int red = distortedBuffer[pixelOffset + 0]; ;                      int green = distortedBuffer[pixelOffset + 1];                      int blue = distortedBuffer[pixelOffset + 2];                      rectifideBuffer[rectifedBufferIndex + 0] = (byte)red;                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)green;                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)blue;                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: if (DoBilinearFilter)              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 0] * 4;                      int weight = bilinearWeightTable[i * 4 + 0];                      int red = distortedBuffer[pixelOffset + 0] * weight;                      int green = distortedBuffer[pixelOffset + 1] * weight;                      int blue = distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 1] * 4;                      weight = bilinearWeightTable[i * 4 + 1];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 2] * 4;                      weight = bilinearWeightTable[i * 4 + 2];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 3] * 4;                      weight = bilinearWeightTable[i * 4 + 3];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        rectifideBuffer[rectifedBufferIndex + 0] = (byte)(red / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)(green / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)(blue / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }              else              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4] * 4;                      int red = distortedBuffer[pixelOffset + 0]; ;                      int green = distortedBuffer[pixelOffset + 1];                      int blue = distortedBuffer[pixelOffset + 2];                      rectifideBuffer[rectifedBufferIndex + 0] = (byte)red;                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)green;                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)blue;                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: if (DoBilinearFilter)              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 0] * 4;                      int weight = bilinearWeightTable[i * 4 + 0];                      int red = distortedBuffer[pixelOffset + 0] * weight;                      int green = distortedBuffer[pixelOffset + 1] * weight;                      int blue = distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 1] * 4;                      weight = bilinearWeightTable[i * 4 + 1];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 2] * 4;                      weight = bilinearWeightTable[i * 4 + 2];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 3] * 4;                      weight = bilinearWeightTable[i * 4 + 3];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        rectifideBuffer[rectifedBufferIndex + 0] = (byte)(red / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)(green / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)(blue / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }              else              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4] * 4;                      int red = distortedBuffer[pixelOffset + 0]; ;                      int green = distortedBuffer[pixelOffset + 1];                      int blue = distortedBuffer[pixelOffset + 2];                      rectifideBuffer[rectifedBufferIndex + 0] = (byte)red;                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)green;                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)blue;                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: if (DoBilinearFilter)              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 0] * 4;                      int weight = bilinearWeightTable[i * 4 + 0];                      int red = distortedBuffer[pixelOffset + 0] * weight;                      int green = distortedBuffer[pixelOffset + 1] * weight;                      int blue = distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 1] * 4;                      weight = bilinearWeightTable[i * 4 + 1];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 2] * 4;                      weight = bilinearWeightTable[i * 4 + 2];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 3] * 4;                      weight = bilinearWeightTable[i * 4 + 3];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        rectifideBuffer[rectifedBufferIndex + 0] = (byte)(red / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)(green / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)(blue / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }              else              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4] * 4;                      int red = distortedBuffer[pixelOffset + 0]; ;                      int green = distortedBuffer[pixelOffset + 1];                      int blue = distortedBuffer[pixelOffset + 2];                      rectifideBuffer[rectifedBufferIndex + 0] = (byte)red;                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)green;                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)blue;                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: if (DoBilinearFilter)              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 0] * 4;                      int weight = bilinearWeightTable[i * 4 + 0];                      int red = distortedBuffer[pixelOffset + 0] * weight;                      int green = distortedBuffer[pixelOffset + 1] * weight;                      int blue = distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 1] * 4;                      weight = bilinearWeightTable[i * 4 + 1];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 2] * 4;                      weight = bilinearWeightTable[i * 4 + 2];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 3] * 4;                      weight = bilinearWeightTable[i * 4 + 3];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        rectifideBuffer[rectifedBufferIndex + 0] = (byte)(red / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)(green / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)(blue / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }              else              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4] * 4;                      int red = distortedBuffer[pixelOffset + 0]; ;                      int green = distortedBuffer[pixelOffset + 1];                      int blue = distortedBuffer[pixelOffset + 2];                      rectifideBuffer[rectifedBufferIndex + 0] = (byte)red;                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)green;                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)blue;                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: if (DoBilinearFilter)              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 0] * 4;                      int weight = bilinearWeightTable[i * 4 + 0];                      int red = distortedBuffer[pixelOffset + 0] * weight;                      int green = distortedBuffer[pixelOffset + 1] * weight;                      int blue = distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 1] * 4;                      weight = bilinearWeightTable[i * 4 + 1];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 2] * 4;                      weight = bilinearWeightTable[i * 4 + 2];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 3] * 4;                      weight = bilinearWeightTable[i * 4 + 3];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        rectifideBuffer[rectifedBufferIndex + 0] = (byte)(red / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)(green / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)(blue / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }              else              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4] * 4;                      int red = distortedBuffer[pixelOffset + 0]; ;                      int green = distortedBuffer[pixelOffset + 1];                      int blue = distortedBuffer[pixelOffset + 2];                      rectifideBuffer[rectifedBufferIndex + 0] = (byte)red;                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)green;                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)blue;                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: if (DoBilinearFilter)              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 0] * 4;                      int weight = bilinearWeightTable[i * 4 + 0];                      int red = distortedBuffer[pixelOffset + 0] * weight;                      int green = distortedBuffer[pixelOffset + 1] * weight;                      int blue = distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 1] * 4;                      weight = bilinearWeightTable[i * 4 + 1];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 2] * 4;                      weight = bilinearWeightTable[i * 4 + 2];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 3] * 4;                      weight = bilinearWeightTable[i * 4 + 3];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        rectifideBuffer[rectifedBufferIndex + 0] = (byte)(red / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)(green / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)(blue / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }              else              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4] * 4;                      int red = distortedBuffer[pixelOffset + 0]; ;                      int green = distortedBuffer[pixelOffset + 1];                      int blue = distortedBuffer[pixelOffset + 2];                      rectifideBuffer[rectifedBufferIndex + 0] = (byte)red;                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)green;                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)blue;                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: if (DoBilinearFilter)              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 0] * 4;                      int weight = bilinearWeightTable[i * 4 + 0];                      int red = distortedBuffer[pixelOffset + 0] * weight;                      int green = distortedBuffer[pixelOffset + 1] * weight;                      int blue = distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 1] * 4;                      weight = bilinearWeightTable[i * 4 + 1];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 2] * 4;                      weight = bilinearWeightTable[i * 4 + 2];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 3] * 4;                      weight = bilinearWeightTable[i * 4 + 3];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        rectifideBuffer[rectifedBufferIndex + 0] = (byte)(red / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)(green / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)(blue / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }              else              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4] * 4;                      int red = distortedBuffer[pixelOffset + 0]; ;                      int green = distortedBuffer[pixelOffset + 1];                      int blue = distortedBuffer[pixelOffset + 2];                      rectifideBuffer[rectifedBufferIndex + 0] = (byte)red;                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)green;                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)blue;                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: if (DoBilinearFilter)              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 0] * 4;                      int weight = bilinearWeightTable[i * 4 + 0];                      int red = distortedBuffer[pixelOffset + 0] * weight;                      int green = distortedBuffer[pixelOffset + 1] * weight;                      int blue = distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 1] * 4;                      weight = bilinearWeightTable[i * 4 + 1];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 2] * 4;                      weight = bilinearWeightTable[i * 4 + 2];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 3] * 4;                      weight = bilinearWeightTable[i * 4 + 3];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        rectifideBuffer[rectifedBufferIndex + 0] = (byte)(red / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)(green / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)(blue / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }              else              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4] * 4;                      int red = distortedBuffer[pixelOffset + 0]; ;                      int green = distortedBuffer[pixelOffset + 1];                      int blue = distortedBuffer[pixelOffset + 2];                      rectifideBuffer[rectifedBufferIndex + 0] = (byte)red;                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)green;                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)blue;                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: if (DoBilinearFilter)              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 0] * 4;                      int weight = bilinearWeightTable[i * 4 + 0];                      int red = distortedBuffer[pixelOffset + 0] * weight;                      int green = distortedBuffer[pixelOffset + 1] * weight;                      int blue = distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 1] * 4;                      weight = bilinearWeightTable[i * 4 + 1];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 2] * 4;                      weight = bilinearWeightTable[i * 4 + 2];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 3] * 4;                      weight = bilinearWeightTable[i * 4 + 3];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        rectifideBuffer[rectifedBufferIndex + 0] = (byte)(red / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)(green / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)(blue / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }              else              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4] * 4;                      int red = distortedBuffer[pixelOffset + 0]; ;                      int green = distortedBuffer[pixelOffset + 1];                      int blue = distortedBuffer[pixelOffset + 2];                      rectifideBuffer[rectifedBufferIndex + 0] = (byte)red;                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)green;                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)blue;                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: if (DoBilinearFilter)              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 0] * 4;                      int weight = bilinearWeightTable[i * 4 + 0];                      int red = distortedBuffer[pixelOffset + 0] * weight;                      int green = distortedBuffer[pixelOffset + 1] * weight;                      int blue = distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 1] * 4;                      weight = bilinearWeightTable[i * 4 + 1];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 2] * 4;                      weight = bilinearWeightTable[i * 4 + 2];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 3] * 4;                      weight = bilinearWeightTable[i * 4 + 3];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        rectifideBuffer[rectifedBufferIndex + 0] = (byte)(red / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)(green / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)(blue / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }              else              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4] * 4;                      int red = distortedBuffer[pixelOffset + 0]; ;                      int green = distortedBuffer[pixelOffset + 1];                      int blue = distortedBuffer[pixelOffset + 2];                      rectifideBuffer[rectifedBufferIndex + 0] = (byte)red;                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)green;                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)blue;                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: if (DoBilinearFilter)              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 0] * 4;                      int weight = bilinearWeightTable[i * 4 + 0];                      int red = distortedBuffer[pixelOffset + 0] * weight;                      int green = distortedBuffer[pixelOffset + 1] * weight;                      int blue = distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 1] * 4;                      weight = bilinearWeightTable[i * 4 + 1];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 2] * 4;                      weight = bilinearWeightTable[i * 4 + 2];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 3] * 4;                      weight = bilinearWeightTable[i * 4 + 3];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        rectifideBuffer[rectifedBufferIndex + 0] = (byte)(red / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)(green / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)(blue / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }              else              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4] * 4;                      int red = distortedBuffer[pixelOffset + 0]; ;                      int green = distortedBuffer[pixelOffset + 1];                      int blue = distortedBuffer[pixelOffset + 2];                      rectifideBuffer[rectifedBufferIndex + 0] = (byte)red;                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)green;                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)blue;                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: if (DoBilinearFilter)              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 0] * 4;                      int weight = bilinearWeightTable[i * 4 + 0];                      int red = distortedBuffer[pixelOffset + 0] * weight;                      int green = distortedBuffer[pixelOffset + 1] * weight;                      int blue = distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 1] * 4;                      weight = bilinearWeightTable[i * 4 + 1];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 2] * 4;                      weight = bilinearWeightTable[i * 4 + 2];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 3] * 4;                      weight = bilinearWeightTable[i * 4 + 3];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        rectifideBuffer[rectifedBufferIndex + 0] = (byte)(red / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)(green / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)(blue / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }              else              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4] * 4;                      int red = distortedBuffer[pixelOffset + 0]; ;                      int green = distortedBuffer[pixelOffset + 1];                      int blue = distortedBuffer[pixelOffset + 2];                      rectifideBuffer[rectifedBufferIndex + 0] = (byte)red;                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)green;                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)blue;                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: if (DoBilinearFilter)              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 0] * 4;                      int weight = bilinearWeightTable[i * 4 + 0];                      int red = distortedBuffer[pixelOffset + 0] * weight;                      int green = distortedBuffer[pixelOffset + 1] * weight;                      int blue = distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 1] * 4;                      weight = bilinearWeightTable[i * 4 + 1];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 2] * 4;                      weight = bilinearWeightTable[i * 4 + 2];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 3] * 4;                      weight = bilinearWeightTable[i * 4 + 3];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        rectifideBuffer[rectifedBufferIndex + 0] = (byte)(red / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)(green / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)(blue / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }              else              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4] * 4;                      int red = distortedBuffer[pixelOffset + 0]; ;                      int green = distortedBuffer[pixelOffset + 1];                      int blue = distortedBuffer[pixelOffset + 2];                      rectifideBuffer[rectifedBufferIndex + 0] = (byte)red;                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)green;                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)blue;                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: if (DoBilinearFilter)              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 0] * 4;                      int weight = bilinearWeightTable[i * 4 + 0];                      int red = distortedBuffer[pixelOffset + 0] * weight;                      int green = distortedBuffer[pixelOffset + 1] * weight;                      int blue = distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 1] * 4;                      weight = bilinearWeightTable[i * 4 + 1];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 2] * 4;                      weight = bilinearWeightTable[i * 4 + 2];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 3] * 4;                      weight = bilinearWeightTable[i * 4 + 3];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        rectifideBuffer[rectifedBufferIndex + 0] = (byte)(red / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)(green / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)(blue / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }              else              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4] * 4;                      int red = distortedBuffer[pixelOffset + 0]; ;                      int green = distortedBuffer[pixelOffset + 1];                      int blue = distortedBuffer[pixelOffset + 2];                      rectifideBuffer[rectifedBufferIndex + 0] = (byte)red;                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)green;                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)blue;                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: if (DoBilinearFilter)              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 0] * 4;                      int weight = bilinearWeightTable[i * 4 + 0];                      int red = distortedBuffer[pixelOffset + 0] * weight;                      int green = distortedBuffer[pixelOffset + 1] * weight;                      int blue = distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 1] * 4;                      weight = bilinearWeightTable[i * 4 + 1];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 2] * 4;                      weight = bilinearWeightTable[i * 4 + 2];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 3] * 4;                      weight = bilinearWeightTable[i * 4 + 3];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        rectifideBuffer[rectifedBufferIndex + 0] = (byte)(red / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)(green / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)(blue / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }              else              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4] * 4;                      int red = distortedBuffer[pixelOffset + 0]; ;                      int green = distortedBuffer[pixelOffset + 1];                      int blue = distortedBuffer[pixelOffset + 2];                      rectifideBuffer[rectifedBufferIndex + 0] = (byte)red;                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)green;                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)blue;                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }
Magic Number,MatterHackers.Rectification,ImageCorrection,C:\repos\MatterHackers_agg-sharp\Rectification\ImageCorrection.cs,ProcessImage,The following statement contains a magic number: if (DoBilinearFilter)              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 0] * 4;                      int weight = bilinearWeightTable[i * 4 + 0];                      int red = distortedBuffer[pixelOffset + 0] * weight;                      int green = distortedBuffer[pixelOffset + 1] * weight;                      int blue = distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 1] * 4;                      weight = bilinearWeightTable[i * 4 + 1];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 2] * 4;                      weight = bilinearWeightTable[i * 4 + 2];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4 + 3] * 4;                      weight = bilinearWeightTable[i * 4 + 3];                      red += distortedBuffer[pixelOffset + 0] * weight;                      green += distortedBuffer[pixelOffset + 1] * weight;                      blue += distortedBuffer[pixelOffset + 2] * weight;                        rectifideBuffer[rectifedBufferIndex + 0] = (byte)(red / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)(green / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)(blue / blendFractionDenominator);                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }              else              {                  for (int i = 0; i < bilinearDistortedToRectifideOffsetTable.Length / 4; i++)                  {                      int rectifedBufferIndex = i * 4;                      int pixelOffset = bilinearDistortedToRectifideOffsetTable[i * 4] * 4;                      int red = distortedBuffer[pixelOffset + 0]; ;                      int green = distortedBuffer[pixelOffset + 1];                      int blue = distortedBuffer[pixelOffset + 2];                      rectifideBuffer[rectifedBufferIndex + 0] = (byte)red;                      rectifideBuffer[rectifedBufferIndex + 1] = (byte)green;                      rectifideBuffer[rectifedBufferIndex + 2] = (byte)blue;                      rectifideBuffer[rectifedBufferIndex + 3] = 255;                  }              }
Magic Number,MatterHackers.Rectification,LensDistortionMapping,C:\repos\MatterHackers_agg-sharp\Rectification\LensDistortionMapping.cs,GetDistorted,The following statement contains a magic number: Vector2 minDistorted = corrected - new Vector2(256' 256);
Magic Number,MatterHackers.Rectification,LensDistortionMapping,C:\repos\MatterHackers_agg-sharp\Rectification\LensDistortionMapping.cs,GetDistorted,The following statement contains a magic number: Vector2 minDistorted = corrected - new Vector2(256' 256);
Magic Number,MatterHackers.Rectification,LensDistortionMapping,C:\repos\MatterHackers_agg-sharp\Rectification\LensDistortionMapping.cs,GetDistorted,The following statement contains a magic number: Vector2 maxDistorted = corrected + new Vector2(256' 256);
Magic Number,MatterHackers.Rectification,LensDistortionMapping,C:\repos\MatterHackers_agg-sharp\Rectification\LensDistortionMapping.cs,GetDistorted,The following statement contains a magic number: Vector2 maxDistorted = corrected + new Vector2(256' 256);
Magic Number,MatterHackers.Rectification,LensDistortionMapping,C:\repos\MatterHackers_agg-sharp\Rectification\LensDistortionMapping.cs,GetDistorted,The following statement contains a magic number: int numIterations = 64;
Magic Number,MatterHackers.Rectification,LensDistortionMapping,C:\repos\MatterHackers_agg-sharp\Rectification\LensDistortionMapping.cs,GetDistorted,The following statement contains a magic number: for (int i = 0; i < numIterations; i++)              {                  double xDist = maxDistorted.x - minDistorted.x;                  double yDist = maxDistorted.y - minDistorted.y;                  if (xDist < .01 && yDist < .01)                  {                      return minDistorted;                  }                    if (minCorrected.x > corrected.x)                  {                      AdjustPositionIteration(corrected.x' minCorrected.x' ref minDistorted.x' xDist);                  }                  else if (maxCorrected.x < corrected.x)                  {                      AdjustPositionIteration(corrected.x' maxCorrected.x' ref maxDistorted.x' xDist);                  }                  else if (Math.Abs(minCorrected.x - corrected.x) > Math.Abs(maxCorrected.x - corrected.x))                  {                      AdjustPositionIteration(corrected.x' minCorrected.x' ref minDistorted.x' xDist);                  }                  else                  {                      AdjustPositionIteration(corrected.x' maxCorrected.x' ref maxDistorted.x' xDist);                  }                    if (minCorrected.y > corrected.y)                  {                      AdjustPositionIteration(corrected.y' minCorrected.y' ref minDistorted.y' yDist);                  }                  else if (maxCorrected.y < corrected.y)                  {                      AdjustPositionIteration(corrected.y' maxCorrected.y' ref maxDistorted.y' yDist);                  }                  else if (Math.Abs(minCorrected.y - corrected.y) > Math.Abs(maxCorrected.y - corrected.y))                  {                      AdjustPositionIteration(corrected.y' minCorrected.y' ref minDistorted.y' yDist);                  }                  else                  {                      AdjustPositionIteration(corrected.y' maxCorrected.y' ref maxDistorted.y' yDist);                  }                    minCorrected = GetCorrected(minDistorted);                  maxCorrected = GetCorrected(maxDistorted);              }
Magic Number,MatterHackers.Rectification,LensDistortionMapping,C:\repos\MatterHackers_agg-sharp\Rectification\LensDistortionMapping.cs,GetDistorted,The following statement contains a magic number: for (int i = 0; i < numIterations; i++)              {                  double xDist = maxDistorted.x - minDistorted.x;                  double yDist = maxDistorted.y - minDistorted.y;                  if (xDist < .01 && yDist < .01)                  {                      return minDistorted;                  }                    if (minCorrected.x > corrected.x)                  {                      AdjustPositionIteration(corrected.x' minCorrected.x' ref minDistorted.x' xDist);                  }                  else if (maxCorrected.x < corrected.x)                  {                      AdjustPositionIteration(corrected.x' maxCorrected.x' ref maxDistorted.x' xDist);                  }                  else if (Math.Abs(minCorrected.x - corrected.x) > Math.Abs(maxCorrected.x - corrected.x))                  {                      AdjustPositionIteration(corrected.x' minCorrected.x' ref minDistorted.x' xDist);                  }                  else                  {                      AdjustPositionIteration(corrected.x' maxCorrected.x' ref maxDistorted.x' xDist);                  }                    if (minCorrected.y > corrected.y)                  {                      AdjustPositionIteration(corrected.y' minCorrected.y' ref minDistorted.y' yDist);                  }                  else if (maxCorrected.y < corrected.y)                  {                      AdjustPositionIteration(corrected.y' maxCorrected.y' ref maxDistorted.y' yDist);                  }                  else if (Math.Abs(minCorrected.y - corrected.y) > Math.Abs(maxCorrected.y - corrected.y))                  {                      AdjustPositionIteration(corrected.y' minCorrected.y' ref minDistorted.y' yDist);                  }                  else                  {                      AdjustPositionIteration(corrected.y' maxCorrected.y' ref maxDistorted.y' yDist);                  }                    minCorrected = GetCorrected(minDistorted);                  maxCorrected = GetCorrected(maxDistorted);              }
Magic Number,MatterHackers.Rectification,LensDistortionMapping,C:\repos\MatterHackers_agg-sharp\Rectification\LensDistortionMapping.cs,AdjustPositionIteration,The following statement contains a magic number: if (desiredValue < calculatedValue)              {                  // move the min out more to                   valueToAdjust -= distance / 2;              }              else // corrected.x > calculatedValue              {                  valueToAdjust += distance / 2;              }
Magic Number,MatterHackers.Rectification,LensDistortionMapping,C:\repos\MatterHackers_agg-sharp\Rectification\LensDistortionMapping.cs,AdjustPositionIteration,The following statement contains a magic number: if (desiredValue < calculatedValue)              {                  // move the min out more to                   valueToAdjust -= distance / 2;              }              else // corrected.x > calculatedValue              {                  valueToAdjust += distance / 2;              }
Magic Number,MatterHackers.Rectification,DistortionTests,C:\repos\MatterHackers_agg-sharp\Rectification\UnitTests.cs,TestTransforms,The following statement contains a magic number: LensDistortionMapping correction = new LensDistortionMapping(640' 480' k1_RadialDistortion: .000001);
Magic Number,MatterHackers.Rectification,DistortionTests,C:\repos\MatterHackers_agg-sharp\Rectification\UnitTests.cs,TestTransforms,The following statement contains a magic number: LensDistortionMapping correction = new LensDistortionMapping(640' 480' k1_RadialDistortion: .000001);
Magic Number,MatterHackers.Rectification,DistortionTests,C:\repos\MatterHackers_agg-sharp\Rectification\UnitTests.cs,TestTransforms,The following statement contains a magic number: LensDistortionMapping correction = new LensDistortionMapping(640' 480' k1_RadialDistortion: .000001);
Magic Number,MatterHackers.Rectification,DistortionTests,C:\repos\MatterHackers_agg-sharp\Rectification\UnitTests.cs,TestTransforms,The following statement contains a magic number: CheckOne(correction' new Vector2(630' 470));
Magic Number,MatterHackers.Rectification,DistortionTests,C:\repos\MatterHackers_agg-sharp\Rectification\UnitTests.cs,TestTransforms,The following statement contains a magic number: CheckOne(correction' new Vector2(630' 470));
Magic Number,MatterHackers.Rectification,DistortionTests,C:\repos\MatterHackers_agg-sharp\Rectification\UnitTests.cs,TestTransforms,The following statement contains a magic number: CheckOne(correction' new Vector2(10' 20));
Magic Number,MatterHackers.Rectification,DistortionTests,C:\repos\MatterHackers_agg-sharp\Rectification\UnitTests.cs,TestTransforms,The following statement contains a magic number: CheckOne(correction' new Vector2(10' 20));
Magic Number,MatterHackers.Rectification,DistortionTests,C:\repos\MatterHackers_agg-sharp\Rectification\UnitTests.cs,TestTransforms,The following statement contains a magic number: CheckOne(correction' new Vector2(1' 2));
Magic Number,MatterHackers.Rectification,DistortionTests,C:\repos\MatterHackers_agg-sharp\Rectification\UnitTests.cs,TestTransforms,The following statement contains a magic number: CheckOne(correction' new Vector2(320' 240));
Magic Number,MatterHackers.Rectification,DistortionTests,C:\repos\MatterHackers_agg-sharp\Rectification\UnitTests.cs,TestTransforms,The following statement contains a magic number: CheckOne(correction' new Vector2(320' 240));
Magic Number,MatterHackers.Rectification,DistortionTests,C:\repos\MatterHackers_agg-sharp\Rectification\UnitTests.cs,CheckOne,The following statement contains a magic number: Assert.IsTrue(distorted.Equals(redistorted' .05));
