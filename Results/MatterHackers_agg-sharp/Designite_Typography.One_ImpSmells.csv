Implementation smell,Namespace,Class,File,Method,Description
Long Method,Typography.TextLayout,PixelScaleLayoutExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.GlyphLayout\PixelScaleLayoutExtensions.cs,MeasureGlyphPlanWithLimitWidth,The method has 129 lines of code.
Long Method,Typography.OpenFont,CharMapFormat14,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\CharacterMap.cs,Create,The method has 122 lines of code.
Long Method,Typography.OpenFont,IGlyphReaderExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\IGlyphTranslator.cs,Read,The method has 286 lines of code.
Long Method,Typography.OpenFont,OpenFontReader,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\OpenFontReader.cs,ReadTableEntryCollection,The method has 134 lines of code.
Long Method,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,Execute,The method has 955 lines of code.
Long Method,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType2,The method has 146 lines of code.
Long Method,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType6,The method has 105 lines of code.
Long Method,Typography.OpenFont.Tables,EBLCTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.Others\EBLCTable.cs,ReadContentFrom,The method has 109 lines of code.
Long Method,Typography.OpenFont.Tables,Glyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.TrueType\Glyf.cs,ReadCompositeGlyph,The method has 232 lines of code.
Long Method,Typography.OpenFont.CFF,CffEvaluationEngine,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,Run,The method has 114 lines of code.
Long Method,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HV_CurveTo,The method has 136 lines of code.
Long Method,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VH_CurveTo,The method has 127 lines of code.
Long Method,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,ParseType2CharStringBuffer,The method has 186 lines of code.
Long Method,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,AddHintMaskToList,The method has 146 lines of code.
Long Method,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,ReconstructGlyfTable,The method has 286 lines of code.
Long Method,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildSimpleGlyphStructure,The method has 120 lines of code.
Long Method,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,ReadCompositeGlyph,The method has 162 lines of code.
Long Method,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The method has 185 lines of code.
Complex Method,Typography.TextLayout,GlyphSetPosition,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.GlyphLayout\GlyphPosition.cs,GlyphSetPosition,Cyclomatic complexity of the method is 12
Complex Method,Typography.TextLayout,GlyphSubstitution,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.GlyphLayout\GlyphSubstitution.cs,RebuildTables,Cyclomatic complexity of the method is 9
Complex Method,Typography.OpenFont,AdobeGlyphList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\AdditionalInfo\AdobeGlyphList.cs,InitData,Cyclomatic complexity of the method is 10
Complex Method,Typography.OpenFont,IGlyphReaderExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\IGlyphTranslator.cs,Read,Cyclomatic complexity of the method is 19
Complex Method,Typography.OpenFont,OpenFontReader,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\OpenFontReader.cs,ReadTableEntryCollection,Cyclomatic complexity of the method is 11
Complex Method,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,Execute,Cyclomatic complexity of the method is 168
Complex Method,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,SetVectorToLine,Cyclomatic complexity of the method is 8
Complex Method,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,SetSuperRound,Cyclomatic complexity of the method is 8
Complex Method,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,MoveIndirectRelative,Cyclomatic complexity of the method is 10
Complex Method,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,Round,Cyclomatic complexity of the method is 10
Complex Method,Typography.OpenFont,CffBoundFinder,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Typeface.cs,UpdateMinMax,Cyclomatic complexity of the method is 10
Complex Method,Typography.OpenFont.Tables,GDEF,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GDEF.cs,FillClassDefs,Cyclomatic complexity of the method is 9
Complex Method,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadSubTable,Cyclomatic complexity of the method is 9
Complex Method,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadSubTable,Cyclomatic complexity of the method is 8
Complex Method,Typography.OpenFont.Tables,ValueRecord,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.Others.cs,ReadFrom,Cyclomatic complexity of the method is 9
Complex Method,Typography.OpenFont.Tables,ValueRecord,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.Others.cs,ToString,Cyclomatic complexity of the method is 8
Complex Method,Typography.OpenFont.Tables,LkSubTableT6Fmt3,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GSUB.cs,DoSubstitutionAt,Cyclomatic complexity of the method is 10
Complex Method,Typography.OpenFont.Tables,MathGlyphLoader,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,LoadMathGlyph,Cyclomatic complexity of the method is 13
Complex Method,Typography.OpenFont.Tables,Cmap,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables\Cmap.cs,LookupIndex,Cyclomatic complexity of the method is 8
Complex Method,Typography.OpenFont.Tables,NameEntry,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables\NameEntry.cs,ReadContentFrom,Cyclomatic complexity of the method is 12
Complex Method,Typography.OpenFont.CFF,CffEvaluationEngine,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,Run,Cyclomatic complexity of the method is 59
Complex Method,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HV_CurveTo,Cyclomatic complexity of the method is 9
Complex Method,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VH_CurveTo,Cyclomatic complexity of the method is 9
Complex Method,Typography.OpenFont.CFF,Cff1Parser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,ReadRealNumber,Cyclomatic complexity of the method is 13
Complex Method,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,ParseType2CharStringBuffer,Cyclomatic complexity of the method is 64
Complex Method,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,AddHintMaskToList,Cyclomatic complexity of the method is 21
Complex Method,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,AddCounterMaskToList,Cyclomatic complexity of the method is 14
Complex Method,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,ReconstructGlyfTable,Cyclomatic complexity of the method is 24
Complex Method,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildSimpleGlyphStructure,Cyclomatic complexity of the method is 12
Complex Method,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,dbugValidateTable,Cyclomatic complexity of the method is 10
Complex Method,Typography.WebFont,Woff2Reader,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,ReadTableDirectories,Cyclomatic complexity of the method is 12
Long Parameter List,Typography.TextLayout,PxScaledGlyphPlan,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.GlyphLayout\PixelScaleLayoutExtensions.cs,PxScaledGlyphPlan,The method has 5 parameters. Parameters: input_cp_offset' glyphIndex' advanceW' offsetX' offsetY
Long Parameter List,Typography.TextLayout,PixelScaleLayoutExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.GlyphLayout\PixelScaleLayoutExtensions.cs,MeasureGlyphPlanWithLimitWidth,The method has 5 parameters. Parameters: glyphLayout' pxscale' limitWidth' snapToGrid' stopAtGlyphIndex
Long Parameter List,Typography.TextLayout,PixelScaleLayoutExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.GlyphLayout\PixelScaleLayoutExtensions.cs,LayoutAndMeasureString,The method has 7 parameters. Parameters: glyphLayout' textBuffer' startAt' len' fontSizeInPoints' limitW' snapToGrid
Long Parameter List,Typography.TextLayout,UnscaledGlyphPlan,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.GlyphLayout\GlyphLayout.cs,UnscaledGlyphPlan,The method has 5 parameters. Parameters: input_cp_offset' glyphIndex' advanceW' offsetX' offsetY
Long Parameter List,Typography.TextLayout,GlyphPosStream,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.GlyphLayout\GlyphLayout.cs,GetGlyph,The method has 5 parameters. Parameters: index' inputOffset' offsetX' offsetY' advW
Long Parameter List,Typography.TextLayout,MeasuredStringBox,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.GlyphLayout\MeasureStringBox.cs,MeasuredStringBox,The method has 6 parameters. Parameters: width' ascending' descending' lineGap' btbd' pxscale
Long Parameter List,Typography.OpenFont,CharMapFormat4,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\CharacterMap.cs,CharMapFormat4,The method has 5 parameters. Parameters: startCode' endCode' idDelta' idRangeOffset' glyphIdArray
Long Parameter List,Typography.OpenFont,Glyph,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Glyph.cs,Glyph,The method has 5 parameters. Parameters: glyphPoints' contourEndPoints' bounds' glyphInstructions' index
Long Parameter List,Typography.OpenFont,Glyph,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Glyph.cs,TransformNormalWith2x2Matrix,The method has 5 parameters. Parameters: glyph' m00' m01' m10' m11
Long Parameter List,Typography.OpenFont,IGlyphTranslator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\IGlyphTranslator.cs,Curve4,The method has 6 parameters. Parameters: x1' y1' x2' y2' x3' y3
Long Parameter List,Typography.OpenFont,TrueTypeInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,HintGlyph,The method has 8 parameters. Parameters: horizontalAdv' hFrontSideBearing' minX' maxY' glyphPoints' contourEndPoints' instructions' glyphSizeInPixel
Long Parameter List,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,SharpFontInterpreter,The method has 5 parameters. Parameters: maxStack' maxStorage' maxFunctions' maxInstructionDefs' maxTwilightPoints
Long Parameter List,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,InterpolatePoints,The method has 6 parameters. Parameters: current' original' start' end' ref1' ref2
Long Parameter List,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,InterpolatePointsXAxis,The method has 6 parameters. Parameters: current' original' start' end' ref1' ref2
Long Parameter List,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,InterpolatePointsYAxis,The method has 6 parameters. Parameters: current' original' start' end' ref1' ref2
Long Parameter List,Typography.OpenFont,Typeface,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Typeface.cs,Typeface,The method has 6 parameters. Parameters: nameEntry' bounds' unitsPerEm' glyphs' horizontalMetrics' os2Table
Long Parameter List,Typography.OpenFont,Typeface,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Typeface.cs,Typeface,The method has 6 parameters. Parameters: nameEntry' bounds' unitsPerEm' cffTable' horizontalMetrics' os2Table
Long Parameter List,Typography.OpenFont,Typeface,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Typeface.cs,LoadOpenFontLayoutInfo,The method has 6 parameters. Parameters: gdefTable' gsubTable' gposTable' baseTable' colrTable' cpalTable
Long Parameter List,Typography.OpenFont,IGlyphPositions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Typeface.cs,GetGlyph,The method has 5 parameters. Parameters: index' inputOffset' offsetX' offsetY' advW
Long Parameter List,Typography.OpenFont,CffBoundFinder,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Typeface.cs,Curve4,The method has 6 parameters. Parameters: x1' y1' x2' y2' x3' y3
Long Parameter List,Typography.OpenFont.Tables,GPOS,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupTable,The method has 6 parameters. Parameters: reader' lookupTablePos' lookupType' lookupFlags' subTableOffsets' markFilteringSet
Long Parameter List,Typography.OpenFont.Tables,GSUB,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GSUB.cs,ReadLookupTable,The method has 6 parameters. Parameters: reader' lookupTablePos' lookupType' lookupFlags' subTableOffsets' markFilteringSet
Long Parameter List,Typography.OpenFont.Tables,GlyphShapingTableEntry,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GlyphShapingTableEntry.cs,ReadLookupTable,The method has 6 parameters. Parameters: reader' lookupTablePos' lookupType' lookupFlags' subTableOffsets' markFilteringSet
Long Parameter List,Typography.OpenFont.Tables,CPAL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\CPAL.cs,GetColor,The method has 5 parameters. Parameters: colorIndex' r' g' b' a
Long Parameter List,Typography.OpenFont.Tables,Glyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.TrueType\Glyf.cs,ReadCoordinates,The method has 5 parameters. Parameters: input' pointCount' flags' isByte' signOrSame
Long Parameter List,Typography.OpenFont.MathGlyphs,GlyphPartRecord,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,GlyphPartRecord,The method has 5 parameters. Parameters: glyphId' startConnectorLength' endConnectorLength' fullAdvance' partFlags
Long Parameter List,Typography.OpenFont.CFF,PxScaleGlyphTx,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,Curve4,The method has 6 parameters. Parameters: x1' y1' x2' y2' x3' y3
Long Parameter List,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildSimpleGlyphStructure,The method has 7 parameters. Parameters: glyphStreamReader' tmpGlyph' emptyGlyph' pntPerContours' pntContourIndex' flagStream' flagStreamIndex
Long Parameter List,Typography.WebFont,TripleEncodingRecord,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,TripleEncodingRecord,The method has 7 parameters. Parameters: byteCount' xbits' ybits' deltaX' deltaY' xsign' ysign
Long Parameter List,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,AddRecord,The method has 7 parameters. Parameters: byteCount' xbits' ybits' deltaX' deltaY' xsign' ysign
Long Parameter List,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildRecords,The method has 5 parameters. Parameters: byteCount' xbits' ybits' deltaXs' deltaYs
Long Identifier,Typography.TextLayout,GlyphLayout,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.GlyphLayout\GlyphLayout.cs,CreateMapFromUserCharToGlyphIndices,The length of the parameter outputUserCharToGlyphIndexMapList is 33.
Long Identifier,Typography.TextLayout,GlyphLayout,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.GlyphLayout\GlyphLayout.cs,,The length of the parameter _dbugReusableCodePointFromUserCharList is 38.
Long Identifier,Typography.OpenFont,AdobeGlyphList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\AdditionalInfo\AdobeGlyphList.cs,,The length of the parameter s_glyphNameToUnicodeScalarValueDic is 34.
Long Identifier,Typography.OpenFont,AdobeGlyphList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\AdditionalInfo\AdobeGlyphList.cs,,The length of the parameter s_unicodeScalarValueToGlyphNameDic is 34.
Long Identifier,Typography.OpenFont,ScriptLangs,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\ScriptLang.cs,,The length of the parameter s_registeredScriptTagsToUnicodeLangBits is 39.
Long Identifier,Typography.OpenFont.Tables,MathTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,ReadMathGlyphInfoTable,The length of the parameter offsetTo_MathItalicsCorrectionInfo_Table is 40.
Long Identifier,Typography.OpenFont.Tables,MathTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,ReadMathGlyphInfoTable,The length of the parameter offsetTo_MathTopAccentAttachment_Table is 38.
Long Identifier,Typography.OpenFont.Tables,MathTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,ReadMathGlyphInfoTable,The length of the parameter offsetTo_Extended_Shape_coverage_Table is 38.
Long Identifier,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,ReconstructGlyfTable,The length of the parameter expected_CompositeStreamStartAt is 31.
Long Identifier,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,ReconstructGlyfTable,The length of the parameter expected_InstructionStreamStartAt is 33.
Long Statement,Typography.TextLayout,GlyphIndexList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.GlyphLayout\GlyphIndexList.cs,Replace,The length of the statement  "            GlyphIndexToUserCodePoint newMap = new GlyphIndexToUserCodePoint(firstRemove.o_codepoint_charOffset' (ushort)removeLen); " is 120.
Long Statement,Typography.TextLayout,GlyphIndexList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.GlyphLayout\GlyphIndexList.cs,CreateMapFromUserCodePointToGlyphIndices,The length of the statement  "                UserCodePointToGlyphIndex charToGlyphIndexMap = mapUserCodePointToGlyphIndex[glyphIndexToUserCodePoint.o_codepoint_charOffset]; " is 127.
Long Statement,Typography.TextLayout,GlyphLayout,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.GlyphLayout\GlyphLayout.cs,Layout,The length of the statement  "            // from @samhocevar's PR: (https://github.com/LayoutFarm/Typography/pull/56/commits/b71c7cf863531ebf5caa478354d3249bde40b96e) " is 125.
Long Statement,Typography.TextLayout,GlyphLayout,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.GlyphLayout\GlyphLayout.cs,CreateMapFromUserCharToGlyphIndices,The length of the statement  "            //    CodePointFromUserChar codePointFromUserChar = _reusableCodePointFromUserCharList[userCodePointToGlyphIndex.userCodePointIndex];  " is 133.
Long Statement,Typography.OpenFont,AdobeGlyphList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\AdditionalInfo\AdobeGlyphList.cs,InitData,The length of the statement  "                                    int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture); " is 123.
Long Statement,Typography.OpenFont,AdobeGlyphList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\AdditionalInfo\AdobeGlyphList.cs,InitData,The length of the statement  "                                    int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 8 | " is 129.
Long Statement,Typography.OpenFont,AdobeGlyphList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\AdditionalInfo\AdobeGlyphList.cs,InitData,The length of the statement  "                                    int.Parse(unicodeParts[1]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture); " is 123.
Long Statement,Typography.OpenFont,AdobeGlyphList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\AdditionalInfo\AdobeGlyphList.cs,InitData,The length of the statement  "                                  int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 16 | " is 130.
Long Statement,Typography.OpenFont,AdobeGlyphList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\AdditionalInfo\AdobeGlyphList.cs,InitData,The length of the statement  "                                  int.Parse(unicodeParts[1]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 8 | " is 129.
Long Statement,Typography.OpenFont,AdobeGlyphList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\AdditionalInfo\AdobeGlyphList.cs,InitData,The length of the statement  "                                  int.Parse(unicodeParts[2]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture); " is 123.
Long Statement,Typography.OpenFont,AdobeGlyphList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\AdditionalInfo\AdobeGlyphList.cs,InitData,The length of the statement  "                                  int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 24 | " is 130.
Long Statement,Typography.OpenFont,AdobeGlyphList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\AdditionalInfo\AdobeGlyphList.cs,InitData,The length of the statement  "                                  int.Parse(unicodeParts[1]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 16 | " is 130.
Long Statement,Typography.OpenFont,AdobeGlyphList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\AdditionalInfo\AdobeGlyphList.cs,InitData,The length of the statement  "                                  int.Parse(unicodeParts[2]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 8 | " is 129.
Long Statement,Typography.OpenFont,AdobeGlyphList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\AdditionalInfo\AdobeGlyphList.cs,InitData,The length of the statement  "                                  int.Parse(unicodeParts[3]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture); " is 123.
Long Statement,Typography.OpenFont,MacPostFormat1,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\AdditionalInfo\MacPostFormat1.cs,GetStdMacGlyphNames,The length of the statement  "                            if (int.TryParse(key_value[0]' System.Globalization.NumberStyles.None' System.Globalization.CultureInfo.InvariantCulture' out int index)) " is 137.
Long Statement,Typography.OpenFont,CharMapFormat4,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\CharacterMap.cs,RawCharacterToGlyphIndex,The length of the statement  "                //This sum is used as an offset from the current location within idRangeOffset itself to index out the correct glyphIdArray value. " is 130.
Long Statement,Typography.OpenFont,Glyph,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Glyph.cs,TransformNormalWith2x2Matrix,The length of the statement  "            //http://stackoverflow.com/questions/13188156/whats-the-different-between-vector2-transform-and-vector2-transformnormal-i " is 121.
Long Statement,Typography.OpenFont,OpenFontReader,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\OpenFontReader.cs,ReadTTCHeader,The length of the statement  "            //TAG 	    ttcTag 	        Font Collection ID string: 'ttcf' (used for fonts with CFF or CFF2 outlines as well as TrueType outlines) " is 132.
Long Statement,Typography.OpenFont,OpenFontReader,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\OpenFontReader.cs,ReadTTCHeader,The length of the statement  "            //uint32 	dsigOffset 	    The offset (in bytes) of the DSIG table from the beginning of the TTC file (null if no signature) " is 123.
Long Statement,Typography.OpenFont,OpenFontReader,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\OpenFontReader.cs,ReadTableEntryCollection,The length of the statement  "            HorizontalMetrics horizontalMetrics = ReadTableIfExists(tables' input' new HorizontalMetrics(horizontalHeader.HorizontalMetricsCount' maximumProfile.GlyphCount)); " is 162.
Long Statement,Typography.OpenFont,OpenFontReader,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\OpenFontReader.cs,ReadTableEntryCollection,The length of the statement  "            GlyphLocations glyphLocations = ReadTableIfExists(tables' input' new GlyphLocations(maximumProfile.GlyphCount' header.WideGlyphLocations)); " is 139.
Long Statement,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,Execute,The length of the statement  "                        //                    InterpolatePointsYAxis(currentPnts' originalPnts' lastTouched + 1' point - 1' lastTouched' point); " is 120.
Long Statement,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,Execute,The length of the statement  "                        //                    InterpolatePointsYAxis(currentPnts' originalPnts' lastTouched + 1' endPoint' lastTouched' firstTouched); " is 126.
Long Statement,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,Execute,The length of the statement  "                        //                        InterpolatePointsYAxis(currentPnts' originalPnts' firstPoint' firstTouched - 1' lastTouched' firstTouched); " is 133.
Long Statement,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,Execute,The length of the statement  "                        //                    InterpolatePointsXAxis(currentPnts' originalPnts' lastTouched + 1' point - 1' lastTouched' point); " is 120.
Long Statement,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,Execute,The length of the statement  "                        //                    InterpolatePointsXAxis(currentPnts' originalPnts' lastTouched + 1' endPoint' lastTouched' firstTouched); " is 126.
Long Statement,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,Execute,The length of the statement  "                        //                        InterpolatePointsXAxis(currentPnts' originalPnts' firstPoint' firstTouched - 1' lastTouched' firstTouched); " is 133.
Long Statement,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,Execute,The length of the statement  "                            // calculate intersection using determinants: https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line " is 136.
Long Statement,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,Round,The length of the statement  "                case RoundMode.ToDoubleGrid: return value >= 0 ? (float)(Math.Round(value * 2' MidpointRounding.AwayFromZero) / 2) : -(float)(Math.Round(-value * 2' MidpointRounding.AwayFromZero) / 2); " is 185.
Long Statement,Typography.OpenFont,StringUtils,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Typeface.cs,FillWithCodepoints,The length of the statement  "            //  from @samhocevar's PR: (https://github.com/LayoutFarm/Typography/pull/56/commits/b71c7cf863531ebf5caa478354d3249bde40b96e) " is 126.
Long Statement,Typography.OpenFont,StringUtils,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Typeface.cs,GetCodepoints,The length of the statement  "            //  from @samhocevar's PR: (https://github.com/LayoutFarm/Typography/pull/56/commits/b71c7cf863531ebf5caa478354d3249bde40b96e) " is 126.
Long Statement,Typography.OpenFont.Tables,BASE,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\Base.cs,ReadBaseTagList,The length of the statement  "            //The BaseTagList table identifies the baselines for all scripts in the font that are rendered in the same text direction.  " is 122.
Long Statement,Typography.OpenFont.Tables,BASE,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\Base.cs,ReadBaseTagList,The length of the statement  "            //The BaseTagList can define any number of baselines' and it may include baseline tags for scripts supported in other fonts. " is 124.
Long Statement,Typography.OpenFont.Tables,BASE,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\Base.cs,ReadBaseTagList,The length of the statement  "            //the BaseTagList typically includes a tag for each different default baseline needed to render the scripts in the layout direction. " is 132.
Long Statement,Typography.OpenFont.Tables,BASE,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\Base.cs,ReadBaseTagList,The length of the statement  "            //Baseline for HorizAxis: The hanging baseline.This is the horizontal line from which syllables seem to hang in Tibetan and other similar scripts. " is 146.
Long Statement,Typography.OpenFont.Tables,BASE,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\Base.cs,ReadBaseTagList,The length of the statement  "            //Baseline for VertAxis:  The hanging baseline' (which now appears vertical) for Tibetan(or some other similar script) characters rotated 90 degrees clockwise'  " is 159.
Long Statement,Typography.OpenFont.Tables,BASE,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\Base.cs,ReadBaseTagList,The length of the statement  "            //VertAxis: Ideographic em-box left edge. If this tag is present in the VertAxis' the value must be set to 0. (See Ideographic Em - Box below for usage.) " is 153.
Long Statement,Typography.OpenFont.Tables,BASE,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\Base.cs,ReadBaseTagList,The length of the statement  "            //VertAxis: The baseline about which mathematical characters' when rotated 90 degrees clockwise for vertical writing mode' are centered. " is 136.
Long Statement,Typography.OpenFont.Tables,BASE,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\Base.cs,ReadBaseTagList,The length of the statement  "            //VertAxis: The alphabetic baseline for characters rotated 90 degrees clockwise for vertical writing mode. (This would not apply to alphabetic characters that remain upright in vertical writing mode' since these characters are not rotated.) " is 240.
Long Statement,Typography.OpenFont.Tables,BASE,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\Base.cs,ReadBaseScriptList,The length of the statement  "            //BaseScriptRecords are stored in the baseScriptRecords array' ordered alphabetically by the baseScriptTag in each record. " is 122.
Long Statement,Typography.OpenFont.Tables,BASE,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\Base.cs,ReadBaseScriptList,The length of the statement  "            //BaseScriptRecord 	baseScriptRecords[baseScriptCount] 	Array of BaseScriptRecords' in alphabetical order by baseScriptTag " is 122.
Long Statement,Typography.OpenFont.Tables,BASE,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\Base.cs,ReadBaseScriptList,The length of the statement  "                //Each record also must include an offset to a BaseScript table that defines the baseline and min/max extent data for the script.              " is 129.
Long Statement,Typography.OpenFont.Tables,BASE,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\Base.cs,ReadBaseScriptTable,The length of the statement  "            //Offset16 	            baseValuesOffset 	                    Offset to BaseValues table' from beginning of BaseScript table (may be NULL) " is 138.
Long Statement,Typography.OpenFont.Tables,BASE,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\Base.cs,ReadBaseScriptTable,The length of the statement  "            //Offset16 	            defaultMinMaxOffset 	                Offset to MinMax table' from beginning of BaseScript table (may be NULL) " is 133.
Long Statement,Typography.OpenFont.Tables,BASE,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\Base.cs,ReadBaseScriptTable,The length of the statement  "            //BaseLangSysRecord 	baseLangSysRecords[baseLangSysCount] 	Array of BaseLangSysRecords' in alphabetical order by BaseLangSysTag " is 127.
Long Statement,Typography.OpenFont.Tables,BASE,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\Base.cs,ReadBaseScriptTable,The length of the statement  "                    //Each record contains an identification tag for the language system (baseLangSysTag) and an offset to a MinMax table (MinMax)  " is 126.
Long Statement,Typography.OpenFont.Tables,BASE,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\Base.cs,ReadBaseValues,The length of the statement  "            //A BaseValues table lists the coordinate positions of all baselines named in the baselineTags array of the corresponding BaseTagList and " is 137.
Long Statement,Typography.OpenFont.Tables,BASE,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\Base.cs,ReadBaseValues,The length of the statement  "            //uint16 	defaultBaselineIndex 	    Index number of default baseline for this script — equals index position of baseline tag in baselineTags array of the BaseTagList " is 165.
Long Statement,Typography.OpenFont.Tables,BASE,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\Base.cs,ReadBaseValues,The length of the statement  "            //Offset16 	baseCoords[baseCoordCount] 	Array of offsets to BaseCoord tables' from beginning of BaseValues table — order matches baselineTags array in the BaseTagList " is 166.
Long Statement,Typography.OpenFont.Tables,BASE,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\Base.cs,ReadBaseCoordTable,The length of the statement  "            //All values are defined in design units' which typically are scaled and rounded to the nearest integer when scaling the glyphs.  " is 128.
Long Statement,Typography.OpenFont.Tables,BASE,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\Base.cs,ReadBaseCoordTable,The length of the statement  "            // Note: While separate VariationIndex table references are required for each Coordinate value that requires variation' two or more values that require the same variation-data values can have offsets that point to the same VariationIndex table' and two or more VariationIndex tables can reference the same variation data entries. " is 329.
Long Statement,Typography.OpenFont.Tables,BASE,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\Base.cs,ReadBaseCoordTable,The length of the statement  "            // Note: If no VariationIndex table is used for a particular X or Y value (the offset is zero' or a different BaseCoord format is used)' then that value is used for all variation instances. " is 189.
Long Statement,Typography.OpenFont.Tables,BASE,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\Base.cs,ReadBaseCoordTable,The length of the statement  "            //Offset16 	deviceTable 	    Offset to Device table (non-variable font) / Variation Index table (variable font) for X or Y value' from beginning of BaseCoord table (may be NULL). " is 178.
Long Statement,Typography.OpenFont.Tables,BASE,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\Base.cs,ReadMinMaxTable,The length of the statement  "            //Text-processing clients should use the following procedure to access the script' language system' and feature-specific extent data: " is 133.
Long Statement,Typography.OpenFont.Tables,BASE,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\Base.cs,ReadMinMaxTable,The length of the statement  "            //Offset16 	        minCoord 	        Offset to BaseCoord table that defines the minimum extent value' from the beginning of MinMax table (may be NULL) " is 151.
Long Statement,Typography.OpenFont.Tables,BASE,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\Base.cs,ReadMinMaxTable,The length of the statement  "            //Offset16      	maxCoord 	        Offset to BaseCoord table that defines maximum extent value' from the beginning of MinMax table (may be NULL) " is 144.
Long Statement,Typography.OpenFont.Tables,BASE,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\Base.cs,ReadMinMaxTable,The length of the statement  "            //FeatMinMaxRecord 	featMinMaxRecords[featMinMaxCount] 	Array of FeatMinMaxRecords' in alphabetical order by featureTableTag " is 124.
Long Statement,Typography.OpenFont.Tables,BASE,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\Base.cs,ReadMinMaxTable,The length of the statement  "            //Offset16          minCoord            Offset to BaseCoord table that defines the minimum extent value' from beginning of MinMax table(may be NULL) " is 148.
Long Statement,Typography.OpenFont.Tables,BASE,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\Base.cs,ReadMinMaxTable,The length of the statement  "            //Offset16          maxCoord            Offset to BaseCoord table that defines the maximum extent value' from beginning of MinMax table(may be NULL) " is 148.
Long Statement,Typography.OpenFont.Tables,FeatureList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\FeatureList.cs,CreateFrom,The length of the statement  "            //struct 	FeatureRecord[FeatureCount] 	Array of FeatureRecords-zero-based (first feature has FeatureIndex = 0)-listed alphabetically by FeatureTag " is 146.
Long Statement,Typography.OpenFont.Tables,GDEF,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GDEF.cs,ReadContentFrom,The length of the statement  "            //Offset16 	GlyphClassDef 	    Offset to class definition table for glyph type' from beginning of GDEF header (may be NULL) " is 123.
Long Statement,Typography.OpenFont.Tables,GDEF,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GDEF.cs,ReadContentFrom,The length of the statement  "            //Offset16 	AttachList  	    Offset to list of glyphs with attachment points' from beginning of GDEF header (may be NULL) " is 121.
Long Statement,Typography.OpenFont.Tables,GDEF,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GDEF.cs,ReadContentFrom,The length of the statement  "            //Offset16 	LigCaretList 	    Offset to list of positioning points for ligature carets' from beginning of GDEF header (may be NULL) " is 131.
Long Statement,Typography.OpenFont.Tables,GDEF,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GDEF.cs,ReadContentFrom,The length of the statement  "            //Offset16 	MarkAttachClassDef 	Offset to class definition table for mark attachment type' from beginning of GDEF header (may be NULL) " is 134.
Long Statement,Typography.OpenFont.Tables,GDEF,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GDEF.cs,ReadContentFrom,The length of the statement  "            //Offset16 	GlyphClassDef 	    Offset to class definition table for glyph type' from beginning of GDEF header (may be NULL) " is 123.
Long Statement,Typography.OpenFont.Tables,GDEF,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GDEF.cs,ReadContentFrom,The length of the statement  "            //Offset16 	AttachList 	        Offset to list of glyphs with attachment points' from beginning of GDEF header (may be NULL) " is 124.
Long Statement,Typography.OpenFont.Tables,GDEF,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GDEF.cs,ReadContentFrom,The length of the statement  "            //Offset16 	LigCaretList 	    Offset to list of positioning points for ligature carets' from beginning of GDEF header (may be NULL) " is 131.
Long Statement,Typography.OpenFont.Tables,GDEF,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GDEF.cs,ReadContentFrom,The length of the statement  "            //Offset16 	MarkAttachClassDef 	Offset to class definition table for mark attachment type' from beginning of GDEF header (may be NULL) " is 134.
Long Statement,Typography.OpenFont.Tables,GDEF,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GDEF.cs,ReadContentFrom,The length of the statement  "            //Offset16 	GlyphClassDef 	    Offset to class definition table for glyph type' from beginning of GDEF header (may be NULL) " is 123.
Long Statement,Typography.OpenFont.Tables,GDEF,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GDEF.cs,ReadContentFrom,The length of the statement  "            //Offset16 	AttachList  	    Offset to list of glyphs with attachment points' from beginning of GDEF header (may be NULL) " is 121.
Long Statement,Typography.OpenFont.Tables,GDEF,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GDEF.cs,ReadContentFrom,The length of the statement  "            //Offset16 	LigCaretList 	    Offset to list of positioning points for ligature carets' from beginning of GDEF header (may be NULL) " is 131.
Long Statement,Typography.OpenFont.Tables,GDEF,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GDEF.cs,ReadContentFrom,The length of the statement  "            //Offset16 	MarkAttachClassDef 	Offset to class definition table for mark attachment type' from beginning of GDEF header (may be NULL) " is 134.
Long Statement,Typography.OpenFont.Tables,GDEF,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GDEF.cs,ReadContentFrom,The length of the statement  "            this.GlyphClassDef = (glyphClassDefOffset == 0) ? null : ClassDefTable.CreateFrom(reader' _tableStartAt + glyphClassDefOffset); " is 127.
Long Statement,Typography.OpenFont.Tables,GDEF,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GDEF.cs,ReadContentFrom,The length of the statement  "            this.AttachmentListTable = (attachListOffset == 0) ? null : AttachmentListTable.CreateFrom(reader' _tableStartAt + attachListOffset); " is 133.
Long Statement,Typography.OpenFont.Tables,GDEF,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GDEF.cs,ReadContentFrom,The length of the statement  "            this.LigCaretList = (ligCaretListOffset == 0) ? null : LigCaretList.CreateFrom(reader' _tableStartAt + ligCaretListOffset); " is 123.
Long Statement,Typography.OpenFont.Tables,GDEF,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GDEF.cs,ReadContentFrom,The length of the statement  "                this.MarkAttachmentClassDef = (markAttachClassDefOffset == 0) ? null : ClassDefTable.CreateFrom(reader' reader.BaseStream.Position); " is 132.
Long Statement,Typography.OpenFont.Tables,GDEF,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GDEF.cs,ReadContentFrom,The length of the statement  "                this.MarkAttachmentClassDef = (markAttachClassDefOffset == 0) ? null : ClassDefTable.CreateFrom(reader' _tableStartAt + markAttachClassDefOffset); " is 146.
Long Statement,Typography.OpenFont.Tables,GDEF,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GDEF.cs,ReadContentFrom,The length of the statement  "            this.MarkAttachmentClassDef = (markAttachClassDefOffset == 0) ? null : ClassDefTable.CreateFrom(reader' _tableStartAt + markAttachClassDefOffset); " is 146.
Long Statement,Typography.OpenFont.Tables,GDEF,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GDEF.cs,ReadContentFrom,The length of the statement  "            this.MarkGlyphSetsTable = (markGlyphSetsDefOffset == 0) ? null : MarkGlyphSetsTable.CreateFrom(reader' _tableStartAt + markGlyphSetsDefOffset); " is 143.
Long Statement,Typography.OpenFont.Tables,GDEF,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GDEF.cs,FillMarkAttachmentClassDefs,The length of the statement  "            //that can be used in lookup tables within the GSUB or GPOS table to control how mark glyphs within a glyph sequence are treated by lookups. " is 140.
Long Statement,Typography.OpenFont.Tables,GDEF,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GDEF.cs,FillMarkAttachmentClassDefs,The length of the statement  "            //see the description of lookup flags in the “Lookup Table” section of the chapter' OpenType Layout Common Table Formats. " is 121.
Long Statement,Typography.OpenFont.Tables,GDEF,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GDEF.cs,FillMarkGlyphSets,The length of the statement  "            //A Mark Glyph Sets table is used to define sets of mark glyphs that can be used in lookup tables within the GSUB or GPOS table to control  " is 138.
Long Statement,Typography.OpenFont.Tables,GDEF,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GDEF.cs,FillMarkGlyphSets,The length of the statement  "            //see the description of lookup flags in the “Lookup Table” section of the chapter' OpenType Layout Common Table Formats. " is 121.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType2,The length of the statement  "                //If ValueFormat2 is set to null' then the second glyph of the pair is the “next” glyph for which a lookup should be performed. " is 127.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType2,The length of the statement  "                //A PairPos subtable also defines an offset to a Coverage table(Coverage) that lists the indices of the first glyphs in each pair. " is 130.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType2,The length of the statement  "                //The subtable also contains an array of offsets to PairSet tables(PairSet) and a count of the defined tables(PairSetCount). " is 124.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType2,The length of the statement  "                //The PairSet array contains one offset for each glyph listed in the Coverage table and uses the same order as the Coverage Index. " is 130.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType2,The length of the statement  "                //Offset16 	PairSetOffset[PairSetCount] Array of offsets to PairSet tables-from beginning of PairPos subtable-ordered by Coverage Index                // 	 " is 153.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType2,The length of the statement  "                //A PairValueRecord specifies the second glyph in a pair (SecondGlyph) and defines a ValueRecord for each glyph (Value1 and Value2).  " is 132.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType2,The length of the statement  "                //If ValueFormat1 is set to zero (0) in the PairPos subtable' ValueRecord1 will be empty; similarly' if ValueFormat2 is 0' Value2 will be empty. " is 144.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType2,The length of the statement  "                //Offset16 	Coverage 	        Offset to Coverage table-from beginning of PairPos subtable-for the first glyph of the pair " is 121.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType2,The length of the statement  "                //Offset16 	ClassDef1 	        Offset to ClassDef table-from beginning of PairPos subtable-for the first glyph of the pair " is 122.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType2,The length of the statement  "                //Offset16 	ClassDef2 	        Offset to ClassDef table-from beginning of PairPos subtable-for the second glyph of the pair " is 123.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType4,The length of the statement  "                //The MarkToBase attachment (MarkBasePos) subtable is used to position combining mark glyphs with respect to base glyphs.  " is 121.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType4,The length of the statement  "                //a record specifies its class and an offset to the Anchor table that describes the mark's attachment point (MarkRecord). " is 121.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType4,The length of the statement  "                //Offset16 	MarkCoverage 	Offset to MarkCoverage table-from beginning of MarkBasePos subtable ( all the mark glyphs referenced in the subtable) " is 143.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType4,The length of the statement  "                //Offset16 	BaseCoverage 	Offset to BaseCoverage table-from beginning of MarkBasePos subtable (all the base glyphs referenced in the subtable) " is 142.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType7,The length of the statement  "                            //Offset16 	PosClassSet[PosClassSetCnt] 	Array of offsets to PosClassSet tables-from beginning of ContextPos subtable-ordered by class-may be NULL " is 146.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType8,The length of the statement  "                            //Offset16 	ChainPosRuleSet[ChainPosRuleSetCount] 	Array of offsets to ChainPosRuleSet tables-from beginning of ContextPos subtable-ordered by Coverage Index " is 157.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType8,The length of the statement  "                            //Offset16 	BacktrackClassDef 	        Offset to ClassDef table containing backtrack sequence context-from beginning of ChainContextPos subtable " is 144.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType8,The length of the statement  "                            //Offset16 	InputClassDef 	            Offset to ClassDef table containing input sequence context-from beginning of ChainContextPos subtable " is 140.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType8,The length of the statement  "                            //Offset16 	LookaheadClassDef                   	Offset to ClassDef table containing lookahead sequence context-from beginning of ChainContextPos subtable " is 154.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType8,The length of the statement  "                            //Offset16 	ChainPosClassSet[ChainPosClassSetCnt] 	Array of offsets to ChainPosClassSet tables-from beginning of ChainContextPos subtable-ordered by input class-may be NULL " is 172.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType8,The length of the statement  "                            //Offset16 	Coverage[BacktrackGlyphCount] 	Array of offsets to coverage tables in backtracking sequence' in glyph sequence order " is 128.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType8,The length of the statement  "                            //Offset16 	Coverage[InputGlyphCount] 	    Array of offsets to coverage tables in input sequence' in glyph sequence order " is 121.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType8,The length of the statement  "                            //Offset16 	Coverage[LookaheadGlyphCount] 	Array of offsets to coverage tables in lookahead sequence' in glyph sequence order " is 125.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType8,The length of the statement  "                            subTable.BacktrackCoverages = CoverageTable.CreateMultipleCoverageTables(subTableStartAt' backtrackCoverageOffsets' reader); " is 124.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType8,The length of the statement  "                            subTable.InputGlyphCoverages = CoverageTable.CreateMultipleCoverageTables(subTableStartAt' inputGlyphCoverageOffsets' reader); " is 126.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType8,The length of the statement  "                            subTable.LookaheadCoverages = CoverageTable.CreateMultipleCoverageTables(subTableStartAt' lookaheadCoverageOffsets' reader); " is 124.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType1,The length of the statement  "                //Both formats require two distinct sets of glyph indices: one that defines input glyphs (specified in the Coverage table)'  " is 123.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType1,The length of the statement  "                //DeltaGlyphID is the constant value added to each input glyph index to calculate the index of the corresponding output glyph. " is 126.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType1,The length of the statement  "                //It provides an array of output glyph indices (Substitute) explicitly matched to the input glyph indices specified in the Coverage table. " is 138.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType1,The length of the statement  "                //The SingleSubstFormat2 subtable specifies a format identifier (SubstFormat)' an offset to a Coverage table that defines the input glyph indices' " is 146.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType1,The length of the statement  "                //a count of output glyph indices in the Substitute array (GlyphCount)' and a list of the output glyph indices in the Substitute array (Substitute). " is 148.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType1,The length of the statement  "                //The Substitute array must contain the same number of glyph indices as the Coverage table. To locate the corresponding output glyph index in the Substitute array' this format uses the Coverage Index returned from the Coverage table. " is 233.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType1,The length of the statement  "                //Example 3 at the end of this chapter uses Format 2 to substitute vertically oriented glyphs for horizontally oriented glyphs.  " is 127.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType1,The length of the statement  "                            ushort[] substituteGlyphs = Utils.ReadUInt16Array(reader' glyphCount); // 	Array of substitute GlyphIDs-ordered by Coverage Index                                  " is 129.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType2,The length of the statement  "                //an offset to a Coverage table that defines the input glyph indices' a count of offsets in the Sequence array (SequenceCount)'  " is 127.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType2,The length of the statement  "                //Each Sequence table contains a count of the glyphs in the output glyph sequence (GlyphCount) and an array of output glyph indices (Substitute). " is 145.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType2,The length of the statement  "                //The use of multiple substitution for deletion of an input glyph is prohibited. GlyphCount should always be greater than 0.  " is 124.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType2,The length of the statement  "                //Offset16 	Sequence[SequenceCount] Array of offsets to Sequence tables-from beginning of Substitution table-ordered by Coverage Index " is 134.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType3,The length of the statement  "                //A text - processing client would then have the option of replacing the default glyph with any of the three alternatives. " is 122.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType3,The length of the statement  "                //Offset16      AlternateSet[AlternateSetCount] Array of offsets to AlternateSet tables - from beginning of Substitution table - ordered by Coverage Index " is 154.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType4,The length of the statement  "                //Offset16 	LigatureSet[LigSetCount] 	Array of offsets to LigatureSet tables-from beginning of Substitution table-ordered by Coverage Index " is 139.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType4,The length of the statement  "                //For example' if the “ffl” ligature is preferable to the “ff” ligature' then the Ligature array would list the offset to the “ffl” Ligature table before the offset to the “ff” Ligature table. " is 192.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType4,The length of the statement  "                //Offset16 	Ligature[LigatureCount] Array of offsets to Ligature tables-from beginning of LigatureSet table-ordered by preference " is 129.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType4,The length of the statement  "                //uint16 	Component[CompCount - 1] 	Array of component GlyphIDs-start with the second component-ordered in writing direction " is 124.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType6,The length of the statement  "                //A Chaining Contextual Substitution subtable (ChainContextSubst) describes glyph substitutions in context with an ability to look back and/or look ahead " is 153.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType6,The length of the statement  "                //The design of the Chaining Contextual Substitution subtable is parallel to that of the Contextual Substitution subtable' " is 122.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType6,The length of the statement  "                //including the availability of three formats for handling sequences of glyphs' glyph classes' or glyph sets. Each format can describe one or more backtrack' " is 157.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType6,The length of the statement  "                            //Offset16 	ChainSubRuleSet[ChainSubRuleSetCount] 	Array of offsets to ChainSubRuleSet tables-from beginning of Substitution table-ordered by Coverage Index " is 156.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType6,The length of the statement  "                            //Offset16 	BacktrackClassDef 	Offset to glyph ClassDef table containing backtrack sequence data-from beginning of Substitution table " is 133.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType6,The length of the statement  "                            //Offset16 	InputClassDef 	    Offset to glyph ClassDef table containing input sequence data-from beginning of Substitution table " is 129.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType6,The length of the statement  "                            //Offset16 	LookaheadClassDef 	Offset to glyph ClassDef table containing lookahead sequence data-from beginning of Substitution table " is 133.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType6,The length of the statement  "                            //Offset16 	ChainSubClassSet[ChainSubClassSetCnt] 	Array of offsets to ChainSubClassSet tables-from beginning of Substitution table-ordered by input class-may be NULL " is 166.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType6,The length of the statement  "                            //Offset16 	Coverage[BacktrackGlyphCount] 	Array of offsets to coverage tables in backtracking sequence' in glyph sequence order " is 128.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType6,The length of the statement  "                            //Offset16 	Coverage[InputGlyphCount] 	    Array of offsets to coverage tables in input sequence' in glyph sequence order " is 121.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType6,The length of the statement  "                            //Offset16 	Coverage[LookaheadGlyphCount] 	Array of offsets to coverage tables in lookahead sequence' in glyph sequence order " is 125.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType6,The length of the statement  "                            subTable.BacktrackingCoverages = CoverageTable.CreateMultipleCoverageTables(subTableStartAt' backtrackingCoverageOffsets' reader); " is 130.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType6,The length of the statement  "                            subTable.InputCoverages = CoverageTable.CreateMultipleCoverageTables(subTableStartAt' inputGlyphCoverageOffsets' reader); " is 121.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType6,The length of the statement  "                            subTable.LookaheadCoverages = CoverageTable.CreateMultipleCoverageTables(subTableStartAt' lookAheadCoverageOffsets' reader); " is 124.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType7,The length of the statement  "                //This lookup provides a mechanism whereby any other lookup type's subtables are stored at a 32-bit offset location in the 'GSUB' table.  " is 136.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType7,The length of the statement  "                //This is needed if the total size of the subtables exceeds the 16-bit limits of the various other offsets in the 'GSUB' table. " is 127.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType7,The length of the statement  "                //Offset32      ExtensionOffset     Offset to the extension subtable' of lookup type ExtensionLookupType' relative to the start of the ExtensionSubstFormat1 subtable. " is 166.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType7,The length of the statement  "                //Proceed as though each extension subtable referenced by ExtensionOffset replaced the LookupType 7 subtable that referenced it. " is 128.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType7,The length of the statement  "                //All contextual substitution subtables specify the substitution data in a Substitution Lookup Record (SubstLookupRecord). " is 122.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType7,The length of the statement  "                //In addition' a LookupListIndex identifies the lookup to be applied at the glyph position specified by the SequenceIndex. " is 122.
Long Statement,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType7,The length of the statement  "                //The contextual substitution subtables defined in Examples 7' 8' and 9 at the end of this chapter show SubstLookupRecords. " is 123.
Long Statement,Typography.OpenFont.Tables,AnchorPoint,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.Others.cs,CreateFrom,The length of the statement  "                            //AnchorFormat1 consists of a format identifier (AnchorFormat) and a pair of design unit coordinates (XCoordinate and YCoordinate) " is 130.
Long Statement,Typography.OpenFont.Tables,AnchorPoint,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.Others.cs,CreateFrom,The length of the statement  "                            //In variable fonts' AnchorFormat3 must be used to reference variation data to adjust anchor points for different variation instances' " is 134.
Long Statement,Typography.OpenFont.Tables,AnchorPoint,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.Others.cs,CreateFrom,The length of the statement  "                            //two or more values that require the same variation-data values can have offsets that point to the same VariationIndex table' and two or more VariationIndex tables can reference the same variation data entries. " is 211.
Long Statement,Typography.OpenFont.Tables,AnchorPoint,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.Others.cs,CreateFrom,The length of the statement  "                            //Offset16 	XDeviceTable 	Offset to Device table (non-variable font) / VariationIndex table (variable font) for X coordinate' from beginning of Anchor table (may be NULL) " is 170.
Long Statement,Typography.OpenFont.Tables,AnchorPoint,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.Others.cs,CreateFrom,The length of the statement  "                            //Offset16 	YDeviceTable 	Offset to Device table (non-variable font) / VariationIndex table (variable font) for Y coordinate' from beginning of Anchor table (may be NULL) " is 170.
Long Statement,Typography.OpenFont.Tables,GlyphShapingTableEntry,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GlyphShapingTableEntry.cs,ReadLookupListTable,The length of the statement  "            // Offset16  Lookup[LookupCount]  Array of offsets to Lookup tables-from beginning of LookupList -zero based (first lookup is Lookup index = 0) " is 143.
Long Statement,Typography.OpenFont.Tables,GlyphShapingTableEntry,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GlyphShapingTableEntry.cs,ReadLookupListTable,The length of the statement  "            // The format is determined by the content of the information required for an operation and by required storage efficiency. " is 123.
Long Statement,Typography.OpenFont.Tables,GlyphShapingTableEntry,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GlyphShapingTableEntry.cs,ReadLookupListTable,The length of the statement  "            // To move to the “next” glyph' the client will typically skip all the glyphs that participated in the lookup operation: glyphs " is 127.
Long Statement,Typography.OpenFont.Tables,GlyphShapingTableEntry,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GlyphShapingTableEntry.cs,ReadLookupListTable,The length of the statement  "            // the “next” glyph in a sequence may be the second glyph of the positioned pair (see pair positioning lookup for details). " is 123.
Long Statement,Typography.OpenFont.Tables,GlyphShapingTableEntry,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GlyphShapingTableEntry.cs,ReadLookupListTable,The length of the statement  "            // A Lookup table contains a LookupType' specified as an integer' that defines the type of information stored in the lookup. " is 124.
Long Statement,Typography.OpenFont.Tables,GlyphShapingTableEntry,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GlyphShapingTableEntry.cs,ReadLookupListTable,The length of the statement  "            // The LookupFlag specifies lookup qualifiers that assist a text-processing client in substituting or positioning glyphs. " is 121.
Long Statement,Typography.OpenFont.Tables,GlyphShapingTableEntry,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GlyphShapingTableEntry.cs,ReadLookupListTable,The length of the statement  "            // The SubTable array specifies offsets' measured from the beginning of the Lookup table' to each SubTable enumerated in the SubTable array. " is 140.
Long Statement,Typography.OpenFont.Tables,GlyphShapingTableEntry,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GlyphShapingTableEntry.cs,ReadLookupListTable,The length of the statement  "            //Each of the first four bits can be set in order to specify additional instructions for applying a lookup to a glyph string.The LookUpFlag bit enumeration table provides details about the use of these bits. " is 207.
Long Statement,Typography.OpenFont.Tables,GlyphShapingTableEntry,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GlyphShapingTableEntry.cs,ReadLookupListTable,The length of the statement  "            //0x0001  rightToLeft             This bit relates only to the correct processing of the cursive attachment lookup type(GPOS lookup type 3).When this bit is set' the last glyph in a given sequence to which the cursive attachment lookup is applied' will be positioned on the baseline. " is 283.
Long Statement,Typography.OpenFont.Tables,GlyphShapingTableEntry,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GlyphShapingTableEntry.cs,ReadLookupListTable,The length of the statement  "            //                                Note: Setting of this bit is not intended to be used by operating systems or applications to determine text direction. " is 152.
Long Statement,Typography.OpenFont.Tables,GlyphShapingTableEntry,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GlyphShapingTableEntry.cs,ReadLookupListTable,The length of the statement  "            //0x0010  useMarkFilteringSet     If set' indicates that the lookup table structure is followed by a MarkFilteringSet field.The layout engine skips over all mark glyphs not in the mark filtering set indicated. " is 209.
Long Statement,Typography.OpenFont.Tables,GlyphShapingTableEntry,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GlyphShapingTableEntry.cs,ReadLookupListTable,The length of the statement  "                //Each LookupType is defined with one or more subtables' and each subtable definition provides a different representation format " is 128.
Long Statement,Typography.OpenFont.Tables,JSTF,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\JustificationTable.cs,ReadContentFrom,The length of the statement  "            //JstfScriptRecord  jstfScriptRecords[jstfScriptCount]  Array of JstfScriptRecords' in alphabetical order by jstfScriptTag " is 122.
Long Statement,Typography.OpenFont.Tables,JSTF,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\JustificationTable.cs,ReadJstfScriptTable,The length of the statement  "            //Offset16          extenderGlyphOffset             Offset to ExtenderGlyph table' from beginning of JstfScript table(may be NULL) " is 130.
Long Statement,Typography.OpenFont.Tables,JSTF,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\JustificationTable.cs,ReadJstfScriptTable,The length of the statement  "            //Offset16          defJstfLangSysOffset            Offset to default JstfLangSys table' from beginning of JstfScript table(may be NULL) " is 136.
Long Statement,Typography.OpenFont.Tables,JSTF,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\JustificationTable.cs,ReadJstfScriptTable,The length of the statement  "            //JstfLangSysRecord jstfLangSysRecords[jstfLangSysCount]    Array of JstfLangSysRecords' in alphabetical order by JstfLangSysTag " is 128.
Long Statement,Typography.OpenFont.Tables,JSTF,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\JustificationTable.cs,ReadJstfLangSysRecord,The length of the statement  "            //Offset16   jstfPriorityOffsets[jstfPriorityCount]  Array of offsets to JstfPriority tables' from beginning of JstfLangSys table' in priority order " is 148.
Long Statement,Typography.OpenFont.Tables,MathGlyphLoader,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,LoadMathGlyph,The length of the statement  "                        GetMathGlyphOrCreateNew(mathGlyphInfos' glyphIndex).TopAccentAttachment = topAccentAttachment.TopAccentAttachment[index]; " is 121.
Long Statement,Typography.OpenFont.Tables,MathGlyphLoader,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,LoadMathGlyph,The length of the statement  "                        GetMathGlyphOrCreateNew(mathGlyphInfos' glyphIndex).HoriGlyphConstruction = mathVariants.horizConstructionTables[index]; " is 120.
Long Statement,Typography.OpenFont.Tables,MathTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,ReadMathConstantsTable,The length of the statement  "            //The MathConstants table defines miscellaneous constants required to properly position elements of mathematical formulas. " is 122.
Long Statement,Typography.OpenFont.Tables,MathTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,ReadMathConstantsTable,The length of the statement  "            //These constants belong to several groups of semantically related values such as values needed to properly position accents' " is 125.
Long Statement,Typography.OpenFont.Tables,MathTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,ReadMathGlyphInfoTable,The length of the statement  "            //  The MathGlyphInfo table contains positioning information that is defined on per - glyph basis.The table consists of the following parts: " is 140.
Long Statement,Typography.OpenFont.Tables,MathTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,ReadMathGlyphInfoTable,The length of the statement  "            //  NOTE: Here' and elsewhere in the subclause – please refer to subclause 6.2.4 "Features and Lookups" for description of the coverage table formats. " is 150.
Long Statement,Typography.OpenFont.Tables,MathTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,ReadMathItalicCorrectionInfoTable,The length of the statement  "            //Offset16       Coverage                       Offset to Coverage table - from the beginning of MathItalicsCorrectionInfo table. " is 129.
Long Statement,Typography.OpenFont.Tables,MathTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,ReadMathItalicCorrectionInfoTable,The length of the statement  "            //uint16         ItalicsCorrectionCount         Number of italics correction values.Should coincide with the number of covered glyphs. " is 134.
Long Statement,Typography.OpenFont.Tables,MathTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,ReadMathItalicCorrectionInfoTable,The length of the statement  "            //MathValueRecord ItalicsCorrection[ItalicsCorrectionCount]  Array of MathValueRecords defining italics correction values for each covered glyph.  " is 145.
Long Statement,Typography.OpenFont.Tables,MathTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,ReadMathTopAccentAttachment,The length of the statement  "            //The MathTopAccentAttachment table contains information on horizontal positioning of top math accents. The table consists of the following parts: " is 146.
Long Statement,Typography.OpenFont.Tables,MathTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,ReadMathTopAccentAttachment,The length of the statement  "            //Coverage of glyphs for which information on horizontal positioning of math accents is provided.To position accents over any other glyph' its geometrical center(with respect to advance width) can be used. " is 205.
Long Statement,Typography.OpenFont.Tables,MathTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,ReadMathTopAccentAttachment,The length of the statement  "            //Array of top accent attachment points for each covered glyph' in order of coverage.These attachment points are to be used for finding horizontal positions of accents over characters.It is done by aligning the attachment point of the base glyph with the attachment point of the accent.Note that this is very similar to mark - to - base attachment' but here alignment only happens in the horizontal direction' and the vertical positions of accents are determined by different means. " is 482.
Long Statement,Typography.OpenFont.Tables,MathTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,ReadMathTopAccentAttachment,The length of the statement  "            //Offset16      TopAccentCoverage           Offset to Coverage table - from the beginning of MathTopAccentAttachment table. " is 123.
Long Statement,Typography.OpenFont.Tables,MathTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,ReadMathTopAccentAttachment,The length of the statement  "            //uint16        TopAccentAttachmentCount    Number of top accent attachment point values.Should coincide with the number of covered glyphs. " is 139.
Long Statement,Typography.OpenFont.Tables,MathTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,ReadMathTopAccentAttachment,The length of the statement  "            //MathValueRecord TopAccentAttachment[TopAccentAttachmentCount]  Array of MathValueRecords defining top accent attachment points for each covered glyph. " is 152.
Long Statement,Typography.OpenFont.Tables,MathTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,ReadMathKernInfoTable,The length of the statement  "            //The MathKernInfo table provides information on glyphs for which mathematical (height - dependent) kerning values are defined. " is 127.
Long Statement,Typography.OpenFont.Tables,MathTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,ReadMathKernInfoTable,The length of the statement  "            //MathKernInfoRecord MathKernInfoRecords[MathKernCount]     Array of MathKernInfoRecords' per - glyph information for mathematical positioning of subscripts and superscripts. " is 174.
Long Statement,Typography.OpenFont.Tables,MathTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,ReadMathKernInfoTable,The length of the statement  "            //    //Offset16  TopRightMathKern    Offset to MathKern table for top right corner - from the beginning of MathKernInfo table.May be NULL. " is 139.
Long Statement,Typography.OpenFont.Tables,MathTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,ReadMathKernInfoTable,The length of the statement  "            //    //Offset16  TopLeftMathKern     Offset to MathKern table for the top left corner - from the beginning of MathKernInfo table. May be NULL. " is 143.
Long Statement,Typography.OpenFont.Tables,MathTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,ReadMathKernInfoTable,The length of the statement  "            //    //Offset16  BottomRightMathKern Offset to MathKern table for bottom right corner - from the beginning of MathKernInfo table. May be NULL. " is 143.
Long Statement,Typography.OpenFont.Tables,MathTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,ReadMathKernInfoTable,The length of the statement  "            //    //Offset16  BottomLeftMathKern  Offset to MathKern table for bottom left corner - from the beginning of MathKernInfo table. May be NULL. " is 142.
Long Statement,Typography.OpenFont.Tables,MathTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,ReadMathKernTable,The length of the statement  "            //3. Set the default horizontal position for the superscript as shifted relative to the position of the subscript by the italics correction of the base glyph. " is 158.
Long Statement,Typography.OpenFont.Tables,MathTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,ReadMathKernTable,The length of the statement  "            //4. Based on the vertical positions' calculate the height of the top/ bottom for the bounding boxes of sub/superscript relative to the base glyph' and the height of the top/ bottom of the base relative to the super/ subscript.These will be the correction heights. " is 264.
Long Statement,Typography.OpenFont.Tables,MathTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,ReadMathKernTable,The length of the statement  "            //5. Get the kern values corresponding to these correction heights for the appropriate corner of the base glyph and sub/superscript glyph from the appropriate MathKern tables.Kern the default horizontal positions by the minimum of sums of those values at the correction heights for the base and for the sub/superscript. " is 319.
Long Statement,Typography.OpenFont.Tables,MathTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,ReadMathKernTable,The length of the statement  "            //MathValueRecord   CorrectionHeight[HeightCount]       Array of correction heights at which the kern value changes.Sorted by the height value in design units. " is 159.
Long Statement,Typography.OpenFont.Tables,MathTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,ReadMathVariantsTable,The length of the statement  "            //  MinConnectorOverlap defines by how much two glyphs need to overlap with each other when used to construct a larger shape.  " is 125.
Long Statement,Typography.OpenFont.Tables,MathTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,ReadMathVariantsTable,The length of the statement  "            //  Each glyph to be used as a building block in constructing extended shapes will have a straight part at either or both ends. " is 127.
Long Statement,Typography.OpenFont.Tables,MathTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,ReadMathVariantsTable,The length of the statement  "            //uint16        MinConnectorOverlap     Minimum overlap of connecting glyphs during glyph construction' in design units. " is 120.
Long Statement,Typography.OpenFont.Tables,MathTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,ReadMathVariantsTable,The length of the statement  "            //uint16        VertGlyphCount          Number of glyphs for which information is provided for vertically growing variants. " is 123.
Long Statement,Typography.OpenFont.Tables,MathTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,ReadMathVariantsTable,The length of the statement  "            //uint16        HorizGlyphCount         Number of glyphs for which information is provided for horizontally growing variants. " is 125.
Long Statement,Typography.OpenFont.Tables,MathTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,ReadMathVariantsTable,The length of the statement  "            //Offset16      VertGlyphConstruction[VertGlyphCount]  Array of offsets to MathGlyphConstruction tables - from the beginning of the MathVariants table' for shapes growing in vertical direction. " is 193.
Long Statement,Typography.OpenFont.Tables,MathTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,ReadMathVariantsTable,The length of the statement  "            //Offset16      HorizGlyphConstruction[HorizGlyphCount]    Array of offsets to MathGlyphConstruction tables - from the beginning of the MathVariants table' for shapes growing in horizontal direction. " is 199.
Long Statement,Typography.OpenFont.Tables,MathTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,ReadMathVariantsTable,The length of the statement  "            var vertGlyphConstructionTables = _mathVariantsTable.vertConstructionTables = new MathGlyphConstruction[vertGlyphCount]; " is 120.
Long Statement,Typography.OpenFont.Tables,MathTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,ReadMathVariantsTable,The length of the statement  "            var horizGlyphConstructionTables = _mathVariantsTable.horizConstructionTables = new MathGlyphConstruction[horizGlyphCount]; " is 123.
Long Statement,Typography.OpenFont.Tables,MathTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,ReadMathGlyphConstructionTable,The length of the statement  "            //The MathGlyphConstruction table provides information on finding or assembling extended variants for one particular glyph. " is 123.
Long Statement,Typography.OpenFont.Tables,MathTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,ReadMathGlyphConstructionTable,The length of the statement  "            //The MathGlyphConstruction table also contains the count and array of ready-made glyph variants for the specified glyph. " is 121.
Long Statement,Typography.OpenFont.Tables,MathTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,ReadMathGlyphConstructionTable,The length of the statement  "            //Each variant consists of the glyph index and this glyph’s measurement in the direction of extension(vertical or horizontal). " is 126.
Long Statement,Typography.OpenFont.Tables,MathTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,ReadMathGlyphConstructionTable,The length of the statement  "            //Note that it is quite possible that both the GlyphAssembly table and some variants are defined for a particular glyph. " is 120.
Long Statement,Typography.OpenFont.Tables,MathTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,ReadMathGlyphConstructionTable,The length of the statement  "            //and a general mechanism of how larger versions of curly braces can be constructed by stacking parts found in the glyph set. " is 125.
Long Statement,Typography.OpenFont.Tables,MathTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,ReadMathGlyphConstructionTable,The length of the statement  "            //Offset16      GlyphAssembly   Offset to GlyphAssembly table for this shape - from the beginning of MathGlyphConstruction table.May be NULL. " is 141.
Long Statement,Typography.OpenFont.Tables,MathTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,ReadMathGlyphConstructionTable,The length of the statement  "            //MathGlyphVariantRecord MathGlyphVariantRecord [VariantCount]   MathGlyphVariantRecords for alternative variants of the glyphs. " is 128.
Long Statement,Typography.OpenFont.Tables,MathTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,FillGlyphAssemblyInfo,The length of the statement  "            //The GlyphAssembly table specifies how the shape for a particular glyph can be constructed from parts found in the glyph set. " is 126.
Long Statement,Typography.OpenFont.Tables,MathTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,FillGlyphAssemblyInfo,The length of the statement  "            //The table defines the italics correction of the resulting assembly' and a number of parts that have to be put together to form the required shape. " is 148.
Long Statement,Typography.OpenFont.Tables,MathTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,FillGlyphAssemblyInfo,The length of the statement  "            //MathValueRecord   ItalicsCorrection       Italics correction of this GlyphAssembly.Should not depend on the assembly size. " is 124.
Long Statement,Typography.OpenFont.Tables,MathTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,FillGlyphAssemblyInfo,The length of the statement  "            //Note that the glyphs comprising the assembly should be designed so that they align properly in the direction that is orthogonal to the direction of growth. " is 157.
Long Statement,Typography.OpenFont.Tables,SvgTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\SvgTable.cs,ReadContentFrom,The length of the statement  "            //Offset32  svgDocIndexOffset   Offset(relative to the start of the SVG table) to the SVG Documents Index.Must be non - zero. " is 125.
Long Statement,Typography.OpenFont.Tables,EBLCTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.Others\EBLCTable.cs,ReadContentFrom,The length of the statement  "                //uint8     bitDepth                     the Microsoft rasterizer v.1.7 or greater supports the following bitDepth values' as described below: 1' 2' 4' and 8. " is 158.
Long Statement,Typography.OpenFont.Tables,EBLCTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.Others\EBLCTable.cs,ReadContentFrom,The length of the statement  "                bmpsizeTable.BitDepth = reader.ReadByte(); //The colorRef and bitDepth fields are reserved for future enhancements. For monochrome bitmaps they should have the values colorRef=0 and bitDepth=1. " is 193.
Long Statement,Typography.OpenFont.Tables,EBLCTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.Others\EBLCTable.cs,ReadContentFrom,The length of the statement  "                //The 'flags' byte contains two bits to indicate the direction of small glyph metrics: horizontal or vertical.The remaining bits are reserved. " is 142.
Long Statement,Typography.OpenFont.Tables,EBLCTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.Others\EBLCTable.cs,ReadContentFrom,The length of the statement  "                //width' side bearings or advance - must use format 1' 3 or 4.Ranges of glyphs with constant metrics can save space by using format 2 or 5' which keep a single copy of the metrics information in the indexSubTable rather than a copy per glyph in the 'EBDT' table.In some monospaced fonts it makes sense to store extra white space around some of the glyphs to keep all metrics identical' thus permitting the use of format 2 or 5. " is 427.
Long Statement,Typography.OpenFont.Tables,Glyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.TrueType\Glyf.cs,ReadContentFrom,The length of the statement  "                    //SHORT 	numberOfContours 	If the number of contours is greater than or equal to zero' this is a single glyph; if negative' this is a composite glyph. " is 150.
Long Statement,Typography.OpenFont.Tables,Glyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.TrueType\Glyf.cs,ReadCoordinates,The length of the statement  "            //Note: In the glyf table' the position of a point is not stored in absolute terms but as a vector relative to the previous point.  " is 130.
Long Statement,Typography.OpenFont.Tables,Glyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.TrueType\Glyf.cs,ReadCoordinates,The length of the statement  "            //3     Repeat 	 	    If set' the next byte specifies the number of additional times this set of flags is to be repeated. " is 121.
Long Statement,Typography.OpenFont.Tables,Glyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.TrueType\Glyf.cs,ReadCoordinates,The length of the statement  "            //                      In this way' the number of flags listed can be smaller than the number of points in a character. " is 120.
Long Statement,Typography.OpenFont.Tables,Glyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.TrueType\Glyf.cs,ReadCoordinates,The length of the statement  "            //4     This x is same(Positive x-Short Vector) This flag has two meanings' depending on how the x-Short Vector flag is set. " is 124.
Long Statement,Typography.OpenFont.Tables,Glyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.TrueType\Glyf.cs,ReadCoordinates,The length of the statement  "            //                      If the x-Short Vector bit is not set and this bit is set' then the current x-coordinate is the same as the previous x-coordinate.  " is 153.
Long Statement,Typography.OpenFont.Tables,Glyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.TrueType\Glyf.cs,ReadCoordinates,The length of the statement  "            //                      If the x-Short Vector bit is not set and this bit is also not set' the current x-coordinate is a signed 16-bit delta vector. " is 148.
Long Statement,Typography.OpenFont.Tables,Glyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.TrueType\Glyf.cs,ReadCoordinates,The length of the statement  "            //                      If the y-Short Vector bit is not set and this bit is set' then the current y-coordinate is the same as the previous y-coordinate. " is 153.
Long Statement,Typography.OpenFont.Tables,Glyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.TrueType\Glyf.cs,ReadCompositeGlyph,The length of the statement  "            //A composite glyph starts with two USHORT values (“flags” and “glyphIndex'” i.e. the index of the first contour in this composite glyph);  " is 138.
Long Statement,Typography.OpenFont.Tables,Glyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.TrueType\Glyf.cs,ReadCompositeGlyph,The length of the statement  "                    //The bit WE_HAVE_A_TWO_BY_TWO allows for linear transformation of the X and Y coordinates by specifying a 2 × 2 matrix. " is 120.
Long Statement,Typography.OpenFont.Tables,Glyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.TrueType\Glyf.cs,ReadCompositeGlyph,The length of the statement  "            //The C pseudo-code fragment below shows how the composite glyph information is stored and parsed; definitions for “flags” bits follow this fragment: " is 149.
Long Statement,Typography.OpenFont.Tables,GlyphLocations,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.TrueType\GlyphLocations.cs,ReadContentFrom,The length of the statement  "            //Note that the local offsets should be long-aligned' i.e.' multiples of 4. Offsets which are not long-aligned may seriously degrade performance of some processors.  " is 164.
Long Statement,Typography.OpenFont.Tables,Cmap,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables\Cmap.cs,ReadFormat_2,The length of the statement  "            //in which certain byte values signal the first byte of a 2 - byte character(but these values are also legal as the second byte of a 2 - byte character). " is 153.
Long Statement,Typography.OpenFont.Tables,Cmap,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables\Cmap.cs,ReadFormat_2,The length of the statement  "            //In addition' even for the 2 - byte characters' the mapping of character codes to glyph index values depends heavily on the first byte. " is 136.
Long Statement,Typography.OpenFont.Tables,Cmap,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables\Cmap.cs,ReadFormat_2,The length of the statement  "            //For 2 - byte character codes' the SubHeader is used to map the second byte's value through a subArray' as described below. " is 124.
Long Statement,Typography.OpenFont.Tables,Cmap,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables\Cmap.cs,ReadFormat_2,The length of the statement  "            //  uint16  glyphIndexArray[]  Variable - length array containing subarrays used for mapping the low byte of 2 - byte characters. " is 129.
Long Statement,Typography.OpenFont.Tables,Cmap,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables\Cmap.cs,ReadFormat_2,The length of the statement  "            //  The firstCode and entryCount values specify a subrange that begins at firstCode and has a length equal to the value of entryCount. " is 134.
Long Statement,Typography.OpenFont.Tables,Cmap,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables\Cmap.cs,ReadFormat_4,The length of the statement  "            //This is the Microsoft standard character to glyph index mapping table for fonts that support Unicode ranges other than the range [U+D800 - U+DFFF] (defined as Surrogates Area' in Unicode v 3.0)  " is 195.
Long Statement,Typography.OpenFont.Tables,Cmap,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables\Cmap.cs,ReadFormat_4,The length of the statement  "            //If a font supports this character range (i.e. in turn supports the UCS-4 characters) a subtable in this format with a platform specific encoding ID 1 is yet needed' " is 166.
Long Statement,Typography.OpenFont.Tables,Cmap,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables\Cmap.cs,ReadFormat_4,The length of the statement  "            //in addition to a subtable in format 12 with a platform specific encoding ID 10. Please see details on format 12 below' for fonts that support UCS-4 characters on Windows. " is 172.
Long Statement,Typography.OpenFont.Tables,Cmap,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables\Cmap.cs,ReadFormat_4,The length of the statement  "            //This format is used when the character codes for the characters represented by a font fall into several contiguous ranges'  " is 124.
Long Statement,Typography.OpenFont.Tables,Cmap,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables\Cmap.cs,ReadFormat_4,The length of the statement  "            //possibly with holes in some or all of the ranges (that is' some of the codes in a range may not have a representation in the font).  " is 133.
Long Statement,Typography.OpenFont.Tables,Cmap,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables\Cmap.cs,ReadFormat_4,The length of the statement  "            //The language field must be set to zero for all cmap subtables whose platform IDs are other than Macintosh (platform ID 1). " is 124.
Long Statement,Typography.OpenFont.Tables,Cmap,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables\Cmap.cs,ReadFormat_4,The length of the statement  "            //For cmap subtables whose platform IDs are Macintosh' set this field to the Macintosh language ID of the cmap subtable plus one'  " is 129.
Long Statement,Typography.OpenFont.Tables,Cmap,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables\Cmap.cs,ReadFormat_4,The length of the statement  "            //For example' a Mac OS Turkish cmap subtable must set this field to 18' since the Macintosh language ID for Turkish is 17.  " is 123.
Long Statement,Typography.OpenFont.Tables,Cmap,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables\Cmap.cs,ReadFormat_4,The length of the statement  "                                                                      //>This segment need not contain any valid mappings. It can simply map the single character code 0xFFFF to the missing character glyph' glyph 0. " is 144.
Long Statement,Typography.OpenFont.Tables,Cmap,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables\Cmap.cs,ReadFormat_6,The length of the statement  "            //The firstCode and entryCount values specify a subrange(beginning at firstCode' length = entryCount) within the range of possible character codes. " is 147.
Long Statement,Typography.OpenFont.Tables,Cmap,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables\Cmap.cs,ReadFormat_12,The length of the statement  "            //Groups must be sorted by increasing startCharCode.A group's endCharCode must be less than the startCharCode of the following group'  " is 133.
Long Statement,Typography.OpenFont.Tables,Cmap,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables\Cmap.cs,ReadFormat_12,The length of the statement  "            //if any. The endCharCode is used' rather than a count' because comparisons for group matching are usually done on an existing character code'  " is 142.
Long Statement,Typography.OpenFont.Tables,PostTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables\Post.cs,ReadContentFrom,The length of the statement  "            //Apple has defined a version 4.0 for use with Apple Advanced Typography (AAT)' which is described in their documentation. " is 122.
Long Statement,Typography.OpenFont.Tables,PostTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables\Post.cs,ReadContentFrom,The length of the statement  "                        //uint16 	glyphNameIndex[numGlyphs]. 	    This is not an offset' but is the ordinal number of the glyph in 'post' string tables. " is 128.
Long Statement,Typography.OpenFont.Tables,PostTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables\Post.cs,ReadContentFrom,The length of the statement  "                        //If you do not want to associate a PostScript name with a particular glyph' use index number 0 which points to the name .notdef. " is 129.
Long Statement,Extensions,TypefaceExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Typeface.cs,TranslatedOS2FontStyle,The length of the statement  "                //7                         USE_TYPO_METRICS    If set' it is strongly recommended to use OS / 2.sTypoAscender - OS / 2.sTypoDescender + OS / 2.sTypoLineGap as a value for default line spacing for this font. " is 207.
Long Statement,Extensions,TypefaceExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Typeface.cs,TranslatedOS2FontStyle,The length of the statement  "                //8                         WWS     The font has ‘name’ table strings consistent with a weight / width / slope family without requiring use of ‘name’ IDs 21 and 22. (Please see more detailed description below.) " is 210.
Long Statement,Extensions,TypefaceExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Typeface.cs,Calculate_TypoMetricLineSpacing,The length of the statement  "                //While the OpenType specification allows for CJK (Chinese' Japanese' and Korean) fonts' sTypoDescender and sTypoAscender  " is 121.
Long Statement,Extensions,TypefaceExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Typeface.cs,Calculate_TypoMetricLineSpacing,The length of the statement  "                //they should ensure that any ideographic em-box values in the 'BASE' table describe the same bottom and top edges as the sTypoDescender and " is 140.
Long Statement,Extensions,TypefaceExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Typeface.cs,Calculate_TypoMetricLineSpacing,The length of the statement  "                //sTypoAscender' sTypoDescender and sTypoLineGap specify the recommended line spacing for single-spaced horizontal text. " is 120.
Long Statement,Extensions,TypefaceExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Typeface.cs,Calculate_TypoMetricLineSpacing,The length of the statement  "                //sTypoLineGap will usually be set by the font developer such that the value of the above expression is approximately 120% of the em. " is 133.
Long Statement,Extensions,TypefaceExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Typeface.cs,Calculate_BTBD_Windows,The length of the statement  "                int external_leading = System.Math.Max(0' hhea.LineGap - ((usWinAscent + usWinDescent) - (hhea.Ascent - hhea.Descent))); " is 120.
Long Statement,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,ReconstructGlyfTable,The length of the statement  "            //UInt32    glyphStreamSize         Size of glyph stream in bytes(a stream of variable-length encoded values' see description below) " is 132.
Long Statement,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,ReconstructGlyfTable,The length of the statement  "            //UInt32    compositeStreamSize     Size of composite stream in bytes(a stream of variable-length encoded values' see description below) " is 136.
Long Statement,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,ReconstructGlyfTable,The length of the statement  "            //UInt32    bboxStreamSize          Size of bbox data in bytes representing combined length of bboxBitmap(a packed bit array) and bboxStream(a stream of Int16 values) " is 166.
Long Statement,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,ReconstructGlyfTable,The length of the statement  "            //255UInt16 nPointsStream[]         Stream of values representing number of outline points for each contour in glyph records " is 124.
Long Statement,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,ReconstructGlyfTable,The length of the statement  "            //Vary      glyphStream[]           Stream of bytes representing point coordinate values using variable length encoding format(defined in subclause 5.2) " is 152.
Long Statement,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,ReconstructGlyfTable,The length of the statement  "            //Vary      compositeStream[]       Stream of bytes representing component flag values and associated composite glyph data " is 122.
Long Statement,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,ReconstructGlyfTable,The length of the statement  "            //UInt8     instructionStream[]	    Stream of UInt8 values representing a set of instructions for each corresponding glyph " is 122.
Long Statement,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,ReconstructGlyfTable,The length of the statement  "            //    2) Read nPoints UInt8 values from the flags stream.Each corresponds to one point in the reconstructed glyph outline. " is 122.
Long Statement,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,ReconstructGlyfTable,The length of the statement  "            //       Decode these bytes according to the procedure specified in the subclause 5.2 to reconstruct delta-x and delta-y values of the glyph point coordinates. " is 159.
Long Statement,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,ReconstructGlyfTable,The length of the statement  "            //       Store these delta-x and delta-y values in the reconstructed glyph using the standard TrueType glyph encoding[OFF] subclause 5.3.3. " is 139.
Long Statement,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,ReconstructGlyfTable,The length of the statement  "            //    5) Read instructionLength bytes from instructionStream' and store these in the reconstituted glyph as instructions. " is 121.
Long Statement,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,ReconstructGlyfTable,The length of the statement  "                    allGlyphs[compositeGlyphIndex].compositeHasInstructions = CompositeHasInstructions(compositeReader' compositeGlyphIndex); " is 121.
Long Statement,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,ReconstructGlyfTable,The length of the statement  "            //then derive the bounding box by computing the minimum and maximum x and y coordinates in the outline' and storing that. " is 121.
Long Statement,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,ReconstructGlyfTable,The length of the statement  "            //the specified scales of individual components' which would conflict with a purely streaming implementation of font decoding. " is 126.
Long Statement,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,ReconstructGlyfTable,The length of the statement  "                        //then derive the bounding box by computing the minimum and maximum x and y coordinates in the outline' and storing that. " is 121.
Long Statement,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildSimpleGlyphStructure,The length of the statement  "            //    2) Read nPoints UInt8 values from the flags stream.Each corresponds to one point in the reconstructed glyph outline. " is 122.
Long Statement,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildSimpleGlyphStructure,The length of the statement  "            //       Decode these bytes according to the procedure specified in the subclause 5.2 to reconstruct delta-x and delta-y values of the glyph point coordinates. " is 159.
Long Statement,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildSimpleGlyphStructure,The length of the statement  "            //       Store these delta-x and delta-y values in the reconstructed glyph using the standard TrueType glyph encoding[OFF] subclause 5.3.3. " is 139.
Long Statement,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildSimpleGlyphStructure,The length of the statement  "            //    5) Read instructionLength bytes from instructionStream' and store these in the reconstituted glyph as instructions.  " is 121.
Long Statement,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildSimpleGlyphStructure,The length of the statement  "                    byte[] packedXY = glyphStreamReader.ReadBytes(enc.ByteCount - 1); //byte count include 1 byte flags' so actual read=> byteCount-1 " is 129.
Long Statement,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,CompositeHasInstructions,The length of the statement  "                    //The bit WE_HAVE_A_TWO_BY_TWO allows for linear transformation of the X and Y coordinates by specifying a 2 × 2 matrix. " is 120.
Long Statement,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,ReadCompositeGlyph,The length of the statement  "            //For a composite glyph(nContour == -1)' the following steps take the place of (Building Simple Glyph' steps 1 - 5 above): " is 122.
Long Statement,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,ReadCompositeGlyph,The length of the statement  "                    //The bit WE_HAVE_A_TWO_BY_TWO allows for linear transformation of the X and Y coordinates by specifying a 2 × 2 matrix. " is 120.
Long Statement,Typography.WebFont,TripleEncodingRecord,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,ToString,The length of the statement  "                return debugIndex + " " + ByteCount + " " + XBits + " " + YBits + " " + DeltaX + " " + DeltaY + " " + Xsign + " " + Ysign; " is 122.
Long Statement,Typography.WebFont,Woff2Reader,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,ReadUIntBase128,The length of the statement  "            //A decoder MUST reject the font file if it encounters a UintBase128 - encoded value with leading zeros(a value that starts with the byte 0x80)' " is 144.
Long Statement,Typography.WebFont,Woff2Utils,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,Read255UInt16,The length of the statement  "            //where the value of the first byte either represents the small value itself or is treated as a code that defines the format of the additional byte(s). " is 151.
Long Statement,Typography.WebFont,WoffReader,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\WoffReader.cs,ReadPreview,The length of the statement  "            //WOFFHeader        File header with basic font type and version' along with offsets to metadata and private data blocks. " is 121.
Long Statement,Typography.WebFont,WoffReader,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\WoffReader.cs,ReadPreview,The length of the statement  "            //TableDirectory    Directory of font tables' indicating the original size' compressed size and location of each table within the WOFF file. " is 140.
Long Statement,Typography.WebFont,WoffReader,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\WoffReader.cs,ReadPreview,The length of the statement  "            //ExtendedMetadata  An optional block of extended metadata' represented in XML format and compressed for storage in the WOFF file. " is 130.
Long Statement,Typography.WebFont,WoffReader,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\WoffReader.cs,Read,The length of the statement  "            //WOFFHeader        File header with basic font type and version' along with offsets to metadata and private data blocks. " is 121.
Long Statement,Typography.WebFont,WoffReader,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\WoffReader.cs,Read,The length of the statement  "            //TableDirectory    Directory of font tables' indicating the original size' compressed size and location of each table within the WOFF file. " is 140.
Long Statement,Typography.WebFont,WoffReader,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\WoffReader.cs,Read,The length of the statement  "            //ExtendedMetadata  An optional block of extended metadata' represented in XML format and compressed for storage in the WOFF file. " is 130.
Long Statement,Typography.WebFont,WoffReader,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\WoffReader.cs,ReadWOFFHeader,The length of the statement  "            //UInt32  totalSfntSize     Total size needed for the uncompressed font data' including the sfnt header' directory' and font tables(including padding). " is 151.
Long Statement,Typography.WebFont,WoffReader,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\WoffReader.cs,ReadTableDirectories,The length of the statement  "            //Its size is calculated by multiplying the numTables value in the WOFF header times the size of a single WOFF table directory. " is 127.
Complex Conditional,Typography.OpenFont.Tables,Cmap,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables\Cmap.cs,LookupIndex,The conditional expression  "found == 0 || (gid != 0 && cmap.PlatformId == 3 && cmap.EncodingId == 1)"  is complex.
Complex Conditional,Typography.WebFont,Woff2Reader,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,ReadHeader,The conditional expression  "!(b0 == 0x77 && b1 == 0x4f && b2 == 0x46 && b3 == 0x32)"  is complex.
Complex Conditional,Typography.WebFont,WoffReader,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\WoffReader.cs,ReadWOFFHeader,The conditional expression  "!(b0 == 0x77 && b1 == 0x4f && b2 == 0x46 && b3 == 0x46)"  is complex.
Magic Number,Typography.TextLayout,PixelScaleLayoutExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.GlyphLayout\PixelScaleLayoutExtensions.cs,dbugSnapToFitInteger,The following statement contains a magic number: return (value - floor_value >= (1f / 2f)) ? floor_value + 1 : floor_value;
Magic Number,Typography.TextLayout,PixelScaleLayoutExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.GlyphLayout\PixelScaleLayoutExtensions.cs,dbugSnapHalf,The following statement contains a magic number: return (value - floor_value >= (2f / 3f)) ? floor_value + 1 : //else->                     (value - floor_value >= (1f / 3f)) ? floor_value + 0.5f : floor_value;
Magic Number,Typography.TextLayout,PixelScaleLayoutExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.GlyphLayout\PixelScaleLayoutExtensions.cs,dbugSnapHalf,The following statement contains a magic number: return (value - floor_value >= (2f / 3f)) ? floor_value + 1 : //else->                     (value - floor_value >= (1f / 3f)) ? floor_value + 0.5f : floor_value;
Magic Number,Typography.TextLayout,PixelScaleLayoutExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.GlyphLayout\PixelScaleLayoutExtensions.cs,dbugSnapHalf,The following statement contains a magic number: return (value - floor_value >= (2f / 3f)) ? floor_value + 1 : //else->                     (value - floor_value >= (1f / 3f)) ? floor_value + 0.5f : floor_value;
Magic Number,Typography.TextLayout,PixelScaleLayoutExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.GlyphLayout\PixelScaleLayoutExtensions.cs,dbugSnapHalf,The following statement contains a magic number: return (value - floor_value >= (2f / 3f)) ? floor_value + 1 : //else->                     (value - floor_value >= (1f / 3f)) ? floor_value + 0.5f : floor_value;
Magic Number,Typography.OpenFont,AdobeGlyphList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\AdditionalInfo\AdobeGlyphList.cs,InitData,The following statement contains a magic number: switch (partCount)                          {                              case 0:                              default: throw new System.Exception("??");                              case 1:                                  unicodeValue =                                      int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture);                                  break;                              case 2:                                  unicodeValue =                                      int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 8 |                                      int.Parse(unicodeParts[1]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture);                                  break;                              case 3:                                  unicodeValue =                                    int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 16 |                                    int.Parse(unicodeParts[1]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 8 |                                    int.Parse(unicodeParts[2]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture);                                  break;                              case 4:                                  unicodeValue =                                    int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 24 |                                    int.Parse(unicodeParts[1]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 16 |                                    int.Parse(unicodeParts[2]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 8 |                                    int.Parse(unicodeParts[3]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture);                                  break;                          }
Magic Number,Typography.OpenFont,AdobeGlyphList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\AdditionalInfo\AdobeGlyphList.cs,InitData,The following statement contains a magic number: switch (partCount)                          {                              case 0:                              default: throw new System.Exception("??");                              case 1:                                  unicodeValue =                                      int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture);                                  break;                              case 2:                                  unicodeValue =                                      int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 8 |                                      int.Parse(unicodeParts[1]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture);                                  break;                              case 3:                                  unicodeValue =                                    int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 16 |                                    int.Parse(unicodeParts[1]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 8 |                                    int.Parse(unicodeParts[2]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture);                                  break;                              case 4:                                  unicodeValue =                                    int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 24 |                                    int.Parse(unicodeParts[1]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 16 |                                    int.Parse(unicodeParts[2]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 8 |                                    int.Parse(unicodeParts[3]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture);                                  break;                          }
Magic Number,Typography.OpenFont,AdobeGlyphList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\AdditionalInfo\AdobeGlyphList.cs,InitData,The following statement contains a magic number: switch (partCount)                          {                              case 0:                              default: throw new System.Exception("??");                              case 1:                                  unicodeValue =                                      int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture);                                  break;                              case 2:                                  unicodeValue =                                      int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 8 |                                      int.Parse(unicodeParts[1]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture);                                  break;                              case 3:                                  unicodeValue =                                    int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 16 |                                    int.Parse(unicodeParts[1]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 8 |                                    int.Parse(unicodeParts[2]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture);                                  break;                              case 4:                                  unicodeValue =                                    int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 24 |                                    int.Parse(unicodeParts[1]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 16 |                                    int.Parse(unicodeParts[2]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 8 |                                    int.Parse(unicodeParts[3]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture);                                  break;                          }
Magic Number,Typography.OpenFont,AdobeGlyphList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\AdditionalInfo\AdobeGlyphList.cs,InitData,The following statement contains a magic number: switch (partCount)                          {                              case 0:                              default: throw new System.Exception("??");                              case 1:                                  unicodeValue =                                      int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture);                                  break;                              case 2:                                  unicodeValue =                                      int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 8 |                                      int.Parse(unicodeParts[1]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture);                                  break;                              case 3:                                  unicodeValue =                                    int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 16 |                                    int.Parse(unicodeParts[1]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 8 |                                    int.Parse(unicodeParts[2]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture);                                  break;                              case 4:                                  unicodeValue =                                    int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 24 |                                    int.Parse(unicodeParts[1]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 16 |                                    int.Parse(unicodeParts[2]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 8 |                                    int.Parse(unicodeParts[3]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture);                                  break;                          }
Magic Number,Typography.OpenFont,AdobeGlyphList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\AdditionalInfo\AdobeGlyphList.cs,InitData,The following statement contains a magic number: switch (partCount)                          {                              case 0:                              default: throw new System.Exception("??");                              case 1:                                  unicodeValue =                                      int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture);                                  break;                              case 2:                                  unicodeValue =                                      int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 8 |                                      int.Parse(unicodeParts[1]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture);                                  break;                              case 3:                                  unicodeValue =                                    int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 16 |                                    int.Parse(unicodeParts[1]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 8 |                                    int.Parse(unicodeParts[2]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture);                                  break;                              case 4:                                  unicodeValue =                                    int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 24 |                                    int.Parse(unicodeParts[1]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 16 |                                    int.Parse(unicodeParts[2]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 8 |                                    int.Parse(unicodeParts[3]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture);                                  break;                          }
Magic Number,Typography.OpenFont,AdobeGlyphList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\AdditionalInfo\AdobeGlyphList.cs,InitData,The following statement contains a magic number: switch (partCount)                          {                              case 0:                              default: throw new System.Exception("??");                              case 1:                                  unicodeValue =                                      int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture);                                  break;                              case 2:                                  unicodeValue =                                      int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 8 |                                      int.Parse(unicodeParts[1]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture);                                  break;                              case 3:                                  unicodeValue =                                    int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 16 |                                    int.Parse(unicodeParts[1]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 8 |                                    int.Parse(unicodeParts[2]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture);                                  break;                              case 4:                                  unicodeValue =                                    int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 24 |                                    int.Parse(unicodeParts[1]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 16 |                                    int.Parse(unicodeParts[2]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 8 |                                    int.Parse(unicodeParts[3]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture);                                  break;                          }
Magic Number,Typography.OpenFont,AdobeGlyphList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\AdditionalInfo\AdobeGlyphList.cs,InitData,The following statement contains a magic number: switch (partCount)                          {                              case 0:                              default: throw new System.Exception("??");                              case 1:                                  unicodeValue =                                      int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture);                                  break;                              case 2:                                  unicodeValue =                                      int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 8 |                                      int.Parse(unicodeParts[1]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture);                                  break;                              case 3:                                  unicodeValue =                                    int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 16 |                                    int.Parse(unicodeParts[1]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 8 |                                    int.Parse(unicodeParts[2]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture);                                  break;                              case 4:                                  unicodeValue =                                    int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 24 |                                    int.Parse(unicodeParts[1]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 16 |                                    int.Parse(unicodeParts[2]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 8 |                                    int.Parse(unicodeParts[3]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture);                                  break;                          }
Magic Number,Typography.OpenFont,AdobeGlyphList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\AdditionalInfo\AdobeGlyphList.cs,InitData,The following statement contains a magic number: switch (partCount)                          {                              case 0:                              default: throw new System.Exception("??");                              case 1:                                  unicodeValue =                                      int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture);                                  break;                              case 2:                                  unicodeValue =                                      int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 8 |                                      int.Parse(unicodeParts[1]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture);                                  break;                              case 3:                                  unicodeValue =                                    int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 16 |                                    int.Parse(unicodeParts[1]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 8 |                                    int.Parse(unicodeParts[2]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture);                                  break;                              case 4:                                  unicodeValue =                                    int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 24 |                                    int.Parse(unicodeParts[1]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 16 |                                    int.Parse(unicodeParts[2]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 8 |                                    int.Parse(unicodeParts[3]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture);                                  break;                          }
Magic Number,Typography.OpenFont,AdobeGlyphList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\AdditionalInfo\AdobeGlyphList.cs,InitData,The following statement contains a magic number: switch (partCount)                          {                              case 0:                              default: throw new System.Exception("??");                              case 1:                                  unicodeValue =                                      int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture);                                  break;                              case 2:                                  unicodeValue =                                      int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 8 |                                      int.Parse(unicodeParts[1]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture);                                  break;                              case 3:                                  unicodeValue =                                    int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 16 |                                    int.Parse(unicodeParts[1]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 8 |                                    int.Parse(unicodeParts[2]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture);                                  break;                              case 4:                                  unicodeValue =                                    int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 24 |                                    int.Parse(unicodeParts[1]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 16 |                                    int.Parse(unicodeParts[2]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 8 |                                    int.Parse(unicodeParts[3]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture);                                  break;                          }
Magic Number,Typography.OpenFont,AdobeGlyphList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\AdditionalInfo\AdobeGlyphList.cs,InitData,The following statement contains a magic number: switch (partCount)                          {                              case 0:                              default: throw new System.Exception("??");                              case 1:                                  unicodeValue =                                      int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture);                                  break;                              case 2:                                  unicodeValue =                                      int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 8 |                                      int.Parse(unicodeParts[1]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture);                                  break;                              case 3:                                  unicodeValue =                                    int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 16 |                                    int.Parse(unicodeParts[1]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 8 |                                    int.Parse(unicodeParts[2]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture);                                  break;                              case 4:                                  unicodeValue =                                    int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 24 |                                    int.Parse(unicodeParts[1]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 16 |                                    int.Parse(unicodeParts[2]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 8 |                                    int.Parse(unicodeParts[3]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture);                                  break;                          }
Magic Number,Typography.OpenFont,AdobeGlyphList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\AdditionalInfo\AdobeGlyphList.cs,InitData,The following statement contains a magic number: switch (partCount)                          {                              case 0:                              default: throw new System.Exception("??");                              case 1:                                  unicodeValue =                                      int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture);                                  break;                              case 2:                                  unicodeValue =                                      int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 8 |                                      int.Parse(unicodeParts[1]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture);                                  break;                              case 3:                                  unicodeValue =                                    int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 16 |                                    int.Parse(unicodeParts[1]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 8 |                                    int.Parse(unicodeParts[2]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture);                                  break;                              case 4:                                  unicodeValue =                                    int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 24 |                                    int.Parse(unicodeParts[1]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 16 |                                    int.Parse(unicodeParts[2]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 8 |                                    int.Parse(unicodeParts[3]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture);                                  break;                          }
Magic Number,Typography.OpenFont,AdobeGlyphList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\AdditionalInfo\AdobeGlyphList.cs,InitData,The following statement contains a magic number: switch (partCount)                          {                              case 0:                              default: throw new System.Exception("??");                              case 1:                                  unicodeValue =                                      int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture);                                  break;                              case 2:                                  unicodeValue =                                      int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 8 |                                      int.Parse(unicodeParts[1]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture);                                  break;                              case 3:                                  unicodeValue =                                    int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 16 |                                    int.Parse(unicodeParts[1]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 8 |                                    int.Parse(unicodeParts[2]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture);                                  break;                              case 4:                                  unicodeValue =                                    int.Parse(unicodeParts[0]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 24 |                                    int.Parse(unicodeParts[1]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 16 |                                    int.Parse(unicodeParts[2]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture) << 8 |                                    int.Parse(unicodeParts[3]' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture);                                  break;                          }
Magic Number,Typography.OpenFont,AdobeGlyphList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\AdditionalInfo\AdobeGlyphList.cs,InitData,The following statement contains a magic number: kp.Length == 2
Magic Number,Typography.OpenFont,MacPostFormat1,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\AdditionalInfo\MacPostFormat1.cs,GetStdMacGlyphNames,The following statement contains a magic number: s_stdMacGlyphNames = new string[260];
Magic Number,Typography.OpenFont,MacPostFormat1,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\AdditionalInfo\MacPostFormat1.cs,GetStdMacGlyphNames,The following statement contains a magic number: key_value.Length != 2
Magic Number,Typography.OpenFont,MacPostFormat1,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\AdditionalInfo\MacPostFormat1.cs,GetStdMacGlyphNames,The following statement contains a magic number: index < 0 || index > 258
Magic Number,Typography.OpenFont,CharMapFormat4,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\CharacterMap.cs,RawCharacterToGlyphIndex,The following statement contains a magic number: return (ushort)((codepoint + _idDelta[i]) % 65536);
Magic Number,Typography.OpenFont,CharMapFormat14,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\CharacterMap.cs,Create,The following statement contains a magic number: long beginAt = reader.BaseStream.Position - 2;
Magic Number,Typography.OpenFont,IGlyphReaderExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\IGlyphTranslator.cs,GetMidPoint,The following statement contains a magic number: return new Vector2(                  ((v0.X + x1) / 2f)'                  ((v0.Y + y1) / 2f));
Magic Number,Typography.OpenFont,IGlyphReaderExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\IGlyphTranslator.cs,GetMidPoint,The following statement contains a magic number: return new Vector2(                  ((v0.X + x1) / 2f)'                  ((v0.Y + y1) / 2f));
Magic Number,Typography.OpenFont,KnownFontFiles,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\OpenFontReader.cs,IsTtcf,The following statement contains a magic number: return (((u1 >> 8) & 0xff) == (byte)'t') &&                     (((u1) & 0xff) == (byte)'t') &&                     (((u2 >> 8) & 0xff) == (byte)'c') &&                     (((u2) & 0xff) == (byte)'f');
Magic Number,Typography.OpenFont,KnownFontFiles,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\OpenFontReader.cs,IsTtcf,The following statement contains a magic number: return (((u1 >> 8) & 0xff) == (byte)'t') &&                     (((u1) & 0xff) == (byte)'t') &&                     (((u2 >> 8) & 0xff) == (byte)'c') &&                     (((u2) & 0xff) == (byte)'f');
Magic Number,Typography.OpenFont,KnownFontFiles,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\OpenFontReader.cs,IsWoff,The following statement contains a magic number: return (((u1 >> 8) & 0xff) == (byte)'w') && //0x77                    (((u1) & 0xff) == (byte)'O') && //0x4f                     (((u2 >> 8) & 0xff) == (byte)'F') && // 0x46                    (((u2) & 0xff) == (byte)'F');
Magic Number,Typography.OpenFont,KnownFontFiles,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\OpenFontReader.cs,IsWoff,The following statement contains a magic number: return (((u1 >> 8) & 0xff) == (byte)'w') && //0x77                    (((u1) & 0xff) == (byte)'O') && //0x4f                     (((u2 >> 8) & 0xff) == (byte)'F') && // 0x46                    (((u2) & 0xff) == (byte)'F');
Magic Number,Typography.OpenFont,KnownFontFiles,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\OpenFontReader.cs,IsWoff2,The following statement contains a magic number: return (((u1 >> 8) & 0xff) == (byte)'w') &&//0x77              (((u1) & 0xff) == (byte)'O') &&  //0x4f               (((u2 >> 8) & 0xff) == (byte)'F') && //0x46              (((u2) & 0xff) == (byte)'2');
Magic Number,Typography.OpenFont,KnownFontFiles,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\OpenFontReader.cs,IsWoff2,The following statement contains a magic number: return (((u1 >> 8) & 0xff) == (byte)'w') &&//0x77              (((u1) & 0xff) == (byte)'O') &&  //0x4f               (((u2 >> 8) & 0xff) == (byte)'F') && //0x46              (((u2) & 0xff) == (byte)'2');
Magic Number,Typography.OpenFont,OpenFontReader,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\OpenFontReader.cs,ReadTTCHeader,The following statement contains a magic number: ttcHeader.majorVersion == 2
Magic Number,Typography.OpenFont,Features,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\FeatureInfo.cs,Features,The following statement contains a magic number: i < 9
Magic Number,Typography.OpenFont,Features,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\FeatureInfo.cs,Features,The following statement contains a magic number: i < 100
Magic Number,Typography.OpenFont,Features,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\FeatureInfo.cs,Features,The following statement contains a magic number: i < 9
Magic Number,Typography.OpenFont,Features,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\FeatureInfo.cs,Features,The following statement contains a magic number: i < 21
Magic Number,Typography.OpenFont,UnicodeLangBitsExtension,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\ScriptLang.cs,ToUnicodeRangeInfo,The following statement contains a magic number: int bitpos = (int)(bits >> 32);
Magic Number,Typography.OpenFont,UnicodeLangBitsExtension,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\ScriptLang.cs,ToUnicodeRangeInfo,The following statement contains a magic number: return new UnicodeRangeInfo(bitpos'                  (int)(lower32 >> 16)'                   (int)(lower32 & 0xFFFF));
Magic Number,Typography.OpenFont,Utils,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables\Utils.cs,ReadF2Dot14,The following statement contains a magic number: return ((float)reader.ReadInt16()) / (1 << 14);
Magic Number,Typography.OpenFont,Utils,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables\Utils.cs,ReadUInt24,The following statement contains a magic number: return (highByte << 16) | reader.ReadUInt16();
Magic Number,Typography.OpenFont,TrueTypeInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,HintGlyph,The following statement contains a magic number: GlyphPointF[] newGlyphPoints = Utils.CloneArray(glyphPoints' 4);
Magic Number,Typography.OpenFont,TrueTypeInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,HintGlyph,The following statement contains a magic number: newGlyphPoints[orgLen + 2] = pp3;
Magic Number,Typography.OpenFont,TrueTypeInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,HintGlyph,The following statement contains a magic number: newGlyphPoints[orgLen + 3] = pp4;
Magic Number,Typography.OpenFont,TrueTypeInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,HintGlyph,The following statement contains a magic number: float agg_x_scale = 1000;
Magic Number,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,SharpFontInterpreter,The following statement contains a magic number: _instructionDefs = new InstructionStream[maxInstructionDefs > 0 ? 256 : 0];
Magic Number,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,Execute,The following statement contains a magic number: switch (opcode)                  {                      // ==== PUSH INSTRUCTIONS ====                      case OpCode.NPUSHB:                      case OpCode.PUSHB1:                      case OpCode.PUSHB2:                      case OpCode.PUSHB3:                      case OpCode.PUSHB4:                      case OpCode.PUSHB5:                      case OpCode.PUSHB6:                      case OpCode.PUSHB7:                      case OpCode.PUSHB8:                          {                              var count = opcode == OpCode.NPUSHB ? stream.NextByte() : opcode - OpCode.PUSHB1 + 1;                              for (int i = count - 1; i >= 0; --i)                                  _stack.Push(stream.NextByte());                          }                          break;                      case OpCode.NPUSHW:                      case OpCode.PUSHW1:                      case OpCode.PUSHW2:                      case OpCode.PUSHW3:                      case OpCode.PUSHW4:                      case OpCode.PUSHW5:                      case OpCode.PUSHW6:                      case OpCode.PUSHW7:                      case OpCode.PUSHW8:                          {                              var count = opcode == OpCode.NPUSHW ? stream.NextByte() : opcode - OpCode.PUSHW1 + 1;                              for (int i = count - 1; i >= 0; --i)                                  _stack.Push(stream.NextWord());                          }                          break;                        // ==== STORAGE MANAGEMENT ====                      case OpCode.RS:                          {                              var loc = CheckIndex(_stack.Pop()' _storage.Length);                              _stack.Push(_storage[loc]);                          }                          break;                      case OpCode.WS:                          {                              var value = _stack.Pop();                              var loc = CheckIndex(_stack.Pop()' _storage.Length);                              _storage[loc] = value;                          }                          break;                        // ==== CONTROL VALUE TABLE ====                      case OpCode.WCVTP:                          {                              var value = _stack.PopFloat();                              var loc = CheckIndex(_stack.Pop()' _controlValueTable.Length);                              _controlValueTable[loc] = value;                          }                          break;                      case OpCode.WCVTF:                          {                              var value = _stack.Pop();                              var loc = CheckIndex(_stack.Pop()' _controlValueTable.Length);                              _controlValueTable[loc] = value * _scale;                          }                          break;                      case OpCode.RCVT: _stack.Push(ReadCvt()); break;                        // ==== STATE VECTORS ====                      case OpCode.SVTCA0:                      case OpCode.SVTCA1:                          {                              var axis = opcode - OpCode.SVTCA0;                              SetFreedomVectorToAxis(axis);                              SetProjectionVectorToAxis(axis);                          }                          break;                      case OpCode.SFVTPV: _state.Freedom = _state.Projection; OnVectorsUpdated(); break;                      case OpCode.SPVTCA0:                      case OpCode.SPVTCA1: SetProjectionVectorToAxis(opcode - OpCode.SPVTCA0); break;                      case OpCode.SFVTCA0:                      case OpCode.SFVTCA1: SetFreedomVectorToAxis(opcode - OpCode.SFVTCA0); break;                      case OpCode.SPVTL0:                      case OpCode.SPVTL1:                      case OpCode.SFVTL0:                      case OpCode.SFVTL1: SetVectorToLine(opcode - OpCode.SPVTL0' false); break;                      case OpCode.SDPVTL0:                      case OpCode.SDPVTL1: SetVectorToLine(opcode - OpCode.SDPVTL0' true); break;                      case OpCode.SPVFS:                      case OpCode.SFVFS:                          {                              var y = _stack.Pop();                              var x = _stack.Pop();                              var vec = Vector2.Normalize(new Vector2(F2Dot14ToFloat(x)' F2Dot14ToFloat(y)));                              if (opcode == OpCode.SFVFS)                                  _state.Freedom = vec;                              else                              {                                  _state.Projection = vec;                                  _state.DualProjection = vec;                              }                              OnVectorsUpdated();                          }                          break;                      case OpCode.GPV:                      case OpCode.GFV:                          {                              var vec = opcode == OpCode.GPV ? _state.Projection : _state.Freedom;                              _stack.Push(FloatToF2Dot14(vec.X));                              _stack.Push(FloatToF2Dot14(vec.Y));                          }                          break;                        // ==== GRAPHICS STATE ====                      case OpCode.SRP0: _state.Rp0 = _stack.Pop(); break;                      case OpCode.SRP1: _state.Rp1 = _stack.Pop(); break;                      case OpCode.SRP2: _state.Rp2 = _stack.Pop(); break;                      case OpCode.SZP0: _zp0 = GetZoneFromStack(); break;                      case OpCode.SZP1: _zp1 = GetZoneFromStack(); break;                      case OpCode.SZP2: _zp2 = GetZoneFromStack(); break;                      case OpCode.SZPS: _zp0 = _zp1 = _zp2 = GetZoneFromStack(); break;                      case OpCode.RTHG: _state.RoundState = RoundMode.ToHalfGrid; break;                      case OpCode.RTG: _state.RoundState = RoundMode.ToGrid; break;                      case OpCode.RTDG: _state.RoundState = RoundMode.ToDoubleGrid; break;                      case OpCode.RDTG: _state.RoundState = RoundMode.DownToGrid; break;                      case OpCode.RUTG: _state.RoundState = RoundMode.UpToGrid; break;                      case OpCode.ROFF: _state.RoundState = RoundMode.Off; break;                      case OpCode.SROUND: _state.RoundState = RoundMode.Super; SetSuperRound(1.0f); break;                      case OpCode.S45ROUND: _state.RoundState = RoundMode.Super45; SetSuperRound(Sqrt2Over2); break;                      case OpCode.INSTCTRL:                          {                              var selector = _stack.Pop();                              if (selector >= 1 && selector <= 2)                              {                                  // value is false if zero' otherwise shift the right bit into the flags                                  var bit = 1 << (selector - 1);                                  if (_stack.Pop() == 0)                                      _state.InstructionControl = (InstructionControlFlags)((int)_state.InstructionControl & ~bit);                                  else                                      _state.InstructionControl = (InstructionControlFlags)((int)_state.InstructionControl | bit);                              }                          }                          break;                      case OpCode.SCANCTRL: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SCANTYPE: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SANGW: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SLOOP: _state.Loop = _stack.Pop(); break;                      case OpCode.SMD: _state.MinDistance = _stack.PopFloat(); break;                      case OpCode.SCVTCI: _state.ControlValueCutIn = _stack.PopFloat(); break;                      case OpCode.SSWCI: _state.SingleWidthCutIn = _stack.PopFloat(); break;                      case OpCode.SSW: _state.SingleWidthValue = _stack.Pop() * _scale; break;                      case OpCode.FLIPON: _state.AutoFlip = true; break;                      case OpCode.FLIPOFF: _state.AutoFlip = false; break;                      case OpCode.SDB: _state.DeltaBase = _stack.Pop(); break;                      case OpCode.SDS: _state.DeltaShift = _stack.Pop(); break;                        // ==== POINT MEASUREMENT ====                      case OpCode.GC0: _stack.Push(Project(_zp2.GetCurrent(_stack.Pop()))); break;                      case OpCode.GC1: _stack.Push(DualProject(_zp2.GetOriginal(_stack.Pop()))); break;                      case OpCode.SCFS:                          {                              var value = _stack.PopFloat();                              var index = _stack.Pop();                              var point = _zp2.GetCurrent(index);                              MovePoint(_zp2' index' value - Project(point));                                // moving twilight points moves their "original" value also                              if (_zp2.IsTwilight)                                  _zp2.Original[index].P = _zp2.Current[index].P;                          }                          break;                      case OpCode.MD0:                          {                              var p1 = _zp1.GetOriginal(_stack.Pop());                              var p2 = _zp0.GetOriginal(_stack.Pop());                              _stack.Push(DualProject(p2 - p1));                          }                          break;                      case OpCode.MD1:                          {                              var p1 = _zp1.GetCurrent(_stack.Pop());                              var p2 = _zp0.GetCurrent(_stack.Pop());                              _stack.Push(Project(p2 - p1));                          }                          break;                      case OpCode.MPS: // MPS should return point size' but we assume DPI so it's the same as pixel size                      case OpCode.MPPEM: _stack.Push(_ppem); break;                      case OpCode.AA: /* deprecated instruction */ _stack.Pop(); break;                        // ==== POINT MODIFICATION ====                      case OpCode.FLIPPT:                          {                              for (int i = 0; i < _state.Loop; i++)                              {                                  var index = _stack.Pop();                                  //review here again!                                  _points.Current[index].onCurve = !_points.Current[index].onCurve;                                  //if (points.Current[index].onCurve)                                  //    points.Current[index].onCurve = false;                                  //else                                  //    points.Current[index].onCurve = true;                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.FLIPRGON:                          {                              var end = _stack.Pop();                              for (int i = _stack.Pop(); i <= end; i++)                                  //points.Current[i].Type = PointType.OnCurve;                                  _points.Current[i].onCurve = true;                          }                          break;                      case OpCode.FLIPRGOFF:                          {                              var end = _stack.Pop();                              for (int i = _stack.Pop(); i <= end; i++)                                  //points.Current[i].Type = PointType.Quadratic;                                  _points.Current[i].onCurve = false;                          }                          break;                      case OpCode.SHP0:                      case OpCode.SHP1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              ShiftPoints(displacement);                          }                          break;                      case OpCode.SHPIX: ShiftPoints(_stack.PopFloat() * _state.Freedom); break;                      case OpCode.SHC0:                      case OpCode.SHC1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              var touch = GetTouchState();                              var contour = _stack.Pop();                              var start = contour == 0 ? 0 : _contours[contour - 1] + 1;                              var count = _zp2.IsTwilight ? _zp2.Current.Length : _contours[contour] + 1;                                for (int i = start; i < count; i++)                              {                                  // don't move the reference point                                  if (zone.Current != _zp2.Current || point != i)                                  {                                      _zp2.Current[i].P += displacement;                                      _zp2.TouchState[i] |= touch;                                  }                              }                          }                          break;                      case OpCode.SHZ0:                      case OpCode.SHZ1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              var count = 0;                              if (_zp2.IsTwilight)                                  count = _zp2.Current.Length;                              else if (_contours.Length > 0)                                  count = _contours[_contours.Length - 1] + 1;                                for (int i = 0; i < count; i++)                              {                                  // don't move the reference point                                  if (zone.Current != _zp2.Current || point != i)                                      _zp2.Current[i].P += displacement;                              }                          }                          break;                      case OpCode.MIAP0:                      case OpCode.MIAP1:                          {                              var distance = ReadCvt();                              var pointIndex = _stack.Pop();                                // this instruction is used in the CVT to set up twilight points with original values                              if (_zp0.IsTwilight)                              {                                  var original = _state.Freedom * distance;                                  _zp0.Original[pointIndex].P = original;                                  _zp0.Current[pointIndex].P = original;                              }                                // current position of the point along the projection vector                              var point = _zp0.GetCurrent(pointIndex);                              var currentPos = Project(point);                              if (opcode == OpCode.MIAP1)                              {                                  // only use the CVT if we are above the cut-in point                                  if (Math.Abs(distance - currentPos) > _state.ControlValueCutIn)                                      distance = currentPos;                                  distance = Round(distance);                              }                                MovePoint(_zp0' pointIndex' distance - currentPos);                              _state.Rp0 = pointIndex;                              _state.Rp1 = pointIndex;                          }                          break;                      case OpCode.MDAP0:                      case OpCode.MDAP1:                          {                              var pointIndex = _stack.Pop();                              var point = _zp0.GetCurrent(pointIndex);                              var distance = 0.0f;                              if (opcode == OpCode.MDAP1)                              {                                  distance = Project(point);                                  distance = Round(distance) - distance;                              }                                MovePoint(_zp0' pointIndex' distance);                              _state.Rp0 = pointIndex;                              _state.Rp1 = pointIndex;                          }                          break;                      case OpCode.MSIRP0:                      case OpCode.MSIRP1:                          {                              var targetDistance = _stack.PopFloat();                              var pointIndex = _stack.Pop();                                // if we're operating on the twilight zone' initialize the points                              if (_zp1.IsTwilight)                              {                                  _zp1.Original[pointIndex].P = _zp0.Original[_state.Rp0].P + targetDistance * _state.Freedom / _fdotp;                                  _zp1.Current[pointIndex].P = _zp1.Original[pointIndex].P;                              }                                var currentDistance = Project(_zp1.GetCurrent(pointIndex) - _zp0.GetCurrent(_state.Rp0));                              MovePoint(_zp1' pointIndex' targetDistance - currentDistance);                                _state.Rp1 = _state.Rp0;                              _state.Rp2 = pointIndex;                              if (opcode == OpCode.MSIRP1)                                  _state.Rp0 = pointIndex;                          }                          break;                      case OpCode.IP:                          {                              var originalBase = _zp0.GetOriginal(_state.Rp1);                              var currentBase = _zp0.GetCurrent(_state.Rp1);                              var originalRange = DualProject(_zp1.GetOriginal(_state.Rp2) - originalBase);                              var currentRange = Project(_zp1.GetCurrent(_state.Rp2) - currentBase);                                for (int i = 0; i < _state.Loop; i++)                              {                                  var pointIndex = _stack.Pop();                                  var point = _zp2.GetCurrent(pointIndex);                                  var currentDistance = Project(point - currentBase);                                  var originalDistance = DualProject(_zp2.GetOriginal(pointIndex) - originalBase);                                    var newDistance = 0.0f;                                  if (originalDistance != 0.0f)                                  {                                      // a range of 0.0f is invalid according to the spec (would result in a div by zero)                                      if (originalRange == 0.0f)                                          newDistance = originalDistance;                                      else                                          newDistance = originalDistance * currentRange / originalRange;                                  }                                    MovePoint(_zp2' pointIndex' newDistance - currentDistance);                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.ALIGNRP:                          {                              for (int i = 0; i < _state.Loop; i++)                              {                                  var pointIndex = _stack.Pop();                                  var p1 = _zp1.GetCurrent(pointIndex);                                  var p2 = _zp0.GetCurrent(_state.Rp0);                                  MovePoint(_zp1' pointIndex' -Project(p1 - p2));                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.ALIGNPTS:                          {                              var p1 = _stack.Pop();                              var p2 = _stack.Pop();                              var distance = Project(_zp0.GetCurrent(p2) - _zp1.GetCurrent(p1)) / 2;                              MovePoint(_zp1' p1' distance);                              MovePoint(_zp0' p2' -distance);                          }                          break;                      case OpCode.UTP: _zp0.TouchState[_stack.Pop()] &= ~GetTouchState(); break;                      case OpCode.IUP0:                      case OpCode.IUP1:                          // bail if no contours (empty outline)                          if (_contours.Length == 0)                          {                              break;                          }                            //{                            //    //WinterDev's new managed version                          //    GlyphPointF[] currentPnts = points.Current;                          //    GlyphPointF[] originalPnts = points.Original;                            //    int cnt_count = contours.Length;                          //    int point = 0;                          //    // opcode controls whether we care about X or Y direction                          //    // do some pointer trickery so we can operate on the                          //    // points in a direction-agnostic manner                          //    TouchState touchMask;                            //    if (opcode == OpCode.IUP0)                          //    {                          //        //y -axis                          //        touchMask = TouchState.Y;                            //        //                          //        for (int i = 0; i < cnt_count; ++i)                          //        {                          //            int endPoint = contours[i];                          //            int firstPoint = point;                          //            int firstTouched = -1;                          //            int lastTouched = -1;                            //            for (; point <= endPoint; point++)                          //            {                          //                // check whether this point has been touched                          //                if ((points.TouchState[point] & touchMask) != 0)                          //                {                          //                    // if this is the first touched point in the contour' note it and continue                          //                    if (firstTouched < 0)                          //                    {                          //                        firstTouched = point;                          //                        lastTouched = point;                          //                        continue;                          //                    }                            //                    // otherwise' interpolate all untouched points                          //                    // between this point and our last touched point                          //                    InterpolatePointsYAxis(currentPnts' originalPnts' lastTouched + 1' point - 1' lastTouched' point);                          //                    lastTouched = point;                          //                }                          //            }                            //            // check if we had any touched points at all in this contour                          //            if (firstTouched >= 0)                          //            {                          //                // there are two cases left to handle:                          //                // 1. there was only one touched point in the whole contour' in                          //                //    which case we want to shift everything relative to that one                          //                // 2. several touched points' in which case handle the gap from the                          //                //    beginning to the first touched point and the gap from the last                          //                //    touched point to the end of the contour                          //                if (lastTouched == firstTouched)                          //                {                          //                    float delta = currentPnts[lastTouched].Y - originalPnts[lastTouched].Y;                          //                    if (delta != 0.0f)                          //                    {                          //                        for (int n = firstPoint; n < lastTouched; n++)                          //                        {                          //                            currentPnts[n].OffsetY(delta);                          //                        }                          //                        for (int n = lastTouched + 1; n <= endPoint; n++)                          //                        {                          //                            currentPnts[n].OffsetY(delta);                          //                        }                            //                    }                          //                }                          //                else                          //                {                          //                    InterpolatePointsYAxis(currentPnts' originalPnts' lastTouched + 1' endPoint' lastTouched' firstTouched);                          //                    if (firstTouched > 0)                          //                    {                          //                        InterpolatePointsYAxis(currentPnts' originalPnts' firstPoint' firstTouched - 1' lastTouched' firstTouched);                          //                    }                          //                }                          //            }                            //        }                          //    }                          //    else                          //    {                          //        //x-axis                          //        touchMask = TouchState.X;                          //        //                          //        for (int i = 0; i < cnt_count; ++i)                          //        {                          //            int endPoint = contours[i];                          //            int firstPoint = point;                          //            int firstTouched = -1;                          //            int lastTouched = -1;                            //            for (; point <= endPoint; point++)                          //            {                          //                // check whether this point has been touched                          //                if ((points.TouchState[point] & touchMask) != 0)                          //                {                          //                    // if this is the first touched point in the contour' note it and continue                          //                    if (firstTouched < 0)                          //                    {                          //                        firstTouched = point;                          //                        lastTouched = point;                          //                        continue;                          //                    }                            //                    // otherwise' interpolate all untouched points                          //                    // between this point and our last touched point                          //                    InterpolatePointsXAxis(currentPnts' originalPnts' lastTouched + 1' point - 1' lastTouched' point);                          //                    lastTouched = point;                          //                }                          //            }                            //            // check if we had any touched points at all in this contour                          //            if (firstTouched >= 0)                          //            {                          //                // there are two cases left to handle:                          //                // 1. there was only one touched point in the whole contour' in                          //                //    which case we want to shift everything relative to that one                          //                // 2. several touched points' in which case handle the gap from the                          //                //    beginning to the first touched point and the gap from the last                          //                //    touched point to the end of the contour                          //                if (lastTouched == firstTouched)                          //                {                          //                    float delta = currentPnts[lastTouched].X - originalPnts[lastTouched].X;                          //                    if (delta != 0.0f)                          //                    {                          //                        for (int n = firstPoint; n < lastTouched; ++n)                          //                        {                          //                            currentPnts[n].OffsetX(delta);                          //                        }                          //                        for (int n = lastTouched + 1; n <= endPoint; ++n)                          //                        {                          //                            currentPnts[n].OffsetX(delta);                          //                        }                          //                    }                          //                }                          //                else                          //                {                          //                    InterpolatePointsXAxis(currentPnts' originalPnts' lastTouched + 1' endPoint' lastTouched' firstTouched);                          //                    if (firstTouched > 0)                          //                    {                          //                        InterpolatePointsXAxis(currentPnts' originalPnts' firstPoint' firstTouched - 1' lastTouched' firstTouched);                          //                    }                          //                }                          //            }                          //        }                          //    }                          //}                          //-----------------------------------------                          unsafe                          {                                //unsafe version                               //TODO: provide manage version                               fixed (GlyphPointF* currentPtr = _points.Current)                              fixed (GlyphPointF* originalPtr = _points.Original)                              {                                  // opcode controls whether we care about X or Y direction                                  // do some pointer trickery so we can operate on the                                  // points in a direction-agnostic manner                                  TouchState touchMask;                                  byte* current;                                  byte* original;                                  if (opcode == OpCode.IUP0)                                  {                                      touchMask = TouchState.Y;                                      current = (byte*)&currentPtr->P.Y;                                      original = (byte*)&originalPtr->P.Y;                                  }                                  else                                  {                                      touchMask = TouchState.X;                                      current = (byte*)&currentPtr->P.X;                                      original = (byte*)&originalPtr->P.X;                                  }                                    var point = 0;                                  for (int i = 0; i < _contours.Length; i++)                                  {                                      var endPoint = _contours[i];                                      var firstPoint = point;                                      var firstTouched = -1;                                      var lastTouched = -1;                                        for (; point <= endPoint; point++)                                      {                                          // check whether this point has been touched                                          if ((_points.TouchState[point] & touchMask) != 0)                                          {                                              // if this is the first touched point in the contour' note it and continue                                              if (firstTouched < 0)                                              {                                                  firstTouched = point;                                                  lastTouched = point;                                                  continue;                                              }                                                // otherwise' interpolate all untouched points                                              // between this point and our last touched point                                              InterpolatePoints(current' original' lastTouched + 1' point - 1' lastTouched' point);                                              lastTouched = point;                                          }                                      }                                        // check if we had any touched points at all in this contour                                      if (firstTouched >= 0)                                      {                                          // there are two cases left to handle:                                          // 1. there was only one touched point in the whole contour' in                                          //    which case we want to shift everything relative to that one                                          // 2. several touched points' in which case handle the gap from the                                          //    beginning to the first touched point and the gap from the last                                          //    touched point to the end of the contour                                          if (lastTouched == firstTouched)                                          {                                              var delta = *GetPoint(current' lastTouched) - *GetPoint(original' lastTouched);                                              if (delta != 0.0f)                                              {                                                  for (int j = firstPoint; j < lastTouched; j++)                                                      *GetPoint(current' j) += delta;                                                  for (int j = lastTouched + 1; j <= endPoint; j++)                                                      *GetPoint(current' j) += delta;                                              }                                          }                                          else                                          {                                              InterpolatePoints(current' original' lastTouched + 1' endPoint' lastTouched' firstTouched);                                              if (firstTouched > 0)                                                  InterpolatePoints(current' original' firstPoint' firstTouched - 1' lastTouched' firstTouched);                                          }                                      }                                  }                              }                          }                          break;                      case OpCode.ISECT:                          {                              // move point P to the intersection of lines A and B                              var b1 = _zp0.GetCurrent(_stack.Pop());                              var b0 = _zp0.GetCurrent(_stack.Pop());                              var a1 = _zp1.GetCurrent(_stack.Pop());                              var a0 = _zp1.GetCurrent(_stack.Pop());                              var index = _stack.Pop();                                // calculate intersection using determinants: https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line                              var da = a0 - a1;                              var db = b0 - b1;                              var den = (da.X * db.Y) - (da.Y * db.X);                              if (Math.Abs(den) <= Epsilon)                              {                                  // parallel lines; spec says to put the ppoint "into the middle of the two lines"                                  _zp2.Current[index].P = (a0 + a1 + b0 + b1) / 4;                              }                              else                              {                                  var t = (a0.X * a1.Y) - (a0.Y * a1.X);                                  var u = (b0.X * b1.Y) - (b0.Y * b1.X);                                  var p = new Vector2(                                      (t * db.X) - (da.X * u)'                                      (t * db.Y) - (da.Y * u)                                  );                                  _zp2.Current[index].P = p / den;                              }                              _zp2.TouchState[index] = TouchState.Both;                          }                          break;                        // ==== STACK MANAGEMENT ====                      case OpCode.DUP: _stack.Duplicate(); break;                      case OpCode.POP: _stack.Pop(); break;                      case OpCode.CLEAR: _stack.Clear(); break;                      case OpCode.SWAP: _stack.Swap(); break;                      case OpCode.DEPTH: _stack.Depth(); break;                      case OpCode.CINDEX: _stack.Copy(); break;                      case OpCode.MINDEX: _stack.Move(); break;                      case OpCode.ROLL: _stack.Roll(); break;                        // ==== FLOW CONTROL ====                      case OpCode.IF:                          {                              // value is false; jump to the next else block or endif marker                              // otherwise' we don't have to do anything; we'll keep executing this block                              if (!_stack.PopBool())                              {                                  int indent = 1;                                  while (indent > 0)                                  {                                      opcode = SkipNext(ref stream);                                      switch (opcode)                                      {                                          case OpCode.IF: indent++; break;                                          case OpCode.EIF: indent--; break;                                          case OpCode.ELSE:                                              if (indent == 1)                                                  indent = 0;                                              break;                                      }                                  }                              }                          }                          break;                      case OpCode.ELSE:                          {                              // assume we hit the true statement of some previous if block                              // if we had hit false' we would have jumped over this                              int indent = 1;                              while (indent > 0)                              {                                  opcode = SkipNext(ref stream);                                  switch (opcode)                                  {                                      case OpCode.IF: indent++; break;                                      case OpCode.EIF: indent--; break;                                  }                              }                          }                          break;                      case OpCode.EIF: /* nothing to do */ break;                      case OpCode.JROT:                      case OpCode.JROF:                          {                              if (_stack.PopBool() == (opcode == OpCode.JROT))                                  stream.Jump(_stack.Pop() - 1);                              else                                  _stack.Pop();    // ignore the offset                          }                          break;                      case OpCode.JMPR: stream.Jump(_stack.Pop() - 1); break;                        // ==== LOGICAL OPS ====                      case OpCode.LT:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a < b);                          }                          break;                      case OpCode.LTEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a <= b);                          }                          break;                      case OpCode.GT:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a > b);                          }                          break;                      case OpCode.GTEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a >= b);                          }                          break;                      case OpCode.EQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a == b);                          }                          break;                      case OpCode.NEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a != b);                          }                          break;                      case OpCode.AND:                          {                              var b = _stack.PopBool();                              var a = _stack.PopBool();                              _stack.Push(a && b);                          }                          break;                      case OpCode.OR:                          {                              var b = _stack.PopBool();                              var a = _stack.PopBool();                              _stack.Push(a || b);                          }                          break;                      case OpCode.NOT: _stack.Push(!_stack.PopBool()); break;                      case OpCode.ODD:                          {                              var value = (int)Round(_stack.PopFloat());                              _stack.Push(value % 2 != 0);                          }                          break;                      case OpCode.EVEN:                          {                              var value = (int)Round(_stack.PopFloat());                              _stack.Push(value % 2 == 0);                          }                          break;                        // ==== ARITHMETIC ====                      case OpCode.ADD:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a + b);                          }                          break;                      case OpCode.SUB:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a - b);                          }                          break;                      case OpCode.DIV:                          {                              var b = _stack.Pop();                              if (b == 0)                                  throw new InvalidFontException("Division by zero.");                                var a = _stack.Pop();                              var result = ((long)a << 6) / b;                              _stack.Push((int)result);                          }                          break;                      case OpCode.MUL:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              var result = ((long)a * b) >> 6;                              _stack.Push((int)result);                          }                          break;                      case OpCode.ABS: _stack.Push(Math.Abs(_stack.Pop())); break;                      case OpCode.NEG: _stack.Push(-_stack.Pop()); break;                      case OpCode.FLOOR: _stack.Push(_stack.Pop() & ~63); break;                      case OpCode.CEILING: _stack.Push((_stack.Pop() + 63) & ~63); break;                      case OpCode.MAX: _stack.Push(Math.Max(_stack.Pop()' _stack.Pop())); break;                      case OpCode.MIN: _stack.Push(Math.Min(_stack.Pop()' _stack.Pop())); break;                        // ==== FUNCTIONS ====                      case OpCode.FDEF:                          {                              if (!allowFunctionDefs || inFunction)                                  throw new InvalidFontException("Can't define functions here.");                                _functions[_stack.Pop()] = stream;                              while (SkipNext(ref stream) != OpCode.ENDF) ;                          }                          break;                      case OpCode.IDEF:                          {                              if (!allowFunctionDefs || inFunction)                                  throw new InvalidFontException("Can't define functions here.");                                _instructionDefs[_stack.Pop()] = stream;                              while (SkipNext(ref stream) != OpCode.ENDF) ;                          }                          break;                      case OpCode.ENDF:                          {                              if (!inFunction)                                  throw new InvalidFontException("Found invalid ENDF marker outside of a function definition.");                              return;                          }                      case OpCode.CALL:                      case OpCode.LOOPCALL:                          {                              _callStackSize++;                              if (_callStackSize > MaxCallStack)                                  throw new InvalidFontException("Stack overflow; infinite recursion?");                                var function = _functions[_stack.Pop()];                              var count = opcode == OpCode.LOOPCALL ? _stack.Pop() : 1;                              for (int i = 0; i < count; i++)                                  Execute(function' true' false);                              _callStackSize--;                          }                          break;                        // ==== ROUNDING ====                      // we don't have "engine compensation" so the variants are unnecessary                      case OpCode.ROUND0:                      case OpCode.ROUND1:                      case OpCode.ROUND2:                      case OpCode.ROUND3: _stack.Push(Round(_stack.PopFloat())); break;                      case OpCode.NROUND0:                      case OpCode.NROUND1:                      case OpCode.NROUND2:                      case OpCode.NROUND3: break;                        // ==== DELTA EXCEPTIONS ====                      case OpCode.DELTAC1:                      case OpCode.DELTAC2:                      case OpCode.DELTAC3:                          {                              var last = _stack.Pop();                              for (int i = 1; i <= last; i++)                              {                                  var cvtIndex = _stack.Pop();                                  var arg = _stack.Pop();                                    // upper 4 bits of the 8-bit arg is the relative ppem                                  // the opcode specifies the base to add to the ppem                                  var triggerPpem = (arg >> 4) & 0xF;                                  triggerPpem += (opcode - OpCode.DELTAC1) * 16;                                  triggerPpem += _state.DeltaBase;                                    // if the current ppem matches the trigger' apply the exception                                  if (_ppem == triggerPpem)                                  {                                      // the lower 4 bits of the arg is the amount to shift                                      // it's encoded such that 0 isn't an allowable value (who wants to shift by 0 anyway?)                                      var amount = (arg & 0xF) - 8;                                      if (amount >= 0)                                          amount++;                                      amount *= 1 << (6 - _state.DeltaShift);                                        // update the CVT                                      CheckIndex(cvtIndex' _controlValueTable.Length);                                      _controlValueTable[cvtIndex] += F26Dot6ToFloat(amount);                                  }                              }                          }                          break;                      case OpCode.DELTAP1:                      case OpCode.DELTAP2:                      case OpCode.DELTAP3:                          {                              var last = _stack.Pop();                              for (int i = 1; i <= last; i++)                              {                                  var pointIndex = _stack.Pop();                                  var arg = _stack.Pop();                                    // upper 4 bits of the 8-bit arg is the relative ppem                                  // the opcode specifies the base to add to the ppem                                  var triggerPpem = (arg >> 4) & 0xF;                                  triggerPpem += _state.DeltaBase;                                  if (opcode != OpCode.DELTAP1)                                      triggerPpem += (opcode - OpCode.DELTAP2 + 1) * 16;                                    // if the current ppem matches the trigger' apply the exception                                  if (_ppem == triggerPpem)                                  {                                      // the lower 4 bits of the arg is the amount to shift                                      // it's encoded such that 0 isn't an allowable value (who wants to shift by 0 anyway?)                                      var amount = (arg & 0xF) - 8;                                      if (amount >= 0)                                          amount++;                                      amount *= 1 << (6 - _state.DeltaShift);                                        MovePoint(_zp0' pointIndex' F26Dot6ToFloat(amount));                                  }                              }                          }                          break;                        // ==== MISCELLANEOUS ====                      case OpCode.DEBUG: _stack.Pop(); break;                      case OpCode.GETINFO:                          {                              var selector = _stack.Pop();                              var result = 0;                              if ((selector & 0x1) != 0)                              {                                  // pretend we are MS Rasterizer v35                                  result = 35;                              }                                // TODO: rotation and stretching                              //if ((selector & 0x2) != 0)                              //if ((selector & 0x4) != 0)                                // we're always rendering in grayscale                              if ((selector & 0x20) != 0)                                  result |= 1 << 12;                                // TODO: ClearType flags                                _stack.Push(result);                          }                          break;                        default:                          if (opcode >= OpCode.MIRP)                              MoveIndirectRelative(opcode - OpCode.MIRP);                          else if (opcode >= OpCode.MDRP)                              MoveDirectRelative(opcode - OpCode.MDRP);                          else                          {                              // check if this is a runtime-defined opcode                              var index = (int)opcode;                              if (index > _instructionDefs.Length || !_instructionDefs[index].IsValid)                                  throw new InvalidFontException("Unknown opcode in font program.");                                _callStackSize++;                              if (_callStackSize > MaxCallStack)                                  throw new InvalidFontException("Stack overflow; infinite recursion?");                                Execute(_instructionDefs[index]' true' false);                              _callStackSize--;                          }                          break;                  }
Magic Number,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,Execute,The following statement contains a magic number: switch (opcode)                  {                      // ==== PUSH INSTRUCTIONS ====                      case OpCode.NPUSHB:                      case OpCode.PUSHB1:                      case OpCode.PUSHB2:                      case OpCode.PUSHB3:                      case OpCode.PUSHB4:                      case OpCode.PUSHB5:                      case OpCode.PUSHB6:                      case OpCode.PUSHB7:                      case OpCode.PUSHB8:                          {                              var count = opcode == OpCode.NPUSHB ? stream.NextByte() : opcode - OpCode.PUSHB1 + 1;                              for (int i = count - 1; i >= 0; --i)                                  _stack.Push(stream.NextByte());                          }                          break;                      case OpCode.NPUSHW:                      case OpCode.PUSHW1:                      case OpCode.PUSHW2:                      case OpCode.PUSHW3:                      case OpCode.PUSHW4:                      case OpCode.PUSHW5:                      case OpCode.PUSHW6:                      case OpCode.PUSHW7:                      case OpCode.PUSHW8:                          {                              var count = opcode == OpCode.NPUSHW ? stream.NextByte() : opcode - OpCode.PUSHW1 + 1;                              for (int i = count - 1; i >= 0; --i)                                  _stack.Push(stream.NextWord());                          }                          break;                        // ==== STORAGE MANAGEMENT ====                      case OpCode.RS:                          {                              var loc = CheckIndex(_stack.Pop()' _storage.Length);                              _stack.Push(_storage[loc]);                          }                          break;                      case OpCode.WS:                          {                              var value = _stack.Pop();                              var loc = CheckIndex(_stack.Pop()' _storage.Length);                              _storage[loc] = value;                          }                          break;                        // ==== CONTROL VALUE TABLE ====                      case OpCode.WCVTP:                          {                              var value = _stack.PopFloat();                              var loc = CheckIndex(_stack.Pop()' _controlValueTable.Length);                              _controlValueTable[loc] = value;                          }                          break;                      case OpCode.WCVTF:                          {                              var value = _stack.Pop();                              var loc = CheckIndex(_stack.Pop()' _controlValueTable.Length);                              _controlValueTable[loc] = value * _scale;                          }                          break;                      case OpCode.RCVT: _stack.Push(ReadCvt()); break;                        // ==== STATE VECTORS ====                      case OpCode.SVTCA0:                      case OpCode.SVTCA1:                          {                              var axis = opcode - OpCode.SVTCA0;                              SetFreedomVectorToAxis(axis);                              SetProjectionVectorToAxis(axis);                          }                          break;                      case OpCode.SFVTPV: _state.Freedom = _state.Projection; OnVectorsUpdated(); break;                      case OpCode.SPVTCA0:                      case OpCode.SPVTCA1: SetProjectionVectorToAxis(opcode - OpCode.SPVTCA0); break;                      case OpCode.SFVTCA0:                      case OpCode.SFVTCA1: SetFreedomVectorToAxis(opcode - OpCode.SFVTCA0); break;                      case OpCode.SPVTL0:                      case OpCode.SPVTL1:                      case OpCode.SFVTL0:                      case OpCode.SFVTL1: SetVectorToLine(opcode - OpCode.SPVTL0' false); break;                      case OpCode.SDPVTL0:                      case OpCode.SDPVTL1: SetVectorToLine(opcode - OpCode.SDPVTL0' true); break;                      case OpCode.SPVFS:                      case OpCode.SFVFS:                          {                              var y = _stack.Pop();                              var x = _stack.Pop();                              var vec = Vector2.Normalize(new Vector2(F2Dot14ToFloat(x)' F2Dot14ToFloat(y)));                              if (opcode == OpCode.SFVFS)                                  _state.Freedom = vec;                              else                              {                                  _state.Projection = vec;                                  _state.DualProjection = vec;                              }                              OnVectorsUpdated();                          }                          break;                      case OpCode.GPV:                      case OpCode.GFV:                          {                              var vec = opcode == OpCode.GPV ? _state.Projection : _state.Freedom;                              _stack.Push(FloatToF2Dot14(vec.X));                              _stack.Push(FloatToF2Dot14(vec.Y));                          }                          break;                        // ==== GRAPHICS STATE ====                      case OpCode.SRP0: _state.Rp0 = _stack.Pop(); break;                      case OpCode.SRP1: _state.Rp1 = _stack.Pop(); break;                      case OpCode.SRP2: _state.Rp2 = _stack.Pop(); break;                      case OpCode.SZP0: _zp0 = GetZoneFromStack(); break;                      case OpCode.SZP1: _zp1 = GetZoneFromStack(); break;                      case OpCode.SZP2: _zp2 = GetZoneFromStack(); break;                      case OpCode.SZPS: _zp0 = _zp1 = _zp2 = GetZoneFromStack(); break;                      case OpCode.RTHG: _state.RoundState = RoundMode.ToHalfGrid; break;                      case OpCode.RTG: _state.RoundState = RoundMode.ToGrid; break;                      case OpCode.RTDG: _state.RoundState = RoundMode.ToDoubleGrid; break;                      case OpCode.RDTG: _state.RoundState = RoundMode.DownToGrid; break;                      case OpCode.RUTG: _state.RoundState = RoundMode.UpToGrid; break;                      case OpCode.ROFF: _state.RoundState = RoundMode.Off; break;                      case OpCode.SROUND: _state.RoundState = RoundMode.Super; SetSuperRound(1.0f); break;                      case OpCode.S45ROUND: _state.RoundState = RoundMode.Super45; SetSuperRound(Sqrt2Over2); break;                      case OpCode.INSTCTRL:                          {                              var selector = _stack.Pop();                              if (selector >= 1 && selector <= 2)                              {                                  // value is false if zero' otherwise shift the right bit into the flags                                  var bit = 1 << (selector - 1);                                  if (_stack.Pop() == 0)                                      _state.InstructionControl = (InstructionControlFlags)((int)_state.InstructionControl & ~bit);                                  else                                      _state.InstructionControl = (InstructionControlFlags)((int)_state.InstructionControl | bit);                              }                          }                          break;                      case OpCode.SCANCTRL: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SCANTYPE: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SANGW: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SLOOP: _state.Loop = _stack.Pop(); break;                      case OpCode.SMD: _state.MinDistance = _stack.PopFloat(); break;                      case OpCode.SCVTCI: _state.ControlValueCutIn = _stack.PopFloat(); break;                      case OpCode.SSWCI: _state.SingleWidthCutIn = _stack.PopFloat(); break;                      case OpCode.SSW: _state.SingleWidthValue = _stack.Pop() * _scale; break;                      case OpCode.FLIPON: _state.AutoFlip = true; break;                      case OpCode.FLIPOFF: _state.AutoFlip = false; break;                      case OpCode.SDB: _state.DeltaBase = _stack.Pop(); break;                      case OpCode.SDS: _state.DeltaShift = _stack.Pop(); break;                        // ==== POINT MEASUREMENT ====                      case OpCode.GC0: _stack.Push(Project(_zp2.GetCurrent(_stack.Pop()))); break;                      case OpCode.GC1: _stack.Push(DualProject(_zp2.GetOriginal(_stack.Pop()))); break;                      case OpCode.SCFS:                          {                              var value = _stack.PopFloat();                              var index = _stack.Pop();                              var point = _zp2.GetCurrent(index);                              MovePoint(_zp2' index' value - Project(point));                                // moving twilight points moves their "original" value also                              if (_zp2.IsTwilight)                                  _zp2.Original[index].P = _zp2.Current[index].P;                          }                          break;                      case OpCode.MD0:                          {                              var p1 = _zp1.GetOriginal(_stack.Pop());                              var p2 = _zp0.GetOriginal(_stack.Pop());                              _stack.Push(DualProject(p2 - p1));                          }                          break;                      case OpCode.MD1:                          {                              var p1 = _zp1.GetCurrent(_stack.Pop());                              var p2 = _zp0.GetCurrent(_stack.Pop());                              _stack.Push(Project(p2 - p1));                          }                          break;                      case OpCode.MPS: // MPS should return point size' but we assume DPI so it's the same as pixel size                      case OpCode.MPPEM: _stack.Push(_ppem); break;                      case OpCode.AA: /* deprecated instruction */ _stack.Pop(); break;                        // ==== POINT MODIFICATION ====                      case OpCode.FLIPPT:                          {                              for (int i = 0; i < _state.Loop; i++)                              {                                  var index = _stack.Pop();                                  //review here again!                                  _points.Current[index].onCurve = !_points.Current[index].onCurve;                                  //if (points.Current[index].onCurve)                                  //    points.Current[index].onCurve = false;                                  //else                                  //    points.Current[index].onCurve = true;                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.FLIPRGON:                          {                              var end = _stack.Pop();                              for (int i = _stack.Pop(); i <= end; i++)                                  //points.Current[i].Type = PointType.OnCurve;                                  _points.Current[i].onCurve = true;                          }                          break;                      case OpCode.FLIPRGOFF:                          {                              var end = _stack.Pop();                              for (int i = _stack.Pop(); i <= end; i++)                                  //points.Current[i].Type = PointType.Quadratic;                                  _points.Current[i].onCurve = false;                          }                          break;                      case OpCode.SHP0:                      case OpCode.SHP1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              ShiftPoints(displacement);                          }                          break;                      case OpCode.SHPIX: ShiftPoints(_stack.PopFloat() * _state.Freedom); break;                      case OpCode.SHC0:                      case OpCode.SHC1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              var touch = GetTouchState();                              var contour = _stack.Pop();                              var start = contour == 0 ? 0 : _contours[contour - 1] + 1;                              var count = _zp2.IsTwilight ? _zp2.Current.Length : _contours[contour] + 1;                                for (int i = start; i < count; i++)                              {                                  // don't move the reference point                                  if (zone.Current != _zp2.Current || point != i)                                  {                                      _zp2.Current[i].P += displacement;                                      _zp2.TouchState[i] |= touch;                                  }                              }                          }                          break;                      case OpCode.SHZ0:                      case OpCode.SHZ1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              var count = 0;                              if (_zp2.IsTwilight)                                  count = _zp2.Current.Length;                              else if (_contours.Length > 0)                                  count = _contours[_contours.Length - 1] + 1;                                for (int i = 0; i < count; i++)                              {                                  // don't move the reference point                                  if (zone.Current != _zp2.Current || point != i)                                      _zp2.Current[i].P += displacement;                              }                          }                          break;                      case OpCode.MIAP0:                      case OpCode.MIAP1:                          {                              var distance = ReadCvt();                              var pointIndex = _stack.Pop();                                // this instruction is used in the CVT to set up twilight points with original values                              if (_zp0.IsTwilight)                              {                                  var original = _state.Freedom * distance;                                  _zp0.Original[pointIndex].P = original;                                  _zp0.Current[pointIndex].P = original;                              }                                // current position of the point along the projection vector                              var point = _zp0.GetCurrent(pointIndex);                              var currentPos = Project(point);                              if (opcode == OpCode.MIAP1)                              {                                  // only use the CVT if we are above the cut-in point                                  if (Math.Abs(distance - currentPos) > _state.ControlValueCutIn)                                      distance = currentPos;                                  distance = Round(distance);                              }                                MovePoint(_zp0' pointIndex' distance - currentPos);                              _state.Rp0 = pointIndex;                              _state.Rp1 = pointIndex;                          }                          break;                      case OpCode.MDAP0:                      case OpCode.MDAP1:                          {                              var pointIndex = _stack.Pop();                              var point = _zp0.GetCurrent(pointIndex);                              var distance = 0.0f;                              if (opcode == OpCode.MDAP1)                              {                                  distance = Project(point);                                  distance = Round(distance) - distance;                              }                                MovePoint(_zp0' pointIndex' distance);                              _state.Rp0 = pointIndex;                              _state.Rp1 = pointIndex;                          }                          break;                      case OpCode.MSIRP0:                      case OpCode.MSIRP1:                          {                              var targetDistance = _stack.PopFloat();                              var pointIndex = _stack.Pop();                                // if we're operating on the twilight zone' initialize the points                              if (_zp1.IsTwilight)                              {                                  _zp1.Original[pointIndex].P = _zp0.Original[_state.Rp0].P + targetDistance * _state.Freedom / _fdotp;                                  _zp1.Current[pointIndex].P = _zp1.Original[pointIndex].P;                              }                                var currentDistance = Project(_zp1.GetCurrent(pointIndex) - _zp0.GetCurrent(_state.Rp0));                              MovePoint(_zp1' pointIndex' targetDistance - currentDistance);                                _state.Rp1 = _state.Rp0;                              _state.Rp2 = pointIndex;                              if (opcode == OpCode.MSIRP1)                                  _state.Rp0 = pointIndex;                          }                          break;                      case OpCode.IP:                          {                              var originalBase = _zp0.GetOriginal(_state.Rp1);                              var currentBase = _zp0.GetCurrent(_state.Rp1);                              var originalRange = DualProject(_zp1.GetOriginal(_state.Rp2) - originalBase);                              var currentRange = Project(_zp1.GetCurrent(_state.Rp2) - currentBase);                                for (int i = 0; i < _state.Loop; i++)                              {                                  var pointIndex = _stack.Pop();                                  var point = _zp2.GetCurrent(pointIndex);                                  var currentDistance = Project(point - currentBase);                                  var originalDistance = DualProject(_zp2.GetOriginal(pointIndex) - originalBase);                                    var newDistance = 0.0f;                                  if (originalDistance != 0.0f)                                  {                                      // a range of 0.0f is invalid according to the spec (would result in a div by zero)                                      if (originalRange == 0.0f)                                          newDistance = originalDistance;                                      else                                          newDistance = originalDistance * currentRange / originalRange;                                  }                                    MovePoint(_zp2' pointIndex' newDistance - currentDistance);                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.ALIGNRP:                          {                              for (int i = 0; i < _state.Loop; i++)                              {                                  var pointIndex = _stack.Pop();                                  var p1 = _zp1.GetCurrent(pointIndex);                                  var p2 = _zp0.GetCurrent(_state.Rp0);                                  MovePoint(_zp1' pointIndex' -Project(p1 - p2));                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.ALIGNPTS:                          {                              var p1 = _stack.Pop();                              var p2 = _stack.Pop();                              var distance = Project(_zp0.GetCurrent(p2) - _zp1.GetCurrent(p1)) / 2;                              MovePoint(_zp1' p1' distance);                              MovePoint(_zp0' p2' -distance);                          }                          break;                      case OpCode.UTP: _zp0.TouchState[_stack.Pop()] &= ~GetTouchState(); break;                      case OpCode.IUP0:                      case OpCode.IUP1:                          // bail if no contours (empty outline)                          if (_contours.Length == 0)                          {                              break;                          }                            //{                            //    //WinterDev's new managed version                          //    GlyphPointF[] currentPnts = points.Current;                          //    GlyphPointF[] originalPnts = points.Original;                            //    int cnt_count = contours.Length;                          //    int point = 0;                          //    // opcode controls whether we care about X or Y direction                          //    // do some pointer trickery so we can operate on the                          //    // points in a direction-agnostic manner                          //    TouchState touchMask;                            //    if (opcode == OpCode.IUP0)                          //    {                          //        //y -axis                          //        touchMask = TouchState.Y;                            //        //                          //        for (int i = 0; i < cnt_count; ++i)                          //        {                          //            int endPoint = contours[i];                          //            int firstPoint = point;                          //            int firstTouched = -1;                          //            int lastTouched = -1;                            //            for (; point <= endPoint; point++)                          //            {                          //                // check whether this point has been touched                          //                if ((points.TouchState[point] & touchMask) != 0)                          //                {                          //                    // if this is the first touched point in the contour' note it and continue                          //                    if (firstTouched < 0)                          //                    {                          //                        firstTouched = point;                          //                        lastTouched = point;                          //                        continue;                          //                    }                            //                    // otherwise' interpolate all untouched points                          //                    // between this point and our last touched point                          //                    InterpolatePointsYAxis(currentPnts' originalPnts' lastTouched + 1' point - 1' lastTouched' point);                          //                    lastTouched = point;                          //                }                          //            }                            //            // check if we had any touched points at all in this contour                          //            if (firstTouched >= 0)                          //            {                          //                // there are two cases left to handle:                          //                // 1. there was only one touched point in the whole contour' in                          //                //    which case we want to shift everything relative to that one                          //                // 2. several touched points' in which case handle the gap from the                          //                //    beginning to the first touched point and the gap from the last                          //                //    touched point to the end of the contour                          //                if (lastTouched == firstTouched)                          //                {                          //                    float delta = currentPnts[lastTouched].Y - originalPnts[lastTouched].Y;                          //                    if (delta != 0.0f)                          //                    {                          //                        for (int n = firstPoint; n < lastTouched; n++)                          //                        {                          //                            currentPnts[n].OffsetY(delta);                          //                        }                          //                        for (int n = lastTouched + 1; n <= endPoint; n++)                          //                        {                          //                            currentPnts[n].OffsetY(delta);                          //                        }                            //                    }                          //                }                          //                else                          //                {                          //                    InterpolatePointsYAxis(currentPnts' originalPnts' lastTouched + 1' endPoint' lastTouched' firstTouched);                          //                    if (firstTouched > 0)                          //                    {                          //                        InterpolatePointsYAxis(currentPnts' originalPnts' firstPoint' firstTouched - 1' lastTouched' firstTouched);                          //                    }                          //                }                          //            }                            //        }                          //    }                          //    else                          //    {                          //        //x-axis                          //        touchMask = TouchState.X;                          //        //                          //        for (int i = 0; i < cnt_count; ++i)                          //        {                          //            int endPoint = contours[i];                          //            int firstPoint = point;                          //            int firstTouched = -1;                          //            int lastTouched = -1;                            //            for (; point <= endPoint; point++)                          //            {                          //                // check whether this point has been touched                          //                if ((points.TouchState[point] & touchMask) != 0)                          //                {                          //                    // if this is the first touched point in the contour' note it and continue                          //                    if (firstTouched < 0)                          //                    {                          //                        firstTouched = point;                          //                        lastTouched = point;                          //                        continue;                          //                    }                            //                    // otherwise' interpolate all untouched points                          //                    // between this point and our last touched point                          //                    InterpolatePointsXAxis(currentPnts' originalPnts' lastTouched + 1' point - 1' lastTouched' point);                          //                    lastTouched = point;                          //                }                          //            }                            //            // check if we had any touched points at all in this contour                          //            if (firstTouched >= 0)                          //            {                          //                // there are two cases left to handle:                          //                // 1. there was only one touched point in the whole contour' in                          //                //    which case we want to shift everything relative to that one                          //                // 2. several touched points' in which case handle the gap from the                          //                //    beginning to the first touched point and the gap from the last                          //                //    touched point to the end of the contour                          //                if (lastTouched == firstTouched)                          //                {                          //                    float delta = currentPnts[lastTouched].X - originalPnts[lastTouched].X;                          //                    if (delta != 0.0f)                          //                    {                          //                        for (int n = firstPoint; n < lastTouched; ++n)                          //                        {                          //                            currentPnts[n].OffsetX(delta);                          //                        }                          //                        for (int n = lastTouched + 1; n <= endPoint; ++n)                          //                        {                          //                            currentPnts[n].OffsetX(delta);                          //                        }                          //                    }                          //                }                          //                else                          //                {                          //                    InterpolatePointsXAxis(currentPnts' originalPnts' lastTouched + 1' endPoint' lastTouched' firstTouched);                          //                    if (firstTouched > 0)                          //                    {                          //                        InterpolatePointsXAxis(currentPnts' originalPnts' firstPoint' firstTouched - 1' lastTouched' firstTouched);                          //                    }                          //                }                          //            }                          //        }                          //    }                          //}                          //-----------------------------------------                          unsafe                          {                                //unsafe version                               //TODO: provide manage version                               fixed (GlyphPointF* currentPtr = _points.Current)                              fixed (GlyphPointF* originalPtr = _points.Original)                              {                                  // opcode controls whether we care about X or Y direction                                  // do some pointer trickery so we can operate on the                                  // points in a direction-agnostic manner                                  TouchState touchMask;                                  byte* current;                                  byte* original;                                  if (opcode == OpCode.IUP0)                                  {                                      touchMask = TouchState.Y;                                      current = (byte*)&currentPtr->P.Y;                                      original = (byte*)&originalPtr->P.Y;                                  }                                  else                                  {                                      touchMask = TouchState.X;                                      current = (byte*)&currentPtr->P.X;                                      original = (byte*)&originalPtr->P.X;                                  }                                    var point = 0;                                  for (int i = 0; i < _contours.Length; i++)                                  {                                      var endPoint = _contours[i];                                      var firstPoint = point;                                      var firstTouched = -1;                                      var lastTouched = -1;                                        for (; point <= endPoint; point++)                                      {                                          // check whether this point has been touched                                          if ((_points.TouchState[point] & touchMask) != 0)                                          {                                              // if this is the first touched point in the contour' note it and continue                                              if (firstTouched < 0)                                              {                                                  firstTouched = point;                                                  lastTouched = point;                                                  continue;                                              }                                                // otherwise' interpolate all untouched points                                              // between this point and our last touched point                                              InterpolatePoints(current' original' lastTouched + 1' point - 1' lastTouched' point);                                              lastTouched = point;                                          }                                      }                                        // check if we had any touched points at all in this contour                                      if (firstTouched >= 0)                                      {                                          // there are two cases left to handle:                                          // 1. there was only one touched point in the whole contour' in                                          //    which case we want to shift everything relative to that one                                          // 2. several touched points' in which case handle the gap from the                                          //    beginning to the first touched point and the gap from the last                                          //    touched point to the end of the contour                                          if (lastTouched == firstTouched)                                          {                                              var delta = *GetPoint(current' lastTouched) - *GetPoint(original' lastTouched);                                              if (delta != 0.0f)                                              {                                                  for (int j = firstPoint; j < lastTouched; j++)                                                      *GetPoint(current' j) += delta;                                                  for (int j = lastTouched + 1; j <= endPoint; j++)                                                      *GetPoint(current' j) += delta;                                              }                                          }                                          else                                          {                                              InterpolatePoints(current' original' lastTouched + 1' endPoint' lastTouched' firstTouched);                                              if (firstTouched > 0)                                                  InterpolatePoints(current' original' firstPoint' firstTouched - 1' lastTouched' firstTouched);                                          }                                      }                                  }                              }                          }                          break;                      case OpCode.ISECT:                          {                              // move point P to the intersection of lines A and B                              var b1 = _zp0.GetCurrent(_stack.Pop());                              var b0 = _zp0.GetCurrent(_stack.Pop());                              var a1 = _zp1.GetCurrent(_stack.Pop());                              var a0 = _zp1.GetCurrent(_stack.Pop());                              var index = _stack.Pop();                                // calculate intersection using determinants: https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line                              var da = a0 - a1;                              var db = b0 - b1;                              var den = (da.X * db.Y) - (da.Y * db.X);                              if (Math.Abs(den) <= Epsilon)                              {                                  // parallel lines; spec says to put the ppoint "into the middle of the two lines"                                  _zp2.Current[index].P = (a0 + a1 + b0 + b1) / 4;                              }                              else                              {                                  var t = (a0.X * a1.Y) - (a0.Y * a1.X);                                  var u = (b0.X * b1.Y) - (b0.Y * b1.X);                                  var p = new Vector2(                                      (t * db.X) - (da.X * u)'                                      (t * db.Y) - (da.Y * u)                                  );                                  _zp2.Current[index].P = p / den;                              }                              _zp2.TouchState[index] = TouchState.Both;                          }                          break;                        // ==== STACK MANAGEMENT ====                      case OpCode.DUP: _stack.Duplicate(); break;                      case OpCode.POP: _stack.Pop(); break;                      case OpCode.CLEAR: _stack.Clear(); break;                      case OpCode.SWAP: _stack.Swap(); break;                      case OpCode.DEPTH: _stack.Depth(); break;                      case OpCode.CINDEX: _stack.Copy(); break;                      case OpCode.MINDEX: _stack.Move(); break;                      case OpCode.ROLL: _stack.Roll(); break;                        // ==== FLOW CONTROL ====                      case OpCode.IF:                          {                              // value is false; jump to the next else block or endif marker                              // otherwise' we don't have to do anything; we'll keep executing this block                              if (!_stack.PopBool())                              {                                  int indent = 1;                                  while (indent > 0)                                  {                                      opcode = SkipNext(ref stream);                                      switch (opcode)                                      {                                          case OpCode.IF: indent++; break;                                          case OpCode.EIF: indent--; break;                                          case OpCode.ELSE:                                              if (indent == 1)                                                  indent = 0;                                              break;                                      }                                  }                              }                          }                          break;                      case OpCode.ELSE:                          {                              // assume we hit the true statement of some previous if block                              // if we had hit false' we would have jumped over this                              int indent = 1;                              while (indent > 0)                              {                                  opcode = SkipNext(ref stream);                                  switch (opcode)                                  {                                      case OpCode.IF: indent++; break;                                      case OpCode.EIF: indent--; break;                                  }                              }                          }                          break;                      case OpCode.EIF: /* nothing to do */ break;                      case OpCode.JROT:                      case OpCode.JROF:                          {                              if (_stack.PopBool() == (opcode == OpCode.JROT))                                  stream.Jump(_stack.Pop() - 1);                              else                                  _stack.Pop();    // ignore the offset                          }                          break;                      case OpCode.JMPR: stream.Jump(_stack.Pop() - 1); break;                        // ==== LOGICAL OPS ====                      case OpCode.LT:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a < b);                          }                          break;                      case OpCode.LTEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a <= b);                          }                          break;                      case OpCode.GT:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a > b);                          }                          break;                      case OpCode.GTEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a >= b);                          }                          break;                      case OpCode.EQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a == b);                          }                          break;                      case OpCode.NEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a != b);                          }                          break;                      case OpCode.AND:                          {                              var b = _stack.PopBool();                              var a = _stack.PopBool();                              _stack.Push(a && b);                          }                          break;                      case OpCode.OR:                          {                              var b = _stack.PopBool();                              var a = _stack.PopBool();                              _stack.Push(a || b);                          }                          break;                      case OpCode.NOT: _stack.Push(!_stack.PopBool()); break;                      case OpCode.ODD:                          {                              var value = (int)Round(_stack.PopFloat());                              _stack.Push(value % 2 != 0);                          }                          break;                      case OpCode.EVEN:                          {                              var value = (int)Round(_stack.PopFloat());                              _stack.Push(value % 2 == 0);                          }                          break;                        // ==== ARITHMETIC ====                      case OpCode.ADD:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a + b);                          }                          break;                      case OpCode.SUB:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a - b);                          }                          break;                      case OpCode.DIV:                          {                              var b = _stack.Pop();                              if (b == 0)                                  throw new InvalidFontException("Division by zero.");                                var a = _stack.Pop();                              var result = ((long)a << 6) / b;                              _stack.Push((int)result);                          }                          break;                      case OpCode.MUL:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              var result = ((long)a * b) >> 6;                              _stack.Push((int)result);                          }                          break;                      case OpCode.ABS: _stack.Push(Math.Abs(_stack.Pop())); break;                      case OpCode.NEG: _stack.Push(-_stack.Pop()); break;                      case OpCode.FLOOR: _stack.Push(_stack.Pop() & ~63); break;                      case OpCode.CEILING: _stack.Push((_stack.Pop() + 63) & ~63); break;                      case OpCode.MAX: _stack.Push(Math.Max(_stack.Pop()' _stack.Pop())); break;                      case OpCode.MIN: _stack.Push(Math.Min(_stack.Pop()' _stack.Pop())); break;                        // ==== FUNCTIONS ====                      case OpCode.FDEF:                          {                              if (!allowFunctionDefs || inFunction)                                  throw new InvalidFontException("Can't define functions here.");                                _functions[_stack.Pop()] = stream;                              while (SkipNext(ref stream) != OpCode.ENDF) ;                          }                          break;                      case OpCode.IDEF:                          {                              if (!allowFunctionDefs || inFunction)                                  throw new InvalidFontException("Can't define functions here.");                                _instructionDefs[_stack.Pop()] = stream;                              while (SkipNext(ref stream) != OpCode.ENDF) ;                          }                          break;                      case OpCode.ENDF:                          {                              if (!inFunction)                                  throw new InvalidFontException("Found invalid ENDF marker outside of a function definition.");                              return;                          }                      case OpCode.CALL:                      case OpCode.LOOPCALL:                          {                              _callStackSize++;                              if (_callStackSize > MaxCallStack)                                  throw new InvalidFontException("Stack overflow; infinite recursion?");                                var function = _functions[_stack.Pop()];                              var count = opcode == OpCode.LOOPCALL ? _stack.Pop() : 1;                              for (int i = 0; i < count; i++)                                  Execute(function' true' false);                              _callStackSize--;                          }                          break;                        // ==== ROUNDING ====                      // we don't have "engine compensation" so the variants are unnecessary                      case OpCode.ROUND0:                      case OpCode.ROUND1:                      case OpCode.ROUND2:                      case OpCode.ROUND3: _stack.Push(Round(_stack.PopFloat())); break;                      case OpCode.NROUND0:                      case OpCode.NROUND1:                      case OpCode.NROUND2:                      case OpCode.NROUND3: break;                        // ==== DELTA EXCEPTIONS ====                      case OpCode.DELTAC1:                      case OpCode.DELTAC2:                      case OpCode.DELTAC3:                          {                              var last = _stack.Pop();                              for (int i = 1; i <= last; i++)                              {                                  var cvtIndex = _stack.Pop();                                  var arg = _stack.Pop();                                    // upper 4 bits of the 8-bit arg is the relative ppem                                  // the opcode specifies the base to add to the ppem                                  var triggerPpem = (arg >> 4) & 0xF;                                  triggerPpem += (opcode - OpCode.DELTAC1) * 16;                                  triggerPpem += _state.DeltaBase;                                    // if the current ppem matches the trigger' apply the exception                                  if (_ppem == triggerPpem)                                  {                                      // the lower 4 bits of the arg is the amount to shift                                      // it's encoded such that 0 isn't an allowable value (who wants to shift by 0 anyway?)                                      var amount = (arg & 0xF) - 8;                                      if (amount >= 0)                                          amount++;                                      amount *= 1 << (6 - _state.DeltaShift);                                        // update the CVT                                      CheckIndex(cvtIndex' _controlValueTable.Length);                                      _controlValueTable[cvtIndex] += F26Dot6ToFloat(amount);                                  }                              }                          }                          break;                      case OpCode.DELTAP1:                      case OpCode.DELTAP2:                      case OpCode.DELTAP3:                          {                              var last = _stack.Pop();                              for (int i = 1; i <= last; i++)                              {                                  var pointIndex = _stack.Pop();                                  var arg = _stack.Pop();                                    // upper 4 bits of the 8-bit arg is the relative ppem                                  // the opcode specifies the base to add to the ppem                                  var triggerPpem = (arg >> 4) & 0xF;                                  triggerPpem += _state.DeltaBase;                                  if (opcode != OpCode.DELTAP1)                                      triggerPpem += (opcode - OpCode.DELTAP2 + 1) * 16;                                    // if the current ppem matches the trigger' apply the exception                                  if (_ppem == triggerPpem)                                  {                                      // the lower 4 bits of the arg is the amount to shift                                      // it's encoded such that 0 isn't an allowable value (who wants to shift by 0 anyway?)                                      var amount = (arg & 0xF) - 8;                                      if (amount >= 0)                                          amount++;                                      amount *= 1 << (6 - _state.DeltaShift);                                        MovePoint(_zp0' pointIndex' F26Dot6ToFloat(amount));                                  }                              }                          }                          break;                        // ==== MISCELLANEOUS ====                      case OpCode.DEBUG: _stack.Pop(); break;                      case OpCode.GETINFO:                          {                              var selector = _stack.Pop();                              var result = 0;                              if ((selector & 0x1) != 0)                              {                                  // pretend we are MS Rasterizer v35                                  result = 35;                              }                                // TODO: rotation and stretching                              //if ((selector & 0x2) != 0)                              //if ((selector & 0x4) != 0)                                // we're always rendering in grayscale                              if ((selector & 0x20) != 0)                                  result |= 1 << 12;                                // TODO: ClearType flags                                _stack.Push(result);                          }                          break;                        default:                          if (opcode >= OpCode.MIRP)                              MoveIndirectRelative(opcode - OpCode.MIRP);                          else if (opcode >= OpCode.MDRP)                              MoveDirectRelative(opcode - OpCode.MDRP);                          else                          {                              // check if this is a runtime-defined opcode                              var index = (int)opcode;                              if (index > _instructionDefs.Length || !_instructionDefs[index].IsValid)                                  throw new InvalidFontException("Unknown opcode in font program.");                                _callStackSize++;                              if (_callStackSize > MaxCallStack)                                  throw new InvalidFontException("Stack overflow; infinite recursion?");                                Execute(_instructionDefs[index]' true' false);                              _callStackSize--;                          }                          break;                  }
Magic Number,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,Execute,The following statement contains a magic number: switch (opcode)                  {                      // ==== PUSH INSTRUCTIONS ====                      case OpCode.NPUSHB:                      case OpCode.PUSHB1:                      case OpCode.PUSHB2:                      case OpCode.PUSHB3:                      case OpCode.PUSHB4:                      case OpCode.PUSHB5:                      case OpCode.PUSHB6:                      case OpCode.PUSHB7:                      case OpCode.PUSHB8:                          {                              var count = opcode == OpCode.NPUSHB ? stream.NextByte() : opcode - OpCode.PUSHB1 + 1;                              for (int i = count - 1; i >= 0; --i)                                  _stack.Push(stream.NextByte());                          }                          break;                      case OpCode.NPUSHW:                      case OpCode.PUSHW1:                      case OpCode.PUSHW2:                      case OpCode.PUSHW3:                      case OpCode.PUSHW4:                      case OpCode.PUSHW5:                      case OpCode.PUSHW6:                      case OpCode.PUSHW7:                      case OpCode.PUSHW8:                          {                              var count = opcode == OpCode.NPUSHW ? stream.NextByte() : opcode - OpCode.PUSHW1 + 1;                              for (int i = count - 1; i >= 0; --i)                                  _stack.Push(stream.NextWord());                          }                          break;                        // ==== STORAGE MANAGEMENT ====                      case OpCode.RS:                          {                              var loc = CheckIndex(_stack.Pop()' _storage.Length);                              _stack.Push(_storage[loc]);                          }                          break;                      case OpCode.WS:                          {                              var value = _stack.Pop();                              var loc = CheckIndex(_stack.Pop()' _storage.Length);                              _storage[loc] = value;                          }                          break;                        // ==== CONTROL VALUE TABLE ====                      case OpCode.WCVTP:                          {                              var value = _stack.PopFloat();                              var loc = CheckIndex(_stack.Pop()' _controlValueTable.Length);                              _controlValueTable[loc] = value;                          }                          break;                      case OpCode.WCVTF:                          {                              var value = _stack.Pop();                              var loc = CheckIndex(_stack.Pop()' _controlValueTable.Length);                              _controlValueTable[loc] = value * _scale;                          }                          break;                      case OpCode.RCVT: _stack.Push(ReadCvt()); break;                        // ==== STATE VECTORS ====                      case OpCode.SVTCA0:                      case OpCode.SVTCA1:                          {                              var axis = opcode - OpCode.SVTCA0;                              SetFreedomVectorToAxis(axis);                              SetProjectionVectorToAxis(axis);                          }                          break;                      case OpCode.SFVTPV: _state.Freedom = _state.Projection; OnVectorsUpdated(); break;                      case OpCode.SPVTCA0:                      case OpCode.SPVTCA1: SetProjectionVectorToAxis(opcode - OpCode.SPVTCA0); break;                      case OpCode.SFVTCA0:                      case OpCode.SFVTCA1: SetFreedomVectorToAxis(opcode - OpCode.SFVTCA0); break;                      case OpCode.SPVTL0:                      case OpCode.SPVTL1:                      case OpCode.SFVTL0:                      case OpCode.SFVTL1: SetVectorToLine(opcode - OpCode.SPVTL0' false); break;                      case OpCode.SDPVTL0:                      case OpCode.SDPVTL1: SetVectorToLine(opcode - OpCode.SDPVTL0' true); break;                      case OpCode.SPVFS:                      case OpCode.SFVFS:                          {                              var y = _stack.Pop();                              var x = _stack.Pop();                              var vec = Vector2.Normalize(new Vector2(F2Dot14ToFloat(x)' F2Dot14ToFloat(y)));                              if (opcode == OpCode.SFVFS)                                  _state.Freedom = vec;                              else                              {                                  _state.Projection = vec;                                  _state.DualProjection = vec;                              }                              OnVectorsUpdated();                          }                          break;                      case OpCode.GPV:                      case OpCode.GFV:                          {                              var vec = opcode == OpCode.GPV ? _state.Projection : _state.Freedom;                              _stack.Push(FloatToF2Dot14(vec.X));                              _stack.Push(FloatToF2Dot14(vec.Y));                          }                          break;                        // ==== GRAPHICS STATE ====                      case OpCode.SRP0: _state.Rp0 = _stack.Pop(); break;                      case OpCode.SRP1: _state.Rp1 = _stack.Pop(); break;                      case OpCode.SRP2: _state.Rp2 = _stack.Pop(); break;                      case OpCode.SZP0: _zp0 = GetZoneFromStack(); break;                      case OpCode.SZP1: _zp1 = GetZoneFromStack(); break;                      case OpCode.SZP2: _zp2 = GetZoneFromStack(); break;                      case OpCode.SZPS: _zp0 = _zp1 = _zp2 = GetZoneFromStack(); break;                      case OpCode.RTHG: _state.RoundState = RoundMode.ToHalfGrid; break;                      case OpCode.RTG: _state.RoundState = RoundMode.ToGrid; break;                      case OpCode.RTDG: _state.RoundState = RoundMode.ToDoubleGrid; break;                      case OpCode.RDTG: _state.RoundState = RoundMode.DownToGrid; break;                      case OpCode.RUTG: _state.RoundState = RoundMode.UpToGrid; break;                      case OpCode.ROFF: _state.RoundState = RoundMode.Off; break;                      case OpCode.SROUND: _state.RoundState = RoundMode.Super; SetSuperRound(1.0f); break;                      case OpCode.S45ROUND: _state.RoundState = RoundMode.Super45; SetSuperRound(Sqrt2Over2); break;                      case OpCode.INSTCTRL:                          {                              var selector = _stack.Pop();                              if (selector >= 1 && selector <= 2)                              {                                  // value is false if zero' otherwise shift the right bit into the flags                                  var bit = 1 << (selector - 1);                                  if (_stack.Pop() == 0)                                      _state.InstructionControl = (InstructionControlFlags)((int)_state.InstructionControl & ~bit);                                  else                                      _state.InstructionControl = (InstructionControlFlags)((int)_state.InstructionControl | bit);                              }                          }                          break;                      case OpCode.SCANCTRL: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SCANTYPE: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SANGW: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SLOOP: _state.Loop = _stack.Pop(); break;                      case OpCode.SMD: _state.MinDistance = _stack.PopFloat(); break;                      case OpCode.SCVTCI: _state.ControlValueCutIn = _stack.PopFloat(); break;                      case OpCode.SSWCI: _state.SingleWidthCutIn = _stack.PopFloat(); break;                      case OpCode.SSW: _state.SingleWidthValue = _stack.Pop() * _scale; break;                      case OpCode.FLIPON: _state.AutoFlip = true; break;                      case OpCode.FLIPOFF: _state.AutoFlip = false; break;                      case OpCode.SDB: _state.DeltaBase = _stack.Pop(); break;                      case OpCode.SDS: _state.DeltaShift = _stack.Pop(); break;                        // ==== POINT MEASUREMENT ====                      case OpCode.GC0: _stack.Push(Project(_zp2.GetCurrent(_stack.Pop()))); break;                      case OpCode.GC1: _stack.Push(DualProject(_zp2.GetOriginal(_stack.Pop()))); break;                      case OpCode.SCFS:                          {                              var value = _stack.PopFloat();                              var index = _stack.Pop();                              var point = _zp2.GetCurrent(index);                              MovePoint(_zp2' index' value - Project(point));                                // moving twilight points moves their "original" value also                              if (_zp2.IsTwilight)                                  _zp2.Original[index].P = _zp2.Current[index].P;                          }                          break;                      case OpCode.MD0:                          {                              var p1 = _zp1.GetOriginal(_stack.Pop());                              var p2 = _zp0.GetOriginal(_stack.Pop());                              _stack.Push(DualProject(p2 - p1));                          }                          break;                      case OpCode.MD1:                          {                              var p1 = _zp1.GetCurrent(_stack.Pop());                              var p2 = _zp0.GetCurrent(_stack.Pop());                              _stack.Push(Project(p2 - p1));                          }                          break;                      case OpCode.MPS: // MPS should return point size' but we assume DPI so it's the same as pixel size                      case OpCode.MPPEM: _stack.Push(_ppem); break;                      case OpCode.AA: /* deprecated instruction */ _stack.Pop(); break;                        // ==== POINT MODIFICATION ====                      case OpCode.FLIPPT:                          {                              for (int i = 0; i < _state.Loop; i++)                              {                                  var index = _stack.Pop();                                  //review here again!                                  _points.Current[index].onCurve = !_points.Current[index].onCurve;                                  //if (points.Current[index].onCurve)                                  //    points.Current[index].onCurve = false;                                  //else                                  //    points.Current[index].onCurve = true;                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.FLIPRGON:                          {                              var end = _stack.Pop();                              for (int i = _stack.Pop(); i <= end; i++)                                  //points.Current[i].Type = PointType.OnCurve;                                  _points.Current[i].onCurve = true;                          }                          break;                      case OpCode.FLIPRGOFF:                          {                              var end = _stack.Pop();                              for (int i = _stack.Pop(); i <= end; i++)                                  //points.Current[i].Type = PointType.Quadratic;                                  _points.Current[i].onCurve = false;                          }                          break;                      case OpCode.SHP0:                      case OpCode.SHP1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              ShiftPoints(displacement);                          }                          break;                      case OpCode.SHPIX: ShiftPoints(_stack.PopFloat() * _state.Freedom); break;                      case OpCode.SHC0:                      case OpCode.SHC1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              var touch = GetTouchState();                              var contour = _stack.Pop();                              var start = contour == 0 ? 0 : _contours[contour - 1] + 1;                              var count = _zp2.IsTwilight ? _zp2.Current.Length : _contours[contour] + 1;                                for (int i = start; i < count; i++)                              {                                  // don't move the reference point                                  if (zone.Current != _zp2.Current || point != i)                                  {                                      _zp2.Current[i].P += displacement;                                      _zp2.TouchState[i] |= touch;                                  }                              }                          }                          break;                      case OpCode.SHZ0:                      case OpCode.SHZ1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              var count = 0;                              if (_zp2.IsTwilight)                                  count = _zp2.Current.Length;                              else if (_contours.Length > 0)                                  count = _contours[_contours.Length - 1] + 1;                                for (int i = 0; i < count; i++)                              {                                  // don't move the reference point                                  if (zone.Current != _zp2.Current || point != i)                                      _zp2.Current[i].P += displacement;                              }                          }                          break;                      case OpCode.MIAP0:                      case OpCode.MIAP1:                          {                              var distance = ReadCvt();                              var pointIndex = _stack.Pop();                                // this instruction is used in the CVT to set up twilight points with original values                              if (_zp0.IsTwilight)                              {                                  var original = _state.Freedom * distance;                                  _zp0.Original[pointIndex].P = original;                                  _zp0.Current[pointIndex].P = original;                              }                                // current position of the point along the projection vector                              var point = _zp0.GetCurrent(pointIndex);                              var currentPos = Project(point);                              if (opcode == OpCode.MIAP1)                              {                                  // only use the CVT if we are above the cut-in point                                  if (Math.Abs(distance - currentPos) > _state.ControlValueCutIn)                                      distance = currentPos;                                  distance = Round(distance);                              }                                MovePoint(_zp0' pointIndex' distance - currentPos);                              _state.Rp0 = pointIndex;                              _state.Rp1 = pointIndex;                          }                          break;                      case OpCode.MDAP0:                      case OpCode.MDAP1:                          {                              var pointIndex = _stack.Pop();                              var point = _zp0.GetCurrent(pointIndex);                              var distance = 0.0f;                              if (opcode == OpCode.MDAP1)                              {                                  distance = Project(point);                                  distance = Round(distance) - distance;                              }                                MovePoint(_zp0' pointIndex' distance);                              _state.Rp0 = pointIndex;                              _state.Rp1 = pointIndex;                          }                          break;                      case OpCode.MSIRP0:                      case OpCode.MSIRP1:                          {                              var targetDistance = _stack.PopFloat();                              var pointIndex = _stack.Pop();                                // if we're operating on the twilight zone' initialize the points                              if (_zp1.IsTwilight)                              {                                  _zp1.Original[pointIndex].P = _zp0.Original[_state.Rp0].P + targetDistance * _state.Freedom / _fdotp;                                  _zp1.Current[pointIndex].P = _zp1.Original[pointIndex].P;                              }                                var currentDistance = Project(_zp1.GetCurrent(pointIndex) - _zp0.GetCurrent(_state.Rp0));                              MovePoint(_zp1' pointIndex' targetDistance - currentDistance);                                _state.Rp1 = _state.Rp0;                              _state.Rp2 = pointIndex;                              if (opcode == OpCode.MSIRP1)                                  _state.Rp0 = pointIndex;                          }                          break;                      case OpCode.IP:                          {                              var originalBase = _zp0.GetOriginal(_state.Rp1);                              var currentBase = _zp0.GetCurrent(_state.Rp1);                              var originalRange = DualProject(_zp1.GetOriginal(_state.Rp2) - originalBase);                              var currentRange = Project(_zp1.GetCurrent(_state.Rp2) - currentBase);                                for (int i = 0; i < _state.Loop; i++)                              {                                  var pointIndex = _stack.Pop();                                  var point = _zp2.GetCurrent(pointIndex);                                  var currentDistance = Project(point - currentBase);                                  var originalDistance = DualProject(_zp2.GetOriginal(pointIndex) - originalBase);                                    var newDistance = 0.0f;                                  if (originalDistance != 0.0f)                                  {                                      // a range of 0.0f is invalid according to the spec (would result in a div by zero)                                      if (originalRange == 0.0f)                                          newDistance = originalDistance;                                      else                                          newDistance = originalDistance * currentRange / originalRange;                                  }                                    MovePoint(_zp2' pointIndex' newDistance - currentDistance);                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.ALIGNRP:                          {                              for (int i = 0; i < _state.Loop; i++)                              {                                  var pointIndex = _stack.Pop();                                  var p1 = _zp1.GetCurrent(pointIndex);                                  var p2 = _zp0.GetCurrent(_state.Rp0);                                  MovePoint(_zp1' pointIndex' -Project(p1 - p2));                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.ALIGNPTS:                          {                              var p1 = _stack.Pop();                              var p2 = _stack.Pop();                              var distance = Project(_zp0.GetCurrent(p2) - _zp1.GetCurrent(p1)) / 2;                              MovePoint(_zp1' p1' distance);                              MovePoint(_zp0' p2' -distance);                          }                          break;                      case OpCode.UTP: _zp0.TouchState[_stack.Pop()] &= ~GetTouchState(); break;                      case OpCode.IUP0:                      case OpCode.IUP1:                          // bail if no contours (empty outline)                          if (_contours.Length == 0)                          {                              break;                          }                            //{                            //    //WinterDev's new managed version                          //    GlyphPointF[] currentPnts = points.Current;                          //    GlyphPointF[] originalPnts = points.Original;                            //    int cnt_count = contours.Length;                          //    int point = 0;                          //    // opcode controls whether we care about X or Y direction                          //    // do some pointer trickery so we can operate on the                          //    // points in a direction-agnostic manner                          //    TouchState touchMask;                            //    if (opcode == OpCode.IUP0)                          //    {                          //        //y -axis                          //        touchMask = TouchState.Y;                            //        //                          //        for (int i = 0; i < cnt_count; ++i)                          //        {                          //            int endPoint = contours[i];                          //            int firstPoint = point;                          //            int firstTouched = -1;                          //            int lastTouched = -1;                            //            for (; point <= endPoint; point++)                          //            {                          //                // check whether this point has been touched                          //                if ((points.TouchState[point] & touchMask) != 0)                          //                {                          //                    // if this is the first touched point in the contour' note it and continue                          //                    if (firstTouched < 0)                          //                    {                          //                        firstTouched = point;                          //                        lastTouched = point;                          //                        continue;                          //                    }                            //                    // otherwise' interpolate all untouched points                          //                    // between this point and our last touched point                          //                    InterpolatePointsYAxis(currentPnts' originalPnts' lastTouched + 1' point - 1' lastTouched' point);                          //                    lastTouched = point;                          //                }                          //            }                            //            // check if we had any touched points at all in this contour                          //            if (firstTouched >= 0)                          //            {                          //                // there are two cases left to handle:                          //                // 1. there was only one touched point in the whole contour' in                          //                //    which case we want to shift everything relative to that one                          //                // 2. several touched points' in which case handle the gap from the                          //                //    beginning to the first touched point and the gap from the last                          //                //    touched point to the end of the contour                          //                if (lastTouched == firstTouched)                          //                {                          //                    float delta = currentPnts[lastTouched].Y - originalPnts[lastTouched].Y;                          //                    if (delta != 0.0f)                          //                    {                          //                        for (int n = firstPoint; n < lastTouched; n++)                          //                        {                          //                            currentPnts[n].OffsetY(delta);                          //                        }                          //                        for (int n = lastTouched + 1; n <= endPoint; n++)                          //                        {                          //                            currentPnts[n].OffsetY(delta);                          //                        }                            //                    }                          //                }                          //                else                          //                {                          //                    InterpolatePointsYAxis(currentPnts' originalPnts' lastTouched + 1' endPoint' lastTouched' firstTouched);                          //                    if (firstTouched > 0)                          //                    {                          //                        InterpolatePointsYAxis(currentPnts' originalPnts' firstPoint' firstTouched - 1' lastTouched' firstTouched);                          //                    }                          //                }                          //            }                            //        }                          //    }                          //    else                          //    {                          //        //x-axis                          //        touchMask = TouchState.X;                          //        //                          //        for (int i = 0; i < cnt_count; ++i)                          //        {                          //            int endPoint = contours[i];                          //            int firstPoint = point;                          //            int firstTouched = -1;                          //            int lastTouched = -1;                            //            for (; point <= endPoint; point++)                          //            {                          //                // check whether this point has been touched                          //                if ((points.TouchState[point] & touchMask) != 0)                          //                {                          //                    // if this is the first touched point in the contour' note it and continue                          //                    if (firstTouched < 0)                          //                    {                          //                        firstTouched = point;                          //                        lastTouched = point;                          //                        continue;                          //                    }                            //                    // otherwise' interpolate all untouched points                          //                    // between this point and our last touched point                          //                    InterpolatePointsXAxis(currentPnts' originalPnts' lastTouched + 1' point - 1' lastTouched' point);                          //                    lastTouched = point;                          //                }                          //            }                            //            // check if we had any touched points at all in this contour                          //            if (firstTouched >= 0)                          //            {                          //                // there are two cases left to handle:                          //                // 1. there was only one touched point in the whole contour' in                          //                //    which case we want to shift everything relative to that one                          //                // 2. several touched points' in which case handle the gap from the                          //                //    beginning to the first touched point and the gap from the last                          //                //    touched point to the end of the contour                          //                if (lastTouched == firstTouched)                          //                {                          //                    float delta = currentPnts[lastTouched].X - originalPnts[lastTouched].X;                          //                    if (delta != 0.0f)                          //                    {                          //                        for (int n = firstPoint; n < lastTouched; ++n)                          //                        {                          //                            currentPnts[n].OffsetX(delta);                          //                        }                          //                        for (int n = lastTouched + 1; n <= endPoint; ++n)                          //                        {                          //                            currentPnts[n].OffsetX(delta);                          //                        }                          //                    }                          //                }                          //                else                          //                {                          //                    InterpolatePointsXAxis(currentPnts' originalPnts' lastTouched + 1' endPoint' lastTouched' firstTouched);                          //                    if (firstTouched > 0)                          //                    {                          //                        InterpolatePointsXAxis(currentPnts' originalPnts' firstPoint' firstTouched - 1' lastTouched' firstTouched);                          //                    }                          //                }                          //            }                          //        }                          //    }                          //}                          //-----------------------------------------                          unsafe                          {                                //unsafe version                               //TODO: provide manage version                               fixed (GlyphPointF* currentPtr = _points.Current)                              fixed (GlyphPointF* originalPtr = _points.Original)                              {                                  // opcode controls whether we care about X or Y direction                                  // do some pointer trickery so we can operate on the                                  // points in a direction-agnostic manner                                  TouchState touchMask;                                  byte* current;                                  byte* original;                                  if (opcode == OpCode.IUP0)                                  {                                      touchMask = TouchState.Y;                                      current = (byte*)&currentPtr->P.Y;                                      original = (byte*)&originalPtr->P.Y;                                  }                                  else                                  {                                      touchMask = TouchState.X;                                      current = (byte*)&currentPtr->P.X;                                      original = (byte*)&originalPtr->P.X;                                  }                                    var point = 0;                                  for (int i = 0; i < _contours.Length; i++)                                  {                                      var endPoint = _contours[i];                                      var firstPoint = point;                                      var firstTouched = -1;                                      var lastTouched = -1;                                        for (; point <= endPoint; point++)                                      {                                          // check whether this point has been touched                                          if ((_points.TouchState[point] & touchMask) != 0)                                          {                                              // if this is the first touched point in the contour' note it and continue                                              if (firstTouched < 0)                                              {                                                  firstTouched = point;                                                  lastTouched = point;                                                  continue;                                              }                                                // otherwise' interpolate all untouched points                                              // between this point and our last touched point                                              InterpolatePoints(current' original' lastTouched + 1' point - 1' lastTouched' point);                                              lastTouched = point;                                          }                                      }                                        // check if we had any touched points at all in this contour                                      if (firstTouched >= 0)                                      {                                          // there are two cases left to handle:                                          // 1. there was only one touched point in the whole contour' in                                          //    which case we want to shift everything relative to that one                                          // 2. several touched points' in which case handle the gap from the                                          //    beginning to the first touched point and the gap from the last                                          //    touched point to the end of the contour                                          if (lastTouched == firstTouched)                                          {                                              var delta = *GetPoint(current' lastTouched) - *GetPoint(original' lastTouched);                                              if (delta != 0.0f)                                              {                                                  for (int j = firstPoint; j < lastTouched; j++)                                                      *GetPoint(current' j) += delta;                                                  for (int j = lastTouched + 1; j <= endPoint; j++)                                                      *GetPoint(current' j) += delta;                                              }                                          }                                          else                                          {                                              InterpolatePoints(current' original' lastTouched + 1' endPoint' lastTouched' firstTouched);                                              if (firstTouched > 0)                                                  InterpolatePoints(current' original' firstPoint' firstTouched - 1' lastTouched' firstTouched);                                          }                                      }                                  }                              }                          }                          break;                      case OpCode.ISECT:                          {                              // move point P to the intersection of lines A and B                              var b1 = _zp0.GetCurrent(_stack.Pop());                              var b0 = _zp0.GetCurrent(_stack.Pop());                              var a1 = _zp1.GetCurrent(_stack.Pop());                              var a0 = _zp1.GetCurrent(_stack.Pop());                              var index = _stack.Pop();                                // calculate intersection using determinants: https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line                              var da = a0 - a1;                              var db = b0 - b1;                              var den = (da.X * db.Y) - (da.Y * db.X);                              if (Math.Abs(den) <= Epsilon)                              {                                  // parallel lines; spec says to put the ppoint "into the middle of the two lines"                                  _zp2.Current[index].P = (a0 + a1 + b0 + b1) / 4;                              }                              else                              {                                  var t = (a0.X * a1.Y) - (a0.Y * a1.X);                                  var u = (b0.X * b1.Y) - (b0.Y * b1.X);                                  var p = new Vector2(                                      (t * db.X) - (da.X * u)'                                      (t * db.Y) - (da.Y * u)                                  );                                  _zp2.Current[index].P = p / den;                              }                              _zp2.TouchState[index] = TouchState.Both;                          }                          break;                        // ==== STACK MANAGEMENT ====                      case OpCode.DUP: _stack.Duplicate(); break;                      case OpCode.POP: _stack.Pop(); break;                      case OpCode.CLEAR: _stack.Clear(); break;                      case OpCode.SWAP: _stack.Swap(); break;                      case OpCode.DEPTH: _stack.Depth(); break;                      case OpCode.CINDEX: _stack.Copy(); break;                      case OpCode.MINDEX: _stack.Move(); break;                      case OpCode.ROLL: _stack.Roll(); break;                        // ==== FLOW CONTROL ====                      case OpCode.IF:                          {                              // value is false; jump to the next else block or endif marker                              // otherwise' we don't have to do anything; we'll keep executing this block                              if (!_stack.PopBool())                              {                                  int indent = 1;                                  while (indent > 0)                                  {                                      opcode = SkipNext(ref stream);                                      switch (opcode)                                      {                                          case OpCode.IF: indent++; break;                                          case OpCode.EIF: indent--; break;                                          case OpCode.ELSE:                                              if (indent == 1)                                                  indent = 0;                                              break;                                      }                                  }                              }                          }                          break;                      case OpCode.ELSE:                          {                              // assume we hit the true statement of some previous if block                              // if we had hit false' we would have jumped over this                              int indent = 1;                              while (indent > 0)                              {                                  opcode = SkipNext(ref stream);                                  switch (opcode)                                  {                                      case OpCode.IF: indent++; break;                                      case OpCode.EIF: indent--; break;                                  }                              }                          }                          break;                      case OpCode.EIF: /* nothing to do */ break;                      case OpCode.JROT:                      case OpCode.JROF:                          {                              if (_stack.PopBool() == (opcode == OpCode.JROT))                                  stream.Jump(_stack.Pop() - 1);                              else                                  _stack.Pop();    // ignore the offset                          }                          break;                      case OpCode.JMPR: stream.Jump(_stack.Pop() - 1); break;                        // ==== LOGICAL OPS ====                      case OpCode.LT:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a < b);                          }                          break;                      case OpCode.LTEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a <= b);                          }                          break;                      case OpCode.GT:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a > b);                          }                          break;                      case OpCode.GTEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a >= b);                          }                          break;                      case OpCode.EQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a == b);                          }                          break;                      case OpCode.NEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a != b);                          }                          break;                      case OpCode.AND:                          {                              var b = _stack.PopBool();                              var a = _stack.PopBool();                              _stack.Push(a && b);                          }                          break;                      case OpCode.OR:                          {                              var b = _stack.PopBool();                              var a = _stack.PopBool();                              _stack.Push(a || b);                          }                          break;                      case OpCode.NOT: _stack.Push(!_stack.PopBool()); break;                      case OpCode.ODD:                          {                              var value = (int)Round(_stack.PopFloat());                              _stack.Push(value % 2 != 0);                          }                          break;                      case OpCode.EVEN:                          {                              var value = (int)Round(_stack.PopFloat());                              _stack.Push(value % 2 == 0);                          }                          break;                        // ==== ARITHMETIC ====                      case OpCode.ADD:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a + b);                          }                          break;                      case OpCode.SUB:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a - b);                          }                          break;                      case OpCode.DIV:                          {                              var b = _stack.Pop();                              if (b == 0)                                  throw new InvalidFontException("Division by zero.");                                var a = _stack.Pop();                              var result = ((long)a << 6) / b;                              _stack.Push((int)result);                          }                          break;                      case OpCode.MUL:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              var result = ((long)a * b) >> 6;                              _stack.Push((int)result);                          }                          break;                      case OpCode.ABS: _stack.Push(Math.Abs(_stack.Pop())); break;                      case OpCode.NEG: _stack.Push(-_stack.Pop()); break;                      case OpCode.FLOOR: _stack.Push(_stack.Pop() & ~63); break;                      case OpCode.CEILING: _stack.Push((_stack.Pop() + 63) & ~63); break;                      case OpCode.MAX: _stack.Push(Math.Max(_stack.Pop()' _stack.Pop())); break;                      case OpCode.MIN: _stack.Push(Math.Min(_stack.Pop()' _stack.Pop())); break;                        // ==== FUNCTIONS ====                      case OpCode.FDEF:                          {                              if (!allowFunctionDefs || inFunction)                                  throw new InvalidFontException("Can't define functions here.");                                _functions[_stack.Pop()] = stream;                              while (SkipNext(ref stream) != OpCode.ENDF) ;                          }                          break;                      case OpCode.IDEF:                          {                              if (!allowFunctionDefs || inFunction)                                  throw new InvalidFontException("Can't define functions here.");                                _instructionDefs[_stack.Pop()] = stream;                              while (SkipNext(ref stream) != OpCode.ENDF) ;                          }                          break;                      case OpCode.ENDF:                          {                              if (!inFunction)                                  throw new InvalidFontException("Found invalid ENDF marker outside of a function definition.");                              return;                          }                      case OpCode.CALL:                      case OpCode.LOOPCALL:                          {                              _callStackSize++;                              if (_callStackSize > MaxCallStack)                                  throw new InvalidFontException("Stack overflow; infinite recursion?");                                var function = _functions[_stack.Pop()];                              var count = opcode == OpCode.LOOPCALL ? _stack.Pop() : 1;                              for (int i = 0; i < count; i++)                                  Execute(function' true' false);                              _callStackSize--;                          }                          break;                        // ==== ROUNDING ====                      // we don't have "engine compensation" so the variants are unnecessary                      case OpCode.ROUND0:                      case OpCode.ROUND1:                      case OpCode.ROUND2:                      case OpCode.ROUND3: _stack.Push(Round(_stack.PopFloat())); break;                      case OpCode.NROUND0:                      case OpCode.NROUND1:                      case OpCode.NROUND2:                      case OpCode.NROUND3: break;                        // ==== DELTA EXCEPTIONS ====                      case OpCode.DELTAC1:                      case OpCode.DELTAC2:                      case OpCode.DELTAC3:                          {                              var last = _stack.Pop();                              for (int i = 1; i <= last; i++)                              {                                  var cvtIndex = _stack.Pop();                                  var arg = _stack.Pop();                                    // upper 4 bits of the 8-bit arg is the relative ppem                                  // the opcode specifies the base to add to the ppem                                  var triggerPpem = (arg >> 4) & 0xF;                                  triggerPpem += (opcode - OpCode.DELTAC1) * 16;                                  triggerPpem += _state.DeltaBase;                                    // if the current ppem matches the trigger' apply the exception                                  if (_ppem == triggerPpem)                                  {                                      // the lower 4 bits of the arg is the amount to shift                                      // it's encoded such that 0 isn't an allowable value (who wants to shift by 0 anyway?)                                      var amount = (arg & 0xF) - 8;                                      if (amount >= 0)                                          amount++;                                      amount *= 1 << (6 - _state.DeltaShift);                                        // update the CVT                                      CheckIndex(cvtIndex' _controlValueTable.Length);                                      _controlValueTable[cvtIndex] += F26Dot6ToFloat(amount);                                  }                              }                          }                          break;                      case OpCode.DELTAP1:                      case OpCode.DELTAP2:                      case OpCode.DELTAP3:                          {                              var last = _stack.Pop();                              for (int i = 1; i <= last; i++)                              {                                  var pointIndex = _stack.Pop();                                  var arg = _stack.Pop();                                    // upper 4 bits of the 8-bit arg is the relative ppem                                  // the opcode specifies the base to add to the ppem                                  var triggerPpem = (arg >> 4) & 0xF;                                  triggerPpem += _state.DeltaBase;                                  if (opcode != OpCode.DELTAP1)                                      triggerPpem += (opcode - OpCode.DELTAP2 + 1) * 16;                                    // if the current ppem matches the trigger' apply the exception                                  if (_ppem == triggerPpem)                                  {                                      // the lower 4 bits of the arg is the amount to shift                                      // it's encoded such that 0 isn't an allowable value (who wants to shift by 0 anyway?)                                      var amount = (arg & 0xF) - 8;                                      if (amount >= 0)                                          amount++;                                      amount *= 1 << (6 - _state.DeltaShift);                                        MovePoint(_zp0' pointIndex' F26Dot6ToFloat(amount));                                  }                              }                          }                          break;                        // ==== MISCELLANEOUS ====                      case OpCode.DEBUG: _stack.Pop(); break;                      case OpCode.GETINFO:                          {                              var selector = _stack.Pop();                              var result = 0;                              if ((selector & 0x1) != 0)                              {                                  // pretend we are MS Rasterizer v35                                  result = 35;                              }                                // TODO: rotation and stretching                              //if ((selector & 0x2) != 0)                              //if ((selector & 0x4) != 0)                                // we're always rendering in grayscale                              if ((selector & 0x20) != 0)                                  result |= 1 << 12;                                // TODO: ClearType flags                                _stack.Push(result);                          }                          break;                        default:                          if (opcode >= OpCode.MIRP)                              MoveIndirectRelative(opcode - OpCode.MIRP);                          else if (opcode >= OpCode.MDRP)                              MoveDirectRelative(opcode - OpCode.MDRP);                          else                          {                              // check if this is a runtime-defined opcode                              var index = (int)opcode;                              if (index > _instructionDefs.Length || !_instructionDefs[index].IsValid)                                  throw new InvalidFontException("Unknown opcode in font program.");                                _callStackSize++;                              if (_callStackSize > MaxCallStack)                                  throw new InvalidFontException("Stack overflow; infinite recursion?");                                Execute(_instructionDefs[index]' true' false);                              _callStackSize--;                          }                          break;                  }
Magic Number,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,Execute,The following statement contains a magic number: switch (opcode)                  {                      // ==== PUSH INSTRUCTIONS ====                      case OpCode.NPUSHB:                      case OpCode.PUSHB1:                      case OpCode.PUSHB2:                      case OpCode.PUSHB3:                      case OpCode.PUSHB4:                      case OpCode.PUSHB5:                      case OpCode.PUSHB6:                      case OpCode.PUSHB7:                      case OpCode.PUSHB8:                          {                              var count = opcode == OpCode.NPUSHB ? stream.NextByte() : opcode - OpCode.PUSHB1 + 1;                              for (int i = count - 1; i >= 0; --i)                                  _stack.Push(stream.NextByte());                          }                          break;                      case OpCode.NPUSHW:                      case OpCode.PUSHW1:                      case OpCode.PUSHW2:                      case OpCode.PUSHW3:                      case OpCode.PUSHW4:                      case OpCode.PUSHW5:                      case OpCode.PUSHW6:                      case OpCode.PUSHW7:                      case OpCode.PUSHW8:                          {                              var count = opcode == OpCode.NPUSHW ? stream.NextByte() : opcode - OpCode.PUSHW1 + 1;                              for (int i = count - 1; i >= 0; --i)                                  _stack.Push(stream.NextWord());                          }                          break;                        // ==== STORAGE MANAGEMENT ====                      case OpCode.RS:                          {                              var loc = CheckIndex(_stack.Pop()' _storage.Length);                              _stack.Push(_storage[loc]);                          }                          break;                      case OpCode.WS:                          {                              var value = _stack.Pop();                              var loc = CheckIndex(_stack.Pop()' _storage.Length);                              _storage[loc] = value;                          }                          break;                        // ==== CONTROL VALUE TABLE ====                      case OpCode.WCVTP:                          {                              var value = _stack.PopFloat();                              var loc = CheckIndex(_stack.Pop()' _controlValueTable.Length);                              _controlValueTable[loc] = value;                          }                          break;                      case OpCode.WCVTF:                          {                              var value = _stack.Pop();                              var loc = CheckIndex(_stack.Pop()' _controlValueTable.Length);                              _controlValueTable[loc] = value * _scale;                          }                          break;                      case OpCode.RCVT: _stack.Push(ReadCvt()); break;                        // ==== STATE VECTORS ====                      case OpCode.SVTCA0:                      case OpCode.SVTCA1:                          {                              var axis = opcode - OpCode.SVTCA0;                              SetFreedomVectorToAxis(axis);                              SetProjectionVectorToAxis(axis);                          }                          break;                      case OpCode.SFVTPV: _state.Freedom = _state.Projection; OnVectorsUpdated(); break;                      case OpCode.SPVTCA0:                      case OpCode.SPVTCA1: SetProjectionVectorToAxis(opcode - OpCode.SPVTCA0); break;                      case OpCode.SFVTCA0:                      case OpCode.SFVTCA1: SetFreedomVectorToAxis(opcode - OpCode.SFVTCA0); break;                      case OpCode.SPVTL0:                      case OpCode.SPVTL1:                      case OpCode.SFVTL0:                      case OpCode.SFVTL1: SetVectorToLine(opcode - OpCode.SPVTL0' false); break;                      case OpCode.SDPVTL0:                      case OpCode.SDPVTL1: SetVectorToLine(opcode - OpCode.SDPVTL0' true); break;                      case OpCode.SPVFS:                      case OpCode.SFVFS:                          {                              var y = _stack.Pop();                              var x = _stack.Pop();                              var vec = Vector2.Normalize(new Vector2(F2Dot14ToFloat(x)' F2Dot14ToFloat(y)));                              if (opcode == OpCode.SFVFS)                                  _state.Freedom = vec;                              else                              {                                  _state.Projection = vec;                                  _state.DualProjection = vec;                              }                              OnVectorsUpdated();                          }                          break;                      case OpCode.GPV:                      case OpCode.GFV:                          {                              var vec = opcode == OpCode.GPV ? _state.Projection : _state.Freedom;                              _stack.Push(FloatToF2Dot14(vec.X));                              _stack.Push(FloatToF2Dot14(vec.Y));                          }                          break;                        // ==== GRAPHICS STATE ====                      case OpCode.SRP0: _state.Rp0 = _stack.Pop(); break;                      case OpCode.SRP1: _state.Rp1 = _stack.Pop(); break;                      case OpCode.SRP2: _state.Rp2 = _stack.Pop(); break;                      case OpCode.SZP0: _zp0 = GetZoneFromStack(); break;                      case OpCode.SZP1: _zp1 = GetZoneFromStack(); break;                      case OpCode.SZP2: _zp2 = GetZoneFromStack(); break;                      case OpCode.SZPS: _zp0 = _zp1 = _zp2 = GetZoneFromStack(); break;                      case OpCode.RTHG: _state.RoundState = RoundMode.ToHalfGrid; break;                      case OpCode.RTG: _state.RoundState = RoundMode.ToGrid; break;                      case OpCode.RTDG: _state.RoundState = RoundMode.ToDoubleGrid; break;                      case OpCode.RDTG: _state.RoundState = RoundMode.DownToGrid; break;                      case OpCode.RUTG: _state.RoundState = RoundMode.UpToGrid; break;                      case OpCode.ROFF: _state.RoundState = RoundMode.Off; break;                      case OpCode.SROUND: _state.RoundState = RoundMode.Super; SetSuperRound(1.0f); break;                      case OpCode.S45ROUND: _state.RoundState = RoundMode.Super45; SetSuperRound(Sqrt2Over2); break;                      case OpCode.INSTCTRL:                          {                              var selector = _stack.Pop();                              if (selector >= 1 && selector <= 2)                              {                                  // value is false if zero' otherwise shift the right bit into the flags                                  var bit = 1 << (selector - 1);                                  if (_stack.Pop() == 0)                                      _state.InstructionControl = (InstructionControlFlags)((int)_state.InstructionControl & ~bit);                                  else                                      _state.InstructionControl = (InstructionControlFlags)((int)_state.InstructionControl | bit);                              }                          }                          break;                      case OpCode.SCANCTRL: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SCANTYPE: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SANGW: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SLOOP: _state.Loop = _stack.Pop(); break;                      case OpCode.SMD: _state.MinDistance = _stack.PopFloat(); break;                      case OpCode.SCVTCI: _state.ControlValueCutIn = _stack.PopFloat(); break;                      case OpCode.SSWCI: _state.SingleWidthCutIn = _stack.PopFloat(); break;                      case OpCode.SSW: _state.SingleWidthValue = _stack.Pop() * _scale; break;                      case OpCode.FLIPON: _state.AutoFlip = true; break;                      case OpCode.FLIPOFF: _state.AutoFlip = false; break;                      case OpCode.SDB: _state.DeltaBase = _stack.Pop(); break;                      case OpCode.SDS: _state.DeltaShift = _stack.Pop(); break;                        // ==== POINT MEASUREMENT ====                      case OpCode.GC0: _stack.Push(Project(_zp2.GetCurrent(_stack.Pop()))); break;                      case OpCode.GC1: _stack.Push(DualProject(_zp2.GetOriginal(_stack.Pop()))); break;                      case OpCode.SCFS:                          {                              var value = _stack.PopFloat();                              var index = _stack.Pop();                              var point = _zp2.GetCurrent(index);                              MovePoint(_zp2' index' value - Project(point));                                // moving twilight points moves their "original" value also                              if (_zp2.IsTwilight)                                  _zp2.Original[index].P = _zp2.Current[index].P;                          }                          break;                      case OpCode.MD0:                          {                              var p1 = _zp1.GetOriginal(_stack.Pop());                              var p2 = _zp0.GetOriginal(_stack.Pop());                              _stack.Push(DualProject(p2 - p1));                          }                          break;                      case OpCode.MD1:                          {                              var p1 = _zp1.GetCurrent(_stack.Pop());                              var p2 = _zp0.GetCurrent(_stack.Pop());                              _stack.Push(Project(p2 - p1));                          }                          break;                      case OpCode.MPS: // MPS should return point size' but we assume DPI so it's the same as pixel size                      case OpCode.MPPEM: _stack.Push(_ppem); break;                      case OpCode.AA: /* deprecated instruction */ _stack.Pop(); break;                        // ==== POINT MODIFICATION ====                      case OpCode.FLIPPT:                          {                              for (int i = 0; i < _state.Loop; i++)                              {                                  var index = _stack.Pop();                                  //review here again!                                  _points.Current[index].onCurve = !_points.Current[index].onCurve;                                  //if (points.Current[index].onCurve)                                  //    points.Current[index].onCurve = false;                                  //else                                  //    points.Current[index].onCurve = true;                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.FLIPRGON:                          {                              var end = _stack.Pop();                              for (int i = _stack.Pop(); i <= end; i++)                                  //points.Current[i].Type = PointType.OnCurve;                                  _points.Current[i].onCurve = true;                          }                          break;                      case OpCode.FLIPRGOFF:                          {                              var end = _stack.Pop();                              for (int i = _stack.Pop(); i <= end; i++)                                  //points.Current[i].Type = PointType.Quadratic;                                  _points.Current[i].onCurve = false;                          }                          break;                      case OpCode.SHP0:                      case OpCode.SHP1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              ShiftPoints(displacement);                          }                          break;                      case OpCode.SHPIX: ShiftPoints(_stack.PopFloat() * _state.Freedom); break;                      case OpCode.SHC0:                      case OpCode.SHC1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              var touch = GetTouchState();                              var contour = _stack.Pop();                              var start = contour == 0 ? 0 : _contours[contour - 1] + 1;                              var count = _zp2.IsTwilight ? _zp2.Current.Length : _contours[contour] + 1;                                for (int i = start; i < count; i++)                              {                                  // don't move the reference point                                  if (zone.Current != _zp2.Current || point != i)                                  {                                      _zp2.Current[i].P += displacement;                                      _zp2.TouchState[i] |= touch;                                  }                              }                          }                          break;                      case OpCode.SHZ0:                      case OpCode.SHZ1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              var count = 0;                              if (_zp2.IsTwilight)                                  count = _zp2.Current.Length;                              else if (_contours.Length > 0)                                  count = _contours[_contours.Length - 1] + 1;                                for (int i = 0; i < count; i++)                              {                                  // don't move the reference point                                  if (zone.Current != _zp2.Current || point != i)                                      _zp2.Current[i].P += displacement;                              }                          }                          break;                      case OpCode.MIAP0:                      case OpCode.MIAP1:                          {                              var distance = ReadCvt();                              var pointIndex = _stack.Pop();                                // this instruction is used in the CVT to set up twilight points with original values                              if (_zp0.IsTwilight)                              {                                  var original = _state.Freedom * distance;                                  _zp0.Original[pointIndex].P = original;                                  _zp0.Current[pointIndex].P = original;                              }                                // current position of the point along the projection vector                              var point = _zp0.GetCurrent(pointIndex);                              var currentPos = Project(point);                              if (opcode == OpCode.MIAP1)                              {                                  // only use the CVT if we are above the cut-in point                                  if (Math.Abs(distance - currentPos) > _state.ControlValueCutIn)                                      distance = currentPos;                                  distance = Round(distance);                              }                                MovePoint(_zp0' pointIndex' distance - currentPos);                              _state.Rp0 = pointIndex;                              _state.Rp1 = pointIndex;                          }                          break;                      case OpCode.MDAP0:                      case OpCode.MDAP1:                          {                              var pointIndex = _stack.Pop();                              var point = _zp0.GetCurrent(pointIndex);                              var distance = 0.0f;                              if (opcode == OpCode.MDAP1)                              {                                  distance = Project(point);                                  distance = Round(distance) - distance;                              }                                MovePoint(_zp0' pointIndex' distance);                              _state.Rp0 = pointIndex;                              _state.Rp1 = pointIndex;                          }                          break;                      case OpCode.MSIRP0:                      case OpCode.MSIRP1:                          {                              var targetDistance = _stack.PopFloat();                              var pointIndex = _stack.Pop();                                // if we're operating on the twilight zone' initialize the points                              if (_zp1.IsTwilight)                              {                                  _zp1.Original[pointIndex].P = _zp0.Original[_state.Rp0].P + targetDistance * _state.Freedom / _fdotp;                                  _zp1.Current[pointIndex].P = _zp1.Original[pointIndex].P;                              }                                var currentDistance = Project(_zp1.GetCurrent(pointIndex) - _zp0.GetCurrent(_state.Rp0));                              MovePoint(_zp1' pointIndex' targetDistance - currentDistance);                                _state.Rp1 = _state.Rp0;                              _state.Rp2 = pointIndex;                              if (opcode == OpCode.MSIRP1)                                  _state.Rp0 = pointIndex;                          }                          break;                      case OpCode.IP:                          {                              var originalBase = _zp0.GetOriginal(_state.Rp1);                              var currentBase = _zp0.GetCurrent(_state.Rp1);                              var originalRange = DualProject(_zp1.GetOriginal(_state.Rp2) - originalBase);                              var currentRange = Project(_zp1.GetCurrent(_state.Rp2) - currentBase);                                for (int i = 0; i < _state.Loop; i++)                              {                                  var pointIndex = _stack.Pop();                                  var point = _zp2.GetCurrent(pointIndex);                                  var currentDistance = Project(point - currentBase);                                  var originalDistance = DualProject(_zp2.GetOriginal(pointIndex) - originalBase);                                    var newDistance = 0.0f;                                  if (originalDistance != 0.0f)                                  {                                      // a range of 0.0f is invalid according to the spec (would result in a div by zero)                                      if (originalRange == 0.0f)                                          newDistance = originalDistance;                                      else                                          newDistance = originalDistance * currentRange / originalRange;                                  }                                    MovePoint(_zp2' pointIndex' newDistance - currentDistance);                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.ALIGNRP:                          {                              for (int i = 0; i < _state.Loop; i++)                              {                                  var pointIndex = _stack.Pop();                                  var p1 = _zp1.GetCurrent(pointIndex);                                  var p2 = _zp0.GetCurrent(_state.Rp0);                                  MovePoint(_zp1' pointIndex' -Project(p1 - p2));                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.ALIGNPTS:                          {                              var p1 = _stack.Pop();                              var p2 = _stack.Pop();                              var distance = Project(_zp0.GetCurrent(p2) - _zp1.GetCurrent(p1)) / 2;                              MovePoint(_zp1' p1' distance);                              MovePoint(_zp0' p2' -distance);                          }                          break;                      case OpCode.UTP: _zp0.TouchState[_stack.Pop()] &= ~GetTouchState(); break;                      case OpCode.IUP0:                      case OpCode.IUP1:                          // bail if no contours (empty outline)                          if (_contours.Length == 0)                          {                              break;                          }                            //{                            //    //WinterDev's new managed version                          //    GlyphPointF[] currentPnts = points.Current;                          //    GlyphPointF[] originalPnts = points.Original;                            //    int cnt_count = contours.Length;                          //    int point = 0;                          //    // opcode controls whether we care about X or Y direction                          //    // do some pointer trickery so we can operate on the                          //    // points in a direction-agnostic manner                          //    TouchState touchMask;                            //    if (opcode == OpCode.IUP0)                          //    {                          //        //y -axis                          //        touchMask = TouchState.Y;                            //        //                          //        for (int i = 0; i < cnt_count; ++i)                          //        {                          //            int endPoint = contours[i];                          //            int firstPoint = point;                          //            int firstTouched = -1;                          //            int lastTouched = -1;                            //            for (; point <= endPoint; point++)                          //            {                          //                // check whether this point has been touched                          //                if ((points.TouchState[point] & touchMask) != 0)                          //                {                          //                    // if this is the first touched point in the contour' note it and continue                          //                    if (firstTouched < 0)                          //                    {                          //                        firstTouched = point;                          //                        lastTouched = point;                          //                        continue;                          //                    }                            //                    // otherwise' interpolate all untouched points                          //                    // between this point and our last touched point                          //                    InterpolatePointsYAxis(currentPnts' originalPnts' lastTouched + 1' point - 1' lastTouched' point);                          //                    lastTouched = point;                          //                }                          //            }                            //            // check if we had any touched points at all in this contour                          //            if (firstTouched >= 0)                          //            {                          //                // there are two cases left to handle:                          //                // 1. there was only one touched point in the whole contour' in                          //                //    which case we want to shift everything relative to that one                          //                // 2. several touched points' in which case handle the gap from the                          //                //    beginning to the first touched point and the gap from the last                          //                //    touched point to the end of the contour                          //                if (lastTouched == firstTouched)                          //                {                          //                    float delta = currentPnts[lastTouched].Y - originalPnts[lastTouched].Y;                          //                    if (delta != 0.0f)                          //                    {                          //                        for (int n = firstPoint; n < lastTouched; n++)                          //                        {                          //                            currentPnts[n].OffsetY(delta);                          //                        }                          //                        for (int n = lastTouched + 1; n <= endPoint; n++)                          //                        {                          //                            currentPnts[n].OffsetY(delta);                          //                        }                            //                    }                          //                }                          //                else                          //                {                          //                    InterpolatePointsYAxis(currentPnts' originalPnts' lastTouched + 1' endPoint' lastTouched' firstTouched);                          //                    if (firstTouched > 0)                          //                    {                          //                        InterpolatePointsYAxis(currentPnts' originalPnts' firstPoint' firstTouched - 1' lastTouched' firstTouched);                          //                    }                          //                }                          //            }                            //        }                          //    }                          //    else                          //    {                          //        //x-axis                          //        touchMask = TouchState.X;                          //        //                          //        for (int i = 0; i < cnt_count; ++i)                          //        {                          //            int endPoint = contours[i];                          //            int firstPoint = point;                          //            int firstTouched = -1;                          //            int lastTouched = -1;                            //            for (; point <= endPoint; point++)                          //            {                          //                // check whether this point has been touched                          //                if ((points.TouchState[point] & touchMask) != 0)                          //                {                          //                    // if this is the first touched point in the contour' note it and continue                          //                    if (firstTouched < 0)                          //                    {                          //                        firstTouched = point;                          //                        lastTouched = point;                          //                        continue;                          //                    }                            //                    // otherwise' interpolate all untouched points                          //                    // between this point and our last touched point                          //                    InterpolatePointsXAxis(currentPnts' originalPnts' lastTouched + 1' point - 1' lastTouched' point);                          //                    lastTouched = point;                          //                }                          //            }                            //            // check if we had any touched points at all in this contour                          //            if (firstTouched >= 0)                          //            {                          //                // there are two cases left to handle:                          //                // 1. there was only one touched point in the whole contour' in                          //                //    which case we want to shift everything relative to that one                          //                // 2. several touched points' in which case handle the gap from the                          //                //    beginning to the first touched point and the gap from the last                          //                //    touched point to the end of the contour                          //                if (lastTouched == firstTouched)                          //                {                          //                    float delta = currentPnts[lastTouched].X - originalPnts[lastTouched].X;                          //                    if (delta != 0.0f)                          //                    {                          //                        for (int n = firstPoint; n < lastTouched; ++n)                          //                        {                          //                            currentPnts[n].OffsetX(delta);                          //                        }                          //                        for (int n = lastTouched + 1; n <= endPoint; ++n)                          //                        {                          //                            currentPnts[n].OffsetX(delta);                          //                        }                          //                    }                          //                }                          //                else                          //                {                          //                    InterpolatePointsXAxis(currentPnts' originalPnts' lastTouched + 1' endPoint' lastTouched' firstTouched);                          //                    if (firstTouched > 0)                          //                    {                          //                        InterpolatePointsXAxis(currentPnts' originalPnts' firstPoint' firstTouched - 1' lastTouched' firstTouched);                          //                    }                          //                }                          //            }                          //        }                          //    }                          //}                          //-----------------------------------------                          unsafe                          {                                //unsafe version                               //TODO: provide manage version                               fixed (GlyphPointF* currentPtr = _points.Current)                              fixed (GlyphPointF* originalPtr = _points.Original)                              {                                  // opcode controls whether we care about X or Y direction                                  // do some pointer trickery so we can operate on the                                  // points in a direction-agnostic manner                                  TouchState touchMask;                                  byte* current;                                  byte* original;                                  if (opcode == OpCode.IUP0)                                  {                                      touchMask = TouchState.Y;                                      current = (byte*)&currentPtr->P.Y;                                      original = (byte*)&originalPtr->P.Y;                                  }                                  else                                  {                                      touchMask = TouchState.X;                                      current = (byte*)&currentPtr->P.X;                                      original = (byte*)&originalPtr->P.X;                                  }                                    var point = 0;                                  for (int i = 0; i < _contours.Length; i++)                                  {                                      var endPoint = _contours[i];                                      var firstPoint = point;                                      var firstTouched = -1;                                      var lastTouched = -1;                                        for (; point <= endPoint; point++)                                      {                                          // check whether this point has been touched                                          if ((_points.TouchState[point] & touchMask) != 0)                                          {                                              // if this is the first touched point in the contour' note it and continue                                              if (firstTouched < 0)                                              {                                                  firstTouched = point;                                                  lastTouched = point;                                                  continue;                                              }                                                // otherwise' interpolate all untouched points                                              // between this point and our last touched point                                              InterpolatePoints(current' original' lastTouched + 1' point - 1' lastTouched' point);                                              lastTouched = point;                                          }                                      }                                        // check if we had any touched points at all in this contour                                      if (firstTouched >= 0)                                      {                                          // there are two cases left to handle:                                          // 1. there was only one touched point in the whole contour' in                                          //    which case we want to shift everything relative to that one                                          // 2. several touched points' in which case handle the gap from the                                          //    beginning to the first touched point and the gap from the last                                          //    touched point to the end of the contour                                          if (lastTouched == firstTouched)                                          {                                              var delta = *GetPoint(current' lastTouched) - *GetPoint(original' lastTouched);                                              if (delta != 0.0f)                                              {                                                  for (int j = firstPoint; j < lastTouched; j++)                                                      *GetPoint(current' j) += delta;                                                  for (int j = lastTouched + 1; j <= endPoint; j++)                                                      *GetPoint(current' j) += delta;                                              }                                          }                                          else                                          {                                              InterpolatePoints(current' original' lastTouched + 1' endPoint' lastTouched' firstTouched);                                              if (firstTouched > 0)                                                  InterpolatePoints(current' original' firstPoint' firstTouched - 1' lastTouched' firstTouched);                                          }                                      }                                  }                              }                          }                          break;                      case OpCode.ISECT:                          {                              // move point P to the intersection of lines A and B                              var b1 = _zp0.GetCurrent(_stack.Pop());                              var b0 = _zp0.GetCurrent(_stack.Pop());                              var a1 = _zp1.GetCurrent(_stack.Pop());                              var a0 = _zp1.GetCurrent(_stack.Pop());                              var index = _stack.Pop();                                // calculate intersection using determinants: https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line                              var da = a0 - a1;                              var db = b0 - b1;                              var den = (da.X * db.Y) - (da.Y * db.X);                              if (Math.Abs(den) <= Epsilon)                              {                                  // parallel lines; spec says to put the ppoint "into the middle of the two lines"                                  _zp2.Current[index].P = (a0 + a1 + b0 + b1) / 4;                              }                              else                              {                                  var t = (a0.X * a1.Y) - (a0.Y * a1.X);                                  var u = (b0.X * b1.Y) - (b0.Y * b1.X);                                  var p = new Vector2(                                      (t * db.X) - (da.X * u)'                                      (t * db.Y) - (da.Y * u)                                  );                                  _zp2.Current[index].P = p / den;                              }                              _zp2.TouchState[index] = TouchState.Both;                          }                          break;                        // ==== STACK MANAGEMENT ====                      case OpCode.DUP: _stack.Duplicate(); break;                      case OpCode.POP: _stack.Pop(); break;                      case OpCode.CLEAR: _stack.Clear(); break;                      case OpCode.SWAP: _stack.Swap(); break;                      case OpCode.DEPTH: _stack.Depth(); break;                      case OpCode.CINDEX: _stack.Copy(); break;                      case OpCode.MINDEX: _stack.Move(); break;                      case OpCode.ROLL: _stack.Roll(); break;                        // ==== FLOW CONTROL ====                      case OpCode.IF:                          {                              // value is false; jump to the next else block or endif marker                              // otherwise' we don't have to do anything; we'll keep executing this block                              if (!_stack.PopBool())                              {                                  int indent = 1;                                  while (indent > 0)                                  {                                      opcode = SkipNext(ref stream);                                      switch (opcode)                                      {                                          case OpCode.IF: indent++; break;                                          case OpCode.EIF: indent--; break;                                          case OpCode.ELSE:                                              if (indent == 1)                                                  indent = 0;                                              break;                                      }                                  }                              }                          }                          break;                      case OpCode.ELSE:                          {                              // assume we hit the true statement of some previous if block                              // if we had hit false' we would have jumped over this                              int indent = 1;                              while (indent > 0)                              {                                  opcode = SkipNext(ref stream);                                  switch (opcode)                                  {                                      case OpCode.IF: indent++; break;                                      case OpCode.EIF: indent--; break;                                  }                              }                          }                          break;                      case OpCode.EIF: /* nothing to do */ break;                      case OpCode.JROT:                      case OpCode.JROF:                          {                              if (_stack.PopBool() == (opcode == OpCode.JROT))                                  stream.Jump(_stack.Pop() - 1);                              else                                  _stack.Pop();    // ignore the offset                          }                          break;                      case OpCode.JMPR: stream.Jump(_stack.Pop() - 1); break;                        // ==== LOGICAL OPS ====                      case OpCode.LT:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a < b);                          }                          break;                      case OpCode.LTEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a <= b);                          }                          break;                      case OpCode.GT:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a > b);                          }                          break;                      case OpCode.GTEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a >= b);                          }                          break;                      case OpCode.EQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a == b);                          }                          break;                      case OpCode.NEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a != b);                          }                          break;                      case OpCode.AND:                          {                              var b = _stack.PopBool();                              var a = _stack.PopBool();                              _stack.Push(a && b);                          }                          break;                      case OpCode.OR:                          {                              var b = _stack.PopBool();                              var a = _stack.PopBool();                              _stack.Push(a || b);                          }                          break;                      case OpCode.NOT: _stack.Push(!_stack.PopBool()); break;                      case OpCode.ODD:                          {                              var value = (int)Round(_stack.PopFloat());                              _stack.Push(value % 2 != 0);                          }                          break;                      case OpCode.EVEN:                          {                              var value = (int)Round(_stack.PopFloat());                              _stack.Push(value % 2 == 0);                          }                          break;                        // ==== ARITHMETIC ====                      case OpCode.ADD:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a + b);                          }                          break;                      case OpCode.SUB:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a - b);                          }                          break;                      case OpCode.DIV:                          {                              var b = _stack.Pop();                              if (b == 0)                                  throw new InvalidFontException("Division by zero.");                                var a = _stack.Pop();                              var result = ((long)a << 6) / b;                              _stack.Push((int)result);                          }                          break;                      case OpCode.MUL:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              var result = ((long)a * b) >> 6;                              _stack.Push((int)result);                          }                          break;                      case OpCode.ABS: _stack.Push(Math.Abs(_stack.Pop())); break;                      case OpCode.NEG: _stack.Push(-_stack.Pop()); break;                      case OpCode.FLOOR: _stack.Push(_stack.Pop() & ~63); break;                      case OpCode.CEILING: _stack.Push((_stack.Pop() + 63) & ~63); break;                      case OpCode.MAX: _stack.Push(Math.Max(_stack.Pop()' _stack.Pop())); break;                      case OpCode.MIN: _stack.Push(Math.Min(_stack.Pop()' _stack.Pop())); break;                        // ==== FUNCTIONS ====                      case OpCode.FDEF:                          {                              if (!allowFunctionDefs || inFunction)                                  throw new InvalidFontException("Can't define functions here.");                                _functions[_stack.Pop()] = stream;                              while (SkipNext(ref stream) != OpCode.ENDF) ;                          }                          break;                      case OpCode.IDEF:                          {                              if (!allowFunctionDefs || inFunction)                                  throw new InvalidFontException("Can't define functions here.");                                _instructionDefs[_stack.Pop()] = stream;                              while (SkipNext(ref stream) != OpCode.ENDF) ;                          }                          break;                      case OpCode.ENDF:                          {                              if (!inFunction)                                  throw new InvalidFontException("Found invalid ENDF marker outside of a function definition.");                              return;                          }                      case OpCode.CALL:                      case OpCode.LOOPCALL:                          {                              _callStackSize++;                              if (_callStackSize > MaxCallStack)                                  throw new InvalidFontException("Stack overflow; infinite recursion?");                                var function = _functions[_stack.Pop()];                              var count = opcode == OpCode.LOOPCALL ? _stack.Pop() : 1;                              for (int i = 0; i < count; i++)                                  Execute(function' true' false);                              _callStackSize--;                          }                          break;                        // ==== ROUNDING ====                      // we don't have "engine compensation" so the variants are unnecessary                      case OpCode.ROUND0:                      case OpCode.ROUND1:                      case OpCode.ROUND2:                      case OpCode.ROUND3: _stack.Push(Round(_stack.PopFloat())); break;                      case OpCode.NROUND0:                      case OpCode.NROUND1:                      case OpCode.NROUND2:                      case OpCode.NROUND3: break;                        // ==== DELTA EXCEPTIONS ====                      case OpCode.DELTAC1:                      case OpCode.DELTAC2:                      case OpCode.DELTAC3:                          {                              var last = _stack.Pop();                              for (int i = 1; i <= last; i++)                              {                                  var cvtIndex = _stack.Pop();                                  var arg = _stack.Pop();                                    // upper 4 bits of the 8-bit arg is the relative ppem                                  // the opcode specifies the base to add to the ppem                                  var triggerPpem = (arg >> 4) & 0xF;                                  triggerPpem += (opcode - OpCode.DELTAC1) * 16;                                  triggerPpem += _state.DeltaBase;                                    // if the current ppem matches the trigger' apply the exception                                  if (_ppem == triggerPpem)                                  {                                      // the lower 4 bits of the arg is the amount to shift                                      // it's encoded such that 0 isn't an allowable value (who wants to shift by 0 anyway?)                                      var amount = (arg & 0xF) - 8;                                      if (amount >= 0)                                          amount++;                                      amount *= 1 << (6 - _state.DeltaShift);                                        // update the CVT                                      CheckIndex(cvtIndex' _controlValueTable.Length);                                      _controlValueTable[cvtIndex] += F26Dot6ToFloat(amount);                                  }                              }                          }                          break;                      case OpCode.DELTAP1:                      case OpCode.DELTAP2:                      case OpCode.DELTAP3:                          {                              var last = _stack.Pop();                              for (int i = 1; i <= last; i++)                              {                                  var pointIndex = _stack.Pop();                                  var arg = _stack.Pop();                                    // upper 4 bits of the 8-bit arg is the relative ppem                                  // the opcode specifies the base to add to the ppem                                  var triggerPpem = (arg >> 4) & 0xF;                                  triggerPpem += _state.DeltaBase;                                  if (opcode != OpCode.DELTAP1)                                      triggerPpem += (opcode - OpCode.DELTAP2 + 1) * 16;                                    // if the current ppem matches the trigger' apply the exception                                  if (_ppem == triggerPpem)                                  {                                      // the lower 4 bits of the arg is the amount to shift                                      // it's encoded such that 0 isn't an allowable value (who wants to shift by 0 anyway?)                                      var amount = (arg & 0xF) - 8;                                      if (amount >= 0)                                          amount++;                                      amount *= 1 << (6 - _state.DeltaShift);                                        MovePoint(_zp0' pointIndex' F26Dot6ToFloat(amount));                                  }                              }                          }                          break;                        // ==== MISCELLANEOUS ====                      case OpCode.DEBUG: _stack.Pop(); break;                      case OpCode.GETINFO:                          {                              var selector = _stack.Pop();                              var result = 0;                              if ((selector & 0x1) != 0)                              {                                  // pretend we are MS Rasterizer v35                                  result = 35;                              }                                // TODO: rotation and stretching                              //if ((selector & 0x2) != 0)                              //if ((selector & 0x4) != 0)                                // we're always rendering in grayscale                              if ((selector & 0x20) != 0)                                  result |= 1 << 12;                                // TODO: ClearType flags                                _stack.Push(result);                          }                          break;                        default:                          if (opcode >= OpCode.MIRP)                              MoveIndirectRelative(opcode - OpCode.MIRP);                          else if (opcode >= OpCode.MDRP)                              MoveDirectRelative(opcode - OpCode.MDRP);                          else                          {                              // check if this is a runtime-defined opcode                              var index = (int)opcode;                              if (index > _instructionDefs.Length || !_instructionDefs[index].IsValid)                                  throw new InvalidFontException("Unknown opcode in font program.");                                _callStackSize++;                              if (_callStackSize > MaxCallStack)                                  throw new InvalidFontException("Stack overflow; infinite recursion?");                                Execute(_instructionDefs[index]' true' false);                              _callStackSize--;                          }                          break;                  }
Magic Number,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,Execute,The following statement contains a magic number: switch (opcode)                  {                      // ==== PUSH INSTRUCTIONS ====                      case OpCode.NPUSHB:                      case OpCode.PUSHB1:                      case OpCode.PUSHB2:                      case OpCode.PUSHB3:                      case OpCode.PUSHB4:                      case OpCode.PUSHB5:                      case OpCode.PUSHB6:                      case OpCode.PUSHB7:                      case OpCode.PUSHB8:                          {                              var count = opcode == OpCode.NPUSHB ? stream.NextByte() : opcode - OpCode.PUSHB1 + 1;                              for (int i = count - 1; i >= 0; --i)                                  _stack.Push(stream.NextByte());                          }                          break;                      case OpCode.NPUSHW:                      case OpCode.PUSHW1:                      case OpCode.PUSHW2:                      case OpCode.PUSHW3:                      case OpCode.PUSHW4:                      case OpCode.PUSHW5:                      case OpCode.PUSHW6:                      case OpCode.PUSHW7:                      case OpCode.PUSHW8:                          {                              var count = opcode == OpCode.NPUSHW ? stream.NextByte() : opcode - OpCode.PUSHW1 + 1;                              for (int i = count - 1; i >= 0; --i)                                  _stack.Push(stream.NextWord());                          }                          break;                        // ==== STORAGE MANAGEMENT ====                      case OpCode.RS:                          {                              var loc = CheckIndex(_stack.Pop()' _storage.Length);                              _stack.Push(_storage[loc]);                          }                          break;                      case OpCode.WS:                          {                              var value = _stack.Pop();                              var loc = CheckIndex(_stack.Pop()' _storage.Length);                              _storage[loc] = value;                          }                          break;                        // ==== CONTROL VALUE TABLE ====                      case OpCode.WCVTP:                          {                              var value = _stack.PopFloat();                              var loc = CheckIndex(_stack.Pop()' _controlValueTable.Length);                              _controlValueTable[loc] = value;                          }                          break;                      case OpCode.WCVTF:                          {                              var value = _stack.Pop();                              var loc = CheckIndex(_stack.Pop()' _controlValueTable.Length);                              _controlValueTable[loc] = value * _scale;                          }                          break;                      case OpCode.RCVT: _stack.Push(ReadCvt()); break;                        // ==== STATE VECTORS ====                      case OpCode.SVTCA0:                      case OpCode.SVTCA1:                          {                              var axis = opcode - OpCode.SVTCA0;                              SetFreedomVectorToAxis(axis);                              SetProjectionVectorToAxis(axis);                          }                          break;                      case OpCode.SFVTPV: _state.Freedom = _state.Projection; OnVectorsUpdated(); break;                      case OpCode.SPVTCA0:                      case OpCode.SPVTCA1: SetProjectionVectorToAxis(opcode - OpCode.SPVTCA0); break;                      case OpCode.SFVTCA0:                      case OpCode.SFVTCA1: SetFreedomVectorToAxis(opcode - OpCode.SFVTCA0); break;                      case OpCode.SPVTL0:                      case OpCode.SPVTL1:                      case OpCode.SFVTL0:                      case OpCode.SFVTL1: SetVectorToLine(opcode - OpCode.SPVTL0' false); break;                      case OpCode.SDPVTL0:                      case OpCode.SDPVTL1: SetVectorToLine(opcode - OpCode.SDPVTL0' true); break;                      case OpCode.SPVFS:                      case OpCode.SFVFS:                          {                              var y = _stack.Pop();                              var x = _stack.Pop();                              var vec = Vector2.Normalize(new Vector2(F2Dot14ToFloat(x)' F2Dot14ToFloat(y)));                              if (opcode == OpCode.SFVFS)                                  _state.Freedom = vec;                              else                              {                                  _state.Projection = vec;                                  _state.DualProjection = vec;                              }                              OnVectorsUpdated();                          }                          break;                      case OpCode.GPV:                      case OpCode.GFV:                          {                              var vec = opcode == OpCode.GPV ? _state.Projection : _state.Freedom;                              _stack.Push(FloatToF2Dot14(vec.X));                              _stack.Push(FloatToF2Dot14(vec.Y));                          }                          break;                        // ==== GRAPHICS STATE ====                      case OpCode.SRP0: _state.Rp0 = _stack.Pop(); break;                      case OpCode.SRP1: _state.Rp1 = _stack.Pop(); break;                      case OpCode.SRP2: _state.Rp2 = _stack.Pop(); break;                      case OpCode.SZP0: _zp0 = GetZoneFromStack(); break;                      case OpCode.SZP1: _zp1 = GetZoneFromStack(); break;                      case OpCode.SZP2: _zp2 = GetZoneFromStack(); break;                      case OpCode.SZPS: _zp0 = _zp1 = _zp2 = GetZoneFromStack(); break;                      case OpCode.RTHG: _state.RoundState = RoundMode.ToHalfGrid; break;                      case OpCode.RTG: _state.RoundState = RoundMode.ToGrid; break;                      case OpCode.RTDG: _state.RoundState = RoundMode.ToDoubleGrid; break;                      case OpCode.RDTG: _state.RoundState = RoundMode.DownToGrid; break;                      case OpCode.RUTG: _state.RoundState = RoundMode.UpToGrid; break;                      case OpCode.ROFF: _state.RoundState = RoundMode.Off; break;                      case OpCode.SROUND: _state.RoundState = RoundMode.Super; SetSuperRound(1.0f); break;                      case OpCode.S45ROUND: _state.RoundState = RoundMode.Super45; SetSuperRound(Sqrt2Over2); break;                      case OpCode.INSTCTRL:                          {                              var selector = _stack.Pop();                              if (selector >= 1 && selector <= 2)                              {                                  // value is false if zero' otherwise shift the right bit into the flags                                  var bit = 1 << (selector - 1);                                  if (_stack.Pop() == 0)                                      _state.InstructionControl = (InstructionControlFlags)((int)_state.InstructionControl & ~bit);                                  else                                      _state.InstructionControl = (InstructionControlFlags)((int)_state.InstructionControl | bit);                              }                          }                          break;                      case OpCode.SCANCTRL: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SCANTYPE: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SANGW: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SLOOP: _state.Loop = _stack.Pop(); break;                      case OpCode.SMD: _state.MinDistance = _stack.PopFloat(); break;                      case OpCode.SCVTCI: _state.ControlValueCutIn = _stack.PopFloat(); break;                      case OpCode.SSWCI: _state.SingleWidthCutIn = _stack.PopFloat(); break;                      case OpCode.SSW: _state.SingleWidthValue = _stack.Pop() * _scale; break;                      case OpCode.FLIPON: _state.AutoFlip = true; break;                      case OpCode.FLIPOFF: _state.AutoFlip = false; break;                      case OpCode.SDB: _state.DeltaBase = _stack.Pop(); break;                      case OpCode.SDS: _state.DeltaShift = _stack.Pop(); break;                        // ==== POINT MEASUREMENT ====                      case OpCode.GC0: _stack.Push(Project(_zp2.GetCurrent(_stack.Pop()))); break;                      case OpCode.GC1: _stack.Push(DualProject(_zp2.GetOriginal(_stack.Pop()))); break;                      case OpCode.SCFS:                          {                              var value = _stack.PopFloat();                              var index = _stack.Pop();                              var point = _zp2.GetCurrent(index);                              MovePoint(_zp2' index' value - Project(point));                                // moving twilight points moves their "original" value also                              if (_zp2.IsTwilight)                                  _zp2.Original[index].P = _zp2.Current[index].P;                          }                          break;                      case OpCode.MD0:                          {                              var p1 = _zp1.GetOriginal(_stack.Pop());                              var p2 = _zp0.GetOriginal(_stack.Pop());                              _stack.Push(DualProject(p2 - p1));                          }                          break;                      case OpCode.MD1:                          {                              var p1 = _zp1.GetCurrent(_stack.Pop());                              var p2 = _zp0.GetCurrent(_stack.Pop());                              _stack.Push(Project(p2 - p1));                          }                          break;                      case OpCode.MPS: // MPS should return point size' but we assume DPI so it's the same as pixel size                      case OpCode.MPPEM: _stack.Push(_ppem); break;                      case OpCode.AA: /* deprecated instruction */ _stack.Pop(); break;                        // ==== POINT MODIFICATION ====                      case OpCode.FLIPPT:                          {                              for (int i = 0; i < _state.Loop; i++)                              {                                  var index = _stack.Pop();                                  //review here again!                                  _points.Current[index].onCurve = !_points.Current[index].onCurve;                                  //if (points.Current[index].onCurve)                                  //    points.Current[index].onCurve = false;                                  //else                                  //    points.Current[index].onCurve = true;                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.FLIPRGON:                          {                              var end = _stack.Pop();                              for (int i = _stack.Pop(); i <= end; i++)                                  //points.Current[i].Type = PointType.OnCurve;                                  _points.Current[i].onCurve = true;                          }                          break;                      case OpCode.FLIPRGOFF:                          {                              var end = _stack.Pop();                              for (int i = _stack.Pop(); i <= end; i++)                                  //points.Current[i].Type = PointType.Quadratic;                                  _points.Current[i].onCurve = false;                          }                          break;                      case OpCode.SHP0:                      case OpCode.SHP1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              ShiftPoints(displacement);                          }                          break;                      case OpCode.SHPIX: ShiftPoints(_stack.PopFloat() * _state.Freedom); break;                      case OpCode.SHC0:                      case OpCode.SHC1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              var touch = GetTouchState();                              var contour = _stack.Pop();                              var start = contour == 0 ? 0 : _contours[contour - 1] + 1;                              var count = _zp2.IsTwilight ? _zp2.Current.Length : _contours[contour] + 1;                                for (int i = start; i < count; i++)                              {                                  // don't move the reference point                                  if (zone.Current != _zp2.Current || point != i)                                  {                                      _zp2.Current[i].P += displacement;                                      _zp2.TouchState[i] |= touch;                                  }                              }                          }                          break;                      case OpCode.SHZ0:                      case OpCode.SHZ1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              var count = 0;                              if (_zp2.IsTwilight)                                  count = _zp2.Current.Length;                              else if (_contours.Length > 0)                                  count = _contours[_contours.Length - 1] + 1;                                for (int i = 0; i < count; i++)                              {                                  // don't move the reference point                                  if (zone.Current != _zp2.Current || point != i)                                      _zp2.Current[i].P += displacement;                              }                          }                          break;                      case OpCode.MIAP0:                      case OpCode.MIAP1:                          {                              var distance = ReadCvt();                              var pointIndex = _stack.Pop();                                // this instruction is used in the CVT to set up twilight points with original values                              if (_zp0.IsTwilight)                              {                                  var original = _state.Freedom * distance;                                  _zp0.Original[pointIndex].P = original;                                  _zp0.Current[pointIndex].P = original;                              }                                // current position of the point along the projection vector                              var point = _zp0.GetCurrent(pointIndex);                              var currentPos = Project(point);                              if (opcode == OpCode.MIAP1)                              {                                  // only use the CVT if we are above the cut-in point                                  if (Math.Abs(distance - currentPos) > _state.ControlValueCutIn)                                      distance = currentPos;                                  distance = Round(distance);                              }                                MovePoint(_zp0' pointIndex' distance - currentPos);                              _state.Rp0 = pointIndex;                              _state.Rp1 = pointIndex;                          }                          break;                      case OpCode.MDAP0:                      case OpCode.MDAP1:                          {                              var pointIndex = _stack.Pop();                              var point = _zp0.GetCurrent(pointIndex);                              var distance = 0.0f;                              if (opcode == OpCode.MDAP1)                              {                                  distance = Project(point);                                  distance = Round(distance) - distance;                              }                                MovePoint(_zp0' pointIndex' distance);                              _state.Rp0 = pointIndex;                              _state.Rp1 = pointIndex;                          }                          break;                      case OpCode.MSIRP0:                      case OpCode.MSIRP1:                          {                              var targetDistance = _stack.PopFloat();                              var pointIndex = _stack.Pop();                                // if we're operating on the twilight zone' initialize the points                              if (_zp1.IsTwilight)                              {                                  _zp1.Original[pointIndex].P = _zp0.Original[_state.Rp0].P + targetDistance * _state.Freedom / _fdotp;                                  _zp1.Current[pointIndex].P = _zp1.Original[pointIndex].P;                              }                                var currentDistance = Project(_zp1.GetCurrent(pointIndex) - _zp0.GetCurrent(_state.Rp0));                              MovePoint(_zp1' pointIndex' targetDistance - currentDistance);                                _state.Rp1 = _state.Rp0;                              _state.Rp2 = pointIndex;                              if (opcode == OpCode.MSIRP1)                                  _state.Rp0 = pointIndex;                          }                          break;                      case OpCode.IP:                          {                              var originalBase = _zp0.GetOriginal(_state.Rp1);                              var currentBase = _zp0.GetCurrent(_state.Rp1);                              var originalRange = DualProject(_zp1.GetOriginal(_state.Rp2) - originalBase);                              var currentRange = Project(_zp1.GetCurrent(_state.Rp2) - currentBase);                                for (int i = 0; i < _state.Loop; i++)                              {                                  var pointIndex = _stack.Pop();                                  var point = _zp2.GetCurrent(pointIndex);                                  var currentDistance = Project(point - currentBase);                                  var originalDistance = DualProject(_zp2.GetOriginal(pointIndex) - originalBase);                                    var newDistance = 0.0f;                                  if (originalDistance != 0.0f)                                  {                                      // a range of 0.0f is invalid according to the spec (would result in a div by zero)                                      if (originalRange == 0.0f)                                          newDistance = originalDistance;                                      else                                          newDistance = originalDistance * currentRange / originalRange;                                  }                                    MovePoint(_zp2' pointIndex' newDistance - currentDistance);                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.ALIGNRP:                          {                              for (int i = 0; i < _state.Loop; i++)                              {                                  var pointIndex = _stack.Pop();                                  var p1 = _zp1.GetCurrent(pointIndex);                                  var p2 = _zp0.GetCurrent(_state.Rp0);                                  MovePoint(_zp1' pointIndex' -Project(p1 - p2));                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.ALIGNPTS:                          {                              var p1 = _stack.Pop();                              var p2 = _stack.Pop();                              var distance = Project(_zp0.GetCurrent(p2) - _zp1.GetCurrent(p1)) / 2;                              MovePoint(_zp1' p1' distance);                              MovePoint(_zp0' p2' -distance);                          }                          break;                      case OpCode.UTP: _zp0.TouchState[_stack.Pop()] &= ~GetTouchState(); break;                      case OpCode.IUP0:                      case OpCode.IUP1:                          // bail if no contours (empty outline)                          if (_contours.Length == 0)                          {                              break;                          }                            //{                            //    //WinterDev's new managed version                          //    GlyphPointF[] currentPnts = points.Current;                          //    GlyphPointF[] originalPnts = points.Original;                            //    int cnt_count = contours.Length;                          //    int point = 0;                          //    // opcode controls whether we care about X or Y direction                          //    // do some pointer trickery so we can operate on the                          //    // points in a direction-agnostic manner                          //    TouchState touchMask;                            //    if (opcode == OpCode.IUP0)                          //    {                          //        //y -axis                          //        touchMask = TouchState.Y;                            //        //                          //        for (int i = 0; i < cnt_count; ++i)                          //        {                          //            int endPoint = contours[i];                          //            int firstPoint = point;                          //            int firstTouched = -1;                          //            int lastTouched = -1;                            //            for (; point <= endPoint; point++)                          //            {                          //                // check whether this point has been touched                          //                if ((points.TouchState[point] & touchMask) != 0)                          //                {                          //                    // if this is the first touched point in the contour' note it and continue                          //                    if (firstTouched < 0)                          //                    {                          //                        firstTouched = point;                          //                        lastTouched = point;                          //                        continue;                          //                    }                            //                    // otherwise' interpolate all untouched points                          //                    // between this point and our last touched point                          //                    InterpolatePointsYAxis(currentPnts' originalPnts' lastTouched + 1' point - 1' lastTouched' point);                          //                    lastTouched = point;                          //                }                          //            }                            //            // check if we had any touched points at all in this contour                          //            if (firstTouched >= 0)                          //            {                          //                // there are two cases left to handle:                          //                // 1. there was only one touched point in the whole contour' in                          //                //    which case we want to shift everything relative to that one                          //                // 2. several touched points' in which case handle the gap from the                          //                //    beginning to the first touched point and the gap from the last                          //                //    touched point to the end of the contour                          //                if (lastTouched == firstTouched)                          //                {                          //                    float delta = currentPnts[lastTouched].Y - originalPnts[lastTouched].Y;                          //                    if (delta != 0.0f)                          //                    {                          //                        for (int n = firstPoint; n < lastTouched; n++)                          //                        {                          //                            currentPnts[n].OffsetY(delta);                          //                        }                          //                        for (int n = lastTouched + 1; n <= endPoint; n++)                          //                        {                          //                            currentPnts[n].OffsetY(delta);                          //                        }                            //                    }                          //                }                          //                else                          //                {                          //                    InterpolatePointsYAxis(currentPnts' originalPnts' lastTouched + 1' endPoint' lastTouched' firstTouched);                          //                    if (firstTouched > 0)                          //                    {                          //                        InterpolatePointsYAxis(currentPnts' originalPnts' firstPoint' firstTouched - 1' lastTouched' firstTouched);                          //                    }                          //                }                          //            }                            //        }                          //    }                          //    else                          //    {                          //        //x-axis                          //        touchMask = TouchState.X;                          //        //                          //        for (int i = 0; i < cnt_count; ++i)                          //        {                          //            int endPoint = contours[i];                          //            int firstPoint = point;                          //            int firstTouched = -1;                          //            int lastTouched = -1;                            //            for (; point <= endPoint; point++)                          //            {                          //                // check whether this point has been touched                          //                if ((points.TouchState[point] & touchMask) != 0)                          //                {                          //                    // if this is the first touched point in the contour' note it and continue                          //                    if (firstTouched < 0)                          //                    {                          //                        firstTouched = point;                          //                        lastTouched = point;                          //                        continue;                          //                    }                            //                    // otherwise' interpolate all untouched points                          //                    // between this point and our last touched point                          //                    InterpolatePointsXAxis(currentPnts' originalPnts' lastTouched + 1' point - 1' lastTouched' point);                          //                    lastTouched = point;                          //                }                          //            }                            //            // check if we had any touched points at all in this contour                          //            if (firstTouched >= 0)                          //            {                          //                // there are two cases left to handle:                          //                // 1. there was only one touched point in the whole contour' in                          //                //    which case we want to shift everything relative to that one                          //                // 2. several touched points' in which case handle the gap from the                          //                //    beginning to the first touched point and the gap from the last                          //                //    touched point to the end of the contour                          //                if (lastTouched == firstTouched)                          //                {                          //                    float delta = currentPnts[lastTouched].X - originalPnts[lastTouched].X;                          //                    if (delta != 0.0f)                          //                    {                          //                        for (int n = firstPoint; n < lastTouched; ++n)                          //                        {                          //                            currentPnts[n].OffsetX(delta);                          //                        }                          //                        for (int n = lastTouched + 1; n <= endPoint; ++n)                          //                        {                          //                            currentPnts[n].OffsetX(delta);                          //                        }                          //                    }                          //                }                          //                else                          //                {                          //                    InterpolatePointsXAxis(currentPnts' originalPnts' lastTouched + 1' endPoint' lastTouched' firstTouched);                          //                    if (firstTouched > 0)                          //                    {                          //                        InterpolatePointsXAxis(currentPnts' originalPnts' firstPoint' firstTouched - 1' lastTouched' firstTouched);                          //                    }                          //                }                          //            }                          //        }                          //    }                          //}                          //-----------------------------------------                          unsafe                          {                                //unsafe version                               //TODO: provide manage version                               fixed (GlyphPointF* currentPtr = _points.Current)                              fixed (GlyphPointF* originalPtr = _points.Original)                              {                                  // opcode controls whether we care about X or Y direction                                  // do some pointer trickery so we can operate on the                                  // points in a direction-agnostic manner                                  TouchState touchMask;                                  byte* current;                                  byte* original;                                  if (opcode == OpCode.IUP0)                                  {                                      touchMask = TouchState.Y;                                      current = (byte*)&currentPtr->P.Y;                                      original = (byte*)&originalPtr->P.Y;                                  }                                  else                                  {                                      touchMask = TouchState.X;                                      current = (byte*)&currentPtr->P.X;                                      original = (byte*)&originalPtr->P.X;                                  }                                    var point = 0;                                  for (int i = 0; i < _contours.Length; i++)                                  {                                      var endPoint = _contours[i];                                      var firstPoint = point;                                      var firstTouched = -1;                                      var lastTouched = -1;                                        for (; point <= endPoint; point++)                                      {                                          // check whether this point has been touched                                          if ((_points.TouchState[point] & touchMask) != 0)                                          {                                              // if this is the first touched point in the contour' note it and continue                                              if (firstTouched < 0)                                              {                                                  firstTouched = point;                                                  lastTouched = point;                                                  continue;                                              }                                                // otherwise' interpolate all untouched points                                              // between this point and our last touched point                                              InterpolatePoints(current' original' lastTouched + 1' point - 1' lastTouched' point);                                              lastTouched = point;                                          }                                      }                                        // check if we had any touched points at all in this contour                                      if (firstTouched >= 0)                                      {                                          // there are two cases left to handle:                                          // 1. there was only one touched point in the whole contour' in                                          //    which case we want to shift everything relative to that one                                          // 2. several touched points' in which case handle the gap from the                                          //    beginning to the first touched point and the gap from the last                                          //    touched point to the end of the contour                                          if (lastTouched == firstTouched)                                          {                                              var delta = *GetPoint(current' lastTouched) - *GetPoint(original' lastTouched);                                              if (delta != 0.0f)                                              {                                                  for (int j = firstPoint; j < lastTouched; j++)                                                      *GetPoint(current' j) += delta;                                                  for (int j = lastTouched + 1; j <= endPoint; j++)                                                      *GetPoint(current' j) += delta;                                              }                                          }                                          else                                          {                                              InterpolatePoints(current' original' lastTouched + 1' endPoint' lastTouched' firstTouched);                                              if (firstTouched > 0)                                                  InterpolatePoints(current' original' firstPoint' firstTouched - 1' lastTouched' firstTouched);                                          }                                      }                                  }                              }                          }                          break;                      case OpCode.ISECT:                          {                              // move point P to the intersection of lines A and B                              var b1 = _zp0.GetCurrent(_stack.Pop());                              var b0 = _zp0.GetCurrent(_stack.Pop());                              var a1 = _zp1.GetCurrent(_stack.Pop());                              var a0 = _zp1.GetCurrent(_stack.Pop());                              var index = _stack.Pop();                                // calculate intersection using determinants: https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line                              var da = a0 - a1;                              var db = b0 - b1;                              var den = (da.X * db.Y) - (da.Y * db.X);                              if (Math.Abs(den) <= Epsilon)                              {                                  // parallel lines; spec says to put the ppoint "into the middle of the two lines"                                  _zp2.Current[index].P = (a0 + a1 + b0 + b1) / 4;                              }                              else                              {                                  var t = (a0.X * a1.Y) - (a0.Y * a1.X);                                  var u = (b0.X * b1.Y) - (b0.Y * b1.X);                                  var p = new Vector2(                                      (t * db.X) - (da.X * u)'                                      (t * db.Y) - (da.Y * u)                                  );                                  _zp2.Current[index].P = p / den;                              }                              _zp2.TouchState[index] = TouchState.Both;                          }                          break;                        // ==== STACK MANAGEMENT ====                      case OpCode.DUP: _stack.Duplicate(); break;                      case OpCode.POP: _stack.Pop(); break;                      case OpCode.CLEAR: _stack.Clear(); break;                      case OpCode.SWAP: _stack.Swap(); break;                      case OpCode.DEPTH: _stack.Depth(); break;                      case OpCode.CINDEX: _stack.Copy(); break;                      case OpCode.MINDEX: _stack.Move(); break;                      case OpCode.ROLL: _stack.Roll(); break;                        // ==== FLOW CONTROL ====                      case OpCode.IF:                          {                              // value is false; jump to the next else block or endif marker                              // otherwise' we don't have to do anything; we'll keep executing this block                              if (!_stack.PopBool())                              {                                  int indent = 1;                                  while (indent > 0)                                  {                                      opcode = SkipNext(ref stream);                                      switch (opcode)                                      {                                          case OpCode.IF: indent++; break;                                          case OpCode.EIF: indent--; break;                                          case OpCode.ELSE:                                              if (indent == 1)                                                  indent = 0;                                              break;                                      }                                  }                              }                          }                          break;                      case OpCode.ELSE:                          {                              // assume we hit the true statement of some previous if block                              // if we had hit false' we would have jumped over this                              int indent = 1;                              while (indent > 0)                              {                                  opcode = SkipNext(ref stream);                                  switch (opcode)                                  {                                      case OpCode.IF: indent++; break;                                      case OpCode.EIF: indent--; break;                                  }                              }                          }                          break;                      case OpCode.EIF: /* nothing to do */ break;                      case OpCode.JROT:                      case OpCode.JROF:                          {                              if (_stack.PopBool() == (opcode == OpCode.JROT))                                  stream.Jump(_stack.Pop() - 1);                              else                                  _stack.Pop();    // ignore the offset                          }                          break;                      case OpCode.JMPR: stream.Jump(_stack.Pop() - 1); break;                        // ==== LOGICAL OPS ====                      case OpCode.LT:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a < b);                          }                          break;                      case OpCode.LTEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a <= b);                          }                          break;                      case OpCode.GT:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a > b);                          }                          break;                      case OpCode.GTEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a >= b);                          }                          break;                      case OpCode.EQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a == b);                          }                          break;                      case OpCode.NEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a != b);                          }                          break;                      case OpCode.AND:                          {                              var b = _stack.PopBool();                              var a = _stack.PopBool();                              _stack.Push(a && b);                          }                          break;                      case OpCode.OR:                          {                              var b = _stack.PopBool();                              var a = _stack.PopBool();                              _stack.Push(a || b);                          }                          break;                      case OpCode.NOT: _stack.Push(!_stack.PopBool()); break;                      case OpCode.ODD:                          {                              var value = (int)Round(_stack.PopFloat());                              _stack.Push(value % 2 != 0);                          }                          break;                      case OpCode.EVEN:                          {                              var value = (int)Round(_stack.PopFloat());                              _stack.Push(value % 2 == 0);                          }                          break;                        // ==== ARITHMETIC ====                      case OpCode.ADD:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a + b);                          }                          break;                      case OpCode.SUB:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a - b);                          }                          break;                      case OpCode.DIV:                          {                              var b = _stack.Pop();                              if (b == 0)                                  throw new InvalidFontException("Division by zero.");                                var a = _stack.Pop();                              var result = ((long)a << 6) / b;                              _stack.Push((int)result);                          }                          break;                      case OpCode.MUL:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              var result = ((long)a * b) >> 6;                              _stack.Push((int)result);                          }                          break;                      case OpCode.ABS: _stack.Push(Math.Abs(_stack.Pop())); break;                      case OpCode.NEG: _stack.Push(-_stack.Pop()); break;                      case OpCode.FLOOR: _stack.Push(_stack.Pop() & ~63); break;                      case OpCode.CEILING: _stack.Push((_stack.Pop() + 63) & ~63); break;                      case OpCode.MAX: _stack.Push(Math.Max(_stack.Pop()' _stack.Pop())); break;                      case OpCode.MIN: _stack.Push(Math.Min(_stack.Pop()' _stack.Pop())); break;                        // ==== FUNCTIONS ====                      case OpCode.FDEF:                          {                              if (!allowFunctionDefs || inFunction)                                  throw new InvalidFontException("Can't define functions here.");                                _functions[_stack.Pop()] = stream;                              while (SkipNext(ref stream) != OpCode.ENDF) ;                          }                          break;                      case OpCode.IDEF:                          {                              if (!allowFunctionDefs || inFunction)                                  throw new InvalidFontException("Can't define functions here.");                                _instructionDefs[_stack.Pop()] = stream;                              while (SkipNext(ref stream) != OpCode.ENDF) ;                          }                          break;                      case OpCode.ENDF:                          {                              if (!inFunction)                                  throw new InvalidFontException("Found invalid ENDF marker outside of a function definition.");                              return;                          }                      case OpCode.CALL:                      case OpCode.LOOPCALL:                          {                              _callStackSize++;                              if (_callStackSize > MaxCallStack)                                  throw new InvalidFontException("Stack overflow; infinite recursion?");                                var function = _functions[_stack.Pop()];                              var count = opcode == OpCode.LOOPCALL ? _stack.Pop() : 1;                              for (int i = 0; i < count; i++)                                  Execute(function' true' false);                              _callStackSize--;                          }                          break;                        // ==== ROUNDING ====                      // we don't have "engine compensation" so the variants are unnecessary                      case OpCode.ROUND0:                      case OpCode.ROUND1:                      case OpCode.ROUND2:                      case OpCode.ROUND3: _stack.Push(Round(_stack.PopFloat())); break;                      case OpCode.NROUND0:                      case OpCode.NROUND1:                      case OpCode.NROUND2:                      case OpCode.NROUND3: break;                        // ==== DELTA EXCEPTIONS ====                      case OpCode.DELTAC1:                      case OpCode.DELTAC2:                      case OpCode.DELTAC3:                          {                              var last = _stack.Pop();                              for (int i = 1; i <= last; i++)                              {                                  var cvtIndex = _stack.Pop();                                  var arg = _stack.Pop();                                    // upper 4 bits of the 8-bit arg is the relative ppem                                  // the opcode specifies the base to add to the ppem                                  var triggerPpem = (arg >> 4) & 0xF;                                  triggerPpem += (opcode - OpCode.DELTAC1) * 16;                                  triggerPpem += _state.DeltaBase;                                    // if the current ppem matches the trigger' apply the exception                                  if (_ppem == triggerPpem)                                  {                                      // the lower 4 bits of the arg is the amount to shift                                      // it's encoded such that 0 isn't an allowable value (who wants to shift by 0 anyway?)                                      var amount = (arg & 0xF) - 8;                                      if (amount >= 0)                                          amount++;                                      amount *= 1 << (6 - _state.DeltaShift);                                        // update the CVT                                      CheckIndex(cvtIndex' _controlValueTable.Length);                                      _controlValueTable[cvtIndex] += F26Dot6ToFloat(amount);                                  }                              }                          }                          break;                      case OpCode.DELTAP1:                      case OpCode.DELTAP2:                      case OpCode.DELTAP3:                          {                              var last = _stack.Pop();                              for (int i = 1; i <= last; i++)                              {                                  var pointIndex = _stack.Pop();                                  var arg = _stack.Pop();                                    // upper 4 bits of the 8-bit arg is the relative ppem                                  // the opcode specifies the base to add to the ppem                                  var triggerPpem = (arg >> 4) & 0xF;                                  triggerPpem += _state.DeltaBase;                                  if (opcode != OpCode.DELTAP1)                                      triggerPpem += (opcode - OpCode.DELTAP2 + 1) * 16;                                    // if the current ppem matches the trigger' apply the exception                                  if (_ppem == triggerPpem)                                  {                                      // the lower 4 bits of the arg is the amount to shift                                      // it's encoded such that 0 isn't an allowable value (who wants to shift by 0 anyway?)                                      var amount = (arg & 0xF) - 8;                                      if (amount >= 0)                                          amount++;                                      amount *= 1 << (6 - _state.DeltaShift);                                        MovePoint(_zp0' pointIndex' F26Dot6ToFloat(amount));                                  }                              }                          }                          break;                        // ==== MISCELLANEOUS ====                      case OpCode.DEBUG: _stack.Pop(); break;                      case OpCode.GETINFO:                          {                              var selector = _stack.Pop();                              var result = 0;                              if ((selector & 0x1) != 0)                              {                                  // pretend we are MS Rasterizer v35                                  result = 35;                              }                                // TODO: rotation and stretching                              //if ((selector & 0x2) != 0)                              //if ((selector & 0x4) != 0)                                // we're always rendering in grayscale                              if ((selector & 0x20) != 0)                                  result |= 1 << 12;                                // TODO: ClearType flags                                _stack.Push(result);                          }                          break;                        default:                          if (opcode >= OpCode.MIRP)                              MoveIndirectRelative(opcode - OpCode.MIRP);                          else if (opcode >= OpCode.MDRP)                              MoveDirectRelative(opcode - OpCode.MDRP);                          else                          {                              // check if this is a runtime-defined opcode                              var index = (int)opcode;                              if (index > _instructionDefs.Length || !_instructionDefs[index].IsValid)                                  throw new InvalidFontException("Unknown opcode in font program.");                                _callStackSize++;                              if (_callStackSize > MaxCallStack)                                  throw new InvalidFontException("Stack overflow; infinite recursion?");                                Execute(_instructionDefs[index]' true' false);                              _callStackSize--;                          }                          break;                  }
Magic Number,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,Execute,The following statement contains a magic number: switch (opcode)                  {                      // ==== PUSH INSTRUCTIONS ====                      case OpCode.NPUSHB:                      case OpCode.PUSHB1:                      case OpCode.PUSHB2:                      case OpCode.PUSHB3:                      case OpCode.PUSHB4:                      case OpCode.PUSHB5:                      case OpCode.PUSHB6:                      case OpCode.PUSHB7:                      case OpCode.PUSHB8:                          {                              var count = opcode == OpCode.NPUSHB ? stream.NextByte() : opcode - OpCode.PUSHB1 + 1;                              for (int i = count - 1; i >= 0; --i)                                  _stack.Push(stream.NextByte());                          }                          break;                      case OpCode.NPUSHW:                      case OpCode.PUSHW1:                      case OpCode.PUSHW2:                      case OpCode.PUSHW3:                      case OpCode.PUSHW4:                      case OpCode.PUSHW5:                      case OpCode.PUSHW6:                      case OpCode.PUSHW7:                      case OpCode.PUSHW8:                          {                              var count = opcode == OpCode.NPUSHW ? stream.NextByte() : opcode - OpCode.PUSHW1 + 1;                              for (int i = count - 1; i >= 0; --i)                                  _stack.Push(stream.NextWord());                          }                          break;                        // ==== STORAGE MANAGEMENT ====                      case OpCode.RS:                          {                              var loc = CheckIndex(_stack.Pop()' _storage.Length);                              _stack.Push(_storage[loc]);                          }                          break;                      case OpCode.WS:                          {                              var value = _stack.Pop();                              var loc = CheckIndex(_stack.Pop()' _storage.Length);                              _storage[loc] = value;                          }                          break;                        // ==== CONTROL VALUE TABLE ====                      case OpCode.WCVTP:                          {                              var value = _stack.PopFloat();                              var loc = CheckIndex(_stack.Pop()' _controlValueTable.Length);                              _controlValueTable[loc] = value;                          }                          break;                      case OpCode.WCVTF:                          {                              var value = _stack.Pop();                              var loc = CheckIndex(_stack.Pop()' _controlValueTable.Length);                              _controlValueTable[loc] = value * _scale;                          }                          break;                      case OpCode.RCVT: _stack.Push(ReadCvt()); break;                        // ==== STATE VECTORS ====                      case OpCode.SVTCA0:                      case OpCode.SVTCA1:                          {                              var axis = opcode - OpCode.SVTCA0;                              SetFreedomVectorToAxis(axis);                              SetProjectionVectorToAxis(axis);                          }                          break;                      case OpCode.SFVTPV: _state.Freedom = _state.Projection; OnVectorsUpdated(); break;                      case OpCode.SPVTCA0:                      case OpCode.SPVTCA1: SetProjectionVectorToAxis(opcode - OpCode.SPVTCA0); break;                      case OpCode.SFVTCA0:                      case OpCode.SFVTCA1: SetFreedomVectorToAxis(opcode - OpCode.SFVTCA0); break;                      case OpCode.SPVTL0:                      case OpCode.SPVTL1:                      case OpCode.SFVTL0:                      case OpCode.SFVTL1: SetVectorToLine(opcode - OpCode.SPVTL0' false); break;                      case OpCode.SDPVTL0:                      case OpCode.SDPVTL1: SetVectorToLine(opcode - OpCode.SDPVTL0' true); break;                      case OpCode.SPVFS:                      case OpCode.SFVFS:                          {                              var y = _stack.Pop();                              var x = _stack.Pop();                              var vec = Vector2.Normalize(new Vector2(F2Dot14ToFloat(x)' F2Dot14ToFloat(y)));                              if (opcode == OpCode.SFVFS)                                  _state.Freedom = vec;                              else                              {                                  _state.Projection = vec;                                  _state.DualProjection = vec;                              }                              OnVectorsUpdated();                          }                          break;                      case OpCode.GPV:                      case OpCode.GFV:                          {                              var vec = opcode == OpCode.GPV ? _state.Projection : _state.Freedom;                              _stack.Push(FloatToF2Dot14(vec.X));                              _stack.Push(FloatToF2Dot14(vec.Y));                          }                          break;                        // ==== GRAPHICS STATE ====                      case OpCode.SRP0: _state.Rp0 = _stack.Pop(); break;                      case OpCode.SRP1: _state.Rp1 = _stack.Pop(); break;                      case OpCode.SRP2: _state.Rp2 = _stack.Pop(); break;                      case OpCode.SZP0: _zp0 = GetZoneFromStack(); break;                      case OpCode.SZP1: _zp1 = GetZoneFromStack(); break;                      case OpCode.SZP2: _zp2 = GetZoneFromStack(); break;                      case OpCode.SZPS: _zp0 = _zp1 = _zp2 = GetZoneFromStack(); break;                      case OpCode.RTHG: _state.RoundState = RoundMode.ToHalfGrid; break;                      case OpCode.RTG: _state.RoundState = RoundMode.ToGrid; break;                      case OpCode.RTDG: _state.RoundState = RoundMode.ToDoubleGrid; break;                      case OpCode.RDTG: _state.RoundState = RoundMode.DownToGrid; break;                      case OpCode.RUTG: _state.RoundState = RoundMode.UpToGrid; break;                      case OpCode.ROFF: _state.RoundState = RoundMode.Off; break;                      case OpCode.SROUND: _state.RoundState = RoundMode.Super; SetSuperRound(1.0f); break;                      case OpCode.S45ROUND: _state.RoundState = RoundMode.Super45; SetSuperRound(Sqrt2Over2); break;                      case OpCode.INSTCTRL:                          {                              var selector = _stack.Pop();                              if (selector >= 1 && selector <= 2)                              {                                  // value is false if zero' otherwise shift the right bit into the flags                                  var bit = 1 << (selector - 1);                                  if (_stack.Pop() == 0)                                      _state.InstructionControl = (InstructionControlFlags)((int)_state.InstructionControl & ~bit);                                  else                                      _state.InstructionControl = (InstructionControlFlags)((int)_state.InstructionControl | bit);                              }                          }                          break;                      case OpCode.SCANCTRL: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SCANTYPE: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SANGW: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SLOOP: _state.Loop = _stack.Pop(); break;                      case OpCode.SMD: _state.MinDistance = _stack.PopFloat(); break;                      case OpCode.SCVTCI: _state.ControlValueCutIn = _stack.PopFloat(); break;                      case OpCode.SSWCI: _state.SingleWidthCutIn = _stack.PopFloat(); break;                      case OpCode.SSW: _state.SingleWidthValue = _stack.Pop() * _scale; break;                      case OpCode.FLIPON: _state.AutoFlip = true; break;                      case OpCode.FLIPOFF: _state.AutoFlip = false; break;                      case OpCode.SDB: _state.DeltaBase = _stack.Pop(); break;                      case OpCode.SDS: _state.DeltaShift = _stack.Pop(); break;                        // ==== POINT MEASUREMENT ====                      case OpCode.GC0: _stack.Push(Project(_zp2.GetCurrent(_stack.Pop()))); break;                      case OpCode.GC1: _stack.Push(DualProject(_zp2.GetOriginal(_stack.Pop()))); break;                      case OpCode.SCFS:                          {                              var value = _stack.PopFloat();                              var index = _stack.Pop();                              var point = _zp2.GetCurrent(index);                              MovePoint(_zp2' index' value - Project(point));                                // moving twilight points moves their "original" value also                              if (_zp2.IsTwilight)                                  _zp2.Original[index].P = _zp2.Current[index].P;                          }                          break;                      case OpCode.MD0:                          {                              var p1 = _zp1.GetOriginal(_stack.Pop());                              var p2 = _zp0.GetOriginal(_stack.Pop());                              _stack.Push(DualProject(p2 - p1));                          }                          break;                      case OpCode.MD1:                          {                              var p1 = _zp1.GetCurrent(_stack.Pop());                              var p2 = _zp0.GetCurrent(_stack.Pop());                              _stack.Push(Project(p2 - p1));                          }                          break;                      case OpCode.MPS: // MPS should return point size' but we assume DPI so it's the same as pixel size                      case OpCode.MPPEM: _stack.Push(_ppem); break;                      case OpCode.AA: /* deprecated instruction */ _stack.Pop(); break;                        // ==== POINT MODIFICATION ====                      case OpCode.FLIPPT:                          {                              for (int i = 0; i < _state.Loop; i++)                              {                                  var index = _stack.Pop();                                  //review here again!                                  _points.Current[index].onCurve = !_points.Current[index].onCurve;                                  //if (points.Current[index].onCurve)                                  //    points.Current[index].onCurve = false;                                  //else                                  //    points.Current[index].onCurve = true;                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.FLIPRGON:                          {                              var end = _stack.Pop();                              for (int i = _stack.Pop(); i <= end; i++)                                  //points.Current[i].Type = PointType.OnCurve;                                  _points.Current[i].onCurve = true;                          }                          break;                      case OpCode.FLIPRGOFF:                          {                              var end = _stack.Pop();                              for (int i = _stack.Pop(); i <= end; i++)                                  //points.Current[i].Type = PointType.Quadratic;                                  _points.Current[i].onCurve = false;                          }                          break;                      case OpCode.SHP0:                      case OpCode.SHP1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              ShiftPoints(displacement);                          }                          break;                      case OpCode.SHPIX: ShiftPoints(_stack.PopFloat() * _state.Freedom); break;                      case OpCode.SHC0:                      case OpCode.SHC1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              var touch = GetTouchState();                              var contour = _stack.Pop();                              var start = contour == 0 ? 0 : _contours[contour - 1] + 1;                              var count = _zp2.IsTwilight ? _zp2.Current.Length : _contours[contour] + 1;                                for (int i = start; i < count; i++)                              {                                  // don't move the reference point                                  if (zone.Current != _zp2.Current || point != i)                                  {                                      _zp2.Current[i].P += displacement;                                      _zp2.TouchState[i] |= touch;                                  }                              }                          }                          break;                      case OpCode.SHZ0:                      case OpCode.SHZ1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              var count = 0;                              if (_zp2.IsTwilight)                                  count = _zp2.Current.Length;                              else if (_contours.Length > 0)                                  count = _contours[_contours.Length - 1] + 1;                                for (int i = 0; i < count; i++)                              {                                  // don't move the reference point                                  if (zone.Current != _zp2.Current || point != i)                                      _zp2.Current[i].P += displacement;                              }                          }                          break;                      case OpCode.MIAP0:                      case OpCode.MIAP1:                          {                              var distance = ReadCvt();                              var pointIndex = _stack.Pop();                                // this instruction is used in the CVT to set up twilight points with original values                              if (_zp0.IsTwilight)                              {                                  var original = _state.Freedom * distance;                                  _zp0.Original[pointIndex].P = original;                                  _zp0.Current[pointIndex].P = original;                              }                                // current position of the point along the projection vector                              var point = _zp0.GetCurrent(pointIndex);                              var currentPos = Project(point);                              if (opcode == OpCode.MIAP1)                              {                                  // only use the CVT if we are above the cut-in point                                  if (Math.Abs(distance - currentPos) > _state.ControlValueCutIn)                                      distance = currentPos;                                  distance = Round(distance);                              }                                MovePoint(_zp0' pointIndex' distance - currentPos);                              _state.Rp0 = pointIndex;                              _state.Rp1 = pointIndex;                          }                          break;                      case OpCode.MDAP0:                      case OpCode.MDAP1:                          {                              var pointIndex = _stack.Pop();                              var point = _zp0.GetCurrent(pointIndex);                              var distance = 0.0f;                              if (opcode == OpCode.MDAP1)                              {                                  distance = Project(point);                                  distance = Round(distance) - distance;                              }                                MovePoint(_zp0' pointIndex' distance);                              _state.Rp0 = pointIndex;                              _state.Rp1 = pointIndex;                          }                          break;                      case OpCode.MSIRP0:                      case OpCode.MSIRP1:                          {                              var targetDistance = _stack.PopFloat();                              var pointIndex = _stack.Pop();                                // if we're operating on the twilight zone' initialize the points                              if (_zp1.IsTwilight)                              {                                  _zp1.Original[pointIndex].P = _zp0.Original[_state.Rp0].P + targetDistance * _state.Freedom / _fdotp;                                  _zp1.Current[pointIndex].P = _zp1.Original[pointIndex].P;                              }                                var currentDistance = Project(_zp1.GetCurrent(pointIndex) - _zp0.GetCurrent(_state.Rp0));                              MovePoint(_zp1' pointIndex' targetDistance - currentDistance);                                _state.Rp1 = _state.Rp0;                              _state.Rp2 = pointIndex;                              if (opcode == OpCode.MSIRP1)                                  _state.Rp0 = pointIndex;                          }                          break;                      case OpCode.IP:                          {                              var originalBase = _zp0.GetOriginal(_state.Rp1);                              var currentBase = _zp0.GetCurrent(_state.Rp1);                              var originalRange = DualProject(_zp1.GetOriginal(_state.Rp2) - originalBase);                              var currentRange = Project(_zp1.GetCurrent(_state.Rp2) - currentBase);                                for (int i = 0; i < _state.Loop; i++)                              {                                  var pointIndex = _stack.Pop();                                  var point = _zp2.GetCurrent(pointIndex);                                  var currentDistance = Project(point - currentBase);                                  var originalDistance = DualProject(_zp2.GetOriginal(pointIndex) - originalBase);                                    var newDistance = 0.0f;                                  if (originalDistance != 0.0f)                                  {                                      // a range of 0.0f is invalid according to the spec (would result in a div by zero)                                      if (originalRange == 0.0f)                                          newDistance = originalDistance;                                      else                                          newDistance = originalDistance * currentRange / originalRange;                                  }                                    MovePoint(_zp2' pointIndex' newDistance - currentDistance);                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.ALIGNRP:                          {                              for (int i = 0; i < _state.Loop; i++)                              {                                  var pointIndex = _stack.Pop();                                  var p1 = _zp1.GetCurrent(pointIndex);                                  var p2 = _zp0.GetCurrent(_state.Rp0);                                  MovePoint(_zp1' pointIndex' -Project(p1 - p2));                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.ALIGNPTS:                          {                              var p1 = _stack.Pop();                              var p2 = _stack.Pop();                              var distance = Project(_zp0.GetCurrent(p2) - _zp1.GetCurrent(p1)) / 2;                              MovePoint(_zp1' p1' distance);                              MovePoint(_zp0' p2' -distance);                          }                          break;                      case OpCode.UTP: _zp0.TouchState[_stack.Pop()] &= ~GetTouchState(); break;                      case OpCode.IUP0:                      case OpCode.IUP1:                          // bail if no contours (empty outline)                          if (_contours.Length == 0)                          {                              break;                          }                            //{                            //    //WinterDev's new managed version                          //    GlyphPointF[] currentPnts = points.Current;                          //    GlyphPointF[] originalPnts = points.Original;                            //    int cnt_count = contours.Length;                          //    int point = 0;                          //    // opcode controls whether we care about X or Y direction                          //    // do some pointer trickery so we can operate on the                          //    // points in a direction-agnostic manner                          //    TouchState touchMask;                            //    if (opcode == OpCode.IUP0)                          //    {                          //        //y -axis                          //        touchMask = TouchState.Y;                            //        //                          //        for (int i = 0; i < cnt_count; ++i)                          //        {                          //            int endPoint = contours[i];                          //            int firstPoint = point;                          //            int firstTouched = -1;                          //            int lastTouched = -1;                            //            for (; point <= endPoint; point++)                          //            {                          //                // check whether this point has been touched                          //                if ((points.TouchState[point] & touchMask) != 0)                          //                {                          //                    // if this is the first touched point in the contour' note it and continue                          //                    if (firstTouched < 0)                          //                    {                          //                        firstTouched = point;                          //                        lastTouched = point;                          //                        continue;                          //                    }                            //                    // otherwise' interpolate all untouched points                          //                    // between this point and our last touched point                          //                    InterpolatePointsYAxis(currentPnts' originalPnts' lastTouched + 1' point - 1' lastTouched' point);                          //                    lastTouched = point;                          //                }                          //            }                            //            // check if we had any touched points at all in this contour                          //            if (firstTouched >= 0)                          //            {                          //                // there are two cases left to handle:                          //                // 1. there was only one touched point in the whole contour' in                          //                //    which case we want to shift everything relative to that one                          //                // 2. several touched points' in which case handle the gap from the                          //                //    beginning to the first touched point and the gap from the last                          //                //    touched point to the end of the contour                          //                if (lastTouched == firstTouched)                          //                {                          //                    float delta = currentPnts[lastTouched].Y - originalPnts[lastTouched].Y;                          //                    if (delta != 0.0f)                          //                    {                          //                        for (int n = firstPoint; n < lastTouched; n++)                          //                        {                          //                            currentPnts[n].OffsetY(delta);                          //                        }                          //                        for (int n = lastTouched + 1; n <= endPoint; n++)                          //                        {                          //                            currentPnts[n].OffsetY(delta);                          //                        }                            //                    }                          //                }                          //                else                          //                {                          //                    InterpolatePointsYAxis(currentPnts' originalPnts' lastTouched + 1' endPoint' lastTouched' firstTouched);                          //                    if (firstTouched > 0)                          //                    {                          //                        InterpolatePointsYAxis(currentPnts' originalPnts' firstPoint' firstTouched - 1' lastTouched' firstTouched);                          //                    }                          //                }                          //            }                            //        }                          //    }                          //    else                          //    {                          //        //x-axis                          //        touchMask = TouchState.X;                          //        //                          //        for (int i = 0; i < cnt_count; ++i)                          //        {                          //            int endPoint = contours[i];                          //            int firstPoint = point;                          //            int firstTouched = -1;                          //            int lastTouched = -1;                            //            for (; point <= endPoint; point++)                          //            {                          //                // check whether this point has been touched                          //                if ((points.TouchState[point] & touchMask) != 0)                          //                {                          //                    // if this is the first touched point in the contour' note it and continue                          //                    if (firstTouched < 0)                          //                    {                          //                        firstTouched = point;                          //                        lastTouched = point;                          //                        continue;                          //                    }                            //                    // otherwise' interpolate all untouched points                          //                    // between this point and our last touched point                          //                    InterpolatePointsXAxis(currentPnts' originalPnts' lastTouched + 1' point - 1' lastTouched' point);                          //                    lastTouched = point;                          //                }                          //            }                            //            // check if we had any touched points at all in this contour                          //            if (firstTouched >= 0)                          //            {                          //                // there are two cases left to handle:                          //                // 1. there was only one touched point in the whole contour' in                          //                //    which case we want to shift everything relative to that one                          //                // 2. several touched points' in which case handle the gap from the                          //                //    beginning to the first touched point and the gap from the last                          //                //    touched point to the end of the contour                          //                if (lastTouched == firstTouched)                          //                {                          //                    float delta = currentPnts[lastTouched].X - originalPnts[lastTouched].X;                          //                    if (delta != 0.0f)                          //                    {                          //                        for (int n = firstPoint; n < lastTouched; ++n)                          //                        {                          //                            currentPnts[n].OffsetX(delta);                          //                        }                          //                        for (int n = lastTouched + 1; n <= endPoint; ++n)                          //                        {                          //                            currentPnts[n].OffsetX(delta);                          //                        }                          //                    }                          //                }                          //                else                          //                {                          //                    InterpolatePointsXAxis(currentPnts' originalPnts' lastTouched + 1' endPoint' lastTouched' firstTouched);                          //                    if (firstTouched > 0)                          //                    {                          //                        InterpolatePointsXAxis(currentPnts' originalPnts' firstPoint' firstTouched - 1' lastTouched' firstTouched);                          //                    }                          //                }                          //            }                          //        }                          //    }                          //}                          //-----------------------------------------                          unsafe                          {                                //unsafe version                               //TODO: provide manage version                               fixed (GlyphPointF* currentPtr = _points.Current)                              fixed (GlyphPointF* originalPtr = _points.Original)                              {                                  // opcode controls whether we care about X or Y direction                                  // do some pointer trickery so we can operate on the                                  // points in a direction-agnostic manner                                  TouchState touchMask;                                  byte* current;                                  byte* original;                                  if (opcode == OpCode.IUP0)                                  {                                      touchMask = TouchState.Y;                                      current = (byte*)&currentPtr->P.Y;                                      original = (byte*)&originalPtr->P.Y;                                  }                                  else                                  {                                      touchMask = TouchState.X;                                      current = (byte*)&currentPtr->P.X;                                      original = (byte*)&originalPtr->P.X;                                  }                                    var point = 0;                                  for (int i = 0; i < _contours.Length; i++)                                  {                                      var endPoint = _contours[i];                                      var firstPoint = point;                                      var firstTouched = -1;                                      var lastTouched = -1;                                        for (; point <= endPoint; point++)                                      {                                          // check whether this point has been touched                                          if ((_points.TouchState[point] & touchMask) != 0)                                          {                                              // if this is the first touched point in the contour' note it and continue                                              if (firstTouched < 0)                                              {                                                  firstTouched = point;                                                  lastTouched = point;                                                  continue;                                              }                                                // otherwise' interpolate all untouched points                                              // between this point and our last touched point                                              InterpolatePoints(current' original' lastTouched + 1' point - 1' lastTouched' point);                                              lastTouched = point;                                          }                                      }                                        // check if we had any touched points at all in this contour                                      if (firstTouched >= 0)                                      {                                          // there are two cases left to handle:                                          // 1. there was only one touched point in the whole contour' in                                          //    which case we want to shift everything relative to that one                                          // 2. several touched points' in which case handle the gap from the                                          //    beginning to the first touched point and the gap from the last                                          //    touched point to the end of the contour                                          if (lastTouched == firstTouched)                                          {                                              var delta = *GetPoint(current' lastTouched) - *GetPoint(original' lastTouched);                                              if (delta != 0.0f)                                              {                                                  for (int j = firstPoint; j < lastTouched; j++)                                                      *GetPoint(current' j) += delta;                                                  for (int j = lastTouched + 1; j <= endPoint; j++)                                                      *GetPoint(current' j) += delta;                                              }                                          }                                          else                                          {                                              InterpolatePoints(current' original' lastTouched + 1' endPoint' lastTouched' firstTouched);                                              if (firstTouched > 0)                                                  InterpolatePoints(current' original' firstPoint' firstTouched - 1' lastTouched' firstTouched);                                          }                                      }                                  }                              }                          }                          break;                      case OpCode.ISECT:                          {                              // move point P to the intersection of lines A and B                              var b1 = _zp0.GetCurrent(_stack.Pop());                              var b0 = _zp0.GetCurrent(_stack.Pop());                              var a1 = _zp1.GetCurrent(_stack.Pop());                              var a0 = _zp1.GetCurrent(_stack.Pop());                              var index = _stack.Pop();                                // calculate intersection using determinants: https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line                              var da = a0 - a1;                              var db = b0 - b1;                              var den = (da.X * db.Y) - (da.Y * db.X);                              if (Math.Abs(den) <= Epsilon)                              {                                  // parallel lines; spec says to put the ppoint "into the middle of the two lines"                                  _zp2.Current[index].P = (a0 + a1 + b0 + b1) / 4;                              }                              else                              {                                  var t = (a0.X * a1.Y) - (a0.Y * a1.X);                                  var u = (b0.X * b1.Y) - (b0.Y * b1.X);                                  var p = new Vector2(                                      (t * db.X) - (da.X * u)'                                      (t * db.Y) - (da.Y * u)                                  );                                  _zp2.Current[index].P = p / den;                              }                              _zp2.TouchState[index] = TouchState.Both;                          }                          break;                        // ==== STACK MANAGEMENT ====                      case OpCode.DUP: _stack.Duplicate(); break;                      case OpCode.POP: _stack.Pop(); break;                      case OpCode.CLEAR: _stack.Clear(); break;                      case OpCode.SWAP: _stack.Swap(); break;                      case OpCode.DEPTH: _stack.Depth(); break;                      case OpCode.CINDEX: _stack.Copy(); break;                      case OpCode.MINDEX: _stack.Move(); break;                      case OpCode.ROLL: _stack.Roll(); break;                        // ==== FLOW CONTROL ====                      case OpCode.IF:                          {                              // value is false; jump to the next else block or endif marker                              // otherwise' we don't have to do anything; we'll keep executing this block                              if (!_stack.PopBool())                              {                                  int indent = 1;                                  while (indent > 0)                                  {                                      opcode = SkipNext(ref stream);                                      switch (opcode)                                      {                                          case OpCode.IF: indent++; break;                                          case OpCode.EIF: indent--; break;                                          case OpCode.ELSE:                                              if (indent == 1)                                                  indent = 0;                                              break;                                      }                                  }                              }                          }                          break;                      case OpCode.ELSE:                          {                              // assume we hit the true statement of some previous if block                              // if we had hit false' we would have jumped over this                              int indent = 1;                              while (indent > 0)                              {                                  opcode = SkipNext(ref stream);                                  switch (opcode)                                  {                                      case OpCode.IF: indent++; break;                                      case OpCode.EIF: indent--; break;                                  }                              }                          }                          break;                      case OpCode.EIF: /* nothing to do */ break;                      case OpCode.JROT:                      case OpCode.JROF:                          {                              if (_stack.PopBool() == (opcode == OpCode.JROT))                                  stream.Jump(_stack.Pop() - 1);                              else                                  _stack.Pop();    // ignore the offset                          }                          break;                      case OpCode.JMPR: stream.Jump(_stack.Pop() - 1); break;                        // ==== LOGICAL OPS ====                      case OpCode.LT:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a < b);                          }                          break;                      case OpCode.LTEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a <= b);                          }                          break;                      case OpCode.GT:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a > b);                          }                          break;                      case OpCode.GTEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a >= b);                          }                          break;                      case OpCode.EQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a == b);                          }                          break;                      case OpCode.NEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a != b);                          }                          break;                      case OpCode.AND:                          {                              var b = _stack.PopBool();                              var a = _stack.PopBool();                              _stack.Push(a && b);                          }                          break;                      case OpCode.OR:                          {                              var b = _stack.PopBool();                              var a = _stack.PopBool();                              _stack.Push(a || b);                          }                          break;                      case OpCode.NOT: _stack.Push(!_stack.PopBool()); break;                      case OpCode.ODD:                          {                              var value = (int)Round(_stack.PopFloat());                              _stack.Push(value % 2 != 0);                          }                          break;                      case OpCode.EVEN:                          {                              var value = (int)Round(_stack.PopFloat());                              _stack.Push(value % 2 == 0);                          }                          break;                        // ==== ARITHMETIC ====                      case OpCode.ADD:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a + b);                          }                          break;                      case OpCode.SUB:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a - b);                          }                          break;                      case OpCode.DIV:                          {                              var b = _stack.Pop();                              if (b == 0)                                  throw new InvalidFontException("Division by zero.");                                var a = _stack.Pop();                              var result = ((long)a << 6) / b;                              _stack.Push((int)result);                          }                          break;                      case OpCode.MUL:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              var result = ((long)a * b) >> 6;                              _stack.Push((int)result);                          }                          break;                      case OpCode.ABS: _stack.Push(Math.Abs(_stack.Pop())); break;                      case OpCode.NEG: _stack.Push(-_stack.Pop()); break;                      case OpCode.FLOOR: _stack.Push(_stack.Pop() & ~63); break;                      case OpCode.CEILING: _stack.Push((_stack.Pop() + 63) & ~63); break;                      case OpCode.MAX: _stack.Push(Math.Max(_stack.Pop()' _stack.Pop())); break;                      case OpCode.MIN: _stack.Push(Math.Min(_stack.Pop()' _stack.Pop())); break;                        // ==== FUNCTIONS ====                      case OpCode.FDEF:                          {                              if (!allowFunctionDefs || inFunction)                                  throw new InvalidFontException("Can't define functions here.");                                _functions[_stack.Pop()] = stream;                              while (SkipNext(ref stream) != OpCode.ENDF) ;                          }                          break;                      case OpCode.IDEF:                          {                              if (!allowFunctionDefs || inFunction)                                  throw new InvalidFontException("Can't define functions here.");                                _instructionDefs[_stack.Pop()] = stream;                              while (SkipNext(ref stream) != OpCode.ENDF) ;                          }                          break;                      case OpCode.ENDF:                          {                              if (!inFunction)                                  throw new InvalidFontException("Found invalid ENDF marker outside of a function definition.");                              return;                          }                      case OpCode.CALL:                      case OpCode.LOOPCALL:                          {                              _callStackSize++;                              if (_callStackSize > MaxCallStack)                                  throw new InvalidFontException("Stack overflow; infinite recursion?");                                var function = _functions[_stack.Pop()];                              var count = opcode == OpCode.LOOPCALL ? _stack.Pop() : 1;                              for (int i = 0; i < count; i++)                                  Execute(function' true' false);                              _callStackSize--;                          }                          break;                        // ==== ROUNDING ====                      // we don't have "engine compensation" so the variants are unnecessary                      case OpCode.ROUND0:                      case OpCode.ROUND1:                      case OpCode.ROUND2:                      case OpCode.ROUND3: _stack.Push(Round(_stack.PopFloat())); break;                      case OpCode.NROUND0:                      case OpCode.NROUND1:                      case OpCode.NROUND2:                      case OpCode.NROUND3: break;                        // ==== DELTA EXCEPTIONS ====                      case OpCode.DELTAC1:                      case OpCode.DELTAC2:                      case OpCode.DELTAC3:                          {                              var last = _stack.Pop();                              for (int i = 1; i <= last; i++)                              {                                  var cvtIndex = _stack.Pop();                                  var arg = _stack.Pop();                                    // upper 4 bits of the 8-bit arg is the relative ppem                                  // the opcode specifies the base to add to the ppem                                  var triggerPpem = (arg >> 4) & 0xF;                                  triggerPpem += (opcode - OpCode.DELTAC1) * 16;                                  triggerPpem += _state.DeltaBase;                                    // if the current ppem matches the trigger' apply the exception                                  if (_ppem == triggerPpem)                                  {                                      // the lower 4 bits of the arg is the amount to shift                                      // it's encoded such that 0 isn't an allowable value (who wants to shift by 0 anyway?)                                      var amount = (arg & 0xF) - 8;                                      if (amount >= 0)                                          amount++;                                      amount *= 1 << (6 - _state.DeltaShift);                                        // update the CVT                                      CheckIndex(cvtIndex' _controlValueTable.Length);                                      _controlValueTable[cvtIndex] += F26Dot6ToFloat(amount);                                  }                              }                          }                          break;                      case OpCode.DELTAP1:                      case OpCode.DELTAP2:                      case OpCode.DELTAP3:                          {                              var last = _stack.Pop();                              for (int i = 1; i <= last; i++)                              {                                  var pointIndex = _stack.Pop();                                  var arg = _stack.Pop();                                    // upper 4 bits of the 8-bit arg is the relative ppem                                  // the opcode specifies the base to add to the ppem                                  var triggerPpem = (arg >> 4) & 0xF;                                  triggerPpem += _state.DeltaBase;                                  if (opcode != OpCode.DELTAP1)                                      triggerPpem += (opcode - OpCode.DELTAP2 + 1) * 16;                                    // if the current ppem matches the trigger' apply the exception                                  if (_ppem == triggerPpem)                                  {                                      // the lower 4 bits of the arg is the amount to shift                                      // it's encoded such that 0 isn't an allowable value (who wants to shift by 0 anyway?)                                      var amount = (arg & 0xF) - 8;                                      if (amount >= 0)                                          amount++;                                      amount *= 1 << (6 - _state.DeltaShift);                                        MovePoint(_zp0' pointIndex' F26Dot6ToFloat(amount));                                  }                              }                          }                          break;                        // ==== MISCELLANEOUS ====                      case OpCode.DEBUG: _stack.Pop(); break;                      case OpCode.GETINFO:                          {                              var selector = _stack.Pop();                              var result = 0;                              if ((selector & 0x1) != 0)                              {                                  // pretend we are MS Rasterizer v35                                  result = 35;                              }                                // TODO: rotation and stretching                              //if ((selector & 0x2) != 0)                              //if ((selector & 0x4) != 0)                                // we're always rendering in grayscale                              if ((selector & 0x20) != 0)                                  result |= 1 << 12;                                // TODO: ClearType flags                                _stack.Push(result);                          }                          break;                        default:                          if (opcode >= OpCode.MIRP)                              MoveIndirectRelative(opcode - OpCode.MIRP);                          else if (opcode >= OpCode.MDRP)                              MoveDirectRelative(opcode - OpCode.MDRP);                          else                          {                              // check if this is a runtime-defined opcode                              var index = (int)opcode;                              if (index > _instructionDefs.Length || !_instructionDefs[index].IsValid)                                  throw new InvalidFontException("Unknown opcode in font program.");                                _callStackSize++;                              if (_callStackSize > MaxCallStack)                                  throw new InvalidFontException("Stack overflow; infinite recursion?");                                Execute(_instructionDefs[index]' true' false);                              _callStackSize--;                          }                          break;                  }
Magic Number,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,Execute,The following statement contains a magic number: switch (opcode)                  {                      // ==== PUSH INSTRUCTIONS ====                      case OpCode.NPUSHB:                      case OpCode.PUSHB1:                      case OpCode.PUSHB2:                      case OpCode.PUSHB3:                      case OpCode.PUSHB4:                      case OpCode.PUSHB5:                      case OpCode.PUSHB6:                      case OpCode.PUSHB7:                      case OpCode.PUSHB8:                          {                              var count = opcode == OpCode.NPUSHB ? stream.NextByte() : opcode - OpCode.PUSHB1 + 1;                              for (int i = count - 1; i >= 0; --i)                                  _stack.Push(stream.NextByte());                          }                          break;                      case OpCode.NPUSHW:                      case OpCode.PUSHW1:                      case OpCode.PUSHW2:                      case OpCode.PUSHW3:                      case OpCode.PUSHW4:                      case OpCode.PUSHW5:                      case OpCode.PUSHW6:                      case OpCode.PUSHW7:                      case OpCode.PUSHW8:                          {                              var count = opcode == OpCode.NPUSHW ? stream.NextByte() : opcode - OpCode.PUSHW1 + 1;                              for (int i = count - 1; i >= 0; --i)                                  _stack.Push(stream.NextWord());                          }                          break;                        // ==== STORAGE MANAGEMENT ====                      case OpCode.RS:                          {                              var loc = CheckIndex(_stack.Pop()' _storage.Length);                              _stack.Push(_storage[loc]);                          }                          break;                      case OpCode.WS:                          {                              var value = _stack.Pop();                              var loc = CheckIndex(_stack.Pop()' _storage.Length);                              _storage[loc] = value;                          }                          break;                        // ==== CONTROL VALUE TABLE ====                      case OpCode.WCVTP:                          {                              var value = _stack.PopFloat();                              var loc = CheckIndex(_stack.Pop()' _controlValueTable.Length);                              _controlValueTable[loc] = value;                          }                          break;                      case OpCode.WCVTF:                          {                              var value = _stack.Pop();                              var loc = CheckIndex(_stack.Pop()' _controlValueTable.Length);                              _controlValueTable[loc] = value * _scale;                          }                          break;                      case OpCode.RCVT: _stack.Push(ReadCvt()); break;                        // ==== STATE VECTORS ====                      case OpCode.SVTCA0:                      case OpCode.SVTCA1:                          {                              var axis = opcode - OpCode.SVTCA0;                              SetFreedomVectorToAxis(axis);                              SetProjectionVectorToAxis(axis);                          }                          break;                      case OpCode.SFVTPV: _state.Freedom = _state.Projection; OnVectorsUpdated(); break;                      case OpCode.SPVTCA0:                      case OpCode.SPVTCA1: SetProjectionVectorToAxis(opcode - OpCode.SPVTCA0); break;                      case OpCode.SFVTCA0:                      case OpCode.SFVTCA1: SetFreedomVectorToAxis(opcode - OpCode.SFVTCA0); break;                      case OpCode.SPVTL0:                      case OpCode.SPVTL1:                      case OpCode.SFVTL0:                      case OpCode.SFVTL1: SetVectorToLine(opcode - OpCode.SPVTL0' false); break;                      case OpCode.SDPVTL0:                      case OpCode.SDPVTL1: SetVectorToLine(opcode - OpCode.SDPVTL0' true); break;                      case OpCode.SPVFS:                      case OpCode.SFVFS:                          {                              var y = _stack.Pop();                              var x = _stack.Pop();                              var vec = Vector2.Normalize(new Vector2(F2Dot14ToFloat(x)' F2Dot14ToFloat(y)));                              if (opcode == OpCode.SFVFS)                                  _state.Freedom = vec;                              else                              {                                  _state.Projection = vec;                                  _state.DualProjection = vec;                              }                              OnVectorsUpdated();                          }                          break;                      case OpCode.GPV:                      case OpCode.GFV:                          {                              var vec = opcode == OpCode.GPV ? _state.Projection : _state.Freedom;                              _stack.Push(FloatToF2Dot14(vec.X));                              _stack.Push(FloatToF2Dot14(vec.Y));                          }                          break;                        // ==== GRAPHICS STATE ====                      case OpCode.SRP0: _state.Rp0 = _stack.Pop(); break;                      case OpCode.SRP1: _state.Rp1 = _stack.Pop(); break;                      case OpCode.SRP2: _state.Rp2 = _stack.Pop(); break;                      case OpCode.SZP0: _zp0 = GetZoneFromStack(); break;                      case OpCode.SZP1: _zp1 = GetZoneFromStack(); break;                      case OpCode.SZP2: _zp2 = GetZoneFromStack(); break;                      case OpCode.SZPS: _zp0 = _zp1 = _zp2 = GetZoneFromStack(); break;                      case OpCode.RTHG: _state.RoundState = RoundMode.ToHalfGrid; break;                      case OpCode.RTG: _state.RoundState = RoundMode.ToGrid; break;                      case OpCode.RTDG: _state.RoundState = RoundMode.ToDoubleGrid; break;                      case OpCode.RDTG: _state.RoundState = RoundMode.DownToGrid; break;                      case OpCode.RUTG: _state.RoundState = RoundMode.UpToGrid; break;                      case OpCode.ROFF: _state.RoundState = RoundMode.Off; break;                      case OpCode.SROUND: _state.RoundState = RoundMode.Super; SetSuperRound(1.0f); break;                      case OpCode.S45ROUND: _state.RoundState = RoundMode.Super45; SetSuperRound(Sqrt2Over2); break;                      case OpCode.INSTCTRL:                          {                              var selector = _stack.Pop();                              if (selector >= 1 && selector <= 2)                              {                                  // value is false if zero' otherwise shift the right bit into the flags                                  var bit = 1 << (selector - 1);                                  if (_stack.Pop() == 0)                                      _state.InstructionControl = (InstructionControlFlags)((int)_state.InstructionControl & ~bit);                                  else                                      _state.InstructionControl = (InstructionControlFlags)((int)_state.InstructionControl | bit);                              }                          }                          break;                      case OpCode.SCANCTRL: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SCANTYPE: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SANGW: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SLOOP: _state.Loop = _stack.Pop(); break;                      case OpCode.SMD: _state.MinDistance = _stack.PopFloat(); break;                      case OpCode.SCVTCI: _state.ControlValueCutIn = _stack.PopFloat(); break;                      case OpCode.SSWCI: _state.SingleWidthCutIn = _stack.PopFloat(); break;                      case OpCode.SSW: _state.SingleWidthValue = _stack.Pop() * _scale; break;                      case OpCode.FLIPON: _state.AutoFlip = true; break;                      case OpCode.FLIPOFF: _state.AutoFlip = false; break;                      case OpCode.SDB: _state.DeltaBase = _stack.Pop(); break;                      case OpCode.SDS: _state.DeltaShift = _stack.Pop(); break;                        // ==== POINT MEASUREMENT ====                      case OpCode.GC0: _stack.Push(Project(_zp2.GetCurrent(_stack.Pop()))); break;                      case OpCode.GC1: _stack.Push(DualProject(_zp2.GetOriginal(_stack.Pop()))); break;                      case OpCode.SCFS:                          {                              var value = _stack.PopFloat();                              var index = _stack.Pop();                              var point = _zp2.GetCurrent(index);                              MovePoint(_zp2' index' value - Project(point));                                // moving twilight points moves their "original" value also                              if (_zp2.IsTwilight)                                  _zp2.Original[index].P = _zp2.Current[index].P;                          }                          break;                      case OpCode.MD0:                          {                              var p1 = _zp1.GetOriginal(_stack.Pop());                              var p2 = _zp0.GetOriginal(_stack.Pop());                              _stack.Push(DualProject(p2 - p1));                          }                          break;                      case OpCode.MD1:                          {                              var p1 = _zp1.GetCurrent(_stack.Pop());                              var p2 = _zp0.GetCurrent(_stack.Pop());                              _stack.Push(Project(p2 - p1));                          }                          break;                      case OpCode.MPS: // MPS should return point size' but we assume DPI so it's the same as pixel size                      case OpCode.MPPEM: _stack.Push(_ppem); break;                      case OpCode.AA: /* deprecated instruction */ _stack.Pop(); break;                        // ==== POINT MODIFICATION ====                      case OpCode.FLIPPT:                          {                              for (int i = 0; i < _state.Loop; i++)                              {                                  var index = _stack.Pop();                                  //review here again!                                  _points.Current[index].onCurve = !_points.Current[index].onCurve;                                  //if (points.Current[index].onCurve)                                  //    points.Current[index].onCurve = false;                                  //else                                  //    points.Current[index].onCurve = true;                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.FLIPRGON:                          {                              var end = _stack.Pop();                              for (int i = _stack.Pop(); i <= end; i++)                                  //points.Current[i].Type = PointType.OnCurve;                                  _points.Current[i].onCurve = true;                          }                          break;                      case OpCode.FLIPRGOFF:                          {                              var end = _stack.Pop();                              for (int i = _stack.Pop(); i <= end; i++)                                  //points.Current[i].Type = PointType.Quadratic;                                  _points.Current[i].onCurve = false;                          }                          break;                      case OpCode.SHP0:                      case OpCode.SHP1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              ShiftPoints(displacement);                          }                          break;                      case OpCode.SHPIX: ShiftPoints(_stack.PopFloat() * _state.Freedom); break;                      case OpCode.SHC0:                      case OpCode.SHC1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              var touch = GetTouchState();                              var contour = _stack.Pop();                              var start = contour == 0 ? 0 : _contours[contour - 1] + 1;                              var count = _zp2.IsTwilight ? _zp2.Current.Length : _contours[contour] + 1;                                for (int i = start; i < count; i++)                              {                                  // don't move the reference point                                  if (zone.Current != _zp2.Current || point != i)                                  {                                      _zp2.Current[i].P += displacement;                                      _zp2.TouchState[i] |= touch;                                  }                              }                          }                          break;                      case OpCode.SHZ0:                      case OpCode.SHZ1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              var count = 0;                              if (_zp2.IsTwilight)                                  count = _zp2.Current.Length;                              else if (_contours.Length > 0)                                  count = _contours[_contours.Length - 1] + 1;                                for (int i = 0; i < count; i++)                              {                                  // don't move the reference point                                  if (zone.Current != _zp2.Current || point != i)                                      _zp2.Current[i].P += displacement;                              }                          }                          break;                      case OpCode.MIAP0:                      case OpCode.MIAP1:                          {                              var distance = ReadCvt();                              var pointIndex = _stack.Pop();                                // this instruction is used in the CVT to set up twilight points with original values                              if (_zp0.IsTwilight)                              {                                  var original = _state.Freedom * distance;                                  _zp0.Original[pointIndex].P = original;                                  _zp0.Current[pointIndex].P = original;                              }                                // current position of the point along the projection vector                              var point = _zp0.GetCurrent(pointIndex);                              var currentPos = Project(point);                              if (opcode == OpCode.MIAP1)                              {                                  // only use the CVT if we are above the cut-in point                                  if (Math.Abs(distance - currentPos) > _state.ControlValueCutIn)                                      distance = currentPos;                                  distance = Round(distance);                              }                                MovePoint(_zp0' pointIndex' distance - currentPos);                              _state.Rp0 = pointIndex;                              _state.Rp1 = pointIndex;                          }                          break;                      case OpCode.MDAP0:                      case OpCode.MDAP1:                          {                              var pointIndex = _stack.Pop();                              var point = _zp0.GetCurrent(pointIndex);                              var distance = 0.0f;                              if (opcode == OpCode.MDAP1)                              {                                  distance = Project(point);                                  distance = Round(distance) - distance;                              }                                MovePoint(_zp0' pointIndex' distance);                              _state.Rp0 = pointIndex;                              _state.Rp1 = pointIndex;                          }                          break;                      case OpCode.MSIRP0:                      case OpCode.MSIRP1:                          {                              var targetDistance = _stack.PopFloat();                              var pointIndex = _stack.Pop();                                // if we're operating on the twilight zone' initialize the points                              if (_zp1.IsTwilight)                              {                                  _zp1.Original[pointIndex].P = _zp0.Original[_state.Rp0].P + targetDistance * _state.Freedom / _fdotp;                                  _zp1.Current[pointIndex].P = _zp1.Original[pointIndex].P;                              }                                var currentDistance = Project(_zp1.GetCurrent(pointIndex) - _zp0.GetCurrent(_state.Rp0));                              MovePoint(_zp1' pointIndex' targetDistance - currentDistance);                                _state.Rp1 = _state.Rp0;                              _state.Rp2 = pointIndex;                              if (opcode == OpCode.MSIRP1)                                  _state.Rp0 = pointIndex;                          }                          break;                      case OpCode.IP:                          {                              var originalBase = _zp0.GetOriginal(_state.Rp1);                              var currentBase = _zp0.GetCurrent(_state.Rp1);                              var originalRange = DualProject(_zp1.GetOriginal(_state.Rp2) - originalBase);                              var currentRange = Project(_zp1.GetCurrent(_state.Rp2) - currentBase);                                for (int i = 0; i < _state.Loop; i++)                              {                                  var pointIndex = _stack.Pop();                                  var point = _zp2.GetCurrent(pointIndex);                                  var currentDistance = Project(point - currentBase);                                  var originalDistance = DualProject(_zp2.GetOriginal(pointIndex) - originalBase);                                    var newDistance = 0.0f;                                  if (originalDistance != 0.0f)                                  {                                      // a range of 0.0f is invalid according to the spec (would result in a div by zero)                                      if (originalRange == 0.0f)                                          newDistance = originalDistance;                                      else                                          newDistance = originalDistance * currentRange / originalRange;                                  }                                    MovePoint(_zp2' pointIndex' newDistance - currentDistance);                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.ALIGNRP:                          {                              for (int i = 0; i < _state.Loop; i++)                              {                                  var pointIndex = _stack.Pop();                                  var p1 = _zp1.GetCurrent(pointIndex);                                  var p2 = _zp0.GetCurrent(_state.Rp0);                                  MovePoint(_zp1' pointIndex' -Project(p1 - p2));                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.ALIGNPTS:                          {                              var p1 = _stack.Pop();                              var p2 = _stack.Pop();                              var distance = Project(_zp0.GetCurrent(p2) - _zp1.GetCurrent(p1)) / 2;                              MovePoint(_zp1' p1' distance);                              MovePoint(_zp0' p2' -distance);                          }                          break;                      case OpCode.UTP: _zp0.TouchState[_stack.Pop()] &= ~GetTouchState(); break;                      case OpCode.IUP0:                      case OpCode.IUP1:                          // bail if no contours (empty outline)                          if (_contours.Length == 0)                          {                              break;                          }                            //{                            //    //WinterDev's new managed version                          //    GlyphPointF[] currentPnts = points.Current;                          //    GlyphPointF[] originalPnts = points.Original;                            //    int cnt_count = contours.Length;                          //    int point = 0;                          //    // opcode controls whether we care about X or Y direction                          //    // do some pointer trickery so we can operate on the                          //    // points in a direction-agnostic manner                          //    TouchState touchMask;                            //    if (opcode == OpCode.IUP0)                          //    {                          //        //y -axis                          //        touchMask = TouchState.Y;                            //        //                          //        for (int i = 0; i < cnt_count; ++i)                          //        {                          //            int endPoint = contours[i];                          //            int firstPoint = point;                          //            int firstTouched = -1;                          //            int lastTouched = -1;                            //            for (; point <= endPoint; point++)                          //            {                          //                // check whether this point has been touched                          //                if ((points.TouchState[point] & touchMask) != 0)                          //                {                          //                    // if this is the first touched point in the contour' note it and continue                          //                    if (firstTouched < 0)                          //                    {                          //                        firstTouched = point;                          //                        lastTouched = point;                          //                        continue;                          //                    }                            //                    // otherwise' interpolate all untouched points                          //                    // between this point and our last touched point                          //                    InterpolatePointsYAxis(currentPnts' originalPnts' lastTouched + 1' point - 1' lastTouched' point);                          //                    lastTouched = point;                          //                }                          //            }                            //            // check if we had any touched points at all in this contour                          //            if (firstTouched >= 0)                          //            {                          //                // there are two cases left to handle:                          //                // 1. there was only one touched point in the whole contour' in                          //                //    which case we want to shift everything relative to that one                          //                // 2. several touched points' in which case handle the gap from the                          //                //    beginning to the first touched point and the gap from the last                          //                //    touched point to the end of the contour                          //                if (lastTouched == firstTouched)                          //                {                          //                    float delta = currentPnts[lastTouched].Y - originalPnts[lastTouched].Y;                          //                    if (delta != 0.0f)                          //                    {                          //                        for (int n = firstPoint; n < lastTouched; n++)                          //                        {                          //                            currentPnts[n].OffsetY(delta);                          //                        }                          //                        for (int n = lastTouched + 1; n <= endPoint; n++)                          //                        {                          //                            currentPnts[n].OffsetY(delta);                          //                        }                            //                    }                          //                }                          //                else                          //                {                          //                    InterpolatePointsYAxis(currentPnts' originalPnts' lastTouched + 1' endPoint' lastTouched' firstTouched);                          //                    if (firstTouched > 0)                          //                    {                          //                        InterpolatePointsYAxis(currentPnts' originalPnts' firstPoint' firstTouched - 1' lastTouched' firstTouched);                          //                    }                          //                }                          //            }                            //        }                          //    }                          //    else                          //    {                          //        //x-axis                          //        touchMask = TouchState.X;                          //        //                          //        for (int i = 0; i < cnt_count; ++i)                          //        {                          //            int endPoint = contours[i];                          //            int firstPoint = point;                          //            int firstTouched = -1;                          //            int lastTouched = -1;                            //            for (; point <= endPoint; point++)                          //            {                          //                // check whether this point has been touched                          //                if ((points.TouchState[point] & touchMask) != 0)                          //                {                          //                    // if this is the first touched point in the contour' note it and continue                          //                    if (firstTouched < 0)                          //                    {                          //                        firstTouched = point;                          //                        lastTouched = point;                          //                        continue;                          //                    }                            //                    // otherwise' interpolate all untouched points                          //                    // between this point and our last touched point                          //                    InterpolatePointsXAxis(currentPnts' originalPnts' lastTouched + 1' point - 1' lastTouched' point);                          //                    lastTouched = point;                          //                }                          //            }                            //            // check if we had any touched points at all in this contour                          //            if (firstTouched >= 0)                          //            {                          //                // there are two cases left to handle:                          //                // 1. there was only one touched point in the whole contour' in                          //                //    which case we want to shift everything relative to that one                          //                // 2. several touched points' in which case handle the gap from the                          //                //    beginning to the first touched point and the gap from the last                          //                //    touched point to the end of the contour                          //                if (lastTouched == firstTouched)                          //                {                          //                    float delta = currentPnts[lastTouched].X - originalPnts[lastTouched].X;                          //                    if (delta != 0.0f)                          //                    {                          //                        for (int n = firstPoint; n < lastTouched; ++n)                          //                        {                          //                            currentPnts[n].OffsetX(delta);                          //                        }                          //                        for (int n = lastTouched + 1; n <= endPoint; ++n)                          //                        {                          //                            currentPnts[n].OffsetX(delta);                          //                        }                          //                    }                          //                }                          //                else                          //                {                          //                    InterpolatePointsXAxis(currentPnts' originalPnts' lastTouched + 1' endPoint' lastTouched' firstTouched);                          //                    if (firstTouched > 0)                          //                    {                          //                        InterpolatePointsXAxis(currentPnts' originalPnts' firstPoint' firstTouched - 1' lastTouched' firstTouched);                          //                    }                          //                }                          //            }                          //        }                          //    }                          //}                          //-----------------------------------------                          unsafe                          {                                //unsafe version                               //TODO: provide manage version                               fixed (GlyphPointF* currentPtr = _points.Current)                              fixed (GlyphPointF* originalPtr = _points.Original)                              {                                  // opcode controls whether we care about X or Y direction                                  // do some pointer trickery so we can operate on the                                  // points in a direction-agnostic manner                                  TouchState touchMask;                                  byte* current;                                  byte* original;                                  if (opcode == OpCode.IUP0)                                  {                                      touchMask = TouchState.Y;                                      current = (byte*)&currentPtr->P.Y;                                      original = (byte*)&originalPtr->P.Y;                                  }                                  else                                  {                                      touchMask = TouchState.X;                                      current = (byte*)&currentPtr->P.X;                                      original = (byte*)&originalPtr->P.X;                                  }                                    var point = 0;                                  for (int i = 0; i < _contours.Length; i++)                                  {                                      var endPoint = _contours[i];                                      var firstPoint = point;                                      var firstTouched = -1;                                      var lastTouched = -1;                                        for (; point <= endPoint; point++)                                      {                                          // check whether this point has been touched                                          if ((_points.TouchState[point] & touchMask) != 0)                                          {                                              // if this is the first touched point in the contour' note it and continue                                              if (firstTouched < 0)                                              {                                                  firstTouched = point;                                                  lastTouched = point;                                                  continue;                                              }                                                // otherwise' interpolate all untouched points                                              // between this point and our last touched point                                              InterpolatePoints(current' original' lastTouched + 1' point - 1' lastTouched' point);                                              lastTouched = point;                                          }                                      }                                        // check if we had any touched points at all in this contour                                      if (firstTouched >= 0)                                      {                                          // there are two cases left to handle:                                          // 1. there was only one touched point in the whole contour' in                                          //    which case we want to shift everything relative to that one                                          // 2. several touched points' in which case handle the gap from the                                          //    beginning to the first touched point and the gap from the last                                          //    touched point to the end of the contour                                          if (lastTouched == firstTouched)                                          {                                              var delta = *GetPoint(current' lastTouched) - *GetPoint(original' lastTouched);                                              if (delta != 0.0f)                                              {                                                  for (int j = firstPoint; j < lastTouched; j++)                                                      *GetPoint(current' j) += delta;                                                  for (int j = lastTouched + 1; j <= endPoint; j++)                                                      *GetPoint(current' j) += delta;                                              }                                          }                                          else                                          {                                              InterpolatePoints(current' original' lastTouched + 1' endPoint' lastTouched' firstTouched);                                              if (firstTouched > 0)                                                  InterpolatePoints(current' original' firstPoint' firstTouched - 1' lastTouched' firstTouched);                                          }                                      }                                  }                              }                          }                          break;                      case OpCode.ISECT:                          {                              // move point P to the intersection of lines A and B                              var b1 = _zp0.GetCurrent(_stack.Pop());                              var b0 = _zp0.GetCurrent(_stack.Pop());                              var a1 = _zp1.GetCurrent(_stack.Pop());                              var a0 = _zp1.GetCurrent(_stack.Pop());                              var index = _stack.Pop();                                // calculate intersection using determinants: https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line                              var da = a0 - a1;                              var db = b0 - b1;                              var den = (da.X * db.Y) - (da.Y * db.X);                              if (Math.Abs(den) <= Epsilon)                              {                                  // parallel lines; spec says to put the ppoint "into the middle of the two lines"                                  _zp2.Current[index].P = (a0 + a1 + b0 + b1) / 4;                              }                              else                              {                                  var t = (a0.X * a1.Y) - (a0.Y * a1.X);                                  var u = (b0.X * b1.Y) - (b0.Y * b1.X);                                  var p = new Vector2(                                      (t * db.X) - (da.X * u)'                                      (t * db.Y) - (da.Y * u)                                  );                                  _zp2.Current[index].P = p / den;                              }                              _zp2.TouchState[index] = TouchState.Both;                          }                          break;                        // ==== STACK MANAGEMENT ====                      case OpCode.DUP: _stack.Duplicate(); break;                      case OpCode.POP: _stack.Pop(); break;                      case OpCode.CLEAR: _stack.Clear(); break;                      case OpCode.SWAP: _stack.Swap(); break;                      case OpCode.DEPTH: _stack.Depth(); break;                      case OpCode.CINDEX: _stack.Copy(); break;                      case OpCode.MINDEX: _stack.Move(); break;                      case OpCode.ROLL: _stack.Roll(); break;                        // ==== FLOW CONTROL ====                      case OpCode.IF:                          {                              // value is false; jump to the next else block or endif marker                              // otherwise' we don't have to do anything; we'll keep executing this block                              if (!_stack.PopBool())                              {                                  int indent = 1;                                  while (indent > 0)                                  {                                      opcode = SkipNext(ref stream);                                      switch (opcode)                                      {                                          case OpCode.IF: indent++; break;                                          case OpCode.EIF: indent--; break;                                          case OpCode.ELSE:                                              if (indent == 1)                                                  indent = 0;                                              break;                                      }                                  }                              }                          }                          break;                      case OpCode.ELSE:                          {                              // assume we hit the true statement of some previous if block                              // if we had hit false' we would have jumped over this                              int indent = 1;                              while (indent > 0)                              {                                  opcode = SkipNext(ref stream);                                  switch (opcode)                                  {                                      case OpCode.IF: indent++; break;                                      case OpCode.EIF: indent--; break;                                  }                              }                          }                          break;                      case OpCode.EIF: /* nothing to do */ break;                      case OpCode.JROT:                      case OpCode.JROF:                          {                              if (_stack.PopBool() == (opcode == OpCode.JROT))                                  stream.Jump(_stack.Pop() - 1);                              else                                  _stack.Pop();    // ignore the offset                          }                          break;                      case OpCode.JMPR: stream.Jump(_stack.Pop() - 1); break;                        // ==== LOGICAL OPS ====                      case OpCode.LT:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a < b);                          }                          break;                      case OpCode.LTEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a <= b);                          }                          break;                      case OpCode.GT:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a > b);                          }                          break;                      case OpCode.GTEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a >= b);                          }                          break;                      case OpCode.EQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a == b);                          }                          break;                      case OpCode.NEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a != b);                          }                          break;                      case OpCode.AND:                          {                              var b = _stack.PopBool();                              var a = _stack.PopBool();                              _stack.Push(a && b);                          }                          break;                      case OpCode.OR:                          {                              var b = _stack.PopBool();                              var a = _stack.PopBool();                              _stack.Push(a || b);                          }                          break;                      case OpCode.NOT: _stack.Push(!_stack.PopBool()); break;                      case OpCode.ODD:                          {                              var value = (int)Round(_stack.PopFloat());                              _stack.Push(value % 2 != 0);                          }                          break;                      case OpCode.EVEN:                          {                              var value = (int)Round(_stack.PopFloat());                              _stack.Push(value % 2 == 0);                          }                          break;                        // ==== ARITHMETIC ====                      case OpCode.ADD:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a + b);                          }                          break;                      case OpCode.SUB:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a - b);                          }                          break;                      case OpCode.DIV:                          {                              var b = _stack.Pop();                              if (b == 0)                                  throw new InvalidFontException("Division by zero.");                                var a = _stack.Pop();                              var result = ((long)a << 6) / b;                              _stack.Push((int)result);                          }                          break;                      case OpCode.MUL:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              var result = ((long)a * b) >> 6;                              _stack.Push((int)result);                          }                          break;                      case OpCode.ABS: _stack.Push(Math.Abs(_stack.Pop())); break;                      case OpCode.NEG: _stack.Push(-_stack.Pop()); break;                      case OpCode.FLOOR: _stack.Push(_stack.Pop() & ~63); break;                      case OpCode.CEILING: _stack.Push((_stack.Pop() + 63) & ~63); break;                      case OpCode.MAX: _stack.Push(Math.Max(_stack.Pop()' _stack.Pop())); break;                      case OpCode.MIN: _stack.Push(Math.Min(_stack.Pop()' _stack.Pop())); break;                        // ==== FUNCTIONS ====                      case OpCode.FDEF:                          {                              if (!allowFunctionDefs || inFunction)                                  throw new InvalidFontException("Can't define functions here.");                                _functions[_stack.Pop()] = stream;                              while (SkipNext(ref stream) != OpCode.ENDF) ;                          }                          break;                      case OpCode.IDEF:                          {                              if (!allowFunctionDefs || inFunction)                                  throw new InvalidFontException("Can't define functions here.");                                _instructionDefs[_stack.Pop()] = stream;                              while (SkipNext(ref stream) != OpCode.ENDF) ;                          }                          break;                      case OpCode.ENDF:                          {                              if (!inFunction)                                  throw new InvalidFontException("Found invalid ENDF marker outside of a function definition.");                              return;                          }                      case OpCode.CALL:                      case OpCode.LOOPCALL:                          {                              _callStackSize++;                              if (_callStackSize > MaxCallStack)                                  throw new InvalidFontException("Stack overflow; infinite recursion?");                                var function = _functions[_stack.Pop()];                              var count = opcode == OpCode.LOOPCALL ? _stack.Pop() : 1;                              for (int i = 0; i < count; i++)                                  Execute(function' true' false);                              _callStackSize--;                          }                          break;                        // ==== ROUNDING ====                      // we don't have "engine compensation" so the variants are unnecessary                      case OpCode.ROUND0:                      case OpCode.ROUND1:                      case OpCode.ROUND2:                      case OpCode.ROUND3: _stack.Push(Round(_stack.PopFloat())); break;                      case OpCode.NROUND0:                      case OpCode.NROUND1:                      case OpCode.NROUND2:                      case OpCode.NROUND3: break;                        // ==== DELTA EXCEPTIONS ====                      case OpCode.DELTAC1:                      case OpCode.DELTAC2:                      case OpCode.DELTAC3:                          {                              var last = _stack.Pop();                              for (int i = 1; i <= last; i++)                              {                                  var cvtIndex = _stack.Pop();                                  var arg = _stack.Pop();                                    // upper 4 bits of the 8-bit arg is the relative ppem                                  // the opcode specifies the base to add to the ppem                                  var triggerPpem = (arg >> 4) & 0xF;                                  triggerPpem += (opcode - OpCode.DELTAC1) * 16;                                  triggerPpem += _state.DeltaBase;                                    // if the current ppem matches the trigger' apply the exception                                  if (_ppem == triggerPpem)                                  {                                      // the lower 4 bits of the arg is the amount to shift                                      // it's encoded such that 0 isn't an allowable value (who wants to shift by 0 anyway?)                                      var amount = (arg & 0xF) - 8;                                      if (amount >= 0)                                          amount++;                                      amount *= 1 << (6 - _state.DeltaShift);                                        // update the CVT                                      CheckIndex(cvtIndex' _controlValueTable.Length);                                      _controlValueTable[cvtIndex] += F26Dot6ToFloat(amount);                                  }                              }                          }                          break;                      case OpCode.DELTAP1:                      case OpCode.DELTAP2:                      case OpCode.DELTAP3:                          {                              var last = _stack.Pop();                              for (int i = 1; i <= last; i++)                              {                                  var pointIndex = _stack.Pop();                                  var arg = _stack.Pop();                                    // upper 4 bits of the 8-bit arg is the relative ppem                                  // the opcode specifies the base to add to the ppem                                  var triggerPpem = (arg >> 4) & 0xF;                                  triggerPpem += _state.DeltaBase;                                  if (opcode != OpCode.DELTAP1)                                      triggerPpem += (opcode - OpCode.DELTAP2 + 1) * 16;                                    // if the current ppem matches the trigger' apply the exception                                  if (_ppem == triggerPpem)                                  {                                      // the lower 4 bits of the arg is the amount to shift                                      // it's encoded such that 0 isn't an allowable value (who wants to shift by 0 anyway?)                                      var amount = (arg & 0xF) - 8;                                      if (amount >= 0)                                          amount++;                                      amount *= 1 << (6 - _state.DeltaShift);                                        MovePoint(_zp0' pointIndex' F26Dot6ToFloat(amount));                                  }                              }                          }                          break;                        // ==== MISCELLANEOUS ====                      case OpCode.DEBUG: _stack.Pop(); break;                      case OpCode.GETINFO:                          {                              var selector = _stack.Pop();                              var result = 0;                              if ((selector & 0x1) != 0)                              {                                  // pretend we are MS Rasterizer v35                                  result = 35;                              }                                // TODO: rotation and stretching                              //if ((selector & 0x2) != 0)                              //if ((selector & 0x4) != 0)                                // we're always rendering in grayscale                              if ((selector & 0x20) != 0)                                  result |= 1 << 12;                                // TODO: ClearType flags                                _stack.Push(result);                          }                          break;                        default:                          if (opcode >= OpCode.MIRP)                              MoveIndirectRelative(opcode - OpCode.MIRP);                          else if (opcode >= OpCode.MDRP)                              MoveDirectRelative(opcode - OpCode.MDRP);                          else                          {                              // check if this is a runtime-defined opcode                              var index = (int)opcode;                              if (index > _instructionDefs.Length || !_instructionDefs[index].IsValid)                                  throw new InvalidFontException("Unknown opcode in font program.");                                _callStackSize++;                              if (_callStackSize > MaxCallStack)                                  throw new InvalidFontException("Stack overflow; infinite recursion?");                                Execute(_instructionDefs[index]' true' false);                              _callStackSize--;                          }                          break;                  }
Magic Number,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,Execute,The following statement contains a magic number: switch (opcode)                  {                      // ==== PUSH INSTRUCTIONS ====                      case OpCode.NPUSHB:                      case OpCode.PUSHB1:                      case OpCode.PUSHB2:                      case OpCode.PUSHB3:                      case OpCode.PUSHB4:                      case OpCode.PUSHB5:                      case OpCode.PUSHB6:                      case OpCode.PUSHB7:                      case OpCode.PUSHB8:                          {                              var count = opcode == OpCode.NPUSHB ? stream.NextByte() : opcode - OpCode.PUSHB1 + 1;                              for (int i = count - 1; i >= 0; --i)                                  _stack.Push(stream.NextByte());                          }                          break;                      case OpCode.NPUSHW:                      case OpCode.PUSHW1:                      case OpCode.PUSHW2:                      case OpCode.PUSHW3:                      case OpCode.PUSHW4:                      case OpCode.PUSHW5:                      case OpCode.PUSHW6:                      case OpCode.PUSHW7:                      case OpCode.PUSHW8:                          {                              var count = opcode == OpCode.NPUSHW ? stream.NextByte() : opcode - OpCode.PUSHW1 + 1;                              for (int i = count - 1; i >= 0; --i)                                  _stack.Push(stream.NextWord());                          }                          break;                        // ==== STORAGE MANAGEMENT ====                      case OpCode.RS:                          {                              var loc = CheckIndex(_stack.Pop()' _storage.Length);                              _stack.Push(_storage[loc]);                          }                          break;                      case OpCode.WS:                          {                              var value = _stack.Pop();                              var loc = CheckIndex(_stack.Pop()' _storage.Length);                              _storage[loc] = value;                          }                          break;                        // ==== CONTROL VALUE TABLE ====                      case OpCode.WCVTP:                          {                              var value = _stack.PopFloat();                              var loc = CheckIndex(_stack.Pop()' _controlValueTable.Length);                              _controlValueTable[loc] = value;                          }                          break;                      case OpCode.WCVTF:                          {                              var value = _stack.Pop();                              var loc = CheckIndex(_stack.Pop()' _controlValueTable.Length);                              _controlValueTable[loc] = value * _scale;                          }                          break;                      case OpCode.RCVT: _stack.Push(ReadCvt()); break;                        // ==== STATE VECTORS ====                      case OpCode.SVTCA0:                      case OpCode.SVTCA1:                          {                              var axis = opcode - OpCode.SVTCA0;                              SetFreedomVectorToAxis(axis);                              SetProjectionVectorToAxis(axis);                          }                          break;                      case OpCode.SFVTPV: _state.Freedom = _state.Projection; OnVectorsUpdated(); break;                      case OpCode.SPVTCA0:                      case OpCode.SPVTCA1: SetProjectionVectorToAxis(opcode - OpCode.SPVTCA0); break;                      case OpCode.SFVTCA0:                      case OpCode.SFVTCA1: SetFreedomVectorToAxis(opcode - OpCode.SFVTCA0); break;                      case OpCode.SPVTL0:                      case OpCode.SPVTL1:                      case OpCode.SFVTL0:                      case OpCode.SFVTL1: SetVectorToLine(opcode - OpCode.SPVTL0' false); break;                      case OpCode.SDPVTL0:                      case OpCode.SDPVTL1: SetVectorToLine(opcode - OpCode.SDPVTL0' true); break;                      case OpCode.SPVFS:                      case OpCode.SFVFS:                          {                              var y = _stack.Pop();                              var x = _stack.Pop();                              var vec = Vector2.Normalize(new Vector2(F2Dot14ToFloat(x)' F2Dot14ToFloat(y)));                              if (opcode == OpCode.SFVFS)                                  _state.Freedom = vec;                              else                              {                                  _state.Projection = vec;                                  _state.DualProjection = vec;                              }                              OnVectorsUpdated();                          }                          break;                      case OpCode.GPV:                      case OpCode.GFV:                          {                              var vec = opcode == OpCode.GPV ? _state.Projection : _state.Freedom;                              _stack.Push(FloatToF2Dot14(vec.X));                              _stack.Push(FloatToF2Dot14(vec.Y));                          }                          break;                        // ==== GRAPHICS STATE ====                      case OpCode.SRP0: _state.Rp0 = _stack.Pop(); break;                      case OpCode.SRP1: _state.Rp1 = _stack.Pop(); break;                      case OpCode.SRP2: _state.Rp2 = _stack.Pop(); break;                      case OpCode.SZP0: _zp0 = GetZoneFromStack(); break;                      case OpCode.SZP1: _zp1 = GetZoneFromStack(); break;                      case OpCode.SZP2: _zp2 = GetZoneFromStack(); break;                      case OpCode.SZPS: _zp0 = _zp1 = _zp2 = GetZoneFromStack(); break;                      case OpCode.RTHG: _state.RoundState = RoundMode.ToHalfGrid; break;                      case OpCode.RTG: _state.RoundState = RoundMode.ToGrid; break;                      case OpCode.RTDG: _state.RoundState = RoundMode.ToDoubleGrid; break;                      case OpCode.RDTG: _state.RoundState = RoundMode.DownToGrid; break;                      case OpCode.RUTG: _state.RoundState = RoundMode.UpToGrid; break;                      case OpCode.ROFF: _state.RoundState = RoundMode.Off; break;                      case OpCode.SROUND: _state.RoundState = RoundMode.Super; SetSuperRound(1.0f); break;                      case OpCode.S45ROUND: _state.RoundState = RoundMode.Super45; SetSuperRound(Sqrt2Over2); break;                      case OpCode.INSTCTRL:                          {                              var selector = _stack.Pop();                              if (selector >= 1 && selector <= 2)                              {                                  // value is false if zero' otherwise shift the right bit into the flags                                  var bit = 1 << (selector - 1);                                  if (_stack.Pop() == 0)                                      _state.InstructionControl = (InstructionControlFlags)((int)_state.InstructionControl & ~bit);                                  else                                      _state.InstructionControl = (InstructionControlFlags)((int)_state.InstructionControl | bit);                              }                          }                          break;                      case OpCode.SCANCTRL: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SCANTYPE: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SANGW: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SLOOP: _state.Loop = _stack.Pop(); break;                      case OpCode.SMD: _state.MinDistance = _stack.PopFloat(); break;                      case OpCode.SCVTCI: _state.ControlValueCutIn = _stack.PopFloat(); break;                      case OpCode.SSWCI: _state.SingleWidthCutIn = _stack.PopFloat(); break;                      case OpCode.SSW: _state.SingleWidthValue = _stack.Pop() * _scale; break;                      case OpCode.FLIPON: _state.AutoFlip = true; break;                      case OpCode.FLIPOFF: _state.AutoFlip = false; break;                      case OpCode.SDB: _state.DeltaBase = _stack.Pop(); break;                      case OpCode.SDS: _state.DeltaShift = _stack.Pop(); break;                        // ==== POINT MEASUREMENT ====                      case OpCode.GC0: _stack.Push(Project(_zp2.GetCurrent(_stack.Pop()))); break;                      case OpCode.GC1: _stack.Push(DualProject(_zp2.GetOriginal(_stack.Pop()))); break;                      case OpCode.SCFS:                          {                              var value = _stack.PopFloat();                              var index = _stack.Pop();                              var point = _zp2.GetCurrent(index);                              MovePoint(_zp2' index' value - Project(point));                                // moving twilight points moves their "original" value also                              if (_zp2.IsTwilight)                                  _zp2.Original[index].P = _zp2.Current[index].P;                          }                          break;                      case OpCode.MD0:                          {                              var p1 = _zp1.GetOriginal(_stack.Pop());                              var p2 = _zp0.GetOriginal(_stack.Pop());                              _stack.Push(DualProject(p2 - p1));                          }                          break;                      case OpCode.MD1:                          {                              var p1 = _zp1.GetCurrent(_stack.Pop());                              var p2 = _zp0.GetCurrent(_stack.Pop());                              _stack.Push(Project(p2 - p1));                          }                          break;                      case OpCode.MPS: // MPS should return point size' but we assume DPI so it's the same as pixel size                      case OpCode.MPPEM: _stack.Push(_ppem); break;                      case OpCode.AA: /* deprecated instruction */ _stack.Pop(); break;                        // ==== POINT MODIFICATION ====                      case OpCode.FLIPPT:                          {                              for (int i = 0; i < _state.Loop; i++)                              {                                  var index = _stack.Pop();                                  //review here again!                                  _points.Current[index].onCurve = !_points.Current[index].onCurve;                                  //if (points.Current[index].onCurve)                                  //    points.Current[index].onCurve = false;                                  //else                                  //    points.Current[index].onCurve = true;                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.FLIPRGON:                          {                              var end = _stack.Pop();                              for (int i = _stack.Pop(); i <= end; i++)                                  //points.Current[i].Type = PointType.OnCurve;                                  _points.Current[i].onCurve = true;                          }                          break;                      case OpCode.FLIPRGOFF:                          {                              var end = _stack.Pop();                              for (int i = _stack.Pop(); i <= end; i++)                                  //points.Current[i].Type = PointType.Quadratic;                                  _points.Current[i].onCurve = false;                          }                          break;                      case OpCode.SHP0:                      case OpCode.SHP1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              ShiftPoints(displacement);                          }                          break;                      case OpCode.SHPIX: ShiftPoints(_stack.PopFloat() * _state.Freedom); break;                      case OpCode.SHC0:                      case OpCode.SHC1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              var touch = GetTouchState();                              var contour = _stack.Pop();                              var start = contour == 0 ? 0 : _contours[contour - 1] + 1;                              var count = _zp2.IsTwilight ? _zp2.Current.Length : _contours[contour] + 1;                                for (int i = start; i < count; i++)                              {                                  // don't move the reference point                                  if (zone.Current != _zp2.Current || point != i)                                  {                                      _zp2.Current[i].P += displacement;                                      _zp2.TouchState[i] |= touch;                                  }                              }                          }                          break;                      case OpCode.SHZ0:                      case OpCode.SHZ1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              var count = 0;                              if (_zp2.IsTwilight)                                  count = _zp2.Current.Length;                              else if (_contours.Length > 0)                                  count = _contours[_contours.Length - 1] + 1;                                for (int i = 0; i < count; i++)                              {                                  // don't move the reference point                                  if (zone.Current != _zp2.Current || point != i)                                      _zp2.Current[i].P += displacement;                              }                          }                          break;                      case OpCode.MIAP0:                      case OpCode.MIAP1:                          {                              var distance = ReadCvt();                              var pointIndex = _stack.Pop();                                // this instruction is used in the CVT to set up twilight points with original values                              if (_zp0.IsTwilight)                              {                                  var original = _state.Freedom * distance;                                  _zp0.Original[pointIndex].P = original;                                  _zp0.Current[pointIndex].P = original;                              }                                // current position of the point along the projection vector                              var point = _zp0.GetCurrent(pointIndex);                              var currentPos = Project(point);                              if (opcode == OpCode.MIAP1)                              {                                  // only use the CVT if we are above the cut-in point                                  if (Math.Abs(distance - currentPos) > _state.ControlValueCutIn)                                      distance = currentPos;                                  distance = Round(distance);                              }                                MovePoint(_zp0' pointIndex' distance - currentPos);                              _state.Rp0 = pointIndex;                              _state.Rp1 = pointIndex;                          }                          break;                      case OpCode.MDAP0:                      case OpCode.MDAP1:                          {                              var pointIndex = _stack.Pop();                              var point = _zp0.GetCurrent(pointIndex);                              var distance = 0.0f;                              if (opcode == OpCode.MDAP1)                              {                                  distance = Project(point);                                  distance = Round(distance) - distance;                              }                                MovePoint(_zp0' pointIndex' distance);                              _state.Rp0 = pointIndex;                              _state.Rp1 = pointIndex;                          }                          break;                      case OpCode.MSIRP0:                      case OpCode.MSIRP1:                          {                              var targetDistance = _stack.PopFloat();                              var pointIndex = _stack.Pop();                                // if we're operating on the twilight zone' initialize the points                              if (_zp1.IsTwilight)                              {                                  _zp1.Original[pointIndex].P = _zp0.Original[_state.Rp0].P + targetDistance * _state.Freedom / _fdotp;                                  _zp1.Current[pointIndex].P = _zp1.Original[pointIndex].P;                              }                                var currentDistance = Project(_zp1.GetCurrent(pointIndex) - _zp0.GetCurrent(_state.Rp0));                              MovePoint(_zp1' pointIndex' targetDistance - currentDistance);                                _state.Rp1 = _state.Rp0;                              _state.Rp2 = pointIndex;                              if (opcode == OpCode.MSIRP1)                                  _state.Rp0 = pointIndex;                          }                          break;                      case OpCode.IP:                          {                              var originalBase = _zp0.GetOriginal(_state.Rp1);                              var currentBase = _zp0.GetCurrent(_state.Rp1);                              var originalRange = DualProject(_zp1.GetOriginal(_state.Rp2) - originalBase);                              var currentRange = Project(_zp1.GetCurrent(_state.Rp2) - currentBase);                                for (int i = 0; i < _state.Loop; i++)                              {                                  var pointIndex = _stack.Pop();                                  var point = _zp2.GetCurrent(pointIndex);                                  var currentDistance = Project(point - currentBase);                                  var originalDistance = DualProject(_zp2.GetOriginal(pointIndex) - originalBase);                                    var newDistance = 0.0f;                                  if (originalDistance != 0.0f)                                  {                                      // a range of 0.0f is invalid according to the spec (would result in a div by zero)                                      if (originalRange == 0.0f)                                          newDistance = originalDistance;                                      else                                          newDistance = originalDistance * currentRange / originalRange;                                  }                                    MovePoint(_zp2' pointIndex' newDistance - currentDistance);                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.ALIGNRP:                          {                              for (int i = 0; i < _state.Loop; i++)                              {                                  var pointIndex = _stack.Pop();                                  var p1 = _zp1.GetCurrent(pointIndex);                                  var p2 = _zp0.GetCurrent(_state.Rp0);                                  MovePoint(_zp1' pointIndex' -Project(p1 - p2));                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.ALIGNPTS:                          {                              var p1 = _stack.Pop();                              var p2 = _stack.Pop();                              var distance = Project(_zp0.GetCurrent(p2) - _zp1.GetCurrent(p1)) / 2;                              MovePoint(_zp1' p1' distance);                              MovePoint(_zp0' p2' -distance);                          }                          break;                      case OpCode.UTP: _zp0.TouchState[_stack.Pop()] &= ~GetTouchState(); break;                      case OpCode.IUP0:                      case OpCode.IUP1:                          // bail if no contours (empty outline)                          if (_contours.Length == 0)                          {                              break;                          }                            //{                            //    //WinterDev's new managed version                          //    GlyphPointF[] currentPnts = points.Current;                          //    GlyphPointF[] originalPnts = points.Original;                            //    int cnt_count = contours.Length;                          //    int point = 0;                          //    // opcode controls whether we care about X or Y direction                          //    // do some pointer trickery so we can operate on the                          //    // points in a direction-agnostic manner                          //    TouchState touchMask;                            //    if (opcode == OpCode.IUP0)                          //    {                          //        //y -axis                          //        touchMask = TouchState.Y;                            //        //                          //        for (int i = 0; i < cnt_count; ++i)                          //        {                          //            int endPoint = contours[i];                          //            int firstPoint = point;                          //            int firstTouched = -1;                          //            int lastTouched = -1;                            //            for (; point <= endPoint; point++)                          //            {                          //                // check whether this point has been touched                          //                if ((points.TouchState[point] & touchMask) != 0)                          //                {                          //                    // if this is the first touched point in the contour' note it and continue                          //                    if (firstTouched < 0)                          //                    {                          //                        firstTouched = point;                          //                        lastTouched = point;                          //                        continue;                          //                    }                            //                    // otherwise' interpolate all untouched points                          //                    // between this point and our last touched point                          //                    InterpolatePointsYAxis(currentPnts' originalPnts' lastTouched + 1' point - 1' lastTouched' point);                          //                    lastTouched = point;                          //                }                          //            }                            //            // check if we had any touched points at all in this contour                          //            if (firstTouched >= 0)                          //            {                          //                // there are two cases left to handle:                          //                // 1. there was only one touched point in the whole contour' in                          //                //    which case we want to shift everything relative to that one                          //                // 2. several touched points' in which case handle the gap from the                          //                //    beginning to the first touched point and the gap from the last                          //                //    touched point to the end of the contour                          //                if (lastTouched == firstTouched)                          //                {                          //                    float delta = currentPnts[lastTouched].Y - originalPnts[lastTouched].Y;                          //                    if (delta != 0.0f)                          //                    {                          //                        for (int n = firstPoint; n < lastTouched; n++)                          //                        {                          //                            currentPnts[n].OffsetY(delta);                          //                        }                          //                        for (int n = lastTouched + 1; n <= endPoint; n++)                          //                        {                          //                            currentPnts[n].OffsetY(delta);                          //                        }                            //                    }                          //                }                          //                else                          //                {                          //                    InterpolatePointsYAxis(currentPnts' originalPnts' lastTouched + 1' endPoint' lastTouched' firstTouched);                          //                    if (firstTouched > 0)                          //                    {                          //                        InterpolatePointsYAxis(currentPnts' originalPnts' firstPoint' firstTouched - 1' lastTouched' firstTouched);                          //                    }                          //                }                          //            }                            //        }                          //    }                          //    else                          //    {                          //        //x-axis                          //        touchMask = TouchState.X;                          //        //                          //        for (int i = 0; i < cnt_count; ++i)                          //        {                          //            int endPoint = contours[i];                          //            int firstPoint = point;                          //            int firstTouched = -1;                          //            int lastTouched = -1;                            //            for (; point <= endPoint; point++)                          //            {                          //                // check whether this point has been touched                          //                if ((points.TouchState[point] & touchMask) != 0)                          //                {                          //                    // if this is the first touched point in the contour' note it and continue                          //                    if (firstTouched < 0)                          //                    {                          //                        firstTouched = point;                          //                        lastTouched = point;                          //                        continue;                          //                    }                            //                    // otherwise' interpolate all untouched points                          //                    // between this point and our last touched point                          //                    InterpolatePointsXAxis(currentPnts' originalPnts' lastTouched + 1' point - 1' lastTouched' point);                          //                    lastTouched = point;                          //                }                          //            }                            //            // check if we had any touched points at all in this contour                          //            if (firstTouched >= 0)                          //            {                          //                // there are two cases left to handle:                          //                // 1. there was only one touched point in the whole contour' in                          //                //    which case we want to shift everything relative to that one                          //                // 2. several touched points' in which case handle the gap from the                          //                //    beginning to the first touched point and the gap from the last                          //                //    touched point to the end of the contour                          //                if (lastTouched == firstTouched)                          //                {                          //                    float delta = currentPnts[lastTouched].X - originalPnts[lastTouched].X;                          //                    if (delta != 0.0f)                          //                    {                          //                        for (int n = firstPoint; n < lastTouched; ++n)                          //                        {                          //                            currentPnts[n].OffsetX(delta);                          //                        }                          //                        for (int n = lastTouched + 1; n <= endPoint; ++n)                          //                        {                          //                            currentPnts[n].OffsetX(delta);                          //                        }                          //                    }                          //                }                          //                else                          //                {                          //                    InterpolatePointsXAxis(currentPnts' originalPnts' lastTouched + 1' endPoint' lastTouched' firstTouched);                          //                    if (firstTouched > 0)                          //                    {                          //                        InterpolatePointsXAxis(currentPnts' originalPnts' firstPoint' firstTouched - 1' lastTouched' firstTouched);                          //                    }                          //                }                          //            }                          //        }                          //    }                          //}                          //-----------------------------------------                          unsafe                          {                                //unsafe version                               //TODO: provide manage version                               fixed (GlyphPointF* currentPtr = _points.Current)                              fixed (GlyphPointF* originalPtr = _points.Original)                              {                                  // opcode controls whether we care about X or Y direction                                  // do some pointer trickery so we can operate on the                                  // points in a direction-agnostic manner                                  TouchState touchMask;                                  byte* current;                                  byte* original;                                  if (opcode == OpCode.IUP0)                                  {                                      touchMask = TouchState.Y;                                      current = (byte*)&currentPtr->P.Y;                                      original = (byte*)&originalPtr->P.Y;                                  }                                  else                                  {                                      touchMask = TouchState.X;                                      current = (byte*)&currentPtr->P.X;                                      original = (byte*)&originalPtr->P.X;                                  }                                    var point = 0;                                  for (int i = 0; i < _contours.Length; i++)                                  {                                      var endPoint = _contours[i];                                      var firstPoint = point;                                      var firstTouched = -1;                                      var lastTouched = -1;                                        for (; point <= endPoint; point++)                                      {                                          // check whether this point has been touched                                          if ((_points.TouchState[point] & touchMask) != 0)                                          {                                              // if this is the first touched point in the contour' note it and continue                                              if (firstTouched < 0)                                              {                                                  firstTouched = point;                                                  lastTouched = point;                                                  continue;                                              }                                                // otherwise' interpolate all untouched points                                              // between this point and our last touched point                                              InterpolatePoints(current' original' lastTouched + 1' point - 1' lastTouched' point);                                              lastTouched = point;                                          }                                      }                                        // check if we had any touched points at all in this contour                                      if (firstTouched >= 0)                                      {                                          // there are two cases left to handle:                                          // 1. there was only one touched point in the whole contour' in                                          //    which case we want to shift everything relative to that one                                          // 2. several touched points' in which case handle the gap from the                                          //    beginning to the first touched point and the gap from the last                                          //    touched point to the end of the contour                                          if (lastTouched == firstTouched)                                          {                                              var delta = *GetPoint(current' lastTouched) - *GetPoint(original' lastTouched);                                              if (delta != 0.0f)                                              {                                                  for (int j = firstPoint; j < lastTouched; j++)                                                      *GetPoint(current' j) += delta;                                                  for (int j = lastTouched + 1; j <= endPoint; j++)                                                      *GetPoint(current' j) += delta;                                              }                                          }                                          else                                          {                                              InterpolatePoints(current' original' lastTouched + 1' endPoint' lastTouched' firstTouched);                                              if (firstTouched > 0)                                                  InterpolatePoints(current' original' firstPoint' firstTouched - 1' lastTouched' firstTouched);                                          }                                      }                                  }                              }                          }                          break;                      case OpCode.ISECT:                          {                              // move point P to the intersection of lines A and B                              var b1 = _zp0.GetCurrent(_stack.Pop());                              var b0 = _zp0.GetCurrent(_stack.Pop());                              var a1 = _zp1.GetCurrent(_stack.Pop());                              var a0 = _zp1.GetCurrent(_stack.Pop());                              var index = _stack.Pop();                                // calculate intersection using determinants: https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line                              var da = a0 - a1;                              var db = b0 - b1;                              var den = (da.X * db.Y) - (da.Y * db.X);                              if (Math.Abs(den) <= Epsilon)                              {                                  // parallel lines; spec says to put the ppoint "into the middle of the two lines"                                  _zp2.Current[index].P = (a0 + a1 + b0 + b1) / 4;                              }                              else                              {                                  var t = (a0.X * a1.Y) - (a0.Y * a1.X);                                  var u = (b0.X * b1.Y) - (b0.Y * b1.X);                                  var p = new Vector2(                                      (t * db.X) - (da.X * u)'                                      (t * db.Y) - (da.Y * u)                                  );                                  _zp2.Current[index].P = p / den;                              }                              _zp2.TouchState[index] = TouchState.Both;                          }                          break;                        // ==== STACK MANAGEMENT ====                      case OpCode.DUP: _stack.Duplicate(); break;                      case OpCode.POP: _stack.Pop(); break;                      case OpCode.CLEAR: _stack.Clear(); break;                      case OpCode.SWAP: _stack.Swap(); break;                      case OpCode.DEPTH: _stack.Depth(); break;                      case OpCode.CINDEX: _stack.Copy(); break;                      case OpCode.MINDEX: _stack.Move(); break;                      case OpCode.ROLL: _stack.Roll(); break;                        // ==== FLOW CONTROL ====                      case OpCode.IF:                          {                              // value is false; jump to the next else block or endif marker                              // otherwise' we don't have to do anything; we'll keep executing this block                              if (!_stack.PopBool())                              {                                  int indent = 1;                                  while (indent > 0)                                  {                                      opcode = SkipNext(ref stream);                                      switch (opcode)                                      {                                          case OpCode.IF: indent++; break;                                          case OpCode.EIF: indent--; break;                                          case OpCode.ELSE:                                              if (indent == 1)                                                  indent = 0;                                              break;                                      }                                  }                              }                          }                          break;                      case OpCode.ELSE:                          {                              // assume we hit the true statement of some previous if block                              // if we had hit false' we would have jumped over this                              int indent = 1;                              while (indent > 0)                              {                                  opcode = SkipNext(ref stream);                                  switch (opcode)                                  {                                      case OpCode.IF: indent++; break;                                      case OpCode.EIF: indent--; break;                                  }                              }                          }                          break;                      case OpCode.EIF: /* nothing to do */ break;                      case OpCode.JROT:                      case OpCode.JROF:                          {                              if (_stack.PopBool() == (opcode == OpCode.JROT))                                  stream.Jump(_stack.Pop() - 1);                              else                                  _stack.Pop();    // ignore the offset                          }                          break;                      case OpCode.JMPR: stream.Jump(_stack.Pop() - 1); break;                        // ==== LOGICAL OPS ====                      case OpCode.LT:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a < b);                          }                          break;                      case OpCode.LTEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a <= b);                          }                          break;                      case OpCode.GT:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a > b);                          }                          break;                      case OpCode.GTEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a >= b);                          }                          break;                      case OpCode.EQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a == b);                          }                          break;                      case OpCode.NEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a != b);                          }                          break;                      case OpCode.AND:                          {                              var b = _stack.PopBool();                              var a = _stack.PopBool();                              _stack.Push(a && b);                          }                          break;                      case OpCode.OR:                          {                              var b = _stack.PopBool();                              var a = _stack.PopBool();                              _stack.Push(a || b);                          }                          break;                      case OpCode.NOT: _stack.Push(!_stack.PopBool()); break;                      case OpCode.ODD:                          {                              var value = (int)Round(_stack.PopFloat());                              _stack.Push(value % 2 != 0);                          }                          break;                      case OpCode.EVEN:                          {                              var value = (int)Round(_stack.PopFloat());                              _stack.Push(value % 2 == 0);                          }                          break;                        // ==== ARITHMETIC ====                      case OpCode.ADD:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a + b);                          }                          break;                      case OpCode.SUB:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a - b);                          }                          break;                      case OpCode.DIV:                          {                              var b = _stack.Pop();                              if (b == 0)                                  throw new InvalidFontException("Division by zero.");                                var a = _stack.Pop();                              var result = ((long)a << 6) / b;                              _stack.Push((int)result);                          }                          break;                      case OpCode.MUL:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              var result = ((long)a * b) >> 6;                              _stack.Push((int)result);                          }                          break;                      case OpCode.ABS: _stack.Push(Math.Abs(_stack.Pop())); break;                      case OpCode.NEG: _stack.Push(-_stack.Pop()); break;                      case OpCode.FLOOR: _stack.Push(_stack.Pop() & ~63); break;                      case OpCode.CEILING: _stack.Push((_stack.Pop() + 63) & ~63); break;                      case OpCode.MAX: _stack.Push(Math.Max(_stack.Pop()' _stack.Pop())); break;                      case OpCode.MIN: _stack.Push(Math.Min(_stack.Pop()' _stack.Pop())); break;                        // ==== FUNCTIONS ====                      case OpCode.FDEF:                          {                              if (!allowFunctionDefs || inFunction)                                  throw new InvalidFontException("Can't define functions here.");                                _functions[_stack.Pop()] = stream;                              while (SkipNext(ref stream) != OpCode.ENDF) ;                          }                          break;                      case OpCode.IDEF:                          {                              if (!allowFunctionDefs || inFunction)                                  throw new InvalidFontException("Can't define functions here.");                                _instructionDefs[_stack.Pop()] = stream;                              while (SkipNext(ref stream) != OpCode.ENDF) ;                          }                          break;                      case OpCode.ENDF:                          {                              if (!inFunction)                                  throw new InvalidFontException("Found invalid ENDF marker outside of a function definition.");                              return;                          }                      case OpCode.CALL:                      case OpCode.LOOPCALL:                          {                              _callStackSize++;                              if (_callStackSize > MaxCallStack)                                  throw new InvalidFontException("Stack overflow; infinite recursion?");                                var function = _functions[_stack.Pop()];                              var count = opcode == OpCode.LOOPCALL ? _stack.Pop() : 1;                              for (int i = 0; i < count; i++)                                  Execute(function' true' false);                              _callStackSize--;                          }                          break;                        // ==== ROUNDING ====                      // we don't have "engine compensation" so the variants are unnecessary                      case OpCode.ROUND0:                      case OpCode.ROUND1:                      case OpCode.ROUND2:                      case OpCode.ROUND3: _stack.Push(Round(_stack.PopFloat())); break;                      case OpCode.NROUND0:                      case OpCode.NROUND1:                      case OpCode.NROUND2:                      case OpCode.NROUND3: break;                        // ==== DELTA EXCEPTIONS ====                      case OpCode.DELTAC1:                      case OpCode.DELTAC2:                      case OpCode.DELTAC3:                          {                              var last = _stack.Pop();                              for (int i = 1; i <= last; i++)                              {                                  var cvtIndex = _stack.Pop();                                  var arg = _stack.Pop();                                    // upper 4 bits of the 8-bit arg is the relative ppem                                  // the opcode specifies the base to add to the ppem                                  var triggerPpem = (arg >> 4) & 0xF;                                  triggerPpem += (opcode - OpCode.DELTAC1) * 16;                                  triggerPpem += _state.DeltaBase;                                    // if the current ppem matches the trigger' apply the exception                                  if (_ppem == triggerPpem)                                  {                                      // the lower 4 bits of the arg is the amount to shift                                      // it's encoded such that 0 isn't an allowable value (who wants to shift by 0 anyway?)                                      var amount = (arg & 0xF) - 8;                                      if (amount >= 0)                                          amount++;                                      amount *= 1 << (6 - _state.DeltaShift);                                        // update the CVT                                      CheckIndex(cvtIndex' _controlValueTable.Length);                                      _controlValueTable[cvtIndex] += F26Dot6ToFloat(amount);                                  }                              }                          }                          break;                      case OpCode.DELTAP1:                      case OpCode.DELTAP2:                      case OpCode.DELTAP3:                          {                              var last = _stack.Pop();                              for (int i = 1; i <= last; i++)                              {                                  var pointIndex = _stack.Pop();                                  var arg = _stack.Pop();                                    // upper 4 bits of the 8-bit arg is the relative ppem                                  // the opcode specifies the base to add to the ppem                                  var triggerPpem = (arg >> 4) & 0xF;                                  triggerPpem += _state.DeltaBase;                                  if (opcode != OpCode.DELTAP1)                                      triggerPpem += (opcode - OpCode.DELTAP2 + 1) * 16;                                    // if the current ppem matches the trigger' apply the exception                                  if (_ppem == triggerPpem)                                  {                                      // the lower 4 bits of the arg is the amount to shift                                      // it's encoded such that 0 isn't an allowable value (who wants to shift by 0 anyway?)                                      var amount = (arg & 0xF) - 8;                                      if (amount >= 0)                                          amount++;                                      amount *= 1 << (6 - _state.DeltaShift);                                        MovePoint(_zp0' pointIndex' F26Dot6ToFloat(amount));                                  }                              }                          }                          break;                        // ==== MISCELLANEOUS ====                      case OpCode.DEBUG: _stack.Pop(); break;                      case OpCode.GETINFO:                          {                              var selector = _stack.Pop();                              var result = 0;                              if ((selector & 0x1) != 0)                              {                                  // pretend we are MS Rasterizer v35                                  result = 35;                              }                                // TODO: rotation and stretching                              //if ((selector & 0x2) != 0)                              //if ((selector & 0x4) != 0)                                // we're always rendering in grayscale                              if ((selector & 0x20) != 0)                                  result |= 1 << 12;                                // TODO: ClearType flags                                _stack.Push(result);                          }                          break;                        default:                          if (opcode >= OpCode.MIRP)                              MoveIndirectRelative(opcode - OpCode.MIRP);                          else if (opcode >= OpCode.MDRP)                              MoveDirectRelative(opcode - OpCode.MDRP);                          else                          {                              // check if this is a runtime-defined opcode                              var index = (int)opcode;                              if (index > _instructionDefs.Length || !_instructionDefs[index].IsValid)                                  throw new InvalidFontException("Unknown opcode in font program.");                                _callStackSize++;                              if (_callStackSize > MaxCallStack)                                  throw new InvalidFontException("Stack overflow; infinite recursion?");                                Execute(_instructionDefs[index]' true' false);                              _callStackSize--;                          }                          break;                  }
Magic Number,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,Execute,The following statement contains a magic number: switch (opcode)                  {                      // ==== PUSH INSTRUCTIONS ====                      case OpCode.NPUSHB:                      case OpCode.PUSHB1:                      case OpCode.PUSHB2:                      case OpCode.PUSHB3:                      case OpCode.PUSHB4:                      case OpCode.PUSHB5:                      case OpCode.PUSHB6:                      case OpCode.PUSHB7:                      case OpCode.PUSHB8:                          {                              var count = opcode == OpCode.NPUSHB ? stream.NextByte() : opcode - OpCode.PUSHB1 + 1;                              for (int i = count - 1; i >= 0; --i)                                  _stack.Push(stream.NextByte());                          }                          break;                      case OpCode.NPUSHW:                      case OpCode.PUSHW1:                      case OpCode.PUSHW2:                      case OpCode.PUSHW3:                      case OpCode.PUSHW4:                      case OpCode.PUSHW5:                      case OpCode.PUSHW6:                      case OpCode.PUSHW7:                      case OpCode.PUSHW8:                          {                              var count = opcode == OpCode.NPUSHW ? stream.NextByte() : opcode - OpCode.PUSHW1 + 1;                              for (int i = count - 1; i >= 0; --i)                                  _stack.Push(stream.NextWord());                          }                          break;                        // ==== STORAGE MANAGEMENT ====                      case OpCode.RS:                          {                              var loc = CheckIndex(_stack.Pop()' _storage.Length);                              _stack.Push(_storage[loc]);                          }                          break;                      case OpCode.WS:                          {                              var value = _stack.Pop();                              var loc = CheckIndex(_stack.Pop()' _storage.Length);                              _storage[loc] = value;                          }                          break;                        // ==== CONTROL VALUE TABLE ====                      case OpCode.WCVTP:                          {                              var value = _stack.PopFloat();                              var loc = CheckIndex(_stack.Pop()' _controlValueTable.Length);                              _controlValueTable[loc] = value;                          }                          break;                      case OpCode.WCVTF:                          {                              var value = _stack.Pop();                              var loc = CheckIndex(_stack.Pop()' _controlValueTable.Length);                              _controlValueTable[loc] = value * _scale;                          }                          break;                      case OpCode.RCVT: _stack.Push(ReadCvt()); break;                        // ==== STATE VECTORS ====                      case OpCode.SVTCA0:                      case OpCode.SVTCA1:                          {                              var axis = opcode - OpCode.SVTCA0;                              SetFreedomVectorToAxis(axis);                              SetProjectionVectorToAxis(axis);                          }                          break;                      case OpCode.SFVTPV: _state.Freedom = _state.Projection; OnVectorsUpdated(); break;                      case OpCode.SPVTCA0:                      case OpCode.SPVTCA1: SetProjectionVectorToAxis(opcode - OpCode.SPVTCA0); break;                      case OpCode.SFVTCA0:                      case OpCode.SFVTCA1: SetFreedomVectorToAxis(opcode - OpCode.SFVTCA0); break;                      case OpCode.SPVTL0:                      case OpCode.SPVTL1:                      case OpCode.SFVTL0:                      case OpCode.SFVTL1: SetVectorToLine(opcode - OpCode.SPVTL0' false); break;                      case OpCode.SDPVTL0:                      case OpCode.SDPVTL1: SetVectorToLine(opcode - OpCode.SDPVTL0' true); break;                      case OpCode.SPVFS:                      case OpCode.SFVFS:                          {                              var y = _stack.Pop();                              var x = _stack.Pop();                              var vec = Vector2.Normalize(new Vector2(F2Dot14ToFloat(x)' F2Dot14ToFloat(y)));                              if (opcode == OpCode.SFVFS)                                  _state.Freedom = vec;                              else                              {                                  _state.Projection = vec;                                  _state.DualProjection = vec;                              }                              OnVectorsUpdated();                          }                          break;                      case OpCode.GPV:                      case OpCode.GFV:                          {                              var vec = opcode == OpCode.GPV ? _state.Projection : _state.Freedom;                              _stack.Push(FloatToF2Dot14(vec.X));                              _stack.Push(FloatToF2Dot14(vec.Y));                          }                          break;                        // ==== GRAPHICS STATE ====                      case OpCode.SRP0: _state.Rp0 = _stack.Pop(); break;                      case OpCode.SRP1: _state.Rp1 = _stack.Pop(); break;                      case OpCode.SRP2: _state.Rp2 = _stack.Pop(); break;                      case OpCode.SZP0: _zp0 = GetZoneFromStack(); break;                      case OpCode.SZP1: _zp1 = GetZoneFromStack(); break;                      case OpCode.SZP2: _zp2 = GetZoneFromStack(); break;                      case OpCode.SZPS: _zp0 = _zp1 = _zp2 = GetZoneFromStack(); break;                      case OpCode.RTHG: _state.RoundState = RoundMode.ToHalfGrid; break;                      case OpCode.RTG: _state.RoundState = RoundMode.ToGrid; break;                      case OpCode.RTDG: _state.RoundState = RoundMode.ToDoubleGrid; break;                      case OpCode.RDTG: _state.RoundState = RoundMode.DownToGrid; break;                      case OpCode.RUTG: _state.RoundState = RoundMode.UpToGrid; break;                      case OpCode.ROFF: _state.RoundState = RoundMode.Off; break;                      case OpCode.SROUND: _state.RoundState = RoundMode.Super; SetSuperRound(1.0f); break;                      case OpCode.S45ROUND: _state.RoundState = RoundMode.Super45; SetSuperRound(Sqrt2Over2); break;                      case OpCode.INSTCTRL:                          {                              var selector = _stack.Pop();                              if (selector >= 1 && selector <= 2)                              {                                  // value is false if zero' otherwise shift the right bit into the flags                                  var bit = 1 << (selector - 1);                                  if (_stack.Pop() == 0)                                      _state.InstructionControl = (InstructionControlFlags)((int)_state.InstructionControl & ~bit);                                  else                                      _state.InstructionControl = (InstructionControlFlags)((int)_state.InstructionControl | bit);                              }                          }                          break;                      case OpCode.SCANCTRL: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SCANTYPE: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SANGW: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SLOOP: _state.Loop = _stack.Pop(); break;                      case OpCode.SMD: _state.MinDistance = _stack.PopFloat(); break;                      case OpCode.SCVTCI: _state.ControlValueCutIn = _stack.PopFloat(); break;                      case OpCode.SSWCI: _state.SingleWidthCutIn = _stack.PopFloat(); break;                      case OpCode.SSW: _state.SingleWidthValue = _stack.Pop() * _scale; break;                      case OpCode.FLIPON: _state.AutoFlip = true; break;                      case OpCode.FLIPOFF: _state.AutoFlip = false; break;                      case OpCode.SDB: _state.DeltaBase = _stack.Pop(); break;                      case OpCode.SDS: _state.DeltaShift = _stack.Pop(); break;                        // ==== POINT MEASUREMENT ====                      case OpCode.GC0: _stack.Push(Project(_zp2.GetCurrent(_stack.Pop()))); break;                      case OpCode.GC1: _stack.Push(DualProject(_zp2.GetOriginal(_stack.Pop()))); break;                      case OpCode.SCFS:                          {                              var value = _stack.PopFloat();                              var index = _stack.Pop();                              var point = _zp2.GetCurrent(index);                              MovePoint(_zp2' index' value - Project(point));                                // moving twilight points moves their "original" value also                              if (_zp2.IsTwilight)                                  _zp2.Original[index].P = _zp2.Current[index].P;                          }                          break;                      case OpCode.MD0:                          {                              var p1 = _zp1.GetOriginal(_stack.Pop());                              var p2 = _zp0.GetOriginal(_stack.Pop());                              _stack.Push(DualProject(p2 - p1));                          }                          break;                      case OpCode.MD1:                          {                              var p1 = _zp1.GetCurrent(_stack.Pop());                              var p2 = _zp0.GetCurrent(_stack.Pop());                              _stack.Push(Project(p2 - p1));                          }                          break;                      case OpCode.MPS: // MPS should return point size' but we assume DPI so it's the same as pixel size                      case OpCode.MPPEM: _stack.Push(_ppem); break;                      case OpCode.AA: /* deprecated instruction */ _stack.Pop(); break;                        // ==== POINT MODIFICATION ====                      case OpCode.FLIPPT:                          {                              for (int i = 0; i < _state.Loop; i++)                              {                                  var index = _stack.Pop();                                  //review here again!                                  _points.Current[index].onCurve = !_points.Current[index].onCurve;                                  //if (points.Current[index].onCurve)                                  //    points.Current[index].onCurve = false;                                  //else                                  //    points.Current[index].onCurve = true;                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.FLIPRGON:                          {                              var end = _stack.Pop();                              for (int i = _stack.Pop(); i <= end; i++)                                  //points.Current[i].Type = PointType.OnCurve;                                  _points.Current[i].onCurve = true;                          }                          break;                      case OpCode.FLIPRGOFF:                          {                              var end = _stack.Pop();                              for (int i = _stack.Pop(); i <= end; i++)                                  //points.Current[i].Type = PointType.Quadratic;                                  _points.Current[i].onCurve = false;                          }                          break;                      case OpCode.SHP0:                      case OpCode.SHP1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              ShiftPoints(displacement);                          }                          break;                      case OpCode.SHPIX: ShiftPoints(_stack.PopFloat() * _state.Freedom); break;                      case OpCode.SHC0:                      case OpCode.SHC1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              var touch = GetTouchState();                              var contour = _stack.Pop();                              var start = contour == 0 ? 0 : _contours[contour - 1] + 1;                              var count = _zp2.IsTwilight ? _zp2.Current.Length : _contours[contour] + 1;                                for (int i = start; i < count; i++)                              {                                  // don't move the reference point                                  if (zone.Current != _zp2.Current || point != i)                                  {                                      _zp2.Current[i].P += displacement;                                      _zp2.TouchState[i] |= touch;                                  }                              }                          }                          break;                      case OpCode.SHZ0:                      case OpCode.SHZ1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              var count = 0;                              if (_zp2.IsTwilight)                                  count = _zp2.Current.Length;                              else if (_contours.Length > 0)                                  count = _contours[_contours.Length - 1] + 1;                                for (int i = 0; i < count; i++)                              {                                  // don't move the reference point                                  if (zone.Current != _zp2.Current || point != i)                                      _zp2.Current[i].P += displacement;                              }                          }                          break;                      case OpCode.MIAP0:                      case OpCode.MIAP1:                          {                              var distance = ReadCvt();                              var pointIndex = _stack.Pop();                                // this instruction is used in the CVT to set up twilight points with original values                              if (_zp0.IsTwilight)                              {                                  var original = _state.Freedom * distance;                                  _zp0.Original[pointIndex].P = original;                                  _zp0.Current[pointIndex].P = original;                              }                                // current position of the point along the projection vector                              var point = _zp0.GetCurrent(pointIndex);                              var currentPos = Project(point);                              if (opcode == OpCode.MIAP1)                              {                                  // only use the CVT if we are above the cut-in point                                  if (Math.Abs(distance - currentPos) > _state.ControlValueCutIn)                                      distance = currentPos;                                  distance = Round(distance);                              }                                MovePoint(_zp0' pointIndex' distance - currentPos);                              _state.Rp0 = pointIndex;                              _state.Rp1 = pointIndex;                          }                          break;                      case OpCode.MDAP0:                      case OpCode.MDAP1:                          {                              var pointIndex = _stack.Pop();                              var point = _zp0.GetCurrent(pointIndex);                              var distance = 0.0f;                              if (opcode == OpCode.MDAP1)                              {                                  distance = Project(point);                                  distance = Round(distance) - distance;                              }                                MovePoint(_zp0' pointIndex' distance);                              _state.Rp0 = pointIndex;                              _state.Rp1 = pointIndex;                          }                          break;                      case OpCode.MSIRP0:                      case OpCode.MSIRP1:                          {                              var targetDistance = _stack.PopFloat();                              var pointIndex = _stack.Pop();                                // if we're operating on the twilight zone' initialize the points                              if (_zp1.IsTwilight)                              {                                  _zp1.Original[pointIndex].P = _zp0.Original[_state.Rp0].P + targetDistance * _state.Freedom / _fdotp;                                  _zp1.Current[pointIndex].P = _zp1.Original[pointIndex].P;                              }                                var currentDistance = Project(_zp1.GetCurrent(pointIndex) - _zp0.GetCurrent(_state.Rp0));                              MovePoint(_zp1' pointIndex' targetDistance - currentDistance);                                _state.Rp1 = _state.Rp0;                              _state.Rp2 = pointIndex;                              if (opcode == OpCode.MSIRP1)                                  _state.Rp0 = pointIndex;                          }                          break;                      case OpCode.IP:                          {                              var originalBase = _zp0.GetOriginal(_state.Rp1);                              var currentBase = _zp0.GetCurrent(_state.Rp1);                              var originalRange = DualProject(_zp1.GetOriginal(_state.Rp2) - originalBase);                              var currentRange = Project(_zp1.GetCurrent(_state.Rp2) - currentBase);                                for (int i = 0; i < _state.Loop; i++)                              {                                  var pointIndex = _stack.Pop();                                  var point = _zp2.GetCurrent(pointIndex);                                  var currentDistance = Project(point - currentBase);                                  var originalDistance = DualProject(_zp2.GetOriginal(pointIndex) - originalBase);                                    var newDistance = 0.0f;                                  if (originalDistance != 0.0f)                                  {                                      // a range of 0.0f is invalid according to the spec (would result in a div by zero)                                      if (originalRange == 0.0f)                                          newDistance = originalDistance;                                      else                                          newDistance = originalDistance * currentRange / originalRange;                                  }                                    MovePoint(_zp2' pointIndex' newDistance - currentDistance);                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.ALIGNRP:                          {                              for (int i = 0; i < _state.Loop; i++)                              {                                  var pointIndex = _stack.Pop();                                  var p1 = _zp1.GetCurrent(pointIndex);                                  var p2 = _zp0.GetCurrent(_state.Rp0);                                  MovePoint(_zp1' pointIndex' -Project(p1 - p2));                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.ALIGNPTS:                          {                              var p1 = _stack.Pop();                              var p2 = _stack.Pop();                              var distance = Project(_zp0.GetCurrent(p2) - _zp1.GetCurrent(p1)) / 2;                              MovePoint(_zp1' p1' distance);                              MovePoint(_zp0' p2' -distance);                          }                          break;                      case OpCode.UTP: _zp0.TouchState[_stack.Pop()] &= ~GetTouchState(); break;                      case OpCode.IUP0:                      case OpCode.IUP1:                          // bail if no contours (empty outline)                          if (_contours.Length == 0)                          {                              break;                          }                            //{                            //    //WinterDev's new managed version                          //    GlyphPointF[] currentPnts = points.Current;                          //    GlyphPointF[] originalPnts = points.Original;                            //    int cnt_count = contours.Length;                          //    int point = 0;                          //    // opcode controls whether we care about X or Y direction                          //    // do some pointer trickery so we can operate on the                          //    // points in a direction-agnostic manner                          //    TouchState touchMask;                            //    if (opcode == OpCode.IUP0)                          //    {                          //        //y -axis                          //        touchMask = TouchState.Y;                            //        //                          //        for (int i = 0; i < cnt_count; ++i)                          //        {                          //            int endPoint = contours[i];                          //            int firstPoint = point;                          //            int firstTouched = -1;                          //            int lastTouched = -1;                            //            for (; point <= endPoint; point++)                          //            {                          //                // check whether this point has been touched                          //                if ((points.TouchState[point] & touchMask) != 0)                          //                {                          //                    // if this is the first touched point in the contour' note it and continue                          //                    if (firstTouched < 0)                          //                    {                          //                        firstTouched = point;                          //                        lastTouched = point;                          //                        continue;                          //                    }                            //                    // otherwise' interpolate all untouched points                          //                    // between this point and our last touched point                          //                    InterpolatePointsYAxis(currentPnts' originalPnts' lastTouched + 1' point - 1' lastTouched' point);                          //                    lastTouched = point;                          //                }                          //            }                            //            // check if we had any touched points at all in this contour                          //            if (firstTouched >= 0)                          //            {                          //                // there are two cases left to handle:                          //                // 1. there was only one touched point in the whole contour' in                          //                //    which case we want to shift everything relative to that one                          //                // 2. several touched points' in which case handle the gap from the                          //                //    beginning to the first touched point and the gap from the last                          //                //    touched point to the end of the contour                          //                if (lastTouched == firstTouched)                          //                {                          //                    float delta = currentPnts[lastTouched].Y - originalPnts[lastTouched].Y;                          //                    if (delta != 0.0f)                          //                    {                          //                        for (int n = firstPoint; n < lastTouched; n++)                          //                        {                          //                            currentPnts[n].OffsetY(delta);                          //                        }                          //                        for (int n = lastTouched + 1; n <= endPoint; n++)                          //                        {                          //                            currentPnts[n].OffsetY(delta);                          //                        }                            //                    }                          //                }                          //                else                          //                {                          //                    InterpolatePointsYAxis(currentPnts' originalPnts' lastTouched + 1' endPoint' lastTouched' firstTouched);                          //                    if (firstTouched > 0)                          //                    {                          //                        InterpolatePointsYAxis(currentPnts' originalPnts' firstPoint' firstTouched - 1' lastTouched' firstTouched);                          //                    }                          //                }                          //            }                            //        }                          //    }                          //    else                          //    {                          //        //x-axis                          //        touchMask = TouchState.X;                          //        //                          //        for (int i = 0; i < cnt_count; ++i)                          //        {                          //            int endPoint = contours[i];                          //            int firstPoint = point;                          //            int firstTouched = -1;                          //            int lastTouched = -1;                            //            for (; point <= endPoint; point++)                          //            {                          //                // check whether this point has been touched                          //                if ((points.TouchState[point] & touchMask) != 0)                          //                {                          //                    // if this is the first touched point in the contour' note it and continue                          //                    if (firstTouched < 0)                          //                    {                          //                        firstTouched = point;                          //                        lastTouched = point;                          //                        continue;                          //                    }                            //                    // otherwise' interpolate all untouched points                          //                    // between this point and our last touched point                          //                    InterpolatePointsXAxis(currentPnts' originalPnts' lastTouched + 1' point - 1' lastTouched' point);                          //                    lastTouched = point;                          //                }                          //            }                            //            // check if we had any touched points at all in this contour                          //            if (firstTouched >= 0)                          //            {                          //                // there are two cases left to handle:                          //                // 1. there was only one touched point in the whole contour' in                          //                //    which case we want to shift everything relative to that one                          //                // 2. several touched points' in which case handle the gap from the                          //                //    beginning to the first touched point and the gap from the last                          //                //    touched point to the end of the contour                          //                if (lastTouched == firstTouched)                          //                {                          //                    float delta = currentPnts[lastTouched].X - originalPnts[lastTouched].X;                          //                    if (delta != 0.0f)                          //                    {                          //                        for (int n = firstPoint; n < lastTouched; ++n)                          //                        {                          //                            currentPnts[n].OffsetX(delta);                          //                        }                          //                        for (int n = lastTouched + 1; n <= endPoint; ++n)                          //                        {                          //                            currentPnts[n].OffsetX(delta);                          //                        }                          //                    }                          //                }                          //                else                          //                {                          //                    InterpolatePointsXAxis(currentPnts' originalPnts' lastTouched + 1' endPoint' lastTouched' firstTouched);                          //                    if (firstTouched > 0)                          //                    {                          //                        InterpolatePointsXAxis(currentPnts' originalPnts' firstPoint' firstTouched - 1' lastTouched' firstTouched);                          //                    }                          //                }                          //            }                          //        }                          //    }                          //}                          //-----------------------------------------                          unsafe                          {                                //unsafe version                               //TODO: provide manage version                               fixed (GlyphPointF* currentPtr = _points.Current)                              fixed (GlyphPointF* originalPtr = _points.Original)                              {                                  // opcode controls whether we care about X or Y direction                                  // do some pointer trickery so we can operate on the                                  // points in a direction-agnostic manner                                  TouchState touchMask;                                  byte* current;                                  byte* original;                                  if (opcode == OpCode.IUP0)                                  {                                      touchMask = TouchState.Y;                                      current = (byte*)&currentPtr->P.Y;                                      original = (byte*)&originalPtr->P.Y;                                  }                                  else                                  {                                      touchMask = TouchState.X;                                      current = (byte*)&currentPtr->P.X;                                      original = (byte*)&originalPtr->P.X;                                  }                                    var point = 0;                                  for (int i = 0; i < _contours.Length; i++)                                  {                                      var endPoint = _contours[i];                                      var firstPoint = point;                                      var firstTouched = -1;                                      var lastTouched = -1;                                        for (; point <= endPoint; point++)                                      {                                          // check whether this point has been touched                                          if ((_points.TouchState[point] & touchMask) != 0)                                          {                                              // if this is the first touched point in the contour' note it and continue                                              if (firstTouched < 0)                                              {                                                  firstTouched = point;                                                  lastTouched = point;                                                  continue;                                              }                                                // otherwise' interpolate all untouched points                                              // between this point and our last touched point                                              InterpolatePoints(current' original' lastTouched + 1' point - 1' lastTouched' point);                                              lastTouched = point;                                          }                                      }                                        // check if we had any touched points at all in this contour                                      if (firstTouched >= 0)                                      {                                          // there are two cases left to handle:                                          // 1. there was only one touched point in the whole contour' in                                          //    which case we want to shift everything relative to that one                                          // 2. several touched points' in which case handle the gap from the                                          //    beginning to the first touched point and the gap from the last                                          //    touched point to the end of the contour                                          if (lastTouched == firstTouched)                                          {                                              var delta = *GetPoint(current' lastTouched) - *GetPoint(original' lastTouched);                                              if (delta != 0.0f)                                              {                                                  for (int j = firstPoint; j < lastTouched; j++)                                                      *GetPoint(current' j) += delta;                                                  for (int j = lastTouched + 1; j <= endPoint; j++)                                                      *GetPoint(current' j) += delta;                                              }                                          }                                          else                                          {                                              InterpolatePoints(current' original' lastTouched + 1' endPoint' lastTouched' firstTouched);                                              if (firstTouched > 0)                                                  InterpolatePoints(current' original' firstPoint' firstTouched - 1' lastTouched' firstTouched);                                          }                                      }                                  }                              }                          }                          break;                      case OpCode.ISECT:                          {                              // move point P to the intersection of lines A and B                              var b1 = _zp0.GetCurrent(_stack.Pop());                              var b0 = _zp0.GetCurrent(_stack.Pop());                              var a1 = _zp1.GetCurrent(_stack.Pop());                              var a0 = _zp1.GetCurrent(_stack.Pop());                              var index = _stack.Pop();                                // calculate intersection using determinants: https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line                              var da = a0 - a1;                              var db = b0 - b1;                              var den = (da.X * db.Y) - (da.Y * db.X);                              if (Math.Abs(den) <= Epsilon)                              {                                  // parallel lines; spec says to put the ppoint "into the middle of the two lines"                                  _zp2.Current[index].P = (a0 + a1 + b0 + b1) / 4;                              }                              else                              {                                  var t = (a0.X * a1.Y) - (a0.Y * a1.X);                                  var u = (b0.X * b1.Y) - (b0.Y * b1.X);                                  var p = new Vector2(                                      (t * db.X) - (da.X * u)'                                      (t * db.Y) - (da.Y * u)                                  );                                  _zp2.Current[index].P = p / den;                              }                              _zp2.TouchState[index] = TouchState.Both;                          }                          break;                        // ==== STACK MANAGEMENT ====                      case OpCode.DUP: _stack.Duplicate(); break;                      case OpCode.POP: _stack.Pop(); break;                      case OpCode.CLEAR: _stack.Clear(); break;                      case OpCode.SWAP: _stack.Swap(); break;                      case OpCode.DEPTH: _stack.Depth(); break;                      case OpCode.CINDEX: _stack.Copy(); break;                      case OpCode.MINDEX: _stack.Move(); break;                      case OpCode.ROLL: _stack.Roll(); break;                        // ==== FLOW CONTROL ====                      case OpCode.IF:                          {                              // value is false; jump to the next else block or endif marker                              // otherwise' we don't have to do anything; we'll keep executing this block                              if (!_stack.PopBool())                              {                                  int indent = 1;                                  while (indent > 0)                                  {                                      opcode = SkipNext(ref stream);                                      switch (opcode)                                      {                                          case OpCode.IF: indent++; break;                                          case OpCode.EIF: indent--; break;                                          case OpCode.ELSE:                                              if (indent == 1)                                                  indent = 0;                                              break;                                      }                                  }                              }                          }                          break;                      case OpCode.ELSE:                          {                              // assume we hit the true statement of some previous if block                              // if we had hit false' we would have jumped over this                              int indent = 1;                              while (indent > 0)                              {                                  opcode = SkipNext(ref stream);                                  switch (opcode)                                  {                                      case OpCode.IF: indent++; break;                                      case OpCode.EIF: indent--; break;                                  }                              }                          }                          break;                      case OpCode.EIF: /* nothing to do */ break;                      case OpCode.JROT:                      case OpCode.JROF:                          {                              if (_stack.PopBool() == (opcode == OpCode.JROT))                                  stream.Jump(_stack.Pop() - 1);                              else                                  _stack.Pop();    // ignore the offset                          }                          break;                      case OpCode.JMPR: stream.Jump(_stack.Pop() - 1); break;                        // ==== LOGICAL OPS ====                      case OpCode.LT:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a < b);                          }                          break;                      case OpCode.LTEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a <= b);                          }                          break;                      case OpCode.GT:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a > b);                          }                          break;                      case OpCode.GTEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a >= b);                          }                          break;                      case OpCode.EQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a == b);                          }                          break;                      case OpCode.NEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a != b);                          }                          break;                      case OpCode.AND:                          {                              var b = _stack.PopBool();                              var a = _stack.PopBool();                              _stack.Push(a && b);                          }                          break;                      case OpCode.OR:                          {                              var b = _stack.PopBool();                              var a = _stack.PopBool();                              _stack.Push(a || b);                          }                          break;                      case OpCode.NOT: _stack.Push(!_stack.PopBool()); break;                      case OpCode.ODD:                          {                              var value = (int)Round(_stack.PopFloat());                              _stack.Push(value % 2 != 0);                          }                          break;                      case OpCode.EVEN:                          {                              var value = (int)Round(_stack.PopFloat());                              _stack.Push(value % 2 == 0);                          }                          break;                        // ==== ARITHMETIC ====                      case OpCode.ADD:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a + b);                          }                          break;                      case OpCode.SUB:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a - b);                          }                          break;                      case OpCode.DIV:                          {                              var b = _stack.Pop();                              if (b == 0)                                  throw new InvalidFontException("Division by zero.");                                var a = _stack.Pop();                              var result = ((long)a << 6) / b;                              _stack.Push((int)result);                          }                          break;                      case OpCode.MUL:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              var result = ((long)a * b) >> 6;                              _stack.Push((int)result);                          }                          break;                      case OpCode.ABS: _stack.Push(Math.Abs(_stack.Pop())); break;                      case OpCode.NEG: _stack.Push(-_stack.Pop()); break;                      case OpCode.FLOOR: _stack.Push(_stack.Pop() & ~63); break;                      case OpCode.CEILING: _stack.Push((_stack.Pop() + 63) & ~63); break;                      case OpCode.MAX: _stack.Push(Math.Max(_stack.Pop()' _stack.Pop())); break;                      case OpCode.MIN: _stack.Push(Math.Min(_stack.Pop()' _stack.Pop())); break;                        // ==== FUNCTIONS ====                      case OpCode.FDEF:                          {                              if (!allowFunctionDefs || inFunction)                                  throw new InvalidFontException("Can't define functions here.");                                _functions[_stack.Pop()] = stream;                              while (SkipNext(ref stream) != OpCode.ENDF) ;                          }                          break;                      case OpCode.IDEF:                          {                              if (!allowFunctionDefs || inFunction)                                  throw new InvalidFontException("Can't define functions here.");                                _instructionDefs[_stack.Pop()] = stream;                              while (SkipNext(ref stream) != OpCode.ENDF) ;                          }                          break;                      case OpCode.ENDF:                          {                              if (!inFunction)                                  throw new InvalidFontException("Found invalid ENDF marker outside of a function definition.");                              return;                          }                      case OpCode.CALL:                      case OpCode.LOOPCALL:                          {                              _callStackSize++;                              if (_callStackSize > MaxCallStack)                                  throw new InvalidFontException("Stack overflow; infinite recursion?");                                var function = _functions[_stack.Pop()];                              var count = opcode == OpCode.LOOPCALL ? _stack.Pop() : 1;                              for (int i = 0; i < count; i++)                                  Execute(function' true' false);                              _callStackSize--;                          }                          break;                        // ==== ROUNDING ====                      // we don't have "engine compensation" so the variants are unnecessary                      case OpCode.ROUND0:                      case OpCode.ROUND1:                      case OpCode.ROUND2:                      case OpCode.ROUND3: _stack.Push(Round(_stack.PopFloat())); break;                      case OpCode.NROUND0:                      case OpCode.NROUND1:                      case OpCode.NROUND2:                      case OpCode.NROUND3: break;                        // ==== DELTA EXCEPTIONS ====                      case OpCode.DELTAC1:                      case OpCode.DELTAC2:                      case OpCode.DELTAC3:                          {                              var last = _stack.Pop();                              for (int i = 1; i <= last; i++)                              {                                  var cvtIndex = _stack.Pop();                                  var arg = _stack.Pop();                                    // upper 4 bits of the 8-bit arg is the relative ppem                                  // the opcode specifies the base to add to the ppem                                  var triggerPpem = (arg >> 4) & 0xF;                                  triggerPpem += (opcode - OpCode.DELTAC1) * 16;                                  triggerPpem += _state.DeltaBase;                                    // if the current ppem matches the trigger' apply the exception                                  if (_ppem == triggerPpem)                                  {                                      // the lower 4 bits of the arg is the amount to shift                                      // it's encoded such that 0 isn't an allowable value (who wants to shift by 0 anyway?)                                      var amount = (arg & 0xF) - 8;                                      if (amount >= 0)                                          amount++;                                      amount *= 1 << (6 - _state.DeltaShift);                                        // update the CVT                                      CheckIndex(cvtIndex' _controlValueTable.Length);                                      _controlValueTable[cvtIndex] += F26Dot6ToFloat(amount);                                  }                              }                          }                          break;                      case OpCode.DELTAP1:                      case OpCode.DELTAP2:                      case OpCode.DELTAP3:                          {                              var last = _stack.Pop();                              for (int i = 1; i <= last; i++)                              {                                  var pointIndex = _stack.Pop();                                  var arg = _stack.Pop();                                    // upper 4 bits of the 8-bit arg is the relative ppem                                  // the opcode specifies the base to add to the ppem                                  var triggerPpem = (arg >> 4) & 0xF;                                  triggerPpem += _state.DeltaBase;                                  if (opcode != OpCode.DELTAP1)                                      triggerPpem += (opcode - OpCode.DELTAP2 + 1) * 16;                                    // if the current ppem matches the trigger' apply the exception                                  if (_ppem == triggerPpem)                                  {                                      // the lower 4 bits of the arg is the amount to shift                                      // it's encoded such that 0 isn't an allowable value (who wants to shift by 0 anyway?)                                      var amount = (arg & 0xF) - 8;                                      if (amount >= 0)                                          amount++;                                      amount *= 1 << (6 - _state.DeltaShift);                                        MovePoint(_zp0' pointIndex' F26Dot6ToFloat(amount));                                  }                              }                          }                          break;                        // ==== MISCELLANEOUS ====                      case OpCode.DEBUG: _stack.Pop(); break;                      case OpCode.GETINFO:                          {                              var selector = _stack.Pop();                              var result = 0;                              if ((selector & 0x1) != 0)                              {                                  // pretend we are MS Rasterizer v35                                  result = 35;                              }                                // TODO: rotation and stretching                              //if ((selector & 0x2) != 0)                              //if ((selector & 0x4) != 0)                                // we're always rendering in grayscale                              if ((selector & 0x20) != 0)                                  result |= 1 << 12;                                // TODO: ClearType flags                                _stack.Push(result);                          }                          break;                        default:                          if (opcode >= OpCode.MIRP)                              MoveIndirectRelative(opcode - OpCode.MIRP);                          else if (opcode >= OpCode.MDRP)                              MoveDirectRelative(opcode - OpCode.MDRP);                          else                          {                              // check if this is a runtime-defined opcode                              var index = (int)opcode;                              if (index > _instructionDefs.Length || !_instructionDefs[index].IsValid)                                  throw new InvalidFontException("Unknown opcode in font program.");                                _callStackSize++;                              if (_callStackSize > MaxCallStack)                                  throw new InvalidFontException("Stack overflow; infinite recursion?");                                Execute(_instructionDefs[index]' true' false);                              _callStackSize--;                          }                          break;                  }
Magic Number,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,Execute,The following statement contains a magic number: switch (opcode)                  {                      // ==== PUSH INSTRUCTIONS ====                      case OpCode.NPUSHB:                      case OpCode.PUSHB1:                      case OpCode.PUSHB2:                      case OpCode.PUSHB3:                      case OpCode.PUSHB4:                      case OpCode.PUSHB5:                      case OpCode.PUSHB6:                      case OpCode.PUSHB7:                      case OpCode.PUSHB8:                          {                              var count = opcode == OpCode.NPUSHB ? stream.NextByte() : opcode - OpCode.PUSHB1 + 1;                              for (int i = count - 1; i >= 0; --i)                                  _stack.Push(stream.NextByte());                          }                          break;                      case OpCode.NPUSHW:                      case OpCode.PUSHW1:                      case OpCode.PUSHW2:                      case OpCode.PUSHW3:                      case OpCode.PUSHW4:                      case OpCode.PUSHW5:                      case OpCode.PUSHW6:                      case OpCode.PUSHW7:                      case OpCode.PUSHW8:                          {                              var count = opcode == OpCode.NPUSHW ? stream.NextByte() : opcode - OpCode.PUSHW1 + 1;                              for (int i = count - 1; i >= 0; --i)                                  _stack.Push(stream.NextWord());                          }                          break;                        // ==== STORAGE MANAGEMENT ====                      case OpCode.RS:                          {                              var loc = CheckIndex(_stack.Pop()' _storage.Length);                              _stack.Push(_storage[loc]);                          }                          break;                      case OpCode.WS:                          {                              var value = _stack.Pop();                              var loc = CheckIndex(_stack.Pop()' _storage.Length);                              _storage[loc] = value;                          }                          break;                        // ==== CONTROL VALUE TABLE ====                      case OpCode.WCVTP:                          {                              var value = _stack.PopFloat();                              var loc = CheckIndex(_stack.Pop()' _controlValueTable.Length);                              _controlValueTable[loc] = value;                          }                          break;                      case OpCode.WCVTF:                          {                              var value = _stack.Pop();                              var loc = CheckIndex(_stack.Pop()' _controlValueTable.Length);                              _controlValueTable[loc] = value * _scale;                          }                          break;                      case OpCode.RCVT: _stack.Push(ReadCvt()); break;                        // ==== STATE VECTORS ====                      case OpCode.SVTCA0:                      case OpCode.SVTCA1:                          {                              var axis = opcode - OpCode.SVTCA0;                              SetFreedomVectorToAxis(axis);                              SetProjectionVectorToAxis(axis);                          }                          break;                      case OpCode.SFVTPV: _state.Freedom = _state.Projection; OnVectorsUpdated(); break;                      case OpCode.SPVTCA0:                      case OpCode.SPVTCA1: SetProjectionVectorToAxis(opcode - OpCode.SPVTCA0); break;                      case OpCode.SFVTCA0:                      case OpCode.SFVTCA1: SetFreedomVectorToAxis(opcode - OpCode.SFVTCA0); break;                      case OpCode.SPVTL0:                      case OpCode.SPVTL1:                      case OpCode.SFVTL0:                      case OpCode.SFVTL1: SetVectorToLine(opcode - OpCode.SPVTL0' false); break;                      case OpCode.SDPVTL0:                      case OpCode.SDPVTL1: SetVectorToLine(opcode - OpCode.SDPVTL0' true); break;                      case OpCode.SPVFS:                      case OpCode.SFVFS:                          {                              var y = _stack.Pop();                              var x = _stack.Pop();                              var vec = Vector2.Normalize(new Vector2(F2Dot14ToFloat(x)' F2Dot14ToFloat(y)));                              if (opcode == OpCode.SFVFS)                                  _state.Freedom = vec;                              else                              {                                  _state.Projection = vec;                                  _state.DualProjection = vec;                              }                              OnVectorsUpdated();                          }                          break;                      case OpCode.GPV:                      case OpCode.GFV:                          {                              var vec = opcode == OpCode.GPV ? _state.Projection : _state.Freedom;                              _stack.Push(FloatToF2Dot14(vec.X));                              _stack.Push(FloatToF2Dot14(vec.Y));                          }                          break;                        // ==== GRAPHICS STATE ====                      case OpCode.SRP0: _state.Rp0 = _stack.Pop(); break;                      case OpCode.SRP1: _state.Rp1 = _stack.Pop(); break;                      case OpCode.SRP2: _state.Rp2 = _stack.Pop(); break;                      case OpCode.SZP0: _zp0 = GetZoneFromStack(); break;                      case OpCode.SZP1: _zp1 = GetZoneFromStack(); break;                      case OpCode.SZP2: _zp2 = GetZoneFromStack(); break;                      case OpCode.SZPS: _zp0 = _zp1 = _zp2 = GetZoneFromStack(); break;                      case OpCode.RTHG: _state.RoundState = RoundMode.ToHalfGrid; break;                      case OpCode.RTG: _state.RoundState = RoundMode.ToGrid; break;                      case OpCode.RTDG: _state.RoundState = RoundMode.ToDoubleGrid; break;                      case OpCode.RDTG: _state.RoundState = RoundMode.DownToGrid; break;                      case OpCode.RUTG: _state.RoundState = RoundMode.UpToGrid; break;                      case OpCode.ROFF: _state.RoundState = RoundMode.Off; break;                      case OpCode.SROUND: _state.RoundState = RoundMode.Super; SetSuperRound(1.0f); break;                      case OpCode.S45ROUND: _state.RoundState = RoundMode.Super45; SetSuperRound(Sqrt2Over2); break;                      case OpCode.INSTCTRL:                          {                              var selector = _stack.Pop();                              if (selector >= 1 && selector <= 2)                              {                                  // value is false if zero' otherwise shift the right bit into the flags                                  var bit = 1 << (selector - 1);                                  if (_stack.Pop() == 0)                                      _state.InstructionControl = (InstructionControlFlags)((int)_state.InstructionControl & ~bit);                                  else                                      _state.InstructionControl = (InstructionControlFlags)((int)_state.InstructionControl | bit);                              }                          }                          break;                      case OpCode.SCANCTRL: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SCANTYPE: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SANGW: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SLOOP: _state.Loop = _stack.Pop(); break;                      case OpCode.SMD: _state.MinDistance = _stack.PopFloat(); break;                      case OpCode.SCVTCI: _state.ControlValueCutIn = _stack.PopFloat(); break;                      case OpCode.SSWCI: _state.SingleWidthCutIn = _stack.PopFloat(); break;                      case OpCode.SSW: _state.SingleWidthValue = _stack.Pop() * _scale; break;                      case OpCode.FLIPON: _state.AutoFlip = true; break;                      case OpCode.FLIPOFF: _state.AutoFlip = false; break;                      case OpCode.SDB: _state.DeltaBase = _stack.Pop(); break;                      case OpCode.SDS: _state.DeltaShift = _stack.Pop(); break;                        // ==== POINT MEASUREMENT ====                      case OpCode.GC0: _stack.Push(Project(_zp2.GetCurrent(_stack.Pop()))); break;                      case OpCode.GC1: _stack.Push(DualProject(_zp2.GetOriginal(_stack.Pop()))); break;                      case OpCode.SCFS:                          {                              var value = _stack.PopFloat();                              var index = _stack.Pop();                              var point = _zp2.GetCurrent(index);                              MovePoint(_zp2' index' value - Project(point));                                // moving twilight points moves their "original" value also                              if (_zp2.IsTwilight)                                  _zp2.Original[index].P = _zp2.Current[index].P;                          }                          break;                      case OpCode.MD0:                          {                              var p1 = _zp1.GetOriginal(_stack.Pop());                              var p2 = _zp0.GetOriginal(_stack.Pop());                              _stack.Push(DualProject(p2 - p1));                          }                          break;                      case OpCode.MD1:                          {                              var p1 = _zp1.GetCurrent(_stack.Pop());                              var p2 = _zp0.GetCurrent(_stack.Pop());                              _stack.Push(Project(p2 - p1));                          }                          break;                      case OpCode.MPS: // MPS should return point size' but we assume DPI so it's the same as pixel size                      case OpCode.MPPEM: _stack.Push(_ppem); break;                      case OpCode.AA: /* deprecated instruction */ _stack.Pop(); break;                        // ==== POINT MODIFICATION ====                      case OpCode.FLIPPT:                          {                              for (int i = 0; i < _state.Loop; i++)                              {                                  var index = _stack.Pop();                                  //review here again!                                  _points.Current[index].onCurve = !_points.Current[index].onCurve;                                  //if (points.Current[index].onCurve)                                  //    points.Current[index].onCurve = false;                                  //else                                  //    points.Current[index].onCurve = true;                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.FLIPRGON:                          {                              var end = _stack.Pop();                              for (int i = _stack.Pop(); i <= end; i++)                                  //points.Current[i].Type = PointType.OnCurve;                                  _points.Current[i].onCurve = true;                          }                          break;                      case OpCode.FLIPRGOFF:                          {                              var end = _stack.Pop();                              for (int i = _stack.Pop(); i <= end; i++)                                  //points.Current[i].Type = PointType.Quadratic;                                  _points.Current[i].onCurve = false;                          }                          break;                      case OpCode.SHP0:                      case OpCode.SHP1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              ShiftPoints(displacement);                          }                          break;                      case OpCode.SHPIX: ShiftPoints(_stack.PopFloat() * _state.Freedom); break;                      case OpCode.SHC0:                      case OpCode.SHC1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              var touch = GetTouchState();                              var contour = _stack.Pop();                              var start = contour == 0 ? 0 : _contours[contour - 1] + 1;                              var count = _zp2.IsTwilight ? _zp2.Current.Length : _contours[contour] + 1;                                for (int i = start; i < count; i++)                              {                                  // don't move the reference point                                  if (zone.Current != _zp2.Current || point != i)                                  {                                      _zp2.Current[i].P += displacement;                                      _zp2.TouchState[i] |= touch;                                  }                              }                          }                          break;                      case OpCode.SHZ0:                      case OpCode.SHZ1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              var count = 0;                              if (_zp2.IsTwilight)                                  count = _zp2.Current.Length;                              else if (_contours.Length > 0)                                  count = _contours[_contours.Length - 1] + 1;                                for (int i = 0; i < count; i++)                              {                                  // don't move the reference point                                  if (zone.Current != _zp2.Current || point != i)                                      _zp2.Current[i].P += displacement;                              }                          }                          break;                      case OpCode.MIAP0:                      case OpCode.MIAP1:                          {                              var distance = ReadCvt();                              var pointIndex = _stack.Pop();                                // this instruction is used in the CVT to set up twilight points with original values                              if (_zp0.IsTwilight)                              {                                  var original = _state.Freedom * distance;                                  _zp0.Original[pointIndex].P = original;                                  _zp0.Current[pointIndex].P = original;                              }                                // current position of the point along the projection vector                              var point = _zp0.GetCurrent(pointIndex);                              var currentPos = Project(point);                              if (opcode == OpCode.MIAP1)                              {                                  // only use the CVT if we are above the cut-in point                                  if (Math.Abs(distance - currentPos) > _state.ControlValueCutIn)                                      distance = currentPos;                                  distance = Round(distance);                              }                                MovePoint(_zp0' pointIndex' distance - currentPos);                              _state.Rp0 = pointIndex;                              _state.Rp1 = pointIndex;                          }                          break;                      case OpCode.MDAP0:                      case OpCode.MDAP1:                          {                              var pointIndex = _stack.Pop();                              var point = _zp0.GetCurrent(pointIndex);                              var distance = 0.0f;                              if (opcode == OpCode.MDAP1)                              {                                  distance = Project(point);                                  distance = Round(distance) - distance;                              }                                MovePoint(_zp0' pointIndex' distance);                              _state.Rp0 = pointIndex;                              _state.Rp1 = pointIndex;                          }                          break;                      case OpCode.MSIRP0:                      case OpCode.MSIRP1:                          {                              var targetDistance = _stack.PopFloat();                              var pointIndex = _stack.Pop();                                // if we're operating on the twilight zone' initialize the points                              if (_zp1.IsTwilight)                              {                                  _zp1.Original[pointIndex].P = _zp0.Original[_state.Rp0].P + targetDistance * _state.Freedom / _fdotp;                                  _zp1.Current[pointIndex].P = _zp1.Original[pointIndex].P;                              }                                var currentDistance = Project(_zp1.GetCurrent(pointIndex) - _zp0.GetCurrent(_state.Rp0));                              MovePoint(_zp1' pointIndex' targetDistance - currentDistance);                                _state.Rp1 = _state.Rp0;                              _state.Rp2 = pointIndex;                              if (opcode == OpCode.MSIRP1)                                  _state.Rp0 = pointIndex;                          }                          break;                      case OpCode.IP:                          {                              var originalBase = _zp0.GetOriginal(_state.Rp1);                              var currentBase = _zp0.GetCurrent(_state.Rp1);                              var originalRange = DualProject(_zp1.GetOriginal(_state.Rp2) - originalBase);                              var currentRange = Project(_zp1.GetCurrent(_state.Rp2) - currentBase);                                for (int i = 0; i < _state.Loop; i++)                              {                                  var pointIndex = _stack.Pop();                                  var point = _zp2.GetCurrent(pointIndex);                                  var currentDistance = Project(point - currentBase);                                  var originalDistance = DualProject(_zp2.GetOriginal(pointIndex) - originalBase);                                    var newDistance = 0.0f;                                  if (originalDistance != 0.0f)                                  {                                      // a range of 0.0f is invalid according to the spec (would result in a div by zero)                                      if (originalRange == 0.0f)                                          newDistance = originalDistance;                                      else                                          newDistance = originalDistance * currentRange / originalRange;                                  }                                    MovePoint(_zp2' pointIndex' newDistance - currentDistance);                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.ALIGNRP:                          {                              for (int i = 0; i < _state.Loop; i++)                              {                                  var pointIndex = _stack.Pop();                                  var p1 = _zp1.GetCurrent(pointIndex);                                  var p2 = _zp0.GetCurrent(_state.Rp0);                                  MovePoint(_zp1' pointIndex' -Project(p1 - p2));                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.ALIGNPTS:                          {                              var p1 = _stack.Pop();                              var p2 = _stack.Pop();                              var distance = Project(_zp0.GetCurrent(p2) - _zp1.GetCurrent(p1)) / 2;                              MovePoint(_zp1' p1' distance);                              MovePoint(_zp0' p2' -distance);                          }                          break;                      case OpCode.UTP: _zp0.TouchState[_stack.Pop()] &= ~GetTouchState(); break;                      case OpCode.IUP0:                      case OpCode.IUP1:                          // bail if no contours (empty outline)                          if (_contours.Length == 0)                          {                              break;                          }                            //{                            //    //WinterDev's new managed version                          //    GlyphPointF[] currentPnts = points.Current;                          //    GlyphPointF[] originalPnts = points.Original;                            //    int cnt_count = contours.Length;                          //    int point = 0;                          //    // opcode controls whether we care about X or Y direction                          //    // do some pointer trickery so we can operate on the                          //    // points in a direction-agnostic manner                          //    TouchState touchMask;                            //    if (opcode == OpCode.IUP0)                          //    {                          //        //y -axis                          //        touchMask = TouchState.Y;                            //        //                          //        for (int i = 0; i < cnt_count; ++i)                          //        {                          //            int endPoint = contours[i];                          //            int firstPoint = point;                          //            int firstTouched = -1;                          //            int lastTouched = -1;                            //            for (; point <= endPoint; point++)                          //            {                          //                // check whether this point has been touched                          //                if ((points.TouchState[point] & touchMask) != 0)                          //                {                          //                    // if this is the first touched point in the contour' note it and continue                          //                    if (firstTouched < 0)                          //                    {                          //                        firstTouched = point;                          //                        lastTouched = point;                          //                        continue;                          //                    }                            //                    // otherwise' interpolate all untouched points                          //                    // between this point and our last touched point                          //                    InterpolatePointsYAxis(currentPnts' originalPnts' lastTouched + 1' point - 1' lastTouched' point);                          //                    lastTouched = point;                          //                }                          //            }                            //            // check if we had any touched points at all in this contour                          //            if (firstTouched >= 0)                          //            {                          //                // there are two cases left to handle:                          //                // 1. there was only one touched point in the whole contour' in                          //                //    which case we want to shift everything relative to that one                          //                // 2. several touched points' in which case handle the gap from the                          //                //    beginning to the first touched point and the gap from the last                          //                //    touched point to the end of the contour                          //                if (lastTouched == firstTouched)                          //                {                          //                    float delta = currentPnts[lastTouched].Y - originalPnts[lastTouched].Y;                          //                    if (delta != 0.0f)                          //                    {                          //                        for (int n = firstPoint; n < lastTouched; n++)                          //                        {                          //                            currentPnts[n].OffsetY(delta);                          //                        }                          //                        for (int n = lastTouched + 1; n <= endPoint; n++)                          //                        {                          //                            currentPnts[n].OffsetY(delta);                          //                        }                            //                    }                          //                }                          //                else                          //                {                          //                    InterpolatePointsYAxis(currentPnts' originalPnts' lastTouched + 1' endPoint' lastTouched' firstTouched);                          //                    if (firstTouched > 0)                          //                    {                          //                        InterpolatePointsYAxis(currentPnts' originalPnts' firstPoint' firstTouched - 1' lastTouched' firstTouched);                          //                    }                          //                }                          //            }                            //        }                          //    }                          //    else                          //    {                          //        //x-axis                          //        touchMask = TouchState.X;                          //        //                          //        for (int i = 0; i < cnt_count; ++i)                          //        {                          //            int endPoint = contours[i];                          //            int firstPoint = point;                          //            int firstTouched = -1;                          //            int lastTouched = -1;                            //            for (; point <= endPoint; point++)                          //            {                          //                // check whether this point has been touched                          //                if ((points.TouchState[point] & touchMask) != 0)                          //                {                          //                    // if this is the first touched point in the contour' note it and continue                          //                    if (firstTouched < 0)                          //                    {                          //                        firstTouched = point;                          //                        lastTouched = point;                          //                        continue;                          //                    }                            //                    // otherwise' interpolate all untouched points                          //                    // between this point and our last touched point                          //                    InterpolatePointsXAxis(currentPnts' originalPnts' lastTouched + 1' point - 1' lastTouched' point);                          //                    lastTouched = point;                          //                }                          //            }                            //            // check if we had any touched points at all in this contour                          //            if (firstTouched >= 0)                          //            {                          //                // there are two cases left to handle:                          //                // 1. there was only one touched point in the whole contour' in                          //                //    which case we want to shift everything relative to that one                          //                // 2. several touched points' in which case handle the gap from the                          //                //    beginning to the first touched point and the gap from the last                          //                //    touched point to the end of the contour                          //                if (lastTouched == firstTouched)                          //                {                          //                    float delta = currentPnts[lastTouched].X - originalPnts[lastTouched].X;                          //                    if (delta != 0.0f)                          //                    {                          //                        for (int n = firstPoint; n < lastTouched; ++n)                          //                        {                          //                            currentPnts[n].OffsetX(delta);                          //                        }                          //                        for (int n = lastTouched + 1; n <= endPoint; ++n)                          //                        {                          //                            currentPnts[n].OffsetX(delta);                          //                        }                          //                    }                          //                }                          //                else                          //                {                          //                    InterpolatePointsXAxis(currentPnts' originalPnts' lastTouched + 1' endPoint' lastTouched' firstTouched);                          //                    if (firstTouched > 0)                          //                    {                          //                        InterpolatePointsXAxis(currentPnts' originalPnts' firstPoint' firstTouched - 1' lastTouched' firstTouched);                          //                    }                          //                }                          //            }                          //        }                          //    }                          //}                          //-----------------------------------------                          unsafe                          {                                //unsafe version                               //TODO: provide manage version                               fixed (GlyphPointF* currentPtr = _points.Current)                              fixed (GlyphPointF* originalPtr = _points.Original)                              {                                  // opcode controls whether we care about X or Y direction                                  // do some pointer trickery so we can operate on the                                  // points in a direction-agnostic manner                                  TouchState touchMask;                                  byte* current;                                  byte* original;                                  if (opcode == OpCode.IUP0)                                  {                                      touchMask = TouchState.Y;                                      current = (byte*)&currentPtr->P.Y;                                      original = (byte*)&originalPtr->P.Y;                                  }                                  else                                  {                                      touchMask = TouchState.X;                                      current = (byte*)&currentPtr->P.X;                                      original = (byte*)&originalPtr->P.X;                                  }                                    var point = 0;                                  for (int i = 0; i < _contours.Length; i++)                                  {                                      var endPoint = _contours[i];                                      var firstPoint = point;                                      var firstTouched = -1;                                      var lastTouched = -1;                                        for (; point <= endPoint; point++)                                      {                                          // check whether this point has been touched                                          if ((_points.TouchState[point] & touchMask) != 0)                                          {                                              // if this is the first touched point in the contour' note it and continue                                              if (firstTouched < 0)                                              {                                                  firstTouched = point;                                                  lastTouched = point;                                                  continue;                                              }                                                // otherwise' interpolate all untouched points                                              // between this point and our last touched point                                              InterpolatePoints(current' original' lastTouched + 1' point - 1' lastTouched' point);                                              lastTouched = point;                                          }                                      }                                        // check if we had any touched points at all in this contour                                      if (firstTouched >= 0)                                      {                                          // there are two cases left to handle:                                          // 1. there was only one touched point in the whole contour' in                                          //    which case we want to shift everything relative to that one                                          // 2. several touched points' in which case handle the gap from the                                          //    beginning to the first touched point and the gap from the last                                          //    touched point to the end of the contour                                          if (lastTouched == firstTouched)                                          {                                              var delta = *GetPoint(current' lastTouched) - *GetPoint(original' lastTouched);                                              if (delta != 0.0f)                                              {                                                  for (int j = firstPoint; j < lastTouched; j++)                                                      *GetPoint(current' j) += delta;                                                  for (int j = lastTouched + 1; j <= endPoint; j++)                                                      *GetPoint(current' j) += delta;                                              }                                          }                                          else                                          {                                              InterpolatePoints(current' original' lastTouched + 1' endPoint' lastTouched' firstTouched);                                              if (firstTouched > 0)                                                  InterpolatePoints(current' original' firstPoint' firstTouched - 1' lastTouched' firstTouched);                                          }                                      }                                  }                              }                          }                          break;                      case OpCode.ISECT:                          {                              // move point P to the intersection of lines A and B                              var b1 = _zp0.GetCurrent(_stack.Pop());                              var b0 = _zp0.GetCurrent(_stack.Pop());                              var a1 = _zp1.GetCurrent(_stack.Pop());                              var a0 = _zp1.GetCurrent(_stack.Pop());                              var index = _stack.Pop();                                // calculate intersection using determinants: https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line                              var da = a0 - a1;                              var db = b0 - b1;                              var den = (da.X * db.Y) - (da.Y * db.X);                              if (Math.Abs(den) <= Epsilon)                              {                                  // parallel lines; spec says to put the ppoint "into the middle of the two lines"                                  _zp2.Current[index].P = (a0 + a1 + b0 + b1) / 4;                              }                              else                              {                                  var t = (a0.X * a1.Y) - (a0.Y * a1.X);                                  var u = (b0.X * b1.Y) - (b0.Y * b1.X);                                  var p = new Vector2(                                      (t * db.X) - (da.X * u)'                                      (t * db.Y) - (da.Y * u)                                  );                                  _zp2.Current[index].P = p / den;                              }                              _zp2.TouchState[index] = TouchState.Both;                          }                          break;                        // ==== STACK MANAGEMENT ====                      case OpCode.DUP: _stack.Duplicate(); break;                      case OpCode.POP: _stack.Pop(); break;                      case OpCode.CLEAR: _stack.Clear(); break;                      case OpCode.SWAP: _stack.Swap(); break;                      case OpCode.DEPTH: _stack.Depth(); break;                      case OpCode.CINDEX: _stack.Copy(); break;                      case OpCode.MINDEX: _stack.Move(); break;                      case OpCode.ROLL: _stack.Roll(); break;                        // ==== FLOW CONTROL ====                      case OpCode.IF:                          {                              // value is false; jump to the next else block or endif marker                              // otherwise' we don't have to do anything; we'll keep executing this block                              if (!_stack.PopBool())                              {                                  int indent = 1;                                  while (indent > 0)                                  {                                      opcode = SkipNext(ref stream);                                      switch (opcode)                                      {                                          case OpCode.IF: indent++; break;                                          case OpCode.EIF: indent--; break;                                          case OpCode.ELSE:                                              if (indent == 1)                                                  indent = 0;                                              break;                                      }                                  }                              }                          }                          break;                      case OpCode.ELSE:                          {                              // assume we hit the true statement of some previous if block                              // if we had hit false' we would have jumped over this                              int indent = 1;                              while (indent > 0)                              {                                  opcode = SkipNext(ref stream);                                  switch (opcode)                                  {                                      case OpCode.IF: indent++; break;                                      case OpCode.EIF: indent--; break;                                  }                              }                          }                          break;                      case OpCode.EIF: /* nothing to do */ break;                      case OpCode.JROT:                      case OpCode.JROF:                          {                              if (_stack.PopBool() == (opcode == OpCode.JROT))                                  stream.Jump(_stack.Pop() - 1);                              else                                  _stack.Pop();    // ignore the offset                          }                          break;                      case OpCode.JMPR: stream.Jump(_stack.Pop() - 1); break;                        // ==== LOGICAL OPS ====                      case OpCode.LT:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a < b);                          }                          break;                      case OpCode.LTEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a <= b);                          }                          break;                      case OpCode.GT:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a > b);                          }                          break;                      case OpCode.GTEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a >= b);                          }                          break;                      case OpCode.EQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a == b);                          }                          break;                      case OpCode.NEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a != b);                          }                          break;                      case OpCode.AND:                          {                              var b = _stack.PopBool();                              var a = _stack.PopBool();                              _stack.Push(a && b);                          }                          break;                      case OpCode.OR:                          {                              var b = _stack.PopBool();                              var a = _stack.PopBool();                              _stack.Push(a || b);                          }                          break;                      case OpCode.NOT: _stack.Push(!_stack.PopBool()); break;                      case OpCode.ODD:                          {                              var value = (int)Round(_stack.PopFloat());                              _stack.Push(value % 2 != 0);                          }                          break;                      case OpCode.EVEN:                          {                              var value = (int)Round(_stack.PopFloat());                              _stack.Push(value % 2 == 0);                          }                          break;                        // ==== ARITHMETIC ====                      case OpCode.ADD:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a + b);                          }                          break;                      case OpCode.SUB:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a - b);                          }                          break;                      case OpCode.DIV:                          {                              var b = _stack.Pop();                              if (b == 0)                                  throw new InvalidFontException("Division by zero.");                                var a = _stack.Pop();                              var result = ((long)a << 6) / b;                              _stack.Push((int)result);                          }                          break;                      case OpCode.MUL:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              var result = ((long)a * b) >> 6;                              _stack.Push((int)result);                          }                          break;                      case OpCode.ABS: _stack.Push(Math.Abs(_stack.Pop())); break;                      case OpCode.NEG: _stack.Push(-_stack.Pop()); break;                      case OpCode.FLOOR: _stack.Push(_stack.Pop() & ~63); break;                      case OpCode.CEILING: _stack.Push((_stack.Pop() + 63) & ~63); break;                      case OpCode.MAX: _stack.Push(Math.Max(_stack.Pop()' _stack.Pop())); break;                      case OpCode.MIN: _stack.Push(Math.Min(_stack.Pop()' _stack.Pop())); break;                        // ==== FUNCTIONS ====                      case OpCode.FDEF:                          {                              if (!allowFunctionDefs || inFunction)                                  throw new InvalidFontException("Can't define functions here.");                                _functions[_stack.Pop()] = stream;                              while (SkipNext(ref stream) != OpCode.ENDF) ;                          }                          break;                      case OpCode.IDEF:                          {                              if (!allowFunctionDefs || inFunction)                                  throw new InvalidFontException("Can't define functions here.");                                _instructionDefs[_stack.Pop()] = stream;                              while (SkipNext(ref stream) != OpCode.ENDF) ;                          }                          break;                      case OpCode.ENDF:                          {                              if (!inFunction)                                  throw new InvalidFontException("Found invalid ENDF marker outside of a function definition.");                              return;                          }                      case OpCode.CALL:                      case OpCode.LOOPCALL:                          {                              _callStackSize++;                              if (_callStackSize > MaxCallStack)                                  throw new InvalidFontException("Stack overflow; infinite recursion?");                                var function = _functions[_stack.Pop()];                              var count = opcode == OpCode.LOOPCALL ? _stack.Pop() : 1;                              for (int i = 0; i < count; i++)                                  Execute(function' true' false);                              _callStackSize--;                          }                          break;                        // ==== ROUNDING ====                      // we don't have "engine compensation" so the variants are unnecessary                      case OpCode.ROUND0:                      case OpCode.ROUND1:                      case OpCode.ROUND2:                      case OpCode.ROUND3: _stack.Push(Round(_stack.PopFloat())); break;                      case OpCode.NROUND0:                      case OpCode.NROUND1:                      case OpCode.NROUND2:                      case OpCode.NROUND3: break;                        // ==== DELTA EXCEPTIONS ====                      case OpCode.DELTAC1:                      case OpCode.DELTAC2:                      case OpCode.DELTAC3:                          {                              var last = _stack.Pop();                              for (int i = 1; i <= last; i++)                              {                                  var cvtIndex = _stack.Pop();                                  var arg = _stack.Pop();                                    // upper 4 bits of the 8-bit arg is the relative ppem                                  // the opcode specifies the base to add to the ppem                                  var triggerPpem = (arg >> 4) & 0xF;                                  triggerPpem += (opcode - OpCode.DELTAC1) * 16;                                  triggerPpem += _state.DeltaBase;                                    // if the current ppem matches the trigger' apply the exception                                  if (_ppem == triggerPpem)                                  {                                      // the lower 4 bits of the arg is the amount to shift                                      // it's encoded such that 0 isn't an allowable value (who wants to shift by 0 anyway?)                                      var amount = (arg & 0xF) - 8;                                      if (amount >= 0)                                          amount++;                                      amount *= 1 << (6 - _state.DeltaShift);                                        // update the CVT                                      CheckIndex(cvtIndex' _controlValueTable.Length);                                      _controlValueTable[cvtIndex] += F26Dot6ToFloat(amount);                                  }                              }                          }                          break;                      case OpCode.DELTAP1:                      case OpCode.DELTAP2:                      case OpCode.DELTAP3:                          {                              var last = _stack.Pop();                              for (int i = 1; i <= last; i++)                              {                                  var pointIndex = _stack.Pop();                                  var arg = _stack.Pop();                                    // upper 4 bits of the 8-bit arg is the relative ppem                                  // the opcode specifies the base to add to the ppem                                  var triggerPpem = (arg >> 4) & 0xF;                                  triggerPpem += _state.DeltaBase;                                  if (opcode != OpCode.DELTAP1)                                      triggerPpem += (opcode - OpCode.DELTAP2 + 1) * 16;                                    // if the current ppem matches the trigger' apply the exception                                  if (_ppem == triggerPpem)                                  {                                      // the lower 4 bits of the arg is the amount to shift                                      // it's encoded such that 0 isn't an allowable value (who wants to shift by 0 anyway?)                                      var amount = (arg & 0xF) - 8;                                      if (amount >= 0)                                          amount++;                                      amount *= 1 << (6 - _state.DeltaShift);                                        MovePoint(_zp0' pointIndex' F26Dot6ToFloat(amount));                                  }                              }                          }                          break;                        // ==== MISCELLANEOUS ====                      case OpCode.DEBUG: _stack.Pop(); break;                      case OpCode.GETINFO:                          {                              var selector = _stack.Pop();                              var result = 0;                              if ((selector & 0x1) != 0)                              {                                  // pretend we are MS Rasterizer v35                                  result = 35;                              }                                // TODO: rotation and stretching                              //if ((selector & 0x2) != 0)                              //if ((selector & 0x4) != 0)                                // we're always rendering in grayscale                              if ((selector & 0x20) != 0)                                  result |= 1 << 12;                                // TODO: ClearType flags                                _stack.Push(result);                          }                          break;                        default:                          if (opcode >= OpCode.MIRP)                              MoveIndirectRelative(opcode - OpCode.MIRP);                          else if (opcode >= OpCode.MDRP)                              MoveDirectRelative(opcode - OpCode.MDRP);                          else                          {                              // check if this is a runtime-defined opcode                              var index = (int)opcode;                              if (index > _instructionDefs.Length || !_instructionDefs[index].IsValid)                                  throw new InvalidFontException("Unknown opcode in font program.");                                _callStackSize++;                              if (_callStackSize > MaxCallStack)                                  throw new InvalidFontException("Stack overflow; infinite recursion?");                                Execute(_instructionDefs[index]' true' false);                              _callStackSize--;                          }                          break;                  }
Magic Number,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,Execute,The following statement contains a magic number: switch (opcode)                  {                      // ==== PUSH INSTRUCTIONS ====                      case OpCode.NPUSHB:                      case OpCode.PUSHB1:                      case OpCode.PUSHB2:                      case OpCode.PUSHB3:                      case OpCode.PUSHB4:                      case OpCode.PUSHB5:                      case OpCode.PUSHB6:                      case OpCode.PUSHB7:                      case OpCode.PUSHB8:                          {                              var count = opcode == OpCode.NPUSHB ? stream.NextByte() : opcode - OpCode.PUSHB1 + 1;                              for (int i = count - 1; i >= 0; --i)                                  _stack.Push(stream.NextByte());                          }                          break;                      case OpCode.NPUSHW:                      case OpCode.PUSHW1:                      case OpCode.PUSHW2:                      case OpCode.PUSHW3:                      case OpCode.PUSHW4:                      case OpCode.PUSHW5:                      case OpCode.PUSHW6:                      case OpCode.PUSHW7:                      case OpCode.PUSHW8:                          {                              var count = opcode == OpCode.NPUSHW ? stream.NextByte() : opcode - OpCode.PUSHW1 + 1;                              for (int i = count - 1; i >= 0; --i)                                  _stack.Push(stream.NextWord());                          }                          break;                        // ==== STORAGE MANAGEMENT ====                      case OpCode.RS:                          {                              var loc = CheckIndex(_stack.Pop()' _storage.Length);                              _stack.Push(_storage[loc]);                          }                          break;                      case OpCode.WS:                          {                              var value = _stack.Pop();                              var loc = CheckIndex(_stack.Pop()' _storage.Length);                              _storage[loc] = value;                          }                          break;                        // ==== CONTROL VALUE TABLE ====                      case OpCode.WCVTP:                          {                              var value = _stack.PopFloat();                              var loc = CheckIndex(_stack.Pop()' _controlValueTable.Length);                              _controlValueTable[loc] = value;                          }                          break;                      case OpCode.WCVTF:                          {                              var value = _stack.Pop();                              var loc = CheckIndex(_stack.Pop()' _controlValueTable.Length);                              _controlValueTable[loc] = value * _scale;                          }                          break;                      case OpCode.RCVT: _stack.Push(ReadCvt()); break;                        // ==== STATE VECTORS ====                      case OpCode.SVTCA0:                      case OpCode.SVTCA1:                          {                              var axis = opcode - OpCode.SVTCA0;                              SetFreedomVectorToAxis(axis);                              SetProjectionVectorToAxis(axis);                          }                          break;                      case OpCode.SFVTPV: _state.Freedom = _state.Projection; OnVectorsUpdated(); break;                      case OpCode.SPVTCA0:                      case OpCode.SPVTCA1: SetProjectionVectorToAxis(opcode - OpCode.SPVTCA0); break;                      case OpCode.SFVTCA0:                      case OpCode.SFVTCA1: SetFreedomVectorToAxis(opcode - OpCode.SFVTCA0); break;                      case OpCode.SPVTL0:                      case OpCode.SPVTL1:                      case OpCode.SFVTL0:                      case OpCode.SFVTL1: SetVectorToLine(opcode - OpCode.SPVTL0' false); break;                      case OpCode.SDPVTL0:                      case OpCode.SDPVTL1: SetVectorToLine(opcode - OpCode.SDPVTL0' true); break;                      case OpCode.SPVFS:                      case OpCode.SFVFS:                          {                              var y = _stack.Pop();                              var x = _stack.Pop();                              var vec = Vector2.Normalize(new Vector2(F2Dot14ToFloat(x)' F2Dot14ToFloat(y)));                              if (opcode == OpCode.SFVFS)                                  _state.Freedom = vec;                              else                              {                                  _state.Projection = vec;                                  _state.DualProjection = vec;                              }                              OnVectorsUpdated();                          }                          break;                      case OpCode.GPV:                      case OpCode.GFV:                          {                              var vec = opcode == OpCode.GPV ? _state.Projection : _state.Freedom;                              _stack.Push(FloatToF2Dot14(vec.X));                              _stack.Push(FloatToF2Dot14(vec.Y));                          }                          break;                        // ==== GRAPHICS STATE ====                      case OpCode.SRP0: _state.Rp0 = _stack.Pop(); break;                      case OpCode.SRP1: _state.Rp1 = _stack.Pop(); break;                      case OpCode.SRP2: _state.Rp2 = _stack.Pop(); break;                      case OpCode.SZP0: _zp0 = GetZoneFromStack(); break;                      case OpCode.SZP1: _zp1 = GetZoneFromStack(); break;                      case OpCode.SZP2: _zp2 = GetZoneFromStack(); break;                      case OpCode.SZPS: _zp0 = _zp1 = _zp2 = GetZoneFromStack(); break;                      case OpCode.RTHG: _state.RoundState = RoundMode.ToHalfGrid; break;                      case OpCode.RTG: _state.RoundState = RoundMode.ToGrid; break;                      case OpCode.RTDG: _state.RoundState = RoundMode.ToDoubleGrid; break;                      case OpCode.RDTG: _state.RoundState = RoundMode.DownToGrid; break;                      case OpCode.RUTG: _state.RoundState = RoundMode.UpToGrid; break;                      case OpCode.ROFF: _state.RoundState = RoundMode.Off; break;                      case OpCode.SROUND: _state.RoundState = RoundMode.Super; SetSuperRound(1.0f); break;                      case OpCode.S45ROUND: _state.RoundState = RoundMode.Super45; SetSuperRound(Sqrt2Over2); break;                      case OpCode.INSTCTRL:                          {                              var selector = _stack.Pop();                              if (selector >= 1 && selector <= 2)                              {                                  // value is false if zero' otherwise shift the right bit into the flags                                  var bit = 1 << (selector - 1);                                  if (_stack.Pop() == 0)                                      _state.InstructionControl = (InstructionControlFlags)((int)_state.InstructionControl & ~bit);                                  else                                      _state.InstructionControl = (InstructionControlFlags)((int)_state.InstructionControl | bit);                              }                          }                          break;                      case OpCode.SCANCTRL: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SCANTYPE: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SANGW: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SLOOP: _state.Loop = _stack.Pop(); break;                      case OpCode.SMD: _state.MinDistance = _stack.PopFloat(); break;                      case OpCode.SCVTCI: _state.ControlValueCutIn = _stack.PopFloat(); break;                      case OpCode.SSWCI: _state.SingleWidthCutIn = _stack.PopFloat(); break;                      case OpCode.SSW: _state.SingleWidthValue = _stack.Pop() * _scale; break;                      case OpCode.FLIPON: _state.AutoFlip = true; break;                      case OpCode.FLIPOFF: _state.AutoFlip = false; break;                      case OpCode.SDB: _state.DeltaBase = _stack.Pop(); break;                      case OpCode.SDS: _state.DeltaShift = _stack.Pop(); break;                        // ==== POINT MEASUREMENT ====                      case OpCode.GC0: _stack.Push(Project(_zp2.GetCurrent(_stack.Pop()))); break;                      case OpCode.GC1: _stack.Push(DualProject(_zp2.GetOriginal(_stack.Pop()))); break;                      case OpCode.SCFS:                          {                              var value = _stack.PopFloat();                              var index = _stack.Pop();                              var point = _zp2.GetCurrent(index);                              MovePoint(_zp2' index' value - Project(point));                                // moving twilight points moves their "original" value also                              if (_zp2.IsTwilight)                                  _zp2.Original[index].P = _zp2.Current[index].P;                          }                          break;                      case OpCode.MD0:                          {                              var p1 = _zp1.GetOriginal(_stack.Pop());                              var p2 = _zp0.GetOriginal(_stack.Pop());                              _stack.Push(DualProject(p2 - p1));                          }                          break;                      case OpCode.MD1:                          {                              var p1 = _zp1.GetCurrent(_stack.Pop());                              var p2 = _zp0.GetCurrent(_stack.Pop());                              _stack.Push(Project(p2 - p1));                          }                          break;                      case OpCode.MPS: // MPS should return point size' but we assume DPI so it's the same as pixel size                      case OpCode.MPPEM: _stack.Push(_ppem); break;                      case OpCode.AA: /* deprecated instruction */ _stack.Pop(); break;                        // ==== POINT MODIFICATION ====                      case OpCode.FLIPPT:                          {                              for (int i = 0; i < _state.Loop; i++)                              {                                  var index = _stack.Pop();                                  //review here again!                                  _points.Current[index].onCurve = !_points.Current[index].onCurve;                                  //if (points.Current[index].onCurve)                                  //    points.Current[index].onCurve = false;                                  //else                                  //    points.Current[index].onCurve = true;                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.FLIPRGON:                          {                              var end = _stack.Pop();                              for (int i = _stack.Pop(); i <= end; i++)                                  //points.Current[i].Type = PointType.OnCurve;                                  _points.Current[i].onCurve = true;                          }                          break;                      case OpCode.FLIPRGOFF:                          {                              var end = _stack.Pop();                              for (int i = _stack.Pop(); i <= end; i++)                                  //points.Current[i].Type = PointType.Quadratic;                                  _points.Current[i].onCurve = false;                          }                          break;                      case OpCode.SHP0:                      case OpCode.SHP1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              ShiftPoints(displacement);                          }                          break;                      case OpCode.SHPIX: ShiftPoints(_stack.PopFloat() * _state.Freedom); break;                      case OpCode.SHC0:                      case OpCode.SHC1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              var touch = GetTouchState();                              var contour = _stack.Pop();                              var start = contour == 0 ? 0 : _contours[contour - 1] + 1;                              var count = _zp2.IsTwilight ? _zp2.Current.Length : _contours[contour] + 1;                                for (int i = start; i < count; i++)                              {                                  // don't move the reference point                                  if (zone.Current != _zp2.Current || point != i)                                  {                                      _zp2.Current[i].P += displacement;                                      _zp2.TouchState[i] |= touch;                                  }                              }                          }                          break;                      case OpCode.SHZ0:                      case OpCode.SHZ1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              var count = 0;                              if (_zp2.IsTwilight)                                  count = _zp2.Current.Length;                              else if (_contours.Length > 0)                                  count = _contours[_contours.Length - 1] + 1;                                for (int i = 0; i < count; i++)                              {                                  // don't move the reference point                                  if (zone.Current != _zp2.Current || point != i)                                      _zp2.Current[i].P += displacement;                              }                          }                          break;                      case OpCode.MIAP0:                      case OpCode.MIAP1:                          {                              var distance = ReadCvt();                              var pointIndex = _stack.Pop();                                // this instruction is used in the CVT to set up twilight points with original values                              if (_zp0.IsTwilight)                              {                                  var original = _state.Freedom * distance;                                  _zp0.Original[pointIndex].P = original;                                  _zp0.Current[pointIndex].P = original;                              }                                // current position of the point along the projection vector                              var point = _zp0.GetCurrent(pointIndex);                              var currentPos = Project(point);                              if (opcode == OpCode.MIAP1)                              {                                  // only use the CVT if we are above the cut-in point                                  if (Math.Abs(distance - currentPos) > _state.ControlValueCutIn)                                      distance = currentPos;                                  distance = Round(distance);                              }                                MovePoint(_zp0' pointIndex' distance - currentPos);                              _state.Rp0 = pointIndex;                              _state.Rp1 = pointIndex;                          }                          break;                      case OpCode.MDAP0:                      case OpCode.MDAP1:                          {                              var pointIndex = _stack.Pop();                              var point = _zp0.GetCurrent(pointIndex);                              var distance = 0.0f;                              if (opcode == OpCode.MDAP1)                              {                                  distance = Project(point);                                  distance = Round(distance) - distance;                              }                                MovePoint(_zp0' pointIndex' distance);                              _state.Rp0 = pointIndex;                              _state.Rp1 = pointIndex;                          }                          break;                      case OpCode.MSIRP0:                      case OpCode.MSIRP1:                          {                              var targetDistance = _stack.PopFloat();                              var pointIndex = _stack.Pop();                                // if we're operating on the twilight zone' initialize the points                              if (_zp1.IsTwilight)                              {                                  _zp1.Original[pointIndex].P = _zp0.Original[_state.Rp0].P + targetDistance * _state.Freedom / _fdotp;                                  _zp1.Current[pointIndex].P = _zp1.Original[pointIndex].P;                              }                                var currentDistance = Project(_zp1.GetCurrent(pointIndex) - _zp0.GetCurrent(_state.Rp0));                              MovePoint(_zp1' pointIndex' targetDistance - currentDistance);                                _state.Rp1 = _state.Rp0;                              _state.Rp2 = pointIndex;                              if (opcode == OpCode.MSIRP1)                                  _state.Rp0 = pointIndex;                          }                          break;                      case OpCode.IP:                          {                              var originalBase = _zp0.GetOriginal(_state.Rp1);                              var currentBase = _zp0.GetCurrent(_state.Rp1);                              var originalRange = DualProject(_zp1.GetOriginal(_state.Rp2) - originalBase);                              var currentRange = Project(_zp1.GetCurrent(_state.Rp2) - currentBase);                                for (int i = 0; i < _state.Loop; i++)                              {                                  var pointIndex = _stack.Pop();                                  var point = _zp2.GetCurrent(pointIndex);                                  var currentDistance = Project(point - currentBase);                                  var originalDistance = DualProject(_zp2.GetOriginal(pointIndex) - originalBase);                                    var newDistance = 0.0f;                                  if (originalDistance != 0.0f)                                  {                                      // a range of 0.0f is invalid according to the spec (would result in a div by zero)                                      if (originalRange == 0.0f)                                          newDistance = originalDistance;                                      else                                          newDistance = originalDistance * currentRange / originalRange;                                  }                                    MovePoint(_zp2' pointIndex' newDistance - currentDistance);                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.ALIGNRP:                          {                              for (int i = 0; i < _state.Loop; i++)                              {                                  var pointIndex = _stack.Pop();                                  var p1 = _zp1.GetCurrent(pointIndex);                                  var p2 = _zp0.GetCurrent(_state.Rp0);                                  MovePoint(_zp1' pointIndex' -Project(p1 - p2));                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.ALIGNPTS:                          {                              var p1 = _stack.Pop();                              var p2 = _stack.Pop();                              var distance = Project(_zp0.GetCurrent(p2) - _zp1.GetCurrent(p1)) / 2;                              MovePoint(_zp1' p1' distance);                              MovePoint(_zp0' p2' -distance);                          }                          break;                      case OpCode.UTP: _zp0.TouchState[_stack.Pop()] &= ~GetTouchState(); break;                      case OpCode.IUP0:                      case OpCode.IUP1:                          // bail if no contours (empty outline)                          if (_contours.Length == 0)                          {                              break;                          }                            //{                            //    //WinterDev's new managed version                          //    GlyphPointF[] currentPnts = points.Current;                          //    GlyphPointF[] originalPnts = points.Original;                            //    int cnt_count = contours.Length;                          //    int point = 0;                          //    // opcode controls whether we care about X or Y direction                          //    // do some pointer trickery so we can operate on the                          //    // points in a direction-agnostic manner                          //    TouchState touchMask;                            //    if (opcode == OpCode.IUP0)                          //    {                          //        //y -axis                          //        touchMask = TouchState.Y;                            //        //                          //        for (int i = 0; i < cnt_count; ++i)                          //        {                          //            int endPoint = contours[i];                          //            int firstPoint = point;                          //            int firstTouched = -1;                          //            int lastTouched = -1;                            //            for (; point <= endPoint; point++)                          //            {                          //                // check whether this point has been touched                          //                if ((points.TouchState[point] & touchMask) != 0)                          //                {                          //                    // if this is the first touched point in the contour' note it and continue                          //                    if (firstTouched < 0)                          //                    {                          //                        firstTouched = point;                          //                        lastTouched = point;                          //                        continue;                          //                    }                            //                    // otherwise' interpolate all untouched points                          //                    // between this point and our last touched point                          //                    InterpolatePointsYAxis(currentPnts' originalPnts' lastTouched + 1' point - 1' lastTouched' point);                          //                    lastTouched = point;                          //                }                          //            }                            //            // check if we had any touched points at all in this contour                          //            if (firstTouched >= 0)                          //            {                          //                // there are two cases left to handle:                          //                // 1. there was only one touched point in the whole contour' in                          //                //    which case we want to shift everything relative to that one                          //                // 2. several touched points' in which case handle the gap from the                          //                //    beginning to the first touched point and the gap from the last                          //                //    touched point to the end of the contour                          //                if (lastTouched == firstTouched)                          //                {                          //                    float delta = currentPnts[lastTouched].Y - originalPnts[lastTouched].Y;                          //                    if (delta != 0.0f)                          //                    {                          //                        for (int n = firstPoint; n < lastTouched; n++)                          //                        {                          //                            currentPnts[n].OffsetY(delta);                          //                        }                          //                        for (int n = lastTouched + 1; n <= endPoint; n++)                          //                        {                          //                            currentPnts[n].OffsetY(delta);                          //                        }                            //                    }                          //                }                          //                else                          //                {                          //                    InterpolatePointsYAxis(currentPnts' originalPnts' lastTouched + 1' endPoint' lastTouched' firstTouched);                          //                    if (firstTouched > 0)                          //                    {                          //                        InterpolatePointsYAxis(currentPnts' originalPnts' firstPoint' firstTouched - 1' lastTouched' firstTouched);                          //                    }                          //                }                          //            }                            //        }                          //    }                          //    else                          //    {                          //        //x-axis                          //        touchMask = TouchState.X;                          //        //                          //        for (int i = 0; i < cnt_count; ++i)                          //        {                          //            int endPoint = contours[i];                          //            int firstPoint = point;                          //            int firstTouched = -1;                          //            int lastTouched = -1;                            //            for (; point <= endPoint; point++)                          //            {                          //                // check whether this point has been touched                          //                if ((points.TouchState[point] & touchMask) != 0)                          //                {                          //                    // if this is the first touched point in the contour' note it and continue                          //                    if (firstTouched < 0)                          //                    {                          //                        firstTouched = point;                          //                        lastTouched = point;                          //                        continue;                          //                    }                            //                    // otherwise' interpolate all untouched points                          //                    // between this point and our last touched point                          //                    InterpolatePointsXAxis(currentPnts' originalPnts' lastTouched + 1' point - 1' lastTouched' point);                          //                    lastTouched = point;                          //                }                          //            }                            //            // check if we had any touched points at all in this contour                          //            if (firstTouched >= 0)                          //            {                          //                // there are two cases left to handle:                          //                // 1. there was only one touched point in the whole contour' in                          //                //    which case we want to shift everything relative to that one                          //                // 2. several touched points' in which case handle the gap from the                          //                //    beginning to the first touched point and the gap from the last                          //                //    touched point to the end of the contour                          //                if (lastTouched == firstTouched)                          //                {                          //                    float delta = currentPnts[lastTouched].X - originalPnts[lastTouched].X;                          //                    if (delta != 0.0f)                          //                    {                          //                        for (int n = firstPoint; n < lastTouched; ++n)                          //                        {                          //                            currentPnts[n].OffsetX(delta);                          //                        }                          //                        for (int n = lastTouched + 1; n <= endPoint; ++n)                          //                        {                          //                            currentPnts[n].OffsetX(delta);                          //                        }                          //                    }                          //                }                          //                else                          //                {                          //                    InterpolatePointsXAxis(currentPnts' originalPnts' lastTouched + 1' endPoint' lastTouched' firstTouched);                          //                    if (firstTouched > 0)                          //                    {                          //                        InterpolatePointsXAxis(currentPnts' originalPnts' firstPoint' firstTouched - 1' lastTouched' firstTouched);                          //                    }                          //                }                          //            }                          //        }                          //    }                          //}                          //-----------------------------------------                          unsafe                          {                                //unsafe version                               //TODO: provide manage version                               fixed (GlyphPointF* currentPtr = _points.Current)                              fixed (GlyphPointF* originalPtr = _points.Original)                              {                                  // opcode controls whether we care about X or Y direction                                  // do some pointer trickery so we can operate on the                                  // points in a direction-agnostic manner                                  TouchState touchMask;                                  byte* current;                                  byte* original;                                  if (opcode == OpCode.IUP0)                                  {                                      touchMask = TouchState.Y;                                      current = (byte*)&currentPtr->P.Y;                                      original = (byte*)&originalPtr->P.Y;                                  }                                  else                                  {                                      touchMask = TouchState.X;                                      current = (byte*)&currentPtr->P.X;                                      original = (byte*)&originalPtr->P.X;                                  }                                    var point = 0;                                  for (int i = 0; i < _contours.Length; i++)                                  {                                      var endPoint = _contours[i];                                      var firstPoint = point;                                      var firstTouched = -1;                                      var lastTouched = -1;                                        for (; point <= endPoint; point++)                                      {                                          // check whether this point has been touched                                          if ((_points.TouchState[point] & touchMask) != 0)                                          {                                              // if this is the first touched point in the contour' note it and continue                                              if (firstTouched < 0)                                              {                                                  firstTouched = point;                                                  lastTouched = point;                                                  continue;                                              }                                                // otherwise' interpolate all untouched points                                              // between this point and our last touched point                                              InterpolatePoints(current' original' lastTouched + 1' point - 1' lastTouched' point);                                              lastTouched = point;                                          }                                      }                                        // check if we had any touched points at all in this contour                                      if (firstTouched >= 0)                                      {                                          // there are two cases left to handle:                                          // 1. there was only one touched point in the whole contour' in                                          //    which case we want to shift everything relative to that one                                          // 2. several touched points' in which case handle the gap from the                                          //    beginning to the first touched point and the gap from the last                                          //    touched point to the end of the contour                                          if (lastTouched == firstTouched)                                          {                                              var delta = *GetPoint(current' lastTouched) - *GetPoint(original' lastTouched);                                              if (delta != 0.0f)                                              {                                                  for (int j = firstPoint; j < lastTouched; j++)                                                      *GetPoint(current' j) += delta;                                                  for (int j = lastTouched + 1; j <= endPoint; j++)                                                      *GetPoint(current' j) += delta;                                              }                                          }                                          else                                          {                                              InterpolatePoints(current' original' lastTouched + 1' endPoint' lastTouched' firstTouched);                                              if (firstTouched > 0)                                                  InterpolatePoints(current' original' firstPoint' firstTouched - 1' lastTouched' firstTouched);                                          }                                      }                                  }                              }                          }                          break;                      case OpCode.ISECT:                          {                              // move point P to the intersection of lines A and B                              var b1 = _zp0.GetCurrent(_stack.Pop());                              var b0 = _zp0.GetCurrent(_stack.Pop());                              var a1 = _zp1.GetCurrent(_stack.Pop());                              var a0 = _zp1.GetCurrent(_stack.Pop());                              var index = _stack.Pop();                                // calculate intersection using determinants: https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line                              var da = a0 - a1;                              var db = b0 - b1;                              var den = (da.X * db.Y) - (da.Y * db.X);                              if (Math.Abs(den) <= Epsilon)                              {                                  // parallel lines; spec says to put the ppoint "into the middle of the two lines"                                  _zp2.Current[index].P = (a0 + a1 + b0 + b1) / 4;                              }                              else                              {                                  var t = (a0.X * a1.Y) - (a0.Y * a1.X);                                  var u = (b0.X * b1.Y) - (b0.Y * b1.X);                                  var p = new Vector2(                                      (t * db.X) - (da.X * u)'                                      (t * db.Y) - (da.Y * u)                                  );                                  _zp2.Current[index].P = p / den;                              }                              _zp2.TouchState[index] = TouchState.Both;                          }                          break;                        // ==== STACK MANAGEMENT ====                      case OpCode.DUP: _stack.Duplicate(); break;                      case OpCode.POP: _stack.Pop(); break;                      case OpCode.CLEAR: _stack.Clear(); break;                      case OpCode.SWAP: _stack.Swap(); break;                      case OpCode.DEPTH: _stack.Depth(); break;                      case OpCode.CINDEX: _stack.Copy(); break;                      case OpCode.MINDEX: _stack.Move(); break;                      case OpCode.ROLL: _stack.Roll(); break;                        // ==== FLOW CONTROL ====                      case OpCode.IF:                          {                              // value is false; jump to the next else block or endif marker                              // otherwise' we don't have to do anything; we'll keep executing this block                              if (!_stack.PopBool())                              {                                  int indent = 1;                                  while (indent > 0)                                  {                                      opcode = SkipNext(ref stream);                                      switch (opcode)                                      {                                          case OpCode.IF: indent++; break;                                          case OpCode.EIF: indent--; break;                                          case OpCode.ELSE:                                              if (indent == 1)                                                  indent = 0;                                              break;                                      }                                  }                              }                          }                          break;                      case OpCode.ELSE:                          {                              // assume we hit the true statement of some previous if block                              // if we had hit false' we would have jumped over this                              int indent = 1;                              while (indent > 0)                              {                                  opcode = SkipNext(ref stream);                                  switch (opcode)                                  {                                      case OpCode.IF: indent++; break;                                      case OpCode.EIF: indent--; break;                                  }                              }                          }                          break;                      case OpCode.EIF: /* nothing to do */ break;                      case OpCode.JROT:                      case OpCode.JROF:                          {                              if (_stack.PopBool() == (opcode == OpCode.JROT))                                  stream.Jump(_stack.Pop() - 1);                              else                                  _stack.Pop();    // ignore the offset                          }                          break;                      case OpCode.JMPR: stream.Jump(_stack.Pop() - 1); break;                        // ==== LOGICAL OPS ====                      case OpCode.LT:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a < b);                          }                          break;                      case OpCode.LTEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a <= b);                          }                          break;                      case OpCode.GT:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a > b);                          }                          break;                      case OpCode.GTEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a >= b);                          }                          break;                      case OpCode.EQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a == b);                          }                          break;                      case OpCode.NEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a != b);                          }                          break;                      case OpCode.AND:                          {                              var b = _stack.PopBool();                              var a = _stack.PopBool();                              _stack.Push(a && b);                          }                          break;                      case OpCode.OR:                          {                              var b = _stack.PopBool();                              var a = _stack.PopBool();                              _stack.Push(a || b);                          }                          break;                      case OpCode.NOT: _stack.Push(!_stack.PopBool()); break;                      case OpCode.ODD:                          {                              var value = (int)Round(_stack.PopFloat());                              _stack.Push(value % 2 != 0);                          }                          break;                      case OpCode.EVEN:                          {                              var value = (int)Round(_stack.PopFloat());                              _stack.Push(value % 2 == 0);                          }                          break;                        // ==== ARITHMETIC ====                      case OpCode.ADD:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a + b);                          }                          break;                      case OpCode.SUB:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a - b);                          }                          break;                      case OpCode.DIV:                          {                              var b = _stack.Pop();                              if (b == 0)                                  throw new InvalidFontException("Division by zero.");                                var a = _stack.Pop();                              var result = ((long)a << 6) / b;                              _stack.Push((int)result);                          }                          break;                      case OpCode.MUL:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              var result = ((long)a * b) >> 6;                              _stack.Push((int)result);                          }                          break;                      case OpCode.ABS: _stack.Push(Math.Abs(_stack.Pop())); break;                      case OpCode.NEG: _stack.Push(-_stack.Pop()); break;                      case OpCode.FLOOR: _stack.Push(_stack.Pop() & ~63); break;                      case OpCode.CEILING: _stack.Push((_stack.Pop() + 63) & ~63); break;                      case OpCode.MAX: _stack.Push(Math.Max(_stack.Pop()' _stack.Pop())); break;                      case OpCode.MIN: _stack.Push(Math.Min(_stack.Pop()' _stack.Pop())); break;                        // ==== FUNCTIONS ====                      case OpCode.FDEF:                          {                              if (!allowFunctionDefs || inFunction)                                  throw new InvalidFontException("Can't define functions here.");                                _functions[_stack.Pop()] = stream;                              while (SkipNext(ref stream) != OpCode.ENDF) ;                          }                          break;                      case OpCode.IDEF:                          {                              if (!allowFunctionDefs || inFunction)                                  throw new InvalidFontException("Can't define functions here.");                                _instructionDefs[_stack.Pop()] = stream;                              while (SkipNext(ref stream) != OpCode.ENDF) ;                          }                          break;                      case OpCode.ENDF:                          {                              if (!inFunction)                                  throw new InvalidFontException("Found invalid ENDF marker outside of a function definition.");                              return;                          }                      case OpCode.CALL:                      case OpCode.LOOPCALL:                          {                              _callStackSize++;                              if (_callStackSize > MaxCallStack)                                  throw new InvalidFontException("Stack overflow; infinite recursion?");                                var function = _functions[_stack.Pop()];                              var count = opcode == OpCode.LOOPCALL ? _stack.Pop() : 1;                              for (int i = 0; i < count; i++)                                  Execute(function' true' false);                              _callStackSize--;                          }                          break;                        // ==== ROUNDING ====                      // we don't have "engine compensation" so the variants are unnecessary                      case OpCode.ROUND0:                      case OpCode.ROUND1:                      case OpCode.ROUND2:                      case OpCode.ROUND3: _stack.Push(Round(_stack.PopFloat())); break;                      case OpCode.NROUND0:                      case OpCode.NROUND1:                      case OpCode.NROUND2:                      case OpCode.NROUND3: break;                        // ==== DELTA EXCEPTIONS ====                      case OpCode.DELTAC1:                      case OpCode.DELTAC2:                      case OpCode.DELTAC3:                          {                              var last = _stack.Pop();                              for (int i = 1; i <= last; i++)                              {                                  var cvtIndex = _stack.Pop();                                  var arg = _stack.Pop();                                    // upper 4 bits of the 8-bit arg is the relative ppem                                  // the opcode specifies the base to add to the ppem                                  var triggerPpem = (arg >> 4) & 0xF;                                  triggerPpem += (opcode - OpCode.DELTAC1) * 16;                                  triggerPpem += _state.DeltaBase;                                    // if the current ppem matches the trigger' apply the exception                                  if (_ppem == triggerPpem)                                  {                                      // the lower 4 bits of the arg is the amount to shift                                      // it's encoded such that 0 isn't an allowable value (who wants to shift by 0 anyway?)                                      var amount = (arg & 0xF) - 8;                                      if (amount >= 0)                                          amount++;                                      amount *= 1 << (6 - _state.DeltaShift);                                        // update the CVT                                      CheckIndex(cvtIndex' _controlValueTable.Length);                                      _controlValueTable[cvtIndex] += F26Dot6ToFloat(amount);                                  }                              }                          }                          break;                      case OpCode.DELTAP1:                      case OpCode.DELTAP2:                      case OpCode.DELTAP3:                          {                              var last = _stack.Pop();                              for (int i = 1; i <= last; i++)                              {                                  var pointIndex = _stack.Pop();                                  var arg = _stack.Pop();                                    // upper 4 bits of the 8-bit arg is the relative ppem                                  // the opcode specifies the base to add to the ppem                                  var triggerPpem = (arg >> 4) & 0xF;                                  triggerPpem += _state.DeltaBase;                                  if (opcode != OpCode.DELTAP1)                                      triggerPpem += (opcode - OpCode.DELTAP2 + 1) * 16;                                    // if the current ppem matches the trigger' apply the exception                                  if (_ppem == triggerPpem)                                  {                                      // the lower 4 bits of the arg is the amount to shift                                      // it's encoded such that 0 isn't an allowable value (who wants to shift by 0 anyway?)                                      var amount = (arg & 0xF) - 8;                                      if (amount >= 0)                                          amount++;                                      amount *= 1 << (6 - _state.DeltaShift);                                        MovePoint(_zp0' pointIndex' F26Dot6ToFloat(amount));                                  }                              }                          }                          break;                        // ==== MISCELLANEOUS ====                      case OpCode.DEBUG: _stack.Pop(); break;                      case OpCode.GETINFO:                          {                              var selector = _stack.Pop();                              var result = 0;                              if ((selector & 0x1) != 0)                              {                                  // pretend we are MS Rasterizer v35                                  result = 35;                              }                                // TODO: rotation and stretching                              //if ((selector & 0x2) != 0)                              //if ((selector & 0x4) != 0)                                // we're always rendering in grayscale                              if ((selector & 0x20) != 0)                                  result |= 1 << 12;                                // TODO: ClearType flags                                _stack.Push(result);                          }                          break;                        default:                          if (opcode >= OpCode.MIRP)                              MoveIndirectRelative(opcode - OpCode.MIRP);                          else if (opcode >= OpCode.MDRP)                              MoveDirectRelative(opcode - OpCode.MDRP);                          else                          {                              // check if this is a runtime-defined opcode                              var index = (int)opcode;                              if (index > _instructionDefs.Length || !_instructionDefs[index].IsValid)                                  throw new InvalidFontException("Unknown opcode in font program.");                                _callStackSize++;                              if (_callStackSize > MaxCallStack)                                  throw new InvalidFontException("Stack overflow; infinite recursion?");                                Execute(_instructionDefs[index]' true' false);                              _callStackSize--;                          }                          break;                  }
Magic Number,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,Execute,The following statement contains a magic number: switch (opcode)                  {                      // ==== PUSH INSTRUCTIONS ====                      case OpCode.NPUSHB:                      case OpCode.PUSHB1:                      case OpCode.PUSHB2:                      case OpCode.PUSHB3:                      case OpCode.PUSHB4:                      case OpCode.PUSHB5:                      case OpCode.PUSHB6:                      case OpCode.PUSHB7:                      case OpCode.PUSHB8:                          {                              var count = opcode == OpCode.NPUSHB ? stream.NextByte() : opcode - OpCode.PUSHB1 + 1;                              for (int i = count - 1; i >= 0; --i)                                  _stack.Push(stream.NextByte());                          }                          break;                      case OpCode.NPUSHW:                      case OpCode.PUSHW1:                      case OpCode.PUSHW2:                      case OpCode.PUSHW3:                      case OpCode.PUSHW4:                      case OpCode.PUSHW5:                      case OpCode.PUSHW6:                      case OpCode.PUSHW7:                      case OpCode.PUSHW8:                          {                              var count = opcode == OpCode.NPUSHW ? stream.NextByte() : opcode - OpCode.PUSHW1 + 1;                              for (int i = count - 1; i >= 0; --i)                                  _stack.Push(stream.NextWord());                          }                          break;                        // ==== STORAGE MANAGEMENT ====                      case OpCode.RS:                          {                              var loc = CheckIndex(_stack.Pop()' _storage.Length);                              _stack.Push(_storage[loc]);                          }                          break;                      case OpCode.WS:                          {                              var value = _stack.Pop();                              var loc = CheckIndex(_stack.Pop()' _storage.Length);                              _storage[loc] = value;                          }                          break;                        // ==== CONTROL VALUE TABLE ====                      case OpCode.WCVTP:                          {                              var value = _stack.PopFloat();                              var loc = CheckIndex(_stack.Pop()' _controlValueTable.Length);                              _controlValueTable[loc] = value;                          }                          break;                      case OpCode.WCVTF:                          {                              var value = _stack.Pop();                              var loc = CheckIndex(_stack.Pop()' _controlValueTable.Length);                              _controlValueTable[loc] = value * _scale;                          }                          break;                      case OpCode.RCVT: _stack.Push(ReadCvt()); break;                        // ==== STATE VECTORS ====                      case OpCode.SVTCA0:                      case OpCode.SVTCA1:                          {                              var axis = opcode - OpCode.SVTCA0;                              SetFreedomVectorToAxis(axis);                              SetProjectionVectorToAxis(axis);                          }                          break;                      case OpCode.SFVTPV: _state.Freedom = _state.Projection; OnVectorsUpdated(); break;                      case OpCode.SPVTCA0:                      case OpCode.SPVTCA1: SetProjectionVectorToAxis(opcode - OpCode.SPVTCA0); break;                      case OpCode.SFVTCA0:                      case OpCode.SFVTCA1: SetFreedomVectorToAxis(opcode - OpCode.SFVTCA0); break;                      case OpCode.SPVTL0:                      case OpCode.SPVTL1:                      case OpCode.SFVTL0:                      case OpCode.SFVTL1: SetVectorToLine(opcode - OpCode.SPVTL0' false); break;                      case OpCode.SDPVTL0:                      case OpCode.SDPVTL1: SetVectorToLine(opcode - OpCode.SDPVTL0' true); break;                      case OpCode.SPVFS:                      case OpCode.SFVFS:                          {                              var y = _stack.Pop();                              var x = _stack.Pop();                              var vec = Vector2.Normalize(new Vector2(F2Dot14ToFloat(x)' F2Dot14ToFloat(y)));                              if (opcode == OpCode.SFVFS)                                  _state.Freedom = vec;                              else                              {                                  _state.Projection = vec;                                  _state.DualProjection = vec;                              }                              OnVectorsUpdated();                          }                          break;                      case OpCode.GPV:                      case OpCode.GFV:                          {                              var vec = opcode == OpCode.GPV ? _state.Projection : _state.Freedom;                              _stack.Push(FloatToF2Dot14(vec.X));                              _stack.Push(FloatToF2Dot14(vec.Y));                          }                          break;                        // ==== GRAPHICS STATE ====                      case OpCode.SRP0: _state.Rp0 = _stack.Pop(); break;                      case OpCode.SRP1: _state.Rp1 = _stack.Pop(); break;                      case OpCode.SRP2: _state.Rp2 = _stack.Pop(); break;                      case OpCode.SZP0: _zp0 = GetZoneFromStack(); break;                      case OpCode.SZP1: _zp1 = GetZoneFromStack(); break;                      case OpCode.SZP2: _zp2 = GetZoneFromStack(); break;                      case OpCode.SZPS: _zp0 = _zp1 = _zp2 = GetZoneFromStack(); break;                      case OpCode.RTHG: _state.RoundState = RoundMode.ToHalfGrid; break;                      case OpCode.RTG: _state.RoundState = RoundMode.ToGrid; break;                      case OpCode.RTDG: _state.RoundState = RoundMode.ToDoubleGrid; break;                      case OpCode.RDTG: _state.RoundState = RoundMode.DownToGrid; break;                      case OpCode.RUTG: _state.RoundState = RoundMode.UpToGrid; break;                      case OpCode.ROFF: _state.RoundState = RoundMode.Off; break;                      case OpCode.SROUND: _state.RoundState = RoundMode.Super; SetSuperRound(1.0f); break;                      case OpCode.S45ROUND: _state.RoundState = RoundMode.Super45; SetSuperRound(Sqrt2Over2); break;                      case OpCode.INSTCTRL:                          {                              var selector = _stack.Pop();                              if (selector >= 1 && selector <= 2)                              {                                  // value is false if zero' otherwise shift the right bit into the flags                                  var bit = 1 << (selector - 1);                                  if (_stack.Pop() == 0)                                      _state.InstructionControl = (InstructionControlFlags)((int)_state.InstructionControl & ~bit);                                  else                                      _state.InstructionControl = (InstructionControlFlags)((int)_state.InstructionControl | bit);                              }                          }                          break;                      case OpCode.SCANCTRL: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SCANTYPE: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SANGW: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SLOOP: _state.Loop = _stack.Pop(); break;                      case OpCode.SMD: _state.MinDistance = _stack.PopFloat(); break;                      case OpCode.SCVTCI: _state.ControlValueCutIn = _stack.PopFloat(); break;                      case OpCode.SSWCI: _state.SingleWidthCutIn = _stack.PopFloat(); break;                      case OpCode.SSW: _state.SingleWidthValue = _stack.Pop() * _scale; break;                      case OpCode.FLIPON: _state.AutoFlip = true; break;                      case OpCode.FLIPOFF: _state.AutoFlip = false; break;                      case OpCode.SDB: _state.DeltaBase = _stack.Pop(); break;                      case OpCode.SDS: _state.DeltaShift = _stack.Pop(); break;                        // ==== POINT MEASUREMENT ====                      case OpCode.GC0: _stack.Push(Project(_zp2.GetCurrent(_stack.Pop()))); break;                      case OpCode.GC1: _stack.Push(DualProject(_zp2.GetOriginal(_stack.Pop()))); break;                      case OpCode.SCFS:                          {                              var value = _stack.PopFloat();                              var index = _stack.Pop();                              var point = _zp2.GetCurrent(index);                              MovePoint(_zp2' index' value - Project(point));                                // moving twilight points moves their "original" value also                              if (_zp2.IsTwilight)                                  _zp2.Original[index].P = _zp2.Current[index].P;                          }                          break;                      case OpCode.MD0:                          {                              var p1 = _zp1.GetOriginal(_stack.Pop());                              var p2 = _zp0.GetOriginal(_stack.Pop());                              _stack.Push(DualProject(p2 - p1));                          }                          break;                      case OpCode.MD1:                          {                              var p1 = _zp1.GetCurrent(_stack.Pop());                              var p2 = _zp0.GetCurrent(_stack.Pop());                              _stack.Push(Project(p2 - p1));                          }                          break;                      case OpCode.MPS: // MPS should return point size' but we assume DPI so it's the same as pixel size                      case OpCode.MPPEM: _stack.Push(_ppem); break;                      case OpCode.AA: /* deprecated instruction */ _stack.Pop(); break;                        // ==== POINT MODIFICATION ====                      case OpCode.FLIPPT:                          {                              for (int i = 0; i < _state.Loop; i++)                              {                                  var index = _stack.Pop();                                  //review here again!                                  _points.Current[index].onCurve = !_points.Current[index].onCurve;                                  //if (points.Current[index].onCurve)                                  //    points.Current[index].onCurve = false;                                  //else                                  //    points.Current[index].onCurve = true;                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.FLIPRGON:                          {                              var end = _stack.Pop();                              for (int i = _stack.Pop(); i <= end; i++)                                  //points.Current[i].Type = PointType.OnCurve;                                  _points.Current[i].onCurve = true;                          }                          break;                      case OpCode.FLIPRGOFF:                          {                              var end = _stack.Pop();                              for (int i = _stack.Pop(); i <= end; i++)                                  //points.Current[i].Type = PointType.Quadratic;                                  _points.Current[i].onCurve = false;                          }                          break;                      case OpCode.SHP0:                      case OpCode.SHP1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              ShiftPoints(displacement);                          }                          break;                      case OpCode.SHPIX: ShiftPoints(_stack.PopFloat() * _state.Freedom); break;                      case OpCode.SHC0:                      case OpCode.SHC1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              var touch = GetTouchState();                              var contour = _stack.Pop();                              var start = contour == 0 ? 0 : _contours[contour - 1] + 1;                              var count = _zp2.IsTwilight ? _zp2.Current.Length : _contours[contour] + 1;                                for (int i = start; i < count; i++)                              {                                  // don't move the reference point                                  if (zone.Current != _zp2.Current || point != i)                                  {                                      _zp2.Current[i].P += displacement;                                      _zp2.TouchState[i] |= touch;                                  }                              }                          }                          break;                      case OpCode.SHZ0:                      case OpCode.SHZ1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              var count = 0;                              if (_zp2.IsTwilight)                                  count = _zp2.Current.Length;                              else if (_contours.Length > 0)                                  count = _contours[_contours.Length - 1] + 1;                                for (int i = 0; i < count; i++)                              {                                  // don't move the reference point                                  if (zone.Current != _zp2.Current || point != i)                                      _zp2.Current[i].P += displacement;                              }                          }                          break;                      case OpCode.MIAP0:                      case OpCode.MIAP1:                          {                              var distance = ReadCvt();                              var pointIndex = _stack.Pop();                                // this instruction is used in the CVT to set up twilight points with original values                              if (_zp0.IsTwilight)                              {                                  var original = _state.Freedom * distance;                                  _zp0.Original[pointIndex].P = original;                                  _zp0.Current[pointIndex].P = original;                              }                                // current position of the point along the projection vector                              var point = _zp0.GetCurrent(pointIndex);                              var currentPos = Project(point);                              if (opcode == OpCode.MIAP1)                              {                                  // only use the CVT if we are above the cut-in point                                  if (Math.Abs(distance - currentPos) > _state.ControlValueCutIn)                                      distance = currentPos;                                  distance = Round(distance);                              }                                MovePoint(_zp0' pointIndex' distance - currentPos);                              _state.Rp0 = pointIndex;                              _state.Rp1 = pointIndex;                          }                          break;                      case OpCode.MDAP0:                      case OpCode.MDAP1:                          {                              var pointIndex = _stack.Pop();                              var point = _zp0.GetCurrent(pointIndex);                              var distance = 0.0f;                              if (opcode == OpCode.MDAP1)                              {                                  distance = Project(point);                                  distance = Round(distance) - distance;                              }                                MovePoint(_zp0' pointIndex' distance);                              _state.Rp0 = pointIndex;                              _state.Rp1 = pointIndex;                          }                          break;                      case OpCode.MSIRP0:                      case OpCode.MSIRP1:                          {                              var targetDistance = _stack.PopFloat();                              var pointIndex = _stack.Pop();                                // if we're operating on the twilight zone' initialize the points                              if (_zp1.IsTwilight)                              {                                  _zp1.Original[pointIndex].P = _zp0.Original[_state.Rp0].P + targetDistance * _state.Freedom / _fdotp;                                  _zp1.Current[pointIndex].P = _zp1.Original[pointIndex].P;                              }                                var currentDistance = Project(_zp1.GetCurrent(pointIndex) - _zp0.GetCurrent(_state.Rp0));                              MovePoint(_zp1' pointIndex' targetDistance - currentDistance);                                _state.Rp1 = _state.Rp0;                              _state.Rp2 = pointIndex;                              if (opcode == OpCode.MSIRP1)                                  _state.Rp0 = pointIndex;                          }                          break;                      case OpCode.IP:                          {                              var originalBase = _zp0.GetOriginal(_state.Rp1);                              var currentBase = _zp0.GetCurrent(_state.Rp1);                              var originalRange = DualProject(_zp1.GetOriginal(_state.Rp2) - originalBase);                              var currentRange = Project(_zp1.GetCurrent(_state.Rp2) - currentBase);                                for (int i = 0; i < _state.Loop; i++)                              {                                  var pointIndex = _stack.Pop();                                  var point = _zp2.GetCurrent(pointIndex);                                  var currentDistance = Project(point - currentBase);                                  var originalDistance = DualProject(_zp2.GetOriginal(pointIndex) - originalBase);                                    var newDistance = 0.0f;                                  if (originalDistance != 0.0f)                                  {                                      // a range of 0.0f is invalid according to the spec (would result in a div by zero)                                      if (originalRange == 0.0f)                                          newDistance = originalDistance;                                      else                                          newDistance = originalDistance * currentRange / originalRange;                                  }                                    MovePoint(_zp2' pointIndex' newDistance - currentDistance);                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.ALIGNRP:                          {                              for (int i = 0; i < _state.Loop; i++)                              {                                  var pointIndex = _stack.Pop();                                  var p1 = _zp1.GetCurrent(pointIndex);                                  var p2 = _zp0.GetCurrent(_state.Rp0);                                  MovePoint(_zp1' pointIndex' -Project(p1 - p2));                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.ALIGNPTS:                          {                              var p1 = _stack.Pop();                              var p2 = _stack.Pop();                              var distance = Project(_zp0.GetCurrent(p2) - _zp1.GetCurrent(p1)) / 2;                              MovePoint(_zp1' p1' distance);                              MovePoint(_zp0' p2' -distance);                          }                          break;                      case OpCode.UTP: _zp0.TouchState[_stack.Pop()] &= ~GetTouchState(); break;                      case OpCode.IUP0:                      case OpCode.IUP1:                          // bail if no contours (empty outline)                          if (_contours.Length == 0)                          {                              break;                          }                            //{                            //    //WinterDev's new managed version                          //    GlyphPointF[] currentPnts = points.Current;                          //    GlyphPointF[] originalPnts = points.Original;                            //    int cnt_count = contours.Length;                          //    int point = 0;                          //    // opcode controls whether we care about X or Y direction                          //    // do some pointer trickery so we can operate on the                          //    // points in a direction-agnostic manner                          //    TouchState touchMask;                            //    if (opcode == OpCode.IUP0)                          //    {                          //        //y -axis                          //        touchMask = TouchState.Y;                            //        //                          //        for (int i = 0; i < cnt_count; ++i)                          //        {                          //            int endPoint = contours[i];                          //            int firstPoint = point;                          //            int firstTouched = -1;                          //            int lastTouched = -1;                            //            for (; point <= endPoint; point++)                          //            {                          //                // check whether this point has been touched                          //                if ((points.TouchState[point] & touchMask) != 0)                          //                {                          //                    // if this is the first touched point in the contour' note it and continue                          //                    if (firstTouched < 0)                          //                    {                          //                        firstTouched = point;                          //                        lastTouched = point;                          //                        continue;                          //                    }                            //                    // otherwise' interpolate all untouched points                          //                    // between this point and our last touched point                          //                    InterpolatePointsYAxis(currentPnts' originalPnts' lastTouched + 1' point - 1' lastTouched' point);                          //                    lastTouched = point;                          //                }                          //            }                            //            // check if we had any touched points at all in this contour                          //            if (firstTouched >= 0)                          //            {                          //                // there are two cases left to handle:                          //                // 1. there was only one touched point in the whole contour' in                          //                //    which case we want to shift everything relative to that one                          //                // 2. several touched points' in which case handle the gap from the                          //                //    beginning to the first touched point and the gap from the last                          //                //    touched point to the end of the contour                          //                if (lastTouched == firstTouched)                          //                {                          //                    float delta = currentPnts[lastTouched].Y - originalPnts[lastTouched].Y;                          //                    if (delta != 0.0f)                          //                    {                          //                        for (int n = firstPoint; n < lastTouched; n++)                          //                        {                          //                            currentPnts[n].OffsetY(delta);                          //                        }                          //                        for (int n = lastTouched + 1; n <= endPoint; n++)                          //                        {                          //                            currentPnts[n].OffsetY(delta);                          //                        }                            //                    }                          //                }                          //                else                          //                {                          //                    InterpolatePointsYAxis(currentPnts' originalPnts' lastTouched + 1' endPoint' lastTouched' firstTouched);                          //                    if (firstTouched > 0)                          //                    {                          //                        InterpolatePointsYAxis(currentPnts' originalPnts' firstPoint' firstTouched - 1' lastTouched' firstTouched);                          //                    }                          //                }                          //            }                            //        }                          //    }                          //    else                          //    {                          //        //x-axis                          //        touchMask = TouchState.X;                          //        //                          //        for (int i = 0; i < cnt_count; ++i)                          //        {                          //            int endPoint = contours[i];                          //            int firstPoint = point;                          //            int firstTouched = -1;                          //            int lastTouched = -1;                            //            for (; point <= endPoint; point++)                          //            {                          //                // check whether this point has been touched                          //                if ((points.TouchState[point] & touchMask) != 0)                          //                {                          //                    // if this is the first touched point in the contour' note it and continue                          //                    if (firstTouched < 0)                          //                    {                          //                        firstTouched = point;                          //                        lastTouched = point;                          //                        continue;                          //                    }                            //                    // otherwise' interpolate all untouched points                          //                    // between this point and our last touched point                          //                    InterpolatePointsXAxis(currentPnts' originalPnts' lastTouched + 1' point - 1' lastTouched' point);                          //                    lastTouched = point;                          //                }                          //            }                            //            // check if we had any touched points at all in this contour                          //            if (firstTouched >= 0)                          //            {                          //                // there are two cases left to handle:                          //                // 1. there was only one touched point in the whole contour' in                          //                //    which case we want to shift everything relative to that one                          //                // 2. several touched points' in which case handle the gap from the                          //                //    beginning to the first touched point and the gap from the last                          //                //    touched point to the end of the contour                          //                if (lastTouched == firstTouched)                          //                {                          //                    float delta = currentPnts[lastTouched].X - originalPnts[lastTouched].X;                          //                    if (delta != 0.0f)                          //                    {                          //                        for (int n = firstPoint; n < lastTouched; ++n)                          //                        {                          //                            currentPnts[n].OffsetX(delta);                          //                        }                          //                        for (int n = lastTouched + 1; n <= endPoint; ++n)                          //                        {                          //                            currentPnts[n].OffsetX(delta);                          //                        }                          //                    }                          //                }                          //                else                          //                {                          //                    InterpolatePointsXAxis(currentPnts' originalPnts' lastTouched + 1' endPoint' lastTouched' firstTouched);                          //                    if (firstTouched > 0)                          //                    {                          //                        InterpolatePointsXAxis(currentPnts' originalPnts' firstPoint' firstTouched - 1' lastTouched' firstTouched);                          //                    }                          //                }                          //            }                          //        }                          //    }                          //}                          //-----------------------------------------                          unsafe                          {                                //unsafe version                               //TODO: provide manage version                               fixed (GlyphPointF* currentPtr = _points.Current)                              fixed (GlyphPointF* originalPtr = _points.Original)                              {                                  // opcode controls whether we care about X or Y direction                                  // do some pointer trickery so we can operate on the                                  // points in a direction-agnostic manner                                  TouchState touchMask;                                  byte* current;                                  byte* original;                                  if (opcode == OpCode.IUP0)                                  {                                      touchMask = TouchState.Y;                                      current = (byte*)&currentPtr->P.Y;                                      original = (byte*)&originalPtr->P.Y;                                  }                                  else                                  {                                      touchMask = TouchState.X;                                      current = (byte*)&currentPtr->P.X;                                      original = (byte*)&originalPtr->P.X;                                  }                                    var point = 0;                                  for (int i = 0; i < _contours.Length; i++)                                  {                                      var endPoint = _contours[i];                                      var firstPoint = point;                                      var firstTouched = -1;                                      var lastTouched = -1;                                        for (; point <= endPoint; point++)                                      {                                          // check whether this point has been touched                                          if ((_points.TouchState[point] & touchMask) != 0)                                          {                                              // if this is the first touched point in the contour' note it and continue                                              if (firstTouched < 0)                                              {                                                  firstTouched = point;                                                  lastTouched = point;                                                  continue;                                              }                                                // otherwise' interpolate all untouched points                                              // between this point and our last touched point                                              InterpolatePoints(current' original' lastTouched + 1' point - 1' lastTouched' point);                                              lastTouched = point;                                          }                                      }                                        // check if we had any touched points at all in this contour                                      if (firstTouched >= 0)                                      {                                          // there are two cases left to handle:                                          // 1. there was only one touched point in the whole contour' in                                          //    which case we want to shift everything relative to that one                                          // 2. several touched points' in which case handle the gap from the                                          //    beginning to the first touched point and the gap from the last                                          //    touched point to the end of the contour                                          if (lastTouched == firstTouched)                                          {                                              var delta = *GetPoint(current' lastTouched) - *GetPoint(original' lastTouched);                                              if (delta != 0.0f)                                              {                                                  for (int j = firstPoint; j < lastTouched; j++)                                                      *GetPoint(current' j) += delta;                                                  for (int j = lastTouched + 1; j <= endPoint; j++)                                                      *GetPoint(current' j) += delta;                                              }                                          }                                          else                                          {                                              InterpolatePoints(current' original' lastTouched + 1' endPoint' lastTouched' firstTouched);                                              if (firstTouched > 0)                                                  InterpolatePoints(current' original' firstPoint' firstTouched - 1' lastTouched' firstTouched);                                          }                                      }                                  }                              }                          }                          break;                      case OpCode.ISECT:                          {                              // move point P to the intersection of lines A and B                              var b1 = _zp0.GetCurrent(_stack.Pop());                              var b0 = _zp0.GetCurrent(_stack.Pop());                              var a1 = _zp1.GetCurrent(_stack.Pop());                              var a0 = _zp1.GetCurrent(_stack.Pop());                              var index = _stack.Pop();                                // calculate intersection using determinants: https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line                              var da = a0 - a1;                              var db = b0 - b1;                              var den = (da.X * db.Y) - (da.Y * db.X);                              if (Math.Abs(den) <= Epsilon)                              {                                  // parallel lines; spec says to put the ppoint "into the middle of the two lines"                                  _zp2.Current[index].P = (a0 + a1 + b0 + b1) / 4;                              }                              else                              {                                  var t = (a0.X * a1.Y) - (a0.Y * a1.X);                                  var u = (b0.X * b1.Y) - (b0.Y * b1.X);                                  var p = new Vector2(                                      (t * db.X) - (da.X * u)'                                      (t * db.Y) - (da.Y * u)                                  );                                  _zp2.Current[index].P = p / den;                              }                              _zp2.TouchState[index] = TouchState.Both;                          }                          break;                        // ==== STACK MANAGEMENT ====                      case OpCode.DUP: _stack.Duplicate(); break;                      case OpCode.POP: _stack.Pop(); break;                      case OpCode.CLEAR: _stack.Clear(); break;                      case OpCode.SWAP: _stack.Swap(); break;                      case OpCode.DEPTH: _stack.Depth(); break;                      case OpCode.CINDEX: _stack.Copy(); break;                      case OpCode.MINDEX: _stack.Move(); break;                      case OpCode.ROLL: _stack.Roll(); break;                        // ==== FLOW CONTROL ====                      case OpCode.IF:                          {                              // value is false; jump to the next else block or endif marker                              // otherwise' we don't have to do anything; we'll keep executing this block                              if (!_stack.PopBool())                              {                                  int indent = 1;                                  while (indent > 0)                                  {                                      opcode = SkipNext(ref stream);                                      switch (opcode)                                      {                                          case OpCode.IF: indent++; break;                                          case OpCode.EIF: indent--; break;                                          case OpCode.ELSE:                                              if (indent == 1)                                                  indent = 0;                                              break;                                      }                                  }                              }                          }                          break;                      case OpCode.ELSE:                          {                              // assume we hit the true statement of some previous if block                              // if we had hit false' we would have jumped over this                              int indent = 1;                              while (indent > 0)                              {                                  opcode = SkipNext(ref stream);                                  switch (opcode)                                  {                                      case OpCode.IF: indent++; break;                                      case OpCode.EIF: indent--; break;                                  }                              }                          }                          break;                      case OpCode.EIF: /* nothing to do */ break;                      case OpCode.JROT:                      case OpCode.JROF:                          {                              if (_stack.PopBool() == (opcode == OpCode.JROT))                                  stream.Jump(_stack.Pop() - 1);                              else                                  _stack.Pop();    // ignore the offset                          }                          break;                      case OpCode.JMPR: stream.Jump(_stack.Pop() - 1); break;                        // ==== LOGICAL OPS ====                      case OpCode.LT:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a < b);                          }                          break;                      case OpCode.LTEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a <= b);                          }                          break;                      case OpCode.GT:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a > b);                          }                          break;                      case OpCode.GTEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a >= b);                          }                          break;                      case OpCode.EQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a == b);                          }                          break;                      case OpCode.NEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a != b);                          }                          break;                      case OpCode.AND:                          {                              var b = _stack.PopBool();                              var a = _stack.PopBool();                              _stack.Push(a && b);                          }                          break;                      case OpCode.OR:                          {                              var b = _stack.PopBool();                              var a = _stack.PopBool();                              _stack.Push(a || b);                          }                          break;                      case OpCode.NOT: _stack.Push(!_stack.PopBool()); break;                      case OpCode.ODD:                          {                              var value = (int)Round(_stack.PopFloat());                              _stack.Push(value % 2 != 0);                          }                          break;                      case OpCode.EVEN:                          {                              var value = (int)Round(_stack.PopFloat());                              _stack.Push(value % 2 == 0);                          }                          break;                        // ==== ARITHMETIC ====                      case OpCode.ADD:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a + b);                          }                          break;                      case OpCode.SUB:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a - b);                          }                          break;                      case OpCode.DIV:                          {                              var b = _stack.Pop();                              if (b == 0)                                  throw new InvalidFontException("Division by zero.");                                var a = _stack.Pop();                              var result = ((long)a << 6) / b;                              _stack.Push((int)result);                          }                          break;                      case OpCode.MUL:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              var result = ((long)a * b) >> 6;                              _stack.Push((int)result);                          }                          break;                      case OpCode.ABS: _stack.Push(Math.Abs(_stack.Pop())); break;                      case OpCode.NEG: _stack.Push(-_stack.Pop()); break;                      case OpCode.FLOOR: _stack.Push(_stack.Pop() & ~63); break;                      case OpCode.CEILING: _stack.Push((_stack.Pop() + 63) & ~63); break;                      case OpCode.MAX: _stack.Push(Math.Max(_stack.Pop()' _stack.Pop())); break;                      case OpCode.MIN: _stack.Push(Math.Min(_stack.Pop()' _stack.Pop())); break;                        // ==== FUNCTIONS ====                      case OpCode.FDEF:                          {                              if (!allowFunctionDefs || inFunction)                                  throw new InvalidFontException("Can't define functions here.");                                _functions[_stack.Pop()] = stream;                              while (SkipNext(ref stream) != OpCode.ENDF) ;                          }                          break;                      case OpCode.IDEF:                          {                              if (!allowFunctionDefs || inFunction)                                  throw new InvalidFontException("Can't define functions here.");                                _instructionDefs[_stack.Pop()] = stream;                              while (SkipNext(ref stream) != OpCode.ENDF) ;                          }                          break;                      case OpCode.ENDF:                          {                              if (!inFunction)                                  throw new InvalidFontException("Found invalid ENDF marker outside of a function definition.");                              return;                          }                      case OpCode.CALL:                      case OpCode.LOOPCALL:                          {                              _callStackSize++;                              if (_callStackSize > MaxCallStack)                                  throw new InvalidFontException("Stack overflow; infinite recursion?");                                var function = _functions[_stack.Pop()];                              var count = opcode == OpCode.LOOPCALL ? _stack.Pop() : 1;                              for (int i = 0; i < count; i++)                                  Execute(function' true' false);                              _callStackSize--;                          }                          break;                        // ==== ROUNDING ====                      // we don't have "engine compensation" so the variants are unnecessary                      case OpCode.ROUND0:                      case OpCode.ROUND1:                      case OpCode.ROUND2:                      case OpCode.ROUND3: _stack.Push(Round(_stack.PopFloat())); break;                      case OpCode.NROUND0:                      case OpCode.NROUND1:                      case OpCode.NROUND2:                      case OpCode.NROUND3: break;                        // ==== DELTA EXCEPTIONS ====                      case OpCode.DELTAC1:                      case OpCode.DELTAC2:                      case OpCode.DELTAC3:                          {                              var last = _stack.Pop();                              for (int i = 1; i <= last; i++)                              {                                  var cvtIndex = _stack.Pop();                                  var arg = _stack.Pop();                                    // upper 4 bits of the 8-bit arg is the relative ppem                                  // the opcode specifies the base to add to the ppem                                  var triggerPpem = (arg >> 4) & 0xF;                                  triggerPpem += (opcode - OpCode.DELTAC1) * 16;                                  triggerPpem += _state.DeltaBase;                                    // if the current ppem matches the trigger' apply the exception                                  if (_ppem == triggerPpem)                                  {                                      // the lower 4 bits of the arg is the amount to shift                                      // it's encoded such that 0 isn't an allowable value (who wants to shift by 0 anyway?)                                      var amount = (arg & 0xF) - 8;                                      if (amount >= 0)                                          amount++;                                      amount *= 1 << (6 - _state.DeltaShift);                                        // update the CVT                                      CheckIndex(cvtIndex' _controlValueTable.Length);                                      _controlValueTable[cvtIndex] += F26Dot6ToFloat(amount);                                  }                              }                          }                          break;                      case OpCode.DELTAP1:                      case OpCode.DELTAP2:                      case OpCode.DELTAP3:                          {                              var last = _stack.Pop();                              for (int i = 1; i <= last; i++)                              {                                  var pointIndex = _stack.Pop();                                  var arg = _stack.Pop();                                    // upper 4 bits of the 8-bit arg is the relative ppem                                  // the opcode specifies the base to add to the ppem                                  var triggerPpem = (arg >> 4) & 0xF;                                  triggerPpem += _state.DeltaBase;                                  if (opcode != OpCode.DELTAP1)                                      triggerPpem += (opcode - OpCode.DELTAP2 + 1) * 16;                                    // if the current ppem matches the trigger' apply the exception                                  if (_ppem == triggerPpem)                                  {                                      // the lower 4 bits of the arg is the amount to shift                                      // it's encoded such that 0 isn't an allowable value (who wants to shift by 0 anyway?)                                      var amount = (arg & 0xF) - 8;                                      if (amount >= 0)                                          amount++;                                      amount *= 1 << (6 - _state.DeltaShift);                                        MovePoint(_zp0' pointIndex' F26Dot6ToFloat(amount));                                  }                              }                          }                          break;                        // ==== MISCELLANEOUS ====                      case OpCode.DEBUG: _stack.Pop(); break;                      case OpCode.GETINFO:                          {                              var selector = _stack.Pop();                              var result = 0;                              if ((selector & 0x1) != 0)                              {                                  // pretend we are MS Rasterizer v35                                  result = 35;                              }                                // TODO: rotation and stretching                              //if ((selector & 0x2) != 0)                              //if ((selector & 0x4) != 0)                                // we're always rendering in grayscale                              if ((selector & 0x20) != 0)                                  result |= 1 << 12;                                // TODO: ClearType flags                                _stack.Push(result);                          }                          break;                        default:                          if (opcode >= OpCode.MIRP)                              MoveIndirectRelative(opcode - OpCode.MIRP);                          else if (opcode >= OpCode.MDRP)                              MoveDirectRelative(opcode - OpCode.MDRP);                          else                          {                              // check if this is a runtime-defined opcode                              var index = (int)opcode;                              if (index > _instructionDefs.Length || !_instructionDefs[index].IsValid)                                  throw new InvalidFontException("Unknown opcode in font program.");                                _callStackSize++;                              if (_callStackSize > MaxCallStack)                                  throw new InvalidFontException("Stack overflow; infinite recursion?");                                Execute(_instructionDefs[index]' true' false);                              _callStackSize--;                          }                          break;                  }
Magic Number,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,Execute,The following statement contains a magic number: switch (opcode)                  {                      // ==== PUSH INSTRUCTIONS ====                      case OpCode.NPUSHB:                      case OpCode.PUSHB1:                      case OpCode.PUSHB2:                      case OpCode.PUSHB3:                      case OpCode.PUSHB4:                      case OpCode.PUSHB5:                      case OpCode.PUSHB6:                      case OpCode.PUSHB7:                      case OpCode.PUSHB8:                          {                              var count = opcode == OpCode.NPUSHB ? stream.NextByte() : opcode - OpCode.PUSHB1 + 1;                              for (int i = count - 1; i >= 0; --i)                                  _stack.Push(stream.NextByte());                          }                          break;                      case OpCode.NPUSHW:                      case OpCode.PUSHW1:                      case OpCode.PUSHW2:                      case OpCode.PUSHW3:                      case OpCode.PUSHW4:                      case OpCode.PUSHW5:                      case OpCode.PUSHW6:                      case OpCode.PUSHW7:                      case OpCode.PUSHW8:                          {                              var count = opcode == OpCode.NPUSHW ? stream.NextByte() : opcode - OpCode.PUSHW1 + 1;                              for (int i = count - 1; i >= 0; --i)                                  _stack.Push(stream.NextWord());                          }                          break;                        // ==== STORAGE MANAGEMENT ====                      case OpCode.RS:                          {                              var loc = CheckIndex(_stack.Pop()' _storage.Length);                              _stack.Push(_storage[loc]);                          }                          break;                      case OpCode.WS:                          {                              var value = _stack.Pop();                              var loc = CheckIndex(_stack.Pop()' _storage.Length);                              _storage[loc] = value;                          }                          break;                        // ==== CONTROL VALUE TABLE ====                      case OpCode.WCVTP:                          {                              var value = _stack.PopFloat();                              var loc = CheckIndex(_stack.Pop()' _controlValueTable.Length);                              _controlValueTable[loc] = value;                          }                          break;                      case OpCode.WCVTF:                          {                              var value = _stack.Pop();                              var loc = CheckIndex(_stack.Pop()' _controlValueTable.Length);                              _controlValueTable[loc] = value * _scale;                          }                          break;                      case OpCode.RCVT: _stack.Push(ReadCvt()); break;                        // ==== STATE VECTORS ====                      case OpCode.SVTCA0:                      case OpCode.SVTCA1:                          {                              var axis = opcode - OpCode.SVTCA0;                              SetFreedomVectorToAxis(axis);                              SetProjectionVectorToAxis(axis);                          }                          break;                      case OpCode.SFVTPV: _state.Freedom = _state.Projection; OnVectorsUpdated(); break;                      case OpCode.SPVTCA0:                      case OpCode.SPVTCA1: SetProjectionVectorToAxis(opcode - OpCode.SPVTCA0); break;                      case OpCode.SFVTCA0:                      case OpCode.SFVTCA1: SetFreedomVectorToAxis(opcode - OpCode.SFVTCA0); break;                      case OpCode.SPVTL0:                      case OpCode.SPVTL1:                      case OpCode.SFVTL0:                      case OpCode.SFVTL1: SetVectorToLine(opcode - OpCode.SPVTL0' false); break;                      case OpCode.SDPVTL0:                      case OpCode.SDPVTL1: SetVectorToLine(opcode - OpCode.SDPVTL0' true); break;                      case OpCode.SPVFS:                      case OpCode.SFVFS:                          {                              var y = _stack.Pop();                              var x = _stack.Pop();                              var vec = Vector2.Normalize(new Vector2(F2Dot14ToFloat(x)' F2Dot14ToFloat(y)));                              if (opcode == OpCode.SFVFS)                                  _state.Freedom = vec;                              else                              {                                  _state.Projection = vec;                                  _state.DualProjection = vec;                              }                              OnVectorsUpdated();                          }                          break;                      case OpCode.GPV:                      case OpCode.GFV:                          {                              var vec = opcode == OpCode.GPV ? _state.Projection : _state.Freedom;                              _stack.Push(FloatToF2Dot14(vec.X));                              _stack.Push(FloatToF2Dot14(vec.Y));                          }                          break;                        // ==== GRAPHICS STATE ====                      case OpCode.SRP0: _state.Rp0 = _stack.Pop(); break;                      case OpCode.SRP1: _state.Rp1 = _stack.Pop(); break;                      case OpCode.SRP2: _state.Rp2 = _stack.Pop(); break;                      case OpCode.SZP0: _zp0 = GetZoneFromStack(); break;                      case OpCode.SZP1: _zp1 = GetZoneFromStack(); break;                      case OpCode.SZP2: _zp2 = GetZoneFromStack(); break;                      case OpCode.SZPS: _zp0 = _zp1 = _zp2 = GetZoneFromStack(); break;                      case OpCode.RTHG: _state.RoundState = RoundMode.ToHalfGrid; break;                      case OpCode.RTG: _state.RoundState = RoundMode.ToGrid; break;                      case OpCode.RTDG: _state.RoundState = RoundMode.ToDoubleGrid; break;                      case OpCode.RDTG: _state.RoundState = RoundMode.DownToGrid; break;                      case OpCode.RUTG: _state.RoundState = RoundMode.UpToGrid; break;                      case OpCode.ROFF: _state.RoundState = RoundMode.Off; break;                      case OpCode.SROUND: _state.RoundState = RoundMode.Super; SetSuperRound(1.0f); break;                      case OpCode.S45ROUND: _state.RoundState = RoundMode.Super45; SetSuperRound(Sqrt2Over2); break;                      case OpCode.INSTCTRL:                          {                              var selector = _stack.Pop();                              if (selector >= 1 && selector <= 2)                              {                                  // value is false if zero' otherwise shift the right bit into the flags                                  var bit = 1 << (selector - 1);                                  if (_stack.Pop() == 0)                                      _state.InstructionControl = (InstructionControlFlags)((int)_state.InstructionControl & ~bit);                                  else                                      _state.InstructionControl = (InstructionControlFlags)((int)_state.InstructionControl | bit);                              }                          }                          break;                      case OpCode.SCANCTRL: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SCANTYPE: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SANGW: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SLOOP: _state.Loop = _stack.Pop(); break;                      case OpCode.SMD: _state.MinDistance = _stack.PopFloat(); break;                      case OpCode.SCVTCI: _state.ControlValueCutIn = _stack.PopFloat(); break;                      case OpCode.SSWCI: _state.SingleWidthCutIn = _stack.PopFloat(); break;                      case OpCode.SSW: _state.SingleWidthValue = _stack.Pop() * _scale; break;                      case OpCode.FLIPON: _state.AutoFlip = true; break;                      case OpCode.FLIPOFF: _state.AutoFlip = false; break;                      case OpCode.SDB: _state.DeltaBase = _stack.Pop(); break;                      case OpCode.SDS: _state.DeltaShift = _stack.Pop(); break;                        // ==== POINT MEASUREMENT ====                      case OpCode.GC0: _stack.Push(Project(_zp2.GetCurrent(_stack.Pop()))); break;                      case OpCode.GC1: _stack.Push(DualProject(_zp2.GetOriginal(_stack.Pop()))); break;                      case OpCode.SCFS:                          {                              var value = _stack.PopFloat();                              var index = _stack.Pop();                              var point = _zp2.GetCurrent(index);                              MovePoint(_zp2' index' value - Project(point));                                // moving twilight points moves their "original" value also                              if (_zp2.IsTwilight)                                  _zp2.Original[index].P = _zp2.Current[index].P;                          }                          break;                      case OpCode.MD0:                          {                              var p1 = _zp1.GetOriginal(_stack.Pop());                              var p2 = _zp0.GetOriginal(_stack.Pop());                              _stack.Push(DualProject(p2 - p1));                          }                          break;                      case OpCode.MD1:                          {                              var p1 = _zp1.GetCurrent(_stack.Pop());                              var p2 = _zp0.GetCurrent(_stack.Pop());                              _stack.Push(Project(p2 - p1));                          }                          break;                      case OpCode.MPS: // MPS should return point size' but we assume DPI so it's the same as pixel size                      case OpCode.MPPEM: _stack.Push(_ppem); break;                      case OpCode.AA: /* deprecated instruction */ _stack.Pop(); break;                        // ==== POINT MODIFICATION ====                      case OpCode.FLIPPT:                          {                              for (int i = 0; i < _state.Loop; i++)                              {                                  var index = _stack.Pop();                                  //review here again!                                  _points.Current[index].onCurve = !_points.Current[index].onCurve;                                  //if (points.Current[index].onCurve)                                  //    points.Current[index].onCurve = false;                                  //else                                  //    points.Current[index].onCurve = true;                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.FLIPRGON:                          {                              var end = _stack.Pop();                              for (int i = _stack.Pop(); i <= end; i++)                                  //points.Current[i].Type = PointType.OnCurve;                                  _points.Current[i].onCurve = true;                          }                          break;                      case OpCode.FLIPRGOFF:                          {                              var end = _stack.Pop();                              for (int i = _stack.Pop(); i <= end; i++)                                  //points.Current[i].Type = PointType.Quadratic;                                  _points.Current[i].onCurve = false;                          }                          break;                      case OpCode.SHP0:                      case OpCode.SHP1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              ShiftPoints(displacement);                          }                          break;                      case OpCode.SHPIX: ShiftPoints(_stack.PopFloat() * _state.Freedom); break;                      case OpCode.SHC0:                      case OpCode.SHC1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              var touch = GetTouchState();                              var contour = _stack.Pop();                              var start = contour == 0 ? 0 : _contours[contour - 1] + 1;                              var count = _zp2.IsTwilight ? _zp2.Current.Length : _contours[contour] + 1;                                for (int i = start; i < count; i++)                              {                                  // don't move the reference point                                  if (zone.Current != _zp2.Current || point != i)                                  {                                      _zp2.Current[i].P += displacement;                                      _zp2.TouchState[i] |= touch;                                  }                              }                          }                          break;                      case OpCode.SHZ0:                      case OpCode.SHZ1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              var count = 0;                              if (_zp2.IsTwilight)                                  count = _zp2.Current.Length;                              else if (_contours.Length > 0)                                  count = _contours[_contours.Length - 1] + 1;                                for (int i = 0; i < count; i++)                              {                                  // don't move the reference point                                  if (zone.Current != _zp2.Current || point != i)                                      _zp2.Current[i].P += displacement;                              }                          }                          break;                      case OpCode.MIAP0:                      case OpCode.MIAP1:                          {                              var distance = ReadCvt();                              var pointIndex = _stack.Pop();                                // this instruction is used in the CVT to set up twilight points with original values                              if (_zp0.IsTwilight)                              {                                  var original = _state.Freedom * distance;                                  _zp0.Original[pointIndex].P = original;                                  _zp0.Current[pointIndex].P = original;                              }                                // current position of the point along the projection vector                              var point = _zp0.GetCurrent(pointIndex);                              var currentPos = Project(point);                              if (opcode == OpCode.MIAP1)                              {                                  // only use the CVT if we are above the cut-in point                                  if (Math.Abs(distance - currentPos) > _state.ControlValueCutIn)                                      distance = currentPos;                                  distance = Round(distance);                              }                                MovePoint(_zp0' pointIndex' distance - currentPos);                              _state.Rp0 = pointIndex;                              _state.Rp1 = pointIndex;                          }                          break;                      case OpCode.MDAP0:                      case OpCode.MDAP1:                          {                              var pointIndex = _stack.Pop();                              var point = _zp0.GetCurrent(pointIndex);                              var distance = 0.0f;                              if (opcode == OpCode.MDAP1)                              {                                  distance = Project(point);                                  distance = Round(distance) - distance;                              }                                MovePoint(_zp0' pointIndex' distance);                              _state.Rp0 = pointIndex;                              _state.Rp1 = pointIndex;                          }                          break;                      case OpCode.MSIRP0:                      case OpCode.MSIRP1:                          {                              var targetDistance = _stack.PopFloat();                              var pointIndex = _stack.Pop();                                // if we're operating on the twilight zone' initialize the points                              if (_zp1.IsTwilight)                              {                                  _zp1.Original[pointIndex].P = _zp0.Original[_state.Rp0].P + targetDistance * _state.Freedom / _fdotp;                                  _zp1.Current[pointIndex].P = _zp1.Original[pointIndex].P;                              }                                var currentDistance = Project(_zp1.GetCurrent(pointIndex) - _zp0.GetCurrent(_state.Rp0));                              MovePoint(_zp1' pointIndex' targetDistance - currentDistance);                                _state.Rp1 = _state.Rp0;                              _state.Rp2 = pointIndex;                              if (opcode == OpCode.MSIRP1)                                  _state.Rp0 = pointIndex;                          }                          break;                      case OpCode.IP:                          {                              var originalBase = _zp0.GetOriginal(_state.Rp1);                              var currentBase = _zp0.GetCurrent(_state.Rp1);                              var originalRange = DualProject(_zp1.GetOriginal(_state.Rp2) - originalBase);                              var currentRange = Project(_zp1.GetCurrent(_state.Rp2) - currentBase);                                for (int i = 0; i < _state.Loop; i++)                              {                                  var pointIndex = _stack.Pop();                                  var point = _zp2.GetCurrent(pointIndex);                                  var currentDistance = Project(point - currentBase);                                  var originalDistance = DualProject(_zp2.GetOriginal(pointIndex) - originalBase);                                    var newDistance = 0.0f;                                  if (originalDistance != 0.0f)                                  {                                      // a range of 0.0f is invalid according to the spec (would result in a div by zero)                                      if (originalRange == 0.0f)                                          newDistance = originalDistance;                                      else                                          newDistance = originalDistance * currentRange / originalRange;                                  }                                    MovePoint(_zp2' pointIndex' newDistance - currentDistance);                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.ALIGNRP:                          {                              for (int i = 0; i < _state.Loop; i++)                              {                                  var pointIndex = _stack.Pop();                                  var p1 = _zp1.GetCurrent(pointIndex);                                  var p2 = _zp0.GetCurrent(_state.Rp0);                                  MovePoint(_zp1' pointIndex' -Project(p1 - p2));                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.ALIGNPTS:                          {                              var p1 = _stack.Pop();                              var p2 = _stack.Pop();                              var distance = Project(_zp0.GetCurrent(p2) - _zp1.GetCurrent(p1)) / 2;                              MovePoint(_zp1' p1' distance);                              MovePoint(_zp0' p2' -distance);                          }                          break;                      case OpCode.UTP: _zp0.TouchState[_stack.Pop()] &= ~GetTouchState(); break;                      case OpCode.IUP0:                      case OpCode.IUP1:                          // bail if no contours (empty outline)                          if (_contours.Length == 0)                          {                              break;                          }                            //{                            //    //WinterDev's new managed version                          //    GlyphPointF[] currentPnts = points.Current;                          //    GlyphPointF[] originalPnts = points.Original;                            //    int cnt_count = contours.Length;                          //    int point = 0;                          //    // opcode controls whether we care about X or Y direction                          //    // do some pointer trickery so we can operate on the                          //    // points in a direction-agnostic manner                          //    TouchState touchMask;                            //    if (opcode == OpCode.IUP0)                          //    {                          //        //y -axis                          //        touchMask = TouchState.Y;                            //        //                          //        for (int i = 0; i < cnt_count; ++i)                          //        {                          //            int endPoint = contours[i];                          //            int firstPoint = point;                          //            int firstTouched = -1;                          //            int lastTouched = -1;                            //            for (; point <= endPoint; point++)                          //            {                          //                // check whether this point has been touched                          //                if ((points.TouchState[point] & touchMask) != 0)                          //                {                          //                    // if this is the first touched point in the contour' note it and continue                          //                    if (firstTouched < 0)                          //                    {                          //                        firstTouched = point;                          //                        lastTouched = point;                          //                        continue;                          //                    }                            //                    // otherwise' interpolate all untouched points                          //                    // between this point and our last touched point                          //                    InterpolatePointsYAxis(currentPnts' originalPnts' lastTouched + 1' point - 1' lastTouched' point);                          //                    lastTouched = point;                          //                }                          //            }                            //            // check if we had any touched points at all in this contour                          //            if (firstTouched >= 0)                          //            {                          //                // there are two cases left to handle:                          //                // 1. there was only one touched point in the whole contour' in                          //                //    which case we want to shift everything relative to that one                          //                // 2. several touched points' in which case handle the gap from the                          //                //    beginning to the first touched point and the gap from the last                          //                //    touched point to the end of the contour                          //                if (lastTouched == firstTouched)                          //                {                          //                    float delta = currentPnts[lastTouched].Y - originalPnts[lastTouched].Y;                          //                    if (delta != 0.0f)                          //                    {                          //                        for (int n = firstPoint; n < lastTouched; n++)                          //                        {                          //                            currentPnts[n].OffsetY(delta);                          //                        }                          //                        for (int n = lastTouched + 1; n <= endPoint; n++)                          //                        {                          //                            currentPnts[n].OffsetY(delta);                          //                        }                            //                    }                          //                }                          //                else                          //                {                          //                    InterpolatePointsYAxis(currentPnts' originalPnts' lastTouched + 1' endPoint' lastTouched' firstTouched);                          //                    if (firstTouched > 0)                          //                    {                          //                        InterpolatePointsYAxis(currentPnts' originalPnts' firstPoint' firstTouched - 1' lastTouched' firstTouched);                          //                    }                          //                }                          //            }                            //        }                          //    }                          //    else                          //    {                          //        //x-axis                          //        touchMask = TouchState.X;                          //        //                          //        for (int i = 0; i < cnt_count; ++i)                          //        {                          //            int endPoint = contours[i];                          //            int firstPoint = point;                          //            int firstTouched = -1;                          //            int lastTouched = -1;                            //            for (; point <= endPoint; point++)                          //            {                          //                // check whether this point has been touched                          //                if ((points.TouchState[point] & touchMask) != 0)                          //                {                          //                    // if this is the first touched point in the contour' note it and continue                          //                    if (firstTouched < 0)                          //                    {                          //                        firstTouched = point;                          //                        lastTouched = point;                          //                        continue;                          //                    }                            //                    // otherwise' interpolate all untouched points                          //                    // between this point and our last touched point                          //                    InterpolatePointsXAxis(currentPnts' originalPnts' lastTouched + 1' point - 1' lastTouched' point);                          //                    lastTouched = point;                          //                }                          //            }                            //            // check if we had any touched points at all in this contour                          //            if (firstTouched >= 0)                          //            {                          //                // there are two cases left to handle:                          //                // 1. there was only one touched point in the whole contour' in                          //                //    which case we want to shift everything relative to that one                          //                // 2. several touched points' in which case handle the gap from the                          //                //    beginning to the first touched point and the gap from the last                          //                //    touched point to the end of the contour                          //                if (lastTouched == firstTouched)                          //                {                          //                    float delta = currentPnts[lastTouched].X - originalPnts[lastTouched].X;                          //                    if (delta != 0.0f)                          //                    {                          //                        for (int n = firstPoint; n < lastTouched; ++n)                          //                        {                          //                            currentPnts[n].OffsetX(delta);                          //                        }                          //                        for (int n = lastTouched + 1; n <= endPoint; ++n)                          //                        {                          //                            currentPnts[n].OffsetX(delta);                          //                        }                          //                    }                          //                }                          //                else                          //                {                          //                    InterpolatePointsXAxis(currentPnts' originalPnts' lastTouched + 1' endPoint' lastTouched' firstTouched);                          //                    if (firstTouched > 0)                          //                    {                          //                        InterpolatePointsXAxis(currentPnts' originalPnts' firstPoint' firstTouched - 1' lastTouched' firstTouched);                          //                    }                          //                }                          //            }                          //        }                          //    }                          //}                          //-----------------------------------------                          unsafe                          {                                //unsafe version                               //TODO: provide manage version                               fixed (GlyphPointF* currentPtr = _points.Current)                              fixed (GlyphPointF* originalPtr = _points.Original)                              {                                  // opcode controls whether we care about X or Y direction                                  // do some pointer trickery so we can operate on the                                  // points in a direction-agnostic manner                                  TouchState touchMask;                                  byte* current;                                  byte* original;                                  if (opcode == OpCode.IUP0)                                  {                                      touchMask = TouchState.Y;                                      current = (byte*)&currentPtr->P.Y;                                      original = (byte*)&originalPtr->P.Y;                                  }                                  else                                  {                                      touchMask = TouchState.X;                                      current = (byte*)&currentPtr->P.X;                                      original = (byte*)&originalPtr->P.X;                                  }                                    var point = 0;                                  for (int i = 0; i < _contours.Length; i++)                                  {                                      var endPoint = _contours[i];                                      var firstPoint = point;                                      var firstTouched = -1;                                      var lastTouched = -1;                                        for (; point <= endPoint; point++)                                      {                                          // check whether this point has been touched                                          if ((_points.TouchState[point] & touchMask) != 0)                                          {                                              // if this is the first touched point in the contour' note it and continue                                              if (firstTouched < 0)                                              {                                                  firstTouched = point;                                                  lastTouched = point;                                                  continue;                                              }                                                // otherwise' interpolate all untouched points                                              // between this point and our last touched point                                              InterpolatePoints(current' original' lastTouched + 1' point - 1' lastTouched' point);                                              lastTouched = point;                                          }                                      }                                        // check if we had any touched points at all in this contour                                      if (firstTouched >= 0)                                      {                                          // there are two cases left to handle:                                          // 1. there was only one touched point in the whole contour' in                                          //    which case we want to shift everything relative to that one                                          // 2. several touched points' in which case handle the gap from the                                          //    beginning to the first touched point and the gap from the last                                          //    touched point to the end of the contour                                          if (lastTouched == firstTouched)                                          {                                              var delta = *GetPoint(current' lastTouched) - *GetPoint(original' lastTouched);                                              if (delta != 0.0f)                                              {                                                  for (int j = firstPoint; j < lastTouched; j++)                                                      *GetPoint(current' j) += delta;                                                  for (int j = lastTouched + 1; j <= endPoint; j++)                                                      *GetPoint(current' j) += delta;                                              }                                          }                                          else                                          {                                              InterpolatePoints(current' original' lastTouched + 1' endPoint' lastTouched' firstTouched);                                              if (firstTouched > 0)                                                  InterpolatePoints(current' original' firstPoint' firstTouched - 1' lastTouched' firstTouched);                                          }                                      }                                  }                              }                          }                          break;                      case OpCode.ISECT:                          {                              // move point P to the intersection of lines A and B                              var b1 = _zp0.GetCurrent(_stack.Pop());                              var b0 = _zp0.GetCurrent(_stack.Pop());                              var a1 = _zp1.GetCurrent(_stack.Pop());                              var a0 = _zp1.GetCurrent(_stack.Pop());                              var index = _stack.Pop();                                // calculate intersection using determinants: https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line                              var da = a0 - a1;                              var db = b0 - b1;                              var den = (da.X * db.Y) - (da.Y * db.X);                              if (Math.Abs(den) <= Epsilon)                              {                                  // parallel lines; spec says to put the ppoint "into the middle of the two lines"                                  _zp2.Current[index].P = (a0 + a1 + b0 + b1) / 4;                              }                              else                              {                                  var t = (a0.X * a1.Y) - (a0.Y * a1.X);                                  var u = (b0.X * b1.Y) - (b0.Y * b1.X);                                  var p = new Vector2(                                      (t * db.X) - (da.X * u)'                                      (t * db.Y) - (da.Y * u)                                  );                                  _zp2.Current[index].P = p / den;                              }                              _zp2.TouchState[index] = TouchState.Both;                          }                          break;                        // ==== STACK MANAGEMENT ====                      case OpCode.DUP: _stack.Duplicate(); break;                      case OpCode.POP: _stack.Pop(); break;                      case OpCode.CLEAR: _stack.Clear(); break;                      case OpCode.SWAP: _stack.Swap(); break;                      case OpCode.DEPTH: _stack.Depth(); break;                      case OpCode.CINDEX: _stack.Copy(); break;                      case OpCode.MINDEX: _stack.Move(); break;                      case OpCode.ROLL: _stack.Roll(); break;                        // ==== FLOW CONTROL ====                      case OpCode.IF:                          {                              // value is false; jump to the next else block or endif marker                              // otherwise' we don't have to do anything; we'll keep executing this block                              if (!_stack.PopBool())                              {                                  int indent = 1;                                  while (indent > 0)                                  {                                      opcode = SkipNext(ref stream);                                      switch (opcode)                                      {                                          case OpCode.IF: indent++; break;                                          case OpCode.EIF: indent--; break;                                          case OpCode.ELSE:                                              if (indent == 1)                                                  indent = 0;                                              break;                                      }                                  }                              }                          }                          break;                      case OpCode.ELSE:                          {                              // assume we hit the true statement of some previous if block                              // if we had hit false' we would have jumped over this                              int indent = 1;                              while (indent > 0)                              {                                  opcode = SkipNext(ref stream);                                  switch (opcode)                                  {                                      case OpCode.IF: indent++; break;                                      case OpCode.EIF: indent--; break;                                  }                              }                          }                          break;                      case OpCode.EIF: /* nothing to do */ break;                      case OpCode.JROT:                      case OpCode.JROF:                          {                              if (_stack.PopBool() == (opcode == OpCode.JROT))                                  stream.Jump(_stack.Pop() - 1);                              else                                  _stack.Pop();    // ignore the offset                          }                          break;                      case OpCode.JMPR: stream.Jump(_stack.Pop() - 1); break;                        // ==== LOGICAL OPS ====                      case OpCode.LT:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a < b);                          }                          break;                      case OpCode.LTEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a <= b);                          }                          break;                      case OpCode.GT:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a > b);                          }                          break;                      case OpCode.GTEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a >= b);                          }                          break;                      case OpCode.EQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a == b);                          }                          break;                      case OpCode.NEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a != b);                          }                          break;                      case OpCode.AND:                          {                              var b = _stack.PopBool();                              var a = _stack.PopBool();                              _stack.Push(a && b);                          }                          break;                      case OpCode.OR:                          {                              var b = _stack.PopBool();                              var a = _stack.PopBool();                              _stack.Push(a || b);                          }                          break;                      case OpCode.NOT: _stack.Push(!_stack.PopBool()); break;                      case OpCode.ODD:                          {                              var value = (int)Round(_stack.PopFloat());                              _stack.Push(value % 2 != 0);                          }                          break;                      case OpCode.EVEN:                          {                              var value = (int)Round(_stack.PopFloat());                              _stack.Push(value % 2 == 0);                          }                          break;                        // ==== ARITHMETIC ====                      case OpCode.ADD:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a + b);                          }                          break;                      case OpCode.SUB:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a - b);                          }                          break;                      case OpCode.DIV:                          {                              var b = _stack.Pop();                              if (b == 0)                                  throw new InvalidFontException("Division by zero.");                                var a = _stack.Pop();                              var result = ((long)a << 6) / b;                              _stack.Push((int)result);                          }                          break;                      case OpCode.MUL:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              var result = ((long)a * b) >> 6;                              _stack.Push((int)result);                          }                          break;                      case OpCode.ABS: _stack.Push(Math.Abs(_stack.Pop())); break;                      case OpCode.NEG: _stack.Push(-_stack.Pop()); break;                      case OpCode.FLOOR: _stack.Push(_stack.Pop() & ~63); break;                      case OpCode.CEILING: _stack.Push((_stack.Pop() + 63) & ~63); break;                      case OpCode.MAX: _stack.Push(Math.Max(_stack.Pop()' _stack.Pop())); break;                      case OpCode.MIN: _stack.Push(Math.Min(_stack.Pop()' _stack.Pop())); break;                        // ==== FUNCTIONS ====                      case OpCode.FDEF:                          {                              if (!allowFunctionDefs || inFunction)                                  throw new InvalidFontException("Can't define functions here.");                                _functions[_stack.Pop()] = stream;                              while (SkipNext(ref stream) != OpCode.ENDF) ;                          }                          break;                      case OpCode.IDEF:                          {                              if (!allowFunctionDefs || inFunction)                                  throw new InvalidFontException("Can't define functions here.");                                _instructionDefs[_stack.Pop()] = stream;                              while (SkipNext(ref stream) != OpCode.ENDF) ;                          }                          break;                      case OpCode.ENDF:                          {                              if (!inFunction)                                  throw new InvalidFontException("Found invalid ENDF marker outside of a function definition.");                              return;                          }                      case OpCode.CALL:                      case OpCode.LOOPCALL:                          {                              _callStackSize++;                              if (_callStackSize > MaxCallStack)                                  throw new InvalidFontException("Stack overflow; infinite recursion?");                                var function = _functions[_stack.Pop()];                              var count = opcode == OpCode.LOOPCALL ? _stack.Pop() : 1;                              for (int i = 0; i < count; i++)                                  Execute(function' true' false);                              _callStackSize--;                          }                          break;                        // ==== ROUNDING ====                      // we don't have "engine compensation" so the variants are unnecessary                      case OpCode.ROUND0:                      case OpCode.ROUND1:                      case OpCode.ROUND2:                      case OpCode.ROUND3: _stack.Push(Round(_stack.PopFloat())); break;                      case OpCode.NROUND0:                      case OpCode.NROUND1:                      case OpCode.NROUND2:                      case OpCode.NROUND3: break;                        // ==== DELTA EXCEPTIONS ====                      case OpCode.DELTAC1:                      case OpCode.DELTAC2:                      case OpCode.DELTAC3:                          {                              var last = _stack.Pop();                              for (int i = 1; i <= last; i++)                              {                                  var cvtIndex = _stack.Pop();                                  var arg = _stack.Pop();                                    // upper 4 bits of the 8-bit arg is the relative ppem                                  // the opcode specifies the base to add to the ppem                                  var triggerPpem = (arg >> 4) & 0xF;                                  triggerPpem += (opcode - OpCode.DELTAC1) * 16;                                  triggerPpem += _state.DeltaBase;                                    // if the current ppem matches the trigger' apply the exception                                  if (_ppem == triggerPpem)                                  {                                      // the lower 4 bits of the arg is the amount to shift                                      // it's encoded such that 0 isn't an allowable value (who wants to shift by 0 anyway?)                                      var amount = (arg & 0xF) - 8;                                      if (amount >= 0)                                          amount++;                                      amount *= 1 << (6 - _state.DeltaShift);                                        // update the CVT                                      CheckIndex(cvtIndex' _controlValueTable.Length);                                      _controlValueTable[cvtIndex] += F26Dot6ToFloat(amount);                                  }                              }                          }                          break;                      case OpCode.DELTAP1:                      case OpCode.DELTAP2:                      case OpCode.DELTAP3:                          {                              var last = _stack.Pop();                              for (int i = 1; i <= last; i++)                              {                                  var pointIndex = _stack.Pop();                                  var arg = _stack.Pop();                                    // upper 4 bits of the 8-bit arg is the relative ppem                                  // the opcode specifies the base to add to the ppem                                  var triggerPpem = (arg >> 4) & 0xF;                                  triggerPpem += _state.DeltaBase;                                  if (opcode != OpCode.DELTAP1)                                      triggerPpem += (opcode - OpCode.DELTAP2 + 1) * 16;                                    // if the current ppem matches the trigger' apply the exception                                  if (_ppem == triggerPpem)                                  {                                      // the lower 4 bits of the arg is the amount to shift                                      // it's encoded such that 0 isn't an allowable value (who wants to shift by 0 anyway?)                                      var amount = (arg & 0xF) - 8;                                      if (amount >= 0)                                          amount++;                                      amount *= 1 << (6 - _state.DeltaShift);                                        MovePoint(_zp0' pointIndex' F26Dot6ToFloat(amount));                                  }                              }                          }                          break;                        // ==== MISCELLANEOUS ====                      case OpCode.DEBUG: _stack.Pop(); break;                      case OpCode.GETINFO:                          {                              var selector = _stack.Pop();                              var result = 0;                              if ((selector & 0x1) != 0)                              {                                  // pretend we are MS Rasterizer v35                                  result = 35;                              }                                // TODO: rotation and stretching                              //if ((selector & 0x2) != 0)                              //if ((selector & 0x4) != 0)                                // we're always rendering in grayscale                              if ((selector & 0x20) != 0)                                  result |= 1 << 12;                                // TODO: ClearType flags                                _stack.Push(result);                          }                          break;                        default:                          if (opcode >= OpCode.MIRP)                              MoveIndirectRelative(opcode - OpCode.MIRP);                          else if (opcode >= OpCode.MDRP)                              MoveDirectRelative(opcode - OpCode.MDRP);                          else                          {                              // check if this is a runtime-defined opcode                              var index = (int)opcode;                              if (index > _instructionDefs.Length || !_instructionDefs[index].IsValid)                                  throw new InvalidFontException("Unknown opcode in font program.");                                _callStackSize++;                              if (_callStackSize > MaxCallStack)                                  throw new InvalidFontException("Stack overflow; infinite recursion?");                                Execute(_instructionDefs[index]' true' false);                              _callStackSize--;                          }                          break;                  }
Magic Number,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,Execute,The following statement contains a magic number: switch (opcode)                  {                      // ==== PUSH INSTRUCTIONS ====                      case OpCode.NPUSHB:                      case OpCode.PUSHB1:                      case OpCode.PUSHB2:                      case OpCode.PUSHB3:                      case OpCode.PUSHB4:                      case OpCode.PUSHB5:                      case OpCode.PUSHB6:                      case OpCode.PUSHB7:                      case OpCode.PUSHB8:                          {                              var count = opcode == OpCode.NPUSHB ? stream.NextByte() : opcode - OpCode.PUSHB1 + 1;                              for (int i = count - 1; i >= 0; --i)                                  _stack.Push(stream.NextByte());                          }                          break;                      case OpCode.NPUSHW:                      case OpCode.PUSHW1:                      case OpCode.PUSHW2:                      case OpCode.PUSHW3:                      case OpCode.PUSHW4:                      case OpCode.PUSHW5:                      case OpCode.PUSHW6:                      case OpCode.PUSHW7:                      case OpCode.PUSHW8:                          {                              var count = opcode == OpCode.NPUSHW ? stream.NextByte() : opcode - OpCode.PUSHW1 + 1;                              for (int i = count - 1; i >= 0; --i)                                  _stack.Push(stream.NextWord());                          }                          break;                        // ==== STORAGE MANAGEMENT ====                      case OpCode.RS:                          {                              var loc = CheckIndex(_stack.Pop()' _storage.Length);                              _stack.Push(_storage[loc]);                          }                          break;                      case OpCode.WS:                          {                              var value = _stack.Pop();                              var loc = CheckIndex(_stack.Pop()' _storage.Length);                              _storage[loc] = value;                          }                          break;                        // ==== CONTROL VALUE TABLE ====                      case OpCode.WCVTP:                          {                              var value = _stack.PopFloat();                              var loc = CheckIndex(_stack.Pop()' _controlValueTable.Length);                              _controlValueTable[loc] = value;                          }                          break;                      case OpCode.WCVTF:                          {                              var value = _stack.Pop();                              var loc = CheckIndex(_stack.Pop()' _controlValueTable.Length);                              _controlValueTable[loc] = value * _scale;                          }                          break;                      case OpCode.RCVT: _stack.Push(ReadCvt()); break;                        // ==== STATE VECTORS ====                      case OpCode.SVTCA0:                      case OpCode.SVTCA1:                          {                              var axis = opcode - OpCode.SVTCA0;                              SetFreedomVectorToAxis(axis);                              SetProjectionVectorToAxis(axis);                          }                          break;                      case OpCode.SFVTPV: _state.Freedom = _state.Projection; OnVectorsUpdated(); break;                      case OpCode.SPVTCA0:                      case OpCode.SPVTCA1: SetProjectionVectorToAxis(opcode - OpCode.SPVTCA0); break;                      case OpCode.SFVTCA0:                      case OpCode.SFVTCA1: SetFreedomVectorToAxis(opcode - OpCode.SFVTCA0); break;                      case OpCode.SPVTL0:                      case OpCode.SPVTL1:                      case OpCode.SFVTL0:                      case OpCode.SFVTL1: SetVectorToLine(opcode - OpCode.SPVTL0' false); break;                      case OpCode.SDPVTL0:                      case OpCode.SDPVTL1: SetVectorToLine(opcode - OpCode.SDPVTL0' true); break;                      case OpCode.SPVFS:                      case OpCode.SFVFS:                          {                              var y = _stack.Pop();                              var x = _stack.Pop();                              var vec = Vector2.Normalize(new Vector2(F2Dot14ToFloat(x)' F2Dot14ToFloat(y)));                              if (opcode == OpCode.SFVFS)                                  _state.Freedom = vec;                              else                              {                                  _state.Projection = vec;                                  _state.DualProjection = vec;                              }                              OnVectorsUpdated();                          }                          break;                      case OpCode.GPV:                      case OpCode.GFV:                          {                              var vec = opcode == OpCode.GPV ? _state.Projection : _state.Freedom;                              _stack.Push(FloatToF2Dot14(vec.X));                              _stack.Push(FloatToF2Dot14(vec.Y));                          }                          break;                        // ==== GRAPHICS STATE ====                      case OpCode.SRP0: _state.Rp0 = _stack.Pop(); break;                      case OpCode.SRP1: _state.Rp1 = _stack.Pop(); break;                      case OpCode.SRP2: _state.Rp2 = _stack.Pop(); break;                      case OpCode.SZP0: _zp0 = GetZoneFromStack(); break;                      case OpCode.SZP1: _zp1 = GetZoneFromStack(); break;                      case OpCode.SZP2: _zp2 = GetZoneFromStack(); break;                      case OpCode.SZPS: _zp0 = _zp1 = _zp2 = GetZoneFromStack(); break;                      case OpCode.RTHG: _state.RoundState = RoundMode.ToHalfGrid; break;                      case OpCode.RTG: _state.RoundState = RoundMode.ToGrid; break;                      case OpCode.RTDG: _state.RoundState = RoundMode.ToDoubleGrid; break;                      case OpCode.RDTG: _state.RoundState = RoundMode.DownToGrid; break;                      case OpCode.RUTG: _state.RoundState = RoundMode.UpToGrid; break;                      case OpCode.ROFF: _state.RoundState = RoundMode.Off; break;                      case OpCode.SROUND: _state.RoundState = RoundMode.Super; SetSuperRound(1.0f); break;                      case OpCode.S45ROUND: _state.RoundState = RoundMode.Super45; SetSuperRound(Sqrt2Over2); break;                      case OpCode.INSTCTRL:                          {                              var selector = _stack.Pop();                              if (selector >= 1 && selector <= 2)                              {                                  // value is false if zero' otherwise shift the right bit into the flags                                  var bit = 1 << (selector - 1);                                  if (_stack.Pop() == 0)                                      _state.InstructionControl = (InstructionControlFlags)((int)_state.InstructionControl & ~bit);                                  else                                      _state.InstructionControl = (InstructionControlFlags)((int)_state.InstructionControl | bit);                              }                          }                          break;                      case OpCode.SCANCTRL: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SCANTYPE: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SANGW: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SLOOP: _state.Loop = _stack.Pop(); break;                      case OpCode.SMD: _state.MinDistance = _stack.PopFloat(); break;                      case OpCode.SCVTCI: _state.ControlValueCutIn = _stack.PopFloat(); break;                      case OpCode.SSWCI: _state.SingleWidthCutIn = _stack.PopFloat(); break;                      case OpCode.SSW: _state.SingleWidthValue = _stack.Pop() * _scale; break;                      case OpCode.FLIPON: _state.AutoFlip = true; break;                      case OpCode.FLIPOFF: _state.AutoFlip = false; break;                      case OpCode.SDB: _state.DeltaBase = _stack.Pop(); break;                      case OpCode.SDS: _state.DeltaShift = _stack.Pop(); break;                        // ==== POINT MEASUREMENT ====                      case OpCode.GC0: _stack.Push(Project(_zp2.GetCurrent(_stack.Pop()))); break;                      case OpCode.GC1: _stack.Push(DualProject(_zp2.GetOriginal(_stack.Pop()))); break;                      case OpCode.SCFS:                          {                              var value = _stack.PopFloat();                              var index = _stack.Pop();                              var point = _zp2.GetCurrent(index);                              MovePoint(_zp2' index' value - Project(point));                                // moving twilight points moves their "original" value also                              if (_zp2.IsTwilight)                                  _zp2.Original[index].P = _zp2.Current[index].P;                          }                          break;                      case OpCode.MD0:                          {                              var p1 = _zp1.GetOriginal(_stack.Pop());                              var p2 = _zp0.GetOriginal(_stack.Pop());                              _stack.Push(DualProject(p2 - p1));                          }                          break;                      case OpCode.MD1:                          {                              var p1 = _zp1.GetCurrent(_stack.Pop());                              var p2 = _zp0.GetCurrent(_stack.Pop());                              _stack.Push(Project(p2 - p1));                          }                          break;                      case OpCode.MPS: // MPS should return point size' but we assume DPI so it's the same as pixel size                      case OpCode.MPPEM: _stack.Push(_ppem); break;                      case OpCode.AA: /* deprecated instruction */ _stack.Pop(); break;                        // ==== POINT MODIFICATION ====                      case OpCode.FLIPPT:                          {                              for (int i = 0; i < _state.Loop; i++)                              {                                  var index = _stack.Pop();                                  //review here again!                                  _points.Current[index].onCurve = !_points.Current[index].onCurve;                                  //if (points.Current[index].onCurve)                                  //    points.Current[index].onCurve = false;                                  //else                                  //    points.Current[index].onCurve = true;                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.FLIPRGON:                          {                              var end = _stack.Pop();                              for (int i = _stack.Pop(); i <= end; i++)                                  //points.Current[i].Type = PointType.OnCurve;                                  _points.Current[i].onCurve = true;                          }                          break;                      case OpCode.FLIPRGOFF:                          {                              var end = _stack.Pop();                              for (int i = _stack.Pop(); i <= end; i++)                                  //points.Current[i].Type = PointType.Quadratic;                                  _points.Current[i].onCurve = false;                          }                          break;                      case OpCode.SHP0:                      case OpCode.SHP1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              ShiftPoints(displacement);                          }                          break;                      case OpCode.SHPIX: ShiftPoints(_stack.PopFloat() * _state.Freedom); break;                      case OpCode.SHC0:                      case OpCode.SHC1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              var touch = GetTouchState();                              var contour = _stack.Pop();                              var start = contour == 0 ? 0 : _contours[contour - 1] + 1;                              var count = _zp2.IsTwilight ? _zp2.Current.Length : _contours[contour] + 1;                                for (int i = start; i < count; i++)                              {                                  // don't move the reference point                                  if (zone.Current != _zp2.Current || point != i)                                  {                                      _zp2.Current[i].P += displacement;                                      _zp2.TouchState[i] |= touch;                                  }                              }                          }                          break;                      case OpCode.SHZ0:                      case OpCode.SHZ1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              var count = 0;                              if (_zp2.IsTwilight)                                  count = _zp2.Current.Length;                              else if (_contours.Length > 0)                                  count = _contours[_contours.Length - 1] + 1;                                for (int i = 0; i < count; i++)                              {                                  // don't move the reference point                                  if (zone.Current != _zp2.Current || point != i)                                      _zp2.Current[i].P += displacement;                              }                          }                          break;                      case OpCode.MIAP0:                      case OpCode.MIAP1:                          {                              var distance = ReadCvt();                              var pointIndex = _stack.Pop();                                // this instruction is used in the CVT to set up twilight points with original values                              if (_zp0.IsTwilight)                              {                                  var original = _state.Freedom * distance;                                  _zp0.Original[pointIndex].P = original;                                  _zp0.Current[pointIndex].P = original;                              }                                // current position of the point along the projection vector                              var point = _zp0.GetCurrent(pointIndex);                              var currentPos = Project(point);                              if (opcode == OpCode.MIAP1)                              {                                  // only use the CVT if we are above the cut-in point                                  if (Math.Abs(distance - currentPos) > _state.ControlValueCutIn)                                      distance = currentPos;                                  distance = Round(distance);                              }                                MovePoint(_zp0' pointIndex' distance - currentPos);                              _state.Rp0 = pointIndex;                              _state.Rp1 = pointIndex;                          }                          break;                      case OpCode.MDAP0:                      case OpCode.MDAP1:                          {                              var pointIndex = _stack.Pop();                              var point = _zp0.GetCurrent(pointIndex);                              var distance = 0.0f;                              if (opcode == OpCode.MDAP1)                              {                                  distance = Project(point);                                  distance = Round(distance) - distance;                              }                                MovePoint(_zp0' pointIndex' distance);                              _state.Rp0 = pointIndex;                              _state.Rp1 = pointIndex;                          }                          break;                      case OpCode.MSIRP0:                      case OpCode.MSIRP1:                          {                              var targetDistance = _stack.PopFloat();                              var pointIndex = _stack.Pop();                                // if we're operating on the twilight zone' initialize the points                              if (_zp1.IsTwilight)                              {                                  _zp1.Original[pointIndex].P = _zp0.Original[_state.Rp0].P + targetDistance * _state.Freedom / _fdotp;                                  _zp1.Current[pointIndex].P = _zp1.Original[pointIndex].P;                              }                                var currentDistance = Project(_zp1.GetCurrent(pointIndex) - _zp0.GetCurrent(_state.Rp0));                              MovePoint(_zp1' pointIndex' targetDistance - currentDistance);                                _state.Rp1 = _state.Rp0;                              _state.Rp2 = pointIndex;                              if (opcode == OpCode.MSIRP1)                                  _state.Rp0 = pointIndex;                          }                          break;                      case OpCode.IP:                          {                              var originalBase = _zp0.GetOriginal(_state.Rp1);                              var currentBase = _zp0.GetCurrent(_state.Rp1);                              var originalRange = DualProject(_zp1.GetOriginal(_state.Rp2) - originalBase);                              var currentRange = Project(_zp1.GetCurrent(_state.Rp2) - currentBase);                                for (int i = 0; i < _state.Loop; i++)                              {                                  var pointIndex = _stack.Pop();                                  var point = _zp2.GetCurrent(pointIndex);                                  var currentDistance = Project(point - currentBase);                                  var originalDistance = DualProject(_zp2.GetOriginal(pointIndex) - originalBase);                                    var newDistance = 0.0f;                                  if (originalDistance != 0.0f)                                  {                                      // a range of 0.0f is invalid according to the spec (would result in a div by zero)                                      if (originalRange == 0.0f)                                          newDistance = originalDistance;                                      else                                          newDistance = originalDistance * currentRange / originalRange;                                  }                                    MovePoint(_zp2' pointIndex' newDistance - currentDistance);                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.ALIGNRP:                          {                              for (int i = 0; i < _state.Loop; i++)                              {                                  var pointIndex = _stack.Pop();                                  var p1 = _zp1.GetCurrent(pointIndex);                                  var p2 = _zp0.GetCurrent(_state.Rp0);                                  MovePoint(_zp1' pointIndex' -Project(p1 - p2));                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.ALIGNPTS:                          {                              var p1 = _stack.Pop();                              var p2 = _stack.Pop();                              var distance = Project(_zp0.GetCurrent(p2) - _zp1.GetCurrent(p1)) / 2;                              MovePoint(_zp1' p1' distance);                              MovePoint(_zp0' p2' -distance);                          }                          break;                      case OpCode.UTP: _zp0.TouchState[_stack.Pop()] &= ~GetTouchState(); break;                      case OpCode.IUP0:                      case OpCode.IUP1:                          // bail if no contours (empty outline)                          if (_contours.Length == 0)                          {                              break;                          }                            //{                            //    //WinterDev's new managed version                          //    GlyphPointF[] currentPnts = points.Current;                          //    GlyphPointF[] originalPnts = points.Original;                            //    int cnt_count = contours.Length;                          //    int point = 0;                          //    // opcode controls whether we care about X or Y direction                          //    // do some pointer trickery so we can operate on the                          //    // points in a direction-agnostic manner                          //    TouchState touchMask;                            //    if (opcode == OpCode.IUP0)                          //    {                          //        //y -axis                          //        touchMask = TouchState.Y;                            //        //                          //        for (int i = 0; i < cnt_count; ++i)                          //        {                          //            int endPoint = contours[i];                          //            int firstPoint = point;                          //            int firstTouched = -1;                          //            int lastTouched = -1;                            //            for (; point <= endPoint; point++)                          //            {                          //                // check whether this point has been touched                          //                if ((points.TouchState[point] & touchMask) != 0)                          //                {                          //                    // if this is the first touched point in the contour' note it and continue                          //                    if (firstTouched < 0)                          //                    {                          //                        firstTouched = point;                          //                        lastTouched = point;                          //                        continue;                          //                    }                            //                    // otherwise' interpolate all untouched points                          //                    // between this point and our last touched point                          //                    InterpolatePointsYAxis(currentPnts' originalPnts' lastTouched + 1' point - 1' lastTouched' point);                          //                    lastTouched = point;                          //                }                          //            }                            //            // check if we had any touched points at all in this contour                          //            if (firstTouched >= 0)                          //            {                          //                // there are two cases left to handle:                          //                // 1. there was only one touched point in the whole contour' in                          //                //    which case we want to shift everything relative to that one                          //                // 2. several touched points' in which case handle the gap from the                          //                //    beginning to the first touched point and the gap from the last                          //                //    touched point to the end of the contour                          //                if (lastTouched == firstTouched)                          //                {                          //                    float delta = currentPnts[lastTouched].Y - originalPnts[lastTouched].Y;                          //                    if (delta != 0.0f)                          //                    {                          //                        for (int n = firstPoint; n < lastTouched; n++)                          //                        {                          //                            currentPnts[n].OffsetY(delta);                          //                        }                          //                        for (int n = lastTouched + 1; n <= endPoint; n++)                          //                        {                          //                            currentPnts[n].OffsetY(delta);                          //                        }                            //                    }                          //                }                          //                else                          //                {                          //                    InterpolatePointsYAxis(currentPnts' originalPnts' lastTouched + 1' endPoint' lastTouched' firstTouched);                          //                    if (firstTouched > 0)                          //                    {                          //                        InterpolatePointsYAxis(currentPnts' originalPnts' firstPoint' firstTouched - 1' lastTouched' firstTouched);                          //                    }                          //                }                          //            }                            //        }                          //    }                          //    else                          //    {                          //        //x-axis                          //        touchMask = TouchState.X;                          //        //                          //        for (int i = 0; i < cnt_count; ++i)                          //        {                          //            int endPoint = contours[i];                          //            int firstPoint = point;                          //            int firstTouched = -1;                          //            int lastTouched = -1;                            //            for (; point <= endPoint; point++)                          //            {                          //                // check whether this point has been touched                          //                if ((points.TouchState[point] & touchMask) != 0)                          //                {                          //                    // if this is the first touched point in the contour' note it and continue                          //                    if (firstTouched < 0)                          //                    {                          //                        firstTouched = point;                          //                        lastTouched = point;                          //                        continue;                          //                    }                            //                    // otherwise' interpolate all untouched points                          //                    // between this point and our last touched point                          //                    InterpolatePointsXAxis(currentPnts' originalPnts' lastTouched + 1' point - 1' lastTouched' point);                          //                    lastTouched = point;                          //                }                          //            }                            //            // check if we had any touched points at all in this contour                          //            if (firstTouched >= 0)                          //            {                          //                // there are two cases left to handle:                          //                // 1. there was only one touched point in the whole contour' in                          //                //    which case we want to shift everything relative to that one                          //                // 2. several touched points' in which case handle the gap from the                          //                //    beginning to the first touched point and the gap from the last                          //                //    touched point to the end of the contour                          //                if (lastTouched == firstTouched)                          //                {                          //                    float delta = currentPnts[lastTouched].X - originalPnts[lastTouched].X;                          //                    if (delta != 0.0f)                          //                    {                          //                        for (int n = firstPoint; n < lastTouched; ++n)                          //                        {                          //                            currentPnts[n].OffsetX(delta);                          //                        }                          //                        for (int n = lastTouched + 1; n <= endPoint; ++n)                          //                        {                          //                            currentPnts[n].OffsetX(delta);                          //                        }                          //                    }                          //                }                          //                else                          //                {                          //                    InterpolatePointsXAxis(currentPnts' originalPnts' lastTouched + 1' endPoint' lastTouched' firstTouched);                          //                    if (firstTouched > 0)                          //                    {                          //                        InterpolatePointsXAxis(currentPnts' originalPnts' firstPoint' firstTouched - 1' lastTouched' firstTouched);                          //                    }                          //                }                          //            }                          //        }                          //    }                          //}                          //-----------------------------------------                          unsafe                          {                                //unsafe version                               //TODO: provide manage version                               fixed (GlyphPointF* currentPtr = _points.Current)                              fixed (GlyphPointF* originalPtr = _points.Original)                              {                                  // opcode controls whether we care about X or Y direction                                  // do some pointer trickery so we can operate on the                                  // points in a direction-agnostic manner                                  TouchState touchMask;                                  byte* current;                                  byte* original;                                  if (opcode == OpCode.IUP0)                                  {                                      touchMask = TouchState.Y;                                      current = (byte*)&currentPtr->P.Y;                                      original = (byte*)&originalPtr->P.Y;                                  }                                  else                                  {                                      touchMask = TouchState.X;                                      current = (byte*)&currentPtr->P.X;                                      original = (byte*)&originalPtr->P.X;                                  }                                    var point = 0;                                  for (int i = 0; i < _contours.Length; i++)                                  {                                      var endPoint = _contours[i];                                      var firstPoint = point;                                      var firstTouched = -1;                                      var lastTouched = -1;                                        for (; point <= endPoint; point++)                                      {                                          // check whether this point has been touched                                          if ((_points.TouchState[point] & touchMask) != 0)                                          {                                              // if this is the first touched point in the contour' note it and continue                                              if (firstTouched < 0)                                              {                                                  firstTouched = point;                                                  lastTouched = point;                                                  continue;                                              }                                                // otherwise' interpolate all untouched points                                              // between this point and our last touched point                                              InterpolatePoints(current' original' lastTouched + 1' point - 1' lastTouched' point);                                              lastTouched = point;                                          }                                      }                                        // check if we had any touched points at all in this contour                                      if (firstTouched >= 0)                                      {                                          // there are two cases left to handle:                                          // 1. there was only one touched point in the whole contour' in                                          //    which case we want to shift everything relative to that one                                          // 2. several touched points' in which case handle the gap from the                                          //    beginning to the first touched point and the gap from the last                                          //    touched point to the end of the contour                                          if (lastTouched == firstTouched)                                          {                                              var delta = *GetPoint(current' lastTouched) - *GetPoint(original' lastTouched);                                              if (delta != 0.0f)                                              {                                                  for (int j = firstPoint; j < lastTouched; j++)                                                      *GetPoint(current' j) += delta;                                                  for (int j = lastTouched + 1; j <= endPoint; j++)                                                      *GetPoint(current' j) += delta;                                              }                                          }                                          else                                          {                                              InterpolatePoints(current' original' lastTouched + 1' endPoint' lastTouched' firstTouched);                                              if (firstTouched > 0)                                                  InterpolatePoints(current' original' firstPoint' firstTouched - 1' lastTouched' firstTouched);                                          }                                      }                                  }                              }                          }                          break;                      case OpCode.ISECT:                          {                              // move point P to the intersection of lines A and B                              var b1 = _zp0.GetCurrent(_stack.Pop());                              var b0 = _zp0.GetCurrent(_stack.Pop());                              var a1 = _zp1.GetCurrent(_stack.Pop());                              var a0 = _zp1.GetCurrent(_stack.Pop());                              var index = _stack.Pop();                                // calculate intersection using determinants: https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line                              var da = a0 - a1;                              var db = b0 - b1;                              var den = (da.X * db.Y) - (da.Y * db.X);                              if (Math.Abs(den) <= Epsilon)                              {                                  // parallel lines; spec says to put the ppoint "into the middle of the two lines"                                  _zp2.Current[index].P = (a0 + a1 + b0 + b1) / 4;                              }                              else                              {                                  var t = (a0.X * a1.Y) - (a0.Y * a1.X);                                  var u = (b0.X * b1.Y) - (b0.Y * b1.X);                                  var p = new Vector2(                                      (t * db.X) - (da.X * u)'                                      (t * db.Y) - (da.Y * u)                                  );                                  _zp2.Current[index].P = p / den;                              }                              _zp2.TouchState[index] = TouchState.Both;                          }                          break;                        // ==== STACK MANAGEMENT ====                      case OpCode.DUP: _stack.Duplicate(); break;                      case OpCode.POP: _stack.Pop(); break;                      case OpCode.CLEAR: _stack.Clear(); break;                      case OpCode.SWAP: _stack.Swap(); break;                      case OpCode.DEPTH: _stack.Depth(); break;                      case OpCode.CINDEX: _stack.Copy(); break;                      case OpCode.MINDEX: _stack.Move(); break;                      case OpCode.ROLL: _stack.Roll(); break;                        // ==== FLOW CONTROL ====                      case OpCode.IF:                          {                              // value is false; jump to the next else block or endif marker                              // otherwise' we don't have to do anything; we'll keep executing this block                              if (!_stack.PopBool())                              {                                  int indent = 1;                                  while (indent > 0)                                  {                                      opcode = SkipNext(ref stream);                                      switch (opcode)                                      {                                          case OpCode.IF: indent++; break;                                          case OpCode.EIF: indent--; break;                                          case OpCode.ELSE:                                              if (indent == 1)                                                  indent = 0;                                              break;                                      }                                  }                              }                          }                          break;                      case OpCode.ELSE:                          {                              // assume we hit the true statement of some previous if block                              // if we had hit false' we would have jumped over this                              int indent = 1;                              while (indent > 0)                              {                                  opcode = SkipNext(ref stream);                                  switch (opcode)                                  {                                      case OpCode.IF: indent++; break;                                      case OpCode.EIF: indent--; break;                                  }                              }                          }                          break;                      case OpCode.EIF: /* nothing to do */ break;                      case OpCode.JROT:                      case OpCode.JROF:                          {                              if (_stack.PopBool() == (opcode == OpCode.JROT))                                  stream.Jump(_stack.Pop() - 1);                              else                                  _stack.Pop();    // ignore the offset                          }                          break;                      case OpCode.JMPR: stream.Jump(_stack.Pop() - 1); break;                        // ==== LOGICAL OPS ====                      case OpCode.LT:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a < b);                          }                          break;                      case OpCode.LTEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a <= b);                          }                          break;                      case OpCode.GT:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a > b);                          }                          break;                      case OpCode.GTEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a >= b);                          }                          break;                      case OpCode.EQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a == b);                          }                          break;                      case OpCode.NEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a != b);                          }                          break;                      case OpCode.AND:                          {                              var b = _stack.PopBool();                              var a = _stack.PopBool();                              _stack.Push(a && b);                          }                          break;                      case OpCode.OR:                          {                              var b = _stack.PopBool();                              var a = _stack.PopBool();                              _stack.Push(a || b);                          }                          break;                      case OpCode.NOT: _stack.Push(!_stack.PopBool()); break;                      case OpCode.ODD:                          {                              var value = (int)Round(_stack.PopFloat());                              _stack.Push(value % 2 != 0);                          }                          break;                      case OpCode.EVEN:                          {                              var value = (int)Round(_stack.PopFloat());                              _stack.Push(value % 2 == 0);                          }                          break;                        // ==== ARITHMETIC ====                      case OpCode.ADD:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a + b);                          }                          break;                      case OpCode.SUB:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a - b);                          }                          break;                      case OpCode.DIV:                          {                              var b = _stack.Pop();                              if (b == 0)                                  throw new InvalidFontException("Division by zero.");                                var a = _stack.Pop();                              var result = ((long)a << 6) / b;                              _stack.Push((int)result);                          }                          break;                      case OpCode.MUL:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              var result = ((long)a * b) >> 6;                              _stack.Push((int)result);                          }                          break;                      case OpCode.ABS: _stack.Push(Math.Abs(_stack.Pop())); break;                      case OpCode.NEG: _stack.Push(-_stack.Pop()); break;                      case OpCode.FLOOR: _stack.Push(_stack.Pop() & ~63); break;                      case OpCode.CEILING: _stack.Push((_stack.Pop() + 63) & ~63); break;                      case OpCode.MAX: _stack.Push(Math.Max(_stack.Pop()' _stack.Pop())); break;                      case OpCode.MIN: _stack.Push(Math.Min(_stack.Pop()' _stack.Pop())); break;                        // ==== FUNCTIONS ====                      case OpCode.FDEF:                          {                              if (!allowFunctionDefs || inFunction)                                  throw new InvalidFontException("Can't define functions here.");                                _functions[_stack.Pop()] = stream;                              while (SkipNext(ref stream) != OpCode.ENDF) ;                          }                          break;                      case OpCode.IDEF:                          {                              if (!allowFunctionDefs || inFunction)                                  throw new InvalidFontException("Can't define functions here.");                                _instructionDefs[_stack.Pop()] = stream;                              while (SkipNext(ref stream) != OpCode.ENDF) ;                          }                          break;                      case OpCode.ENDF:                          {                              if (!inFunction)                                  throw new InvalidFontException("Found invalid ENDF marker outside of a function definition.");                              return;                          }                      case OpCode.CALL:                      case OpCode.LOOPCALL:                          {                              _callStackSize++;                              if (_callStackSize > MaxCallStack)                                  throw new InvalidFontException("Stack overflow; infinite recursion?");                                var function = _functions[_stack.Pop()];                              var count = opcode == OpCode.LOOPCALL ? _stack.Pop() : 1;                              for (int i = 0; i < count; i++)                                  Execute(function' true' false);                              _callStackSize--;                          }                          break;                        // ==== ROUNDING ====                      // we don't have "engine compensation" so the variants are unnecessary                      case OpCode.ROUND0:                      case OpCode.ROUND1:                      case OpCode.ROUND2:                      case OpCode.ROUND3: _stack.Push(Round(_stack.PopFloat())); break;                      case OpCode.NROUND0:                      case OpCode.NROUND1:                      case OpCode.NROUND2:                      case OpCode.NROUND3: break;                        // ==== DELTA EXCEPTIONS ====                      case OpCode.DELTAC1:                      case OpCode.DELTAC2:                      case OpCode.DELTAC3:                          {                              var last = _stack.Pop();                              for (int i = 1; i <= last; i++)                              {                                  var cvtIndex = _stack.Pop();                                  var arg = _stack.Pop();                                    // upper 4 bits of the 8-bit arg is the relative ppem                                  // the opcode specifies the base to add to the ppem                                  var triggerPpem = (arg >> 4) & 0xF;                                  triggerPpem += (opcode - OpCode.DELTAC1) * 16;                                  triggerPpem += _state.DeltaBase;                                    // if the current ppem matches the trigger' apply the exception                                  if (_ppem == triggerPpem)                                  {                                      // the lower 4 bits of the arg is the amount to shift                                      // it's encoded such that 0 isn't an allowable value (who wants to shift by 0 anyway?)                                      var amount = (arg & 0xF) - 8;                                      if (amount >= 0)                                          amount++;                                      amount *= 1 << (6 - _state.DeltaShift);                                        // update the CVT                                      CheckIndex(cvtIndex' _controlValueTable.Length);                                      _controlValueTable[cvtIndex] += F26Dot6ToFloat(amount);                                  }                              }                          }                          break;                      case OpCode.DELTAP1:                      case OpCode.DELTAP2:                      case OpCode.DELTAP3:                          {                              var last = _stack.Pop();                              for (int i = 1; i <= last; i++)                              {                                  var pointIndex = _stack.Pop();                                  var arg = _stack.Pop();                                    // upper 4 bits of the 8-bit arg is the relative ppem                                  // the opcode specifies the base to add to the ppem                                  var triggerPpem = (arg >> 4) & 0xF;                                  triggerPpem += _state.DeltaBase;                                  if (opcode != OpCode.DELTAP1)                                      triggerPpem += (opcode - OpCode.DELTAP2 + 1) * 16;                                    // if the current ppem matches the trigger' apply the exception                                  if (_ppem == triggerPpem)                                  {                                      // the lower 4 bits of the arg is the amount to shift                                      // it's encoded such that 0 isn't an allowable value (who wants to shift by 0 anyway?)                                      var amount = (arg & 0xF) - 8;                                      if (amount >= 0)                                          amount++;                                      amount *= 1 << (6 - _state.DeltaShift);                                        MovePoint(_zp0' pointIndex' F26Dot6ToFloat(amount));                                  }                              }                          }                          break;                        // ==== MISCELLANEOUS ====                      case OpCode.DEBUG: _stack.Pop(); break;                      case OpCode.GETINFO:                          {                              var selector = _stack.Pop();                              var result = 0;                              if ((selector & 0x1) != 0)                              {                                  // pretend we are MS Rasterizer v35                                  result = 35;                              }                                // TODO: rotation and stretching                              //if ((selector & 0x2) != 0)                              //if ((selector & 0x4) != 0)                                // we're always rendering in grayscale                              if ((selector & 0x20) != 0)                                  result |= 1 << 12;                                // TODO: ClearType flags                                _stack.Push(result);                          }                          break;                        default:                          if (opcode >= OpCode.MIRP)                              MoveIndirectRelative(opcode - OpCode.MIRP);                          else if (opcode >= OpCode.MDRP)                              MoveDirectRelative(opcode - OpCode.MDRP);                          else                          {                              // check if this is a runtime-defined opcode                              var index = (int)opcode;                              if (index > _instructionDefs.Length || !_instructionDefs[index].IsValid)                                  throw new InvalidFontException("Unknown opcode in font program.");                                _callStackSize++;                              if (_callStackSize > MaxCallStack)                                  throw new InvalidFontException("Stack overflow; infinite recursion?");                                Execute(_instructionDefs[index]' true' false);                              _callStackSize--;                          }                          break;                  }
Magic Number,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,Execute,The following statement contains a magic number: switch (opcode)                  {                      // ==== PUSH INSTRUCTIONS ====                      case OpCode.NPUSHB:                      case OpCode.PUSHB1:                      case OpCode.PUSHB2:                      case OpCode.PUSHB3:                      case OpCode.PUSHB4:                      case OpCode.PUSHB5:                      case OpCode.PUSHB6:                      case OpCode.PUSHB7:                      case OpCode.PUSHB8:                          {                              var count = opcode == OpCode.NPUSHB ? stream.NextByte() : opcode - OpCode.PUSHB1 + 1;                              for (int i = count - 1; i >= 0; --i)                                  _stack.Push(stream.NextByte());                          }                          break;                      case OpCode.NPUSHW:                      case OpCode.PUSHW1:                      case OpCode.PUSHW2:                      case OpCode.PUSHW3:                      case OpCode.PUSHW4:                      case OpCode.PUSHW5:                      case OpCode.PUSHW6:                      case OpCode.PUSHW7:                      case OpCode.PUSHW8:                          {                              var count = opcode == OpCode.NPUSHW ? stream.NextByte() : opcode - OpCode.PUSHW1 + 1;                              for (int i = count - 1; i >= 0; --i)                                  _stack.Push(stream.NextWord());                          }                          break;                        // ==== STORAGE MANAGEMENT ====                      case OpCode.RS:                          {                              var loc = CheckIndex(_stack.Pop()' _storage.Length);                              _stack.Push(_storage[loc]);                          }                          break;                      case OpCode.WS:                          {                              var value = _stack.Pop();                              var loc = CheckIndex(_stack.Pop()' _storage.Length);                              _storage[loc] = value;                          }                          break;                        // ==== CONTROL VALUE TABLE ====                      case OpCode.WCVTP:                          {                              var value = _stack.PopFloat();                              var loc = CheckIndex(_stack.Pop()' _controlValueTable.Length);                              _controlValueTable[loc] = value;                          }                          break;                      case OpCode.WCVTF:                          {                              var value = _stack.Pop();                              var loc = CheckIndex(_stack.Pop()' _controlValueTable.Length);                              _controlValueTable[loc] = value * _scale;                          }                          break;                      case OpCode.RCVT: _stack.Push(ReadCvt()); break;                        // ==== STATE VECTORS ====                      case OpCode.SVTCA0:                      case OpCode.SVTCA1:                          {                              var axis = opcode - OpCode.SVTCA0;                              SetFreedomVectorToAxis(axis);                              SetProjectionVectorToAxis(axis);                          }                          break;                      case OpCode.SFVTPV: _state.Freedom = _state.Projection; OnVectorsUpdated(); break;                      case OpCode.SPVTCA0:                      case OpCode.SPVTCA1: SetProjectionVectorToAxis(opcode - OpCode.SPVTCA0); break;                      case OpCode.SFVTCA0:                      case OpCode.SFVTCA1: SetFreedomVectorToAxis(opcode - OpCode.SFVTCA0); break;                      case OpCode.SPVTL0:                      case OpCode.SPVTL1:                      case OpCode.SFVTL0:                      case OpCode.SFVTL1: SetVectorToLine(opcode - OpCode.SPVTL0' false); break;                      case OpCode.SDPVTL0:                      case OpCode.SDPVTL1: SetVectorToLine(opcode - OpCode.SDPVTL0' true); break;                      case OpCode.SPVFS:                      case OpCode.SFVFS:                          {                              var y = _stack.Pop();                              var x = _stack.Pop();                              var vec = Vector2.Normalize(new Vector2(F2Dot14ToFloat(x)' F2Dot14ToFloat(y)));                              if (opcode == OpCode.SFVFS)                                  _state.Freedom = vec;                              else                              {                                  _state.Projection = vec;                                  _state.DualProjection = vec;                              }                              OnVectorsUpdated();                          }                          break;                      case OpCode.GPV:                      case OpCode.GFV:                          {                              var vec = opcode == OpCode.GPV ? _state.Projection : _state.Freedom;                              _stack.Push(FloatToF2Dot14(vec.X));                              _stack.Push(FloatToF2Dot14(vec.Y));                          }                          break;                        // ==== GRAPHICS STATE ====                      case OpCode.SRP0: _state.Rp0 = _stack.Pop(); break;                      case OpCode.SRP1: _state.Rp1 = _stack.Pop(); break;                      case OpCode.SRP2: _state.Rp2 = _stack.Pop(); break;                      case OpCode.SZP0: _zp0 = GetZoneFromStack(); break;                      case OpCode.SZP1: _zp1 = GetZoneFromStack(); break;                      case OpCode.SZP2: _zp2 = GetZoneFromStack(); break;                      case OpCode.SZPS: _zp0 = _zp1 = _zp2 = GetZoneFromStack(); break;                      case OpCode.RTHG: _state.RoundState = RoundMode.ToHalfGrid; break;                      case OpCode.RTG: _state.RoundState = RoundMode.ToGrid; break;                      case OpCode.RTDG: _state.RoundState = RoundMode.ToDoubleGrid; break;                      case OpCode.RDTG: _state.RoundState = RoundMode.DownToGrid; break;                      case OpCode.RUTG: _state.RoundState = RoundMode.UpToGrid; break;                      case OpCode.ROFF: _state.RoundState = RoundMode.Off; break;                      case OpCode.SROUND: _state.RoundState = RoundMode.Super; SetSuperRound(1.0f); break;                      case OpCode.S45ROUND: _state.RoundState = RoundMode.Super45; SetSuperRound(Sqrt2Over2); break;                      case OpCode.INSTCTRL:                          {                              var selector = _stack.Pop();                              if (selector >= 1 && selector <= 2)                              {                                  // value is false if zero' otherwise shift the right bit into the flags                                  var bit = 1 << (selector - 1);                                  if (_stack.Pop() == 0)                                      _state.InstructionControl = (InstructionControlFlags)((int)_state.InstructionControl & ~bit);                                  else                                      _state.InstructionControl = (InstructionControlFlags)((int)_state.InstructionControl | bit);                              }                          }                          break;                      case OpCode.SCANCTRL: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SCANTYPE: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SANGW: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SLOOP: _state.Loop = _stack.Pop(); break;                      case OpCode.SMD: _state.MinDistance = _stack.PopFloat(); break;                      case OpCode.SCVTCI: _state.ControlValueCutIn = _stack.PopFloat(); break;                      case OpCode.SSWCI: _state.SingleWidthCutIn = _stack.PopFloat(); break;                      case OpCode.SSW: _state.SingleWidthValue = _stack.Pop() * _scale; break;                      case OpCode.FLIPON: _state.AutoFlip = true; break;                      case OpCode.FLIPOFF: _state.AutoFlip = false; break;                      case OpCode.SDB: _state.DeltaBase = _stack.Pop(); break;                      case OpCode.SDS: _state.DeltaShift = _stack.Pop(); break;                        // ==== POINT MEASUREMENT ====                      case OpCode.GC0: _stack.Push(Project(_zp2.GetCurrent(_stack.Pop()))); break;                      case OpCode.GC1: _stack.Push(DualProject(_zp2.GetOriginal(_stack.Pop()))); break;                      case OpCode.SCFS:                          {                              var value = _stack.PopFloat();                              var index = _stack.Pop();                              var point = _zp2.GetCurrent(index);                              MovePoint(_zp2' index' value - Project(point));                                // moving twilight points moves their "original" value also                              if (_zp2.IsTwilight)                                  _zp2.Original[index].P = _zp2.Current[index].P;                          }                          break;                      case OpCode.MD0:                          {                              var p1 = _zp1.GetOriginal(_stack.Pop());                              var p2 = _zp0.GetOriginal(_stack.Pop());                              _stack.Push(DualProject(p2 - p1));                          }                          break;                      case OpCode.MD1:                          {                              var p1 = _zp1.GetCurrent(_stack.Pop());                              var p2 = _zp0.GetCurrent(_stack.Pop());                              _stack.Push(Project(p2 - p1));                          }                          break;                      case OpCode.MPS: // MPS should return point size' but we assume DPI so it's the same as pixel size                      case OpCode.MPPEM: _stack.Push(_ppem); break;                      case OpCode.AA: /* deprecated instruction */ _stack.Pop(); break;                        // ==== POINT MODIFICATION ====                      case OpCode.FLIPPT:                          {                              for (int i = 0; i < _state.Loop; i++)                              {                                  var index = _stack.Pop();                                  //review here again!                                  _points.Current[index].onCurve = !_points.Current[index].onCurve;                                  //if (points.Current[index].onCurve)                                  //    points.Current[index].onCurve = false;                                  //else                                  //    points.Current[index].onCurve = true;                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.FLIPRGON:                          {                              var end = _stack.Pop();                              for (int i = _stack.Pop(); i <= end; i++)                                  //points.Current[i].Type = PointType.OnCurve;                                  _points.Current[i].onCurve = true;                          }                          break;                      case OpCode.FLIPRGOFF:                          {                              var end = _stack.Pop();                              for (int i = _stack.Pop(); i <= end; i++)                                  //points.Current[i].Type = PointType.Quadratic;                                  _points.Current[i].onCurve = false;                          }                          break;                      case OpCode.SHP0:                      case OpCode.SHP1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              ShiftPoints(displacement);                          }                          break;                      case OpCode.SHPIX: ShiftPoints(_stack.PopFloat() * _state.Freedom); break;                      case OpCode.SHC0:                      case OpCode.SHC1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              var touch = GetTouchState();                              var contour = _stack.Pop();                              var start = contour == 0 ? 0 : _contours[contour - 1] + 1;                              var count = _zp2.IsTwilight ? _zp2.Current.Length : _contours[contour] + 1;                                for (int i = start; i < count; i++)                              {                                  // don't move the reference point                                  if (zone.Current != _zp2.Current || point != i)                                  {                                      _zp2.Current[i].P += displacement;                                      _zp2.TouchState[i] |= touch;                                  }                              }                          }                          break;                      case OpCode.SHZ0:                      case OpCode.SHZ1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              var count = 0;                              if (_zp2.IsTwilight)                                  count = _zp2.Current.Length;                              else if (_contours.Length > 0)                                  count = _contours[_contours.Length - 1] + 1;                                for (int i = 0; i < count; i++)                              {                                  // don't move the reference point                                  if (zone.Current != _zp2.Current || point != i)                                      _zp2.Current[i].P += displacement;                              }                          }                          break;                      case OpCode.MIAP0:                      case OpCode.MIAP1:                          {                              var distance = ReadCvt();                              var pointIndex = _stack.Pop();                                // this instruction is used in the CVT to set up twilight points with original values                              if (_zp0.IsTwilight)                              {                                  var original = _state.Freedom * distance;                                  _zp0.Original[pointIndex].P = original;                                  _zp0.Current[pointIndex].P = original;                              }                                // current position of the point along the projection vector                              var point = _zp0.GetCurrent(pointIndex);                              var currentPos = Project(point);                              if (opcode == OpCode.MIAP1)                              {                                  // only use the CVT if we are above the cut-in point                                  if (Math.Abs(distance - currentPos) > _state.ControlValueCutIn)                                      distance = currentPos;                                  distance = Round(distance);                              }                                MovePoint(_zp0' pointIndex' distance - currentPos);                              _state.Rp0 = pointIndex;                              _state.Rp1 = pointIndex;                          }                          break;                      case OpCode.MDAP0:                      case OpCode.MDAP1:                          {                              var pointIndex = _stack.Pop();                              var point = _zp0.GetCurrent(pointIndex);                              var distance = 0.0f;                              if (opcode == OpCode.MDAP1)                              {                                  distance = Project(point);                                  distance = Round(distance) - distance;                              }                                MovePoint(_zp0' pointIndex' distance);                              _state.Rp0 = pointIndex;                              _state.Rp1 = pointIndex;                          }                          break;                      case OpCode.MSIRP0:                      case OpCode.MSIRP1:                          {                              var targetDistance = _stack.PopFloat();                              var pointIndex = _stack.Pop();                                // if we're operating on the twilight zone' initialize the points                              if (_zp1.IsTwilight)                              {                                  _zp1.Original[pointIndex].P = _zp0.Original[_state.Rp0].P + targetDistance * _state.Freedom / _fdotp;                                  _zp1.Current[pointIndex].P = _zp1.Original[pointIndex].P;                              }                                var currentDistance = Project(_zp1.GetCurrent(pointIndex) - _zp0.GetCurrent(_state.Rp0));                              MovePoint(_zp1' pointIndex' targetDistance - currentDistance);                                _state.Rp1 = _state.Rp0;                              _state.Rp2 = pointIndex;                              if (opcode == OpCode.MSIRP1)                                  _state.Rp0 = pointIndex;                          }                          break;                      case OpCode.IP:                          {                              var originalBase = _zp0.GetOriginal(_state.Rp1);                              var currentBase = _zp0.GetCurrent(_state.Rp1);                              var originalRange = DualProject(_zp1.GetOriginal(_state.Rp2) - originalBase);                              var currentRange = Project(_zp1.GetCurrent(_state.Rp2) - currentBase);                                for (int i = 0; i < _state.Loop; i++)                              {                                  var pointIndex = _stack.Pop();                                  var point = _zp2.GetCurrent(pointIndex);                                  var currentDistance = Project(point - currentBase);                                  var originalDistance = DualProject(_zp2.GetOriginal(pointIndex) - originalBase);                                    var newDistance = 0.0f;                                  if (originalDistance != 0.0f)                                  {                                      // a range of 0.0f is invalid according to the spec (would result in a div by zero)                                      if (originalRange == 0.0f)                                          newDistance = originalDistance;                                      else                                          newDistance = originalDistance * currentRange / originalRange;                                  }                                    MovePoint(_zp2' pointIndex' newDistance - currentDistance);                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.ALIGNRP:                          {                              for (int i = 0; i < _state.Loop; i++)                              {                                  var pointIndex = _stack.Pop();                                  var p1 = _zp1.GetCurrent(pointIndex);                                  var p2 = _zp0.GetCurrent(_state.Rp0);                                  MovePoint(_zp1' pointIndex' -Project(p1 - p2));                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.ALIGNPTS:                          {                              var p1 = _stack.Pop();                              var p2 = _stack.Pop();                              var distance = Project(_zp0.GetCurrent(p2) - _zp1.GetCurrent(p1)) / 2;                              MovePoint(_zp1' p1' distance);                              MovePoint(_zp0' p2' -distance);                          }                          break;                      case OpCode.UTP: _zp0.TouchState[_stack.Pop()] &= ~GetTouchState(); break;                      case OpCode.IUP0:                      case OpCode.IUP1:                          // bail if no contours (empty outline)                          if (_contours.Length == 0)                          {                              break;                          }                            //{                            //    //WinterDev's new managed version                          //    GlyphPointF[] currentPnts = points.Current;                          //    GlyphPointF[] originalPnts = points.Original;                            //    int cnt_count = contours.Length;                          //    int point = 0;                          //    // opcode controls whether we care about X or Y direction                          //    // do some pointer trickery so we can operate on the                          //    // points in a direction-agnostic manner                          //    TouchState touchMask;                            //    if (opcode == OpCode.IUP0)                          //    {                          //        //y -axis                          //        touchMask = TouchState.Y;                            //        //                          //        for (int i = 0; i < cnt_count; ++i)                          //        {                          //            int endPoint = contours[i];                          //            int firstPoint = point;                          //            int firstTouched = -1;                          //            int lastTouched = -1;                            //            for (; point <= endPoint; point++)                          //            {                          //                // check whether this point has been touched                          //                if ((points.TouchState[point] & touchMask) != 0)                          //                {                          //                    // if this is the first touched point in the contour' note it and continue                          //                    if (firstTouched < 0)                          //                    {                          //                        firstTouched = point;                          //                        lastTouched = point;                          //                        continue;                          //                    }                            //                    // otherwise' interpolate all untouched points                          //                    // between this point and our last touched point                          //                    InterpolatePointsYAxis(currentPnts' originalPnts' lastTouched + 1' point - 1' lastTouched' point);                          //                    lastTouched = point;                          //                }                          //            }                            //            // check if we had any touched points at all in this contour                          //            if (firstTouched >= 0)                          //            {                          //                // there are two cases left to handle:                          //                // 1. there was only one touched point in the whole contour' in                          //                //    which case we want to shift everything relative to that one                          //                // 2. several touched points' in which case handle the gap from the                          //                //    beginning to the first touched point and the gap from the last                          //                //    touched point to the end of the contour                          //                if (lastTouched == firstTouched)                          //                {                          //                    float delta = currentPnts[lastTouched].Y - originalPnts[lastTouched].Y;                          //                    if (delta != 0.0f)                          //                    {                          //                        for (int n = firstPoint; n < lastTouched; n++)                          //                        {                          //                            currentPnts[n].OffsetY(delta);                          //                        }                          //                        for (int n = lastTouched + 1; n <= endPoint; n++)                          //                        {                          //                            currentPnts[n].OffsetY(delta);                          //                        }                            //                    }                          //                }                          //                else                          //                {                          //                    InterpolatePointsYAxis(currentPnts' originalPnts' lastTouched + 1' endPoint' lastTouched' firstTouched);                          //                    if (firstTouched > 0)                          //                    {                          //                        InterpolatePointsYAxis(currentPnts' originalPnts' firstPoint' firstTouched - 1' lastTouched' firstTouched);                          //                    }                          //                }                          //            }                            //        }                          //    }                          //    else                          //    {                          //        //x-axis                          //        touchMask = TouchState.X;                          //        //                          //        for (int i = 0; i < cnt_count; ++i)                          //        {                          //            int endPoint = contours[i];                          //            int firstPoint = point;                          //            int firstTouched = -1;                          //            int lastTouched = -1;                            //            for (; point <= endPoint; point++)                          //            {                          //                // check whether this point has been touched                          //                if ((points.TouchState[point] & touchMask) != 0)                          //                {                          //                    // if this is the first touched point in the contour' note it and continue                          //                    if (firstTouched < 0)                          //                    {                          //                        firstTouched = point;                          //                        lastTouched = point;                          //                        continue;                          //                    }                            //                    // otherwise' interpolate all untouched points                          //                    // between this point and our last touched point                          //                    InterpolatePointsXAxis(currentPnts' originalPnts' lastTouched + 1' point - 1' lastTouched' point);                          //                    lastTouched = point;                          //                }                          //            }                            //            // check if we had any touched points at all in this contour                          //            if (firstTouched >= 0)                          //            {                          //                // there are two cases left to handle:                          //                // 1. there was only one touched point in the whole contour' in                          //                //    which case we want to shift everything relative to that one                          //                // 2. several touched points' in which case handle the gap from the                          //                //    beginning to the first touched point and the gap from the last                          //                //    touched point to the end of the contour                          //                if (lastTouched == firstTouched)                          //                {                          //                    float delta = currentPnts[lastTouched].X - originalPnts[lastTouched].X;                          //                    if (delta != 0.0f)                          //                    {                          //                        for (int n = firstPoint; n < lastTouched; ++n)                          //                        {                          //                            currentPnts[n].OffsetX(delta);                          //                        }                          //                        for (int n = lastTouched + 1; n <= endPoint; ++n)                          //                        {                          //                            currentPnts[n].OffsetX(delta);                          //                        }                          //                    }                          //                }                          //                else                          //                {                          //                    InterpolatePointsXAxis(currentPnts' originalPnts' lastTouched + 1' endPoint' lastTouched' firstTouched);                          //                    if (firstTouched > 0)                          //                    {                          //                        InterpolatePointsXAxis(currentPnts' originalPnts' firstPoint' firstTouched - 1' lastTouched' firstTouched);                          //                    }                          //                }                          //            }                          //        }                          //    }                          //}                          //-----------------------------------------                          unsafe                          {                                //unsafe version                               //TODO: provide manage version                               fixed (GlyphPointF* currentPtr = _points.Current)                              fixed (GlyphPointF* originalPtr = _points.Original)                              {                                  // opcode controls whether we care about X or Y direction                                  // do some pointer trickery so we can operate on the                                  // points in a direction-agnostic manner                                  TouchState touchMask;                                  byte* current;                                  byte* original;                                  if (opcode == OpCode.IUP0)                                  {                                      touchMask = TouchState.Y;                                      current = (byte*)&currentPtr->P.Y;                                      original = (byte*)&originalPtr->P.Y;                                  }                                  else                                  {                                      touchMask = TouchState.X;                                      current = (byte*)&currentPtr->P.X;                                      original = (byte*)&originalPtr->P.X;                                  }                                    var point = 0;                                  for (int i = 0; i < _contours.Length; i++)                                  {                                      var endPoint = _contours[i];                                      var firstPoint = point;                                      var firstTouched = -1;                                      var lastTouched = -1;                                        for (; point <= endPoint; point++)                                      {                                          // check whether this point has been touched                                          if ((_points.TouchState[point] & touchMask) != 0)                                          {                                              // if this is the first touched point in the contour' note it and continue                                              if (firstTouched < 0)                                              {                                                  firstTouched = point;                                                  lastTouched = point;                                                  continue;                                              }                                                // otherwise' interpolate all untouched points                                              // between this point and our last touched point                                              InterpolatePoints(current' original' lastTouched + 1' point - 1' lastTouched' point);                                              lastTouched = point;                                          }                                      }                                        // check if we had any touched points at all in this contour                                      if (firstTouched >= 0)                                      {                                          // there are two cases left to handle:                                          // 1. there was only one touched point in the whole contour' in                                          //    which case we want to shift everything relative to that one                                          // 2. several touched points' in which case handle the gap from the                                          //    beginning to the first touched point and the gap from the last                                          //    touched point to the end of the contour                                          if (lastTouched == firstTouched)                                          {                                              var delta = *GetPoint(current' lastTouched) - *GetPoint(original' lastTouched);                                              if (delta != 0.0f)                                              {                                                  for (int j = firstPoint; j < lastTouched; j++)                                                      *GetPoint(current' j) += delta;                                                  for (int j = lastTouched + 1; j <= endPoint; j++)                                                      *GetPoint(current' j) += delta;                                              }                                          }                                          else                                          {                                              InterpolatePoints(current' original' lastTouched + 1' endPoint' lastTouched' firstTouched);                                              if (firstTouched > 0)                                                  InterpolatePoints(current' original' firstPoint' firstTouched - 1' lastTouched' firstTouched);                                          }                                      }                                  }                              }                          }                          break;                      case OpCode.ISECT:                          {                              // move point P to the intersection of lines A and B                              var b1 = _zp0.GetCurrent(_stack.Pop());                              var b0 = _zp0.GetCurrent(_stack.Pop());                              var a1 = _zp1.GetCurrent(_stack.Pop());                              var a0 = _zp1.GetCurrent(_stack.Pop());                              var index = _stack.Pop();                                // calculate intersection using determinants: https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line                              var da = a0 - a1;                              var db = b0 - b1;                              var den = (da.X * db.Y) - (da.Y * db.X);                              if (Math.Abs(den) <= Epsilon)                              {                                  // parallel lines; spec says to put the ppoint "into the middle of the two lines"                                  _zp2.Current[index].P = (a0 + a1 + b0 + b1) / 4;                              }                              else                              {                                  var t = (a0.X * a1.Y) - (a0.Y * a1.X);                                  var u = (b0.X * b1.Y) - (b0.Y * b1.X);                                  var p = new Vector2(                                      (t * db.X) - (da.X * u)'                                      (t * db.Y) - (da.Y * u)                                  );                                  _zp2.Current[index].P = p / den;                              }                              _zp2.TouchState[index] = TouchState.Both;                          }                          break;                        // ==== STACK MANAGEMENT ====                      case OpCode.DUP: _stack.Duplicate(); break;                      case OpCode.POP: _stack.Pop(); break;                      case OpCode.CLEAR: _stack.Clear(); break;                      case OpCode.SWAP: _stack.Swap(); break;                      case OpCode.DEPTH: _stack.Depth(); break;                      case OpCode.CINDEX: _stack.Copy(); break;                      case OpCode.MINDEX: _stack.Move(); break;                      case OpCode.ROLL: _stack.Roll(); break;                        // ==== FLOW CONTROL ====                      case OpCode.IF:                          {                              // value is false; jump to the next else block or endif marker                              // otherwise' we don't have to do anything; we'll keep executing this block                              if (!_stack.PopBool())                              {                                  int indent = 1;                                  while (indent > 0)                                  {                                      opcode = SkipNext(ref stream);                                      switch (opcode)                                      {                                          case OpCode.IF: indent++; break;                                          case OpCode.EIF: indent--; break;                                          case OpCode.ELSE:                                              if (indent == 1)                                                  indent = 0;                                              break;                                      }                                  }                              }                          }                          break;                      case OpCode.ELSE:                          {                              // assume we hit the true statement of some previous if block                              // if we had hit false' we would have jumped over this                              int indent = 1;                              while (indent > 0)                              {                                  opcode = SkipNext(ref stream);                                  switch (opcode)                                  {                                      case OpCode.IF: indent++; break;                                      case OpCode.EIF: indent--; break;                                  }                              }                          }                          break;                      case OpCode.EIF: /* nothing to do */ break;                      case OpCode.JROT:                      case OpCode.JROF:                          {                              if (_stack.PopBool() == (opcode == OpCode.JROT))                                  stream.Jump(_stack.Pop() - 1);                              else                                  _stack.Pop();    // ignore the offset                          }                          break;                      case OpCode.JMPR: stream.Jump(_stack.Pop() - 1); break;                        // ==== LOGICAL OPS ====                      case OpCode.LT:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a < b);                          }                          break;                      case OpCode.LTEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a <= b);                          }                          break;                      case OpCode.GT:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a > b);                          }                          break;                      case OpCode.GTEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a >= b);                          }                          break;                      case OpCode.EQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a == b);                          }                          break;                      case OpCode.NEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a != b);                          }                          break;                      case OpCode.AND:                          {                              var b = _stack.PopBool();                              var a = _stack.PopBool();                              _stack.Push(a && b);                          }                          break;                      case OpCode.OR:                          {                              var b = _stack.PopBool();                              var a = _stack.PopBool();                              _stack.Push(a || b);                          }                          break;                      case OpCode.NOT: _stack.Push(!_stack.PopBool()); break;                      case OpCode.ODD:                          {                              var value = (int)Round(_stack.PopFloat());                              _stack.Push(value % 2 != 0);                          }                          break;                      case OpCode.EVEN:                          {                              var value = (int)Round(_stack.PopFloat());                              _stack.Push(value % 2 == 0);                          }                          break;                        // ==== ARITHMETIC ====                      case OpCode.ADD:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a + b);                          }                          break;                      case OpCode.SUB:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a - b);                          }                          break;                      case OpCode.DIV:                          {                              var b = _stack.Pop();                              if (b == 0)                                  throw new InvalidFontException("Division by zero.");                                var a = _stack.Pop();                              var result = ((long)a << 6) / b;                              _stack.Push((int)result);                          }                          break;                      case OpCode.MUL:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              var result = ((long)a * b) >> 6;                              _stack.Push((int)result);                          }                          break;                      case OpCode.ABS: _stack.Push(Math.Abs(_stack.Pop())); break;                      case OpCode.NEG: _stack.Push(-_stack.Pop()); break;                      case OpCode.FLOOR: _stack.Push(_stack.Pop() & ~63); break;                      case OpCode.CEILING: _stack.Push((_stack.Pop() + 63) & ~63); break;                      case OpCode.MAX: _stack.Push(Math.Max(_stack.Pop()' _stack.Pop())); break;                      case OpCode.MIN: _stack.Push(Math.Min(_stack.Pop()' _stack.Pop())); break;                        // ==== FUNCTIONS ====                      case OpCode.FDEF:                          {                              if (!allowFunctionDefs || inFunction)                                  throw new InvalidFontException("Can't define functions here.");                                _functions[_stack.Pop()] = stream;                              while (SkipNext(ref stream) != OpCode.ENDF) ;                          }                          break;                      case OpCode.IDEF:                          {                              if (!allowFunctionDefs || inFunction)                                  throw new InvalidFontException("Can't define functions here.");                                _instructionDefs[_stack.Pop()] = stream;                              while (SkipNext(ref stream) != OpCode.ENDF) ;                          }                          break;                      case OpCode.ENDF:                          {                              if (!inFunction)                                  throw new InvalidFontException("Found invalid ENDF marker outside of a function definition.");                              return;                          }                      case OpCode.CALL:                      case OpCode.LOOPCALL:                          {                              _callStackSize++;                              if (_callStackSize > MaxCallStack)                                  throw new InvalidFontException("Stack overflow; infinite recursion?");                                var function = _functions[_stack.Pop()];                              var count = opcode == OpCode.LOOPCALL ? _stack.Pop() : 1;                              for (int i = 0; i < count; i++)                                  Execute(function' true' false);                              _callStackSize--;                          }                          break;                        // ==== ROUNDING ====                      // we don't have "engine compensation" so the variants are unnecessary                      case OpCode.ROUND0:                      case OpCode.ROUND1:                      case OpCode.ROUND2:                      case OpCode.ROUND3: _stack.Push(Round(_stack.PopFloat())); break;                      case OpCode.NROUND0:                      case OpCode.NROUND1:                      case OpCode.NROUND2:                      case OpCode.NROUND3: break;                        // ==== DELTA EXCEPTIONS ====                      case OpCode.DELTAC1:                      case OpCode.DELTAC2:                      case OpCode.DELTAC3:                          {                              var last = _stack.Pop();                              for (int i = 1; i <= last; i++)                              {                                  var cvtIndex = _stack.Pop();                                  var arg = _stack.Pop();                                    // upper 4 bits of the 8-bit arg is the relative ppem                                  // the opcode specifies the base to add to the ppem                                  var triggerPpem = (arg >> 4) & 0xF;                                  triggerPpem += (opcode - OpCode.DELTAC1) * 16;                                  triggerPpem += _state.DeltaBase;                                    // if the current ppem matches the trigger' apply the exception                                  if (_ppem == triggerPpem)                                  {                                      // the lower 4 bits of the arg is the amount to shift                                      // it's encoded such that 0 isn't an allowable value (who wants to shift by 0 anyway?)                                      var amount = (arg & 0xF) - 8;                                      if (amount >= 0)                                          amount++;                                      amount *= 1 << (6 - _state.DeltaShift);                                        // update the CVT                                      CheckIndex(cvtIndex' _controlValueTable.Length);                                      _controlValueTable[cvtIndex] += F26Dot6ToFloat(amount);                                  }                              }                          }                          break;                      case OpCode.DELTAP1:                      case OpCode.DELTAP2:                      case OpCode.DELTAP3:                          {                              var last = _stack.Pop();                              for (int i = 1; i <= last; i++)                              {                                  var pointIndex = _stack.Pop();                                  var arg = _stack.Pop();                                    // upper 4 bits of the 8-bit arg is the relative ppem                                  // the opcode specifies the base to add to the ppem                                  var triggerPpem = (arg >> 4) & 0xF;                                  triggerPpem += _state.DeltaBase;                                  if (opcode != OpCode.DELTAP1)                                      triggerPpem += (opcode - OpCode.DELTAP2 + 1) * 16;                                    // if the current ppem matches the trigger' apply the exception                                  if (_ppem == triggerPpem)                                  {                                      // the lower 4 bits of the arg is the amount to shift                                      // it's encoded such that 0 isn't an allowable value (who wants to shift by 0 anyway?)                                      var amount = (arg & 0xF) - 8;                                      if (amount >= 0)                                          amount++;                                      amount *= 1 << (6 - _state.DeltaShift);                                        MovePoint(_zp0' pointIndex' F26Dot6ToFloat(amount));                                  }                              }                          }                          break;                        // ==== MISCELLANEOUS ====                      case OpCode.DEBUG: _stack.Pop(); break;                      case OpCode.GETINFO:                          {                              var selector = _stack.Pop();                              var result = 0;                              if ((selector & 0x1) != 0)                              {                                  // pretend we are MS Rasterizer v35                                  result = 35;                              }                                // TODO: rotation and stretching                              //if ((selector & 0x2) != 0)                              //if ((selector & 0x4) != 0)                                // we're always rendering in grayscale                              if ((selector & 0x20) != 0)                                  result |= 1 << 12;                                // TODO: ClearType flags                                _stack.Push(result);                          }                          break;                        default:                          if (opcode >= OpCode.MIRP)                              MoveIndirectRelative(opcode - OpCode.MIRP);                          else if (opcode >= OpCode.MDRP)                              MoveDirectRelative(opcode - OpCode.MDRP);                          else                          {                              // check if this is a runtime-defined opcode                              var index = (int)opcode;                              if (index > _instructionDefs.Length || !_instructionDefs[index].IsValid)                                  throw new InvalidFontException("Unknown opcode in font program.");                                _callStackSize++;                              if (_callStackSize > MaxCallStack)                                  throw new InvalidFontException("Stack overflow; infinite recursion?");                                Execute(_instructionDefs[index]' true' false);                              _callStackSize--;                          }                          break;                  }
Magic Number,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,Execute,The following statement contains a magic number: switch (opcode)                  {                      // ==== PUSH INSTRUCTIONS ====                      case OpCode.NPUSHB:                      case OpCode.PUSHB1:                      case OpCode.PUSHB2:                      case OpCode.PUSHB3:                      case OpCode.PUSHB4:                      case OpCode.PUSHB5:                      case OpCode.PUSHB6:                      case OpCode.PUSHB7:                      case OpCode.PUSHB8:                          {                              var count = opcode == OpCode.NPUSHB ? stream.NextByte() : opcode - OpCode.PUSHB1 + 1;                              for (int i = count - 1; i >= 0; --i)                                  _stack.Push(stream.NextByte());                          }                          break;                      case OpCode.NPUSHW:                      case OpCode.PUSHW1:                      case OpCode.PUSHW2:                      case OpCode.PUSHW3:                      case OpCode.PUSHW4:                      case OpCode.PUSHW5:                      case OpCode.PUSHW6:                      case OpCode.PUSHW7:                      case OpCode.PUSHW8:                          {                              var count = opcode == OpCode.NPUSHW ? stream.NextByte() : opcode - OpCode.PUSHW1 + 1;                              for (int i = count - 1; i >= 0; --i)                                  _stack.Push(stream.NextWord());                          }                          break;                        // ==== STORAGE MANAGEMENT ====                      case OpCode.RS:                          {                              var loc = CheckIndex(_stack.Pop()' _storage.Length);                              _stack.Push(_storage[loc]);                          }                          break;                      case OpCode.WS:                          {                              var value = _stack.Pop();                              var loc = CheckIndex(_stack.Pop()' _storage.Length);                              _storage[loc] = value;                          }                          break;                        // ==== CONTROL VALUE TABLE ====                      case OpCode.WCVTP:                          {                              var value = _stack.PopFloat();                              var loc = CheckIndex(_stack.Pop()' _controlValueTable.Length);                              _controlValueTable[loc] = value;                          }                          break;                      case OpCode.WCVTF:                          {                              var value = _stack.Pop();                              var loc = CheckIndex(_stack.Pop()' _controlValueTable.Length);                              _controlValueTable[loc] = value * _scale;                          }                          break;                      case OpCode.RCVT: _stack.Push(ReadCvt()); break;                        // ==== STATE VECTORS ====                      case OpCode.SVTCA0:                      case OpCode.SVTCA1:                          {                              var axis = opcode - OpCode.SVTCA0;                              SetFreedomVectorToAxis(axis);                              SetProjectionVectorToAxis(axis);                          }                          break;                      case OpCode.SFVTPV: _state.Freedom = _state.Projection; OnVectorsUpdated(); break;                      case OpCode.SPVTCA0:                      case OpCode.SPVTCA1: SetProjectionVectorToAxis(opcode - OpCode.SPVTCA0); break;                      case OpCode.SFVTCA0:                      case OpCode.SFVTCA1: SetFreedomVectorToAxis(opcode - OpCode.SFVTCA0); break;                      case OpCode.SPVTL0:                      case OpCode.SPVTL1:                      case OpCode.SFVTL0:                      case OpCode.SFVTL1: SetVectorToLine(opcode - OpCode.SPVTL0' false); break;                      case OpCode.SDPVTL0:                      case OpCode.SDPVTL1: SetVectorToLine(opcode - OpCode.SDPVTL0' true); break;                      case OpCode.SPVFS:                      case OpCode.SFVFS:                          {                              var y = _stack.Pop();                              var x = _stack.Pop();                              var vec = Vector2.Normalize(new Vector2(F2Dot14ToFloat(x)' F2Dot14ToFloat(y)));                              if (opcode == OpCode.SFVFS)                                  _state.Freedom = vec;                              else                              {                                  _state.Projection = vec;                                  _state.DualProjection = vec;                              }                              OnVectorsUpdated();                          }                          break;                      case OpCode.GPV:                      case OpCode.GFV:                          {                              var vec = opcode == OpCode.GPV ? _state.Projection : _state.Freedom;                              _stack.Push(FloatToF2Dot14(vec.X));                              _stack.Push(FloatToF2Dot14(vec.Y));                          }                          break;                        // ==== GRAPHICS STATE ====                      case OpCode.SRP0: _state.Rp0 = _stack.Pop(); break;                      case OpCode.SRP1: _state.Rp1 = _stack.Pop(); break;                      case OpCode.SRP2: _state.Rp2 = _stack.Pop(); break;                      case OpCode.SZP0: _zp0 = GetZoneFromStack(); break;                      case OpCode.SZP1: _zp1 = GetZoneFromStack(); break;                      case OpCode.SZP2: _zp2 = GetZoneFromStack(); break;                      case OpCode.SZPS: _zp0 = _zp1 = _zp2 = GetZoneFromStack(); break;                      case OpCode.RTHG: _state.RoundState = RoundMode.ToHalfGrid; break;                      case OpCode.RTG: _state.RoundState = RoundMode.ToGrid; break;                      case OpCode.RTDG: _state.RoundState = RoundMode.ToDoubleGrid; break;                      case OpCode.RDTG: _state.RoundState = RoundMode.DownToGrid; break;                      case OpCode.RUTG: _state.RoundState = RoundMode.UpToGrid; break;                      case OpCode.ROFF: _state.RoundState = RoundMode.Off; break;                      case OpCode.SROUND: _state.RoundState = RoundMode.Super; SetSuperRound(1.0f); break;                      case OpCode.S45ROUND: _state.RoundState = RoundMode.Super45; SetSuperRound(Sqrt2Over2); break;                      case OpCode.INSTCTRL:                          {                              var selector = _stack.Pop();                              if (selector >= 1 && selector <= 2)                              {                                  // value is false if zero' otherwise shift the right bit into the flags                                  var bit = 1 << (selector - 1);                                  if (_stack.Pop() == 0)                                      _state.InstructionControl = (InstructionControlFlags)((int)_state.InstructionControl & ~bit);                                  else                                      _state.InstructionControl = (InstructionControlFlags)((int)_state.InstructionControl | bit);                              }                          }                          break;                      case OpCode.SCANCTRL: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SCANTYPE: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SANGW: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SLOOP: _state.Loop = _stack.Pop(); break;                      case OpCode.SMD: _state.MinDistance = _stack.PopFloat(); break;                      case OpCode.SCVTCI: _state.ControlValueCutIn = _stack.PopFloat(); break;                      case OpCode.SSWCI: _state.SingleWidthCutIn = _stack.PopFloat(); break;                      case OpCode.SSW: _state.SingleWidthValue = _stack.Pop() * _scale; break;                      case OpCode.FLIPON: _state.AutoFlip = true; break;                      case OpCode.FLIPOFF: _state.AutoFlip = false; break;                      case OpCode.SDB: _state.DeltaBase = _stack.Pop(); break;                      case OpCode.SDS: _state.DeltaShift = _stack.Pop(); break;                        // ==== POINT MEASUREMENT ====                      case OpCode.GC0: _stack.Push(Project(_zp2.GetCurrent(_stack.Pop()))); break;                      case OpCode.GC1: _stack.Push(DualProject(_zp2.GetOriginal(_stack.Pop()))); break;                      case OpCode.SCFS:                          {                              var value = _stack.PopFloat();                              var index = _stack.Pop();                              var point = _zp2.GetCurrent(index);                              MovePoint(_zp2' index' value - Project(point));                                // moving twilight points moves their "original" value also                              if (_zp2.IsTwilight)                                  _zp2.Original[index].P = _zp2.Current[index].P;                          }                          break;                      case OpCode.MD0:                          {                              var p1 = _zp1.GetOriginal(_stack.Pop());                              var p2 = _zp0.GetOriginal(_stack.Pop());                              _stack.Push(DualProject(p2 - p1));                          }                          break;                      case OpCode.MD1:                          {                              var p1 = _zp1.GetCurrent(_stack.Pop());                              var p2 = _zp0.GetCurrent(_stack.Pop());                              _stack.Push(Project(p2 - p1));                          }                          break;                      case OpCode.MPS: // MPS should return point size' but we assume DPI so it's the same as pixel size                      case OpCode.MPPEM: _stack.Push(_ppem); break;                      case OpCode.AA: /* deprecated instruction */ _stack.Pop(); break;                        // ==== POINT MODIFICATION ====                      case OpCode.FLIPPT:                          {                              for (int i = 0; i < _state.Loop; i++)                              {                                  var index = _stack.Pop();                                  //review here again!                                  _points.Current[index].onCurve = !_points.Current[index].onCurve;                                  //if (points.Current[index].onCurve)                                  //    points.Current[index].onCurve = false;                                  //else                                  //    points.Current[index].onCurve = true;                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.FLIPRGON:                          {                              var end = _stack.Pop();                              for (int i = _stack.Pop(); i <= end; i++)                                  //points.Current[i].Type = PointType.OnCurve;                                  _points.Current[i].onCurve = true;                          }                          break;                      case OpCode.FLIPRGOFF:                          {                              var end = _stack.Pop();                              for (int i = _stack.Pop(); i <= end; i++)                                  //points.Current[i].Type = PointType.Quadratic;                                  _points.Current[i].onCurve = false;                          }                          break;                      case OpCode.SHP0:                      case OpCode.SHP1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              ShiftPoints(displacement);                          }                          break;                      case OpCode.SHPIX: ShiftPoints(_stack.PopFloat() * _state.Freedom); break;                      case OpCode.SHC0:                      case OpCode.SHC1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              var touch = GetTouchState();                              var contour = _stack.Pop();                              var start = contour == 0 ? 0 : _contours[contour - 1] + 1;                              var count = _zp2.IsTwilight ? _zp2.Current.Length : _contours[contour] + 1;                                for (int i = start; i < count; i++)                              {                                  // don't move the reference point                                  if (zone.Current != _zp2.Current || point != i)                                  {                                      _zp2.Current[i].P += displacement;                                      _zp2.TouchState[i] |= touch;                                  }                              }                          }                          break;                      case OpCode.SHZ0:                      case OpCode.SHZ1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              var count = 0;                              if (_zp2.IsTwilight)                                  count = _zp2.Current.Length;                              else if (_contours.Length > 0)                                  count = _contours[_contours.Length - 1] + 1;                                for (int i = 0; i < count; i++)                              {                                  // don't move the reference point                                  if (zone.Current != _zp2.Current || point != i)                                      _zp2.Current[i].P += displacement;                              }                          }                          break;                      case OpCode.MIAP0:                      case OpCode.MIAP1:                          {                              var distance = ReadCvt();                              var pointIndex = _stack.Pop();                                // this instruction is used in the CVT to set up twilight points with original values                              if (_zp0.IsTwilight)                              {                                  var original = _state.Freedom * distance;                                  _zp0.Original[pointIndex].P = original;                                  _zp0.Current[pointIndex].P = original;                              }                                // current position of the point along the projection vector                              var point = _zp0.GetCurrent(pointIndex);                              var currentPos = Project(point);                              if (opcode == OpCode.MIAP1)                              {                                  // only use the CVT if we are above the cut-in point                                  if (Math.Abs(distance - currentPos) > _state.ControlValueCutIn)                                      distance = currentPos;                                  distance = Round(distance);                              }                                MovePoint(_zp0' pointIndex' distance - currentPos);                              _state.Rp0 = pointIndex;                              _state.Rp1 = pointIndex;                          }                          break;                      case OpCode.MDAP0:                      case OpCode.MDAP1:                          {                              var pointIndex = _stack.Pop();                              var point = _zp0.GetCurrent(pointIndex);                              var distance = 0.0f;                              if (opcode == OpCode.MDAP1)                              {                                  distance = Project(point);                                  distance = Round(distance) - distance;                              }                                MovePoint(_zp0' pointIndex' distance);                              _state.Rp0 = pointIndex;                              _state.Rp1 = pointIndex;                          }                          break;                      case OpCode.MSIRP0:                      case OpCode.MSIRP1:                          {                              var targetDistance = _stack.PopFloat();                              var pointIndex = _stack.Pop();                                // if we're operating on the twilight zone' initialize the points                              if (_zp1.IsTwilight)                              {                                  _zp1.Original[pointIndex].P = _zp0.Original[_state.Rp0].P + targetDistance * _state.Freedom / _fdotp;                                  _zp1.Current[pointIndex].P = _zp1.Original[pointIndex].P;                              }                                var currentDistance = Project(_zp1.GetCurrent(pointIndex) - _zp0.GetCurrent(_state.Rp0));                              MovePoint(_zp1' pointIndex' targetDistance - currentDistance);                                _state.Rp1 = _state.Rp0;                              _state.Rp2 = pointIndex;                              if (opcode == OpCode.MSIRP1)                                  _state.Rp0 = pointIndex;                          }                          break;                      case OpCode.IP:                          {                              var originalBase = _zp0.GetOriginal(_state.Rp1);                              var currentBase = _zp0.GetCurrent(_state.Rp1);                              var originalRange = DualProject(_zp1.GetOriginal(_state.Rp2) - originalBase);                              var currentRange = Project(_zp1.GetCurrent(_state.Rp2) - currentBase);                                for (int i = 0; i < _state.Loop; i++)                              {                                  var pointIndex = _stack.Pop();                                  var point = _zp2.GetCurrent(pointIndex);                                  var currentDistance = Project(point - currentBase);                                  var originalDistance = DualProject(_zp2.GetOriginal(pointIndex) - originalBase);                                    var newDistance = 0.0f;                                  if (originalDistance != 0.0f)                                  {                                      // a range of 0.0f is invalid according to the spec (would result in a div by zero)                                      if (originalRange == 0.0f)                                          newDistance = originalDistance;                                      else                                          newDistance = originalDistance * currentRange / originalRange;                                  }                                    MovePoint(_zp2' pointIndex' newDistance - currentDistance);                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.ALIGNRP:                          {                              for (int i = 0; i < _state.Loop; i++)                              {                                  var pointIndex = _stack.Pop();                                  var p1 = _zp1.GetCurrent(pointIndex);                                  var p2 = _zp0.GetCurrent(_state.Rp0);                                  MovePoint(_zp1' pointIndex' -Project(p1 - p2));                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.ALIGNPTS:                          {                              var p1 = _stack.Pop();                              var p2 = _stack.Pop();                              var distance = Project(_zp0.GetCurrent(p2) - _zp1.GetCurrent(p1)) / 2;                              MovePoint(_zp1' p1' distance);                              MovePoint(_zp0' p2' -distance);                          }                          break;                      case OpCode.UTP: _zp0.TouchState[_stack.Pop()] &= ~GetTouchState(); break;                      case OpCode.IUP0:                      case OpCode.IUP1:                          // bail if no contours (empty outline)                          if (_contours.Length == 0)                          {                              break;                          }                            //{                            //    //WinterDev's new managed version                          //    GlyphPointF[] currentPnts = points.Current;                          //    GlyphPointF[] originalPnts = points.Original;                            //    int cnt_count = contours.Length;                          //    int point = 0;                          //    // opcode controls whether we care about X or Y direction                          //    // do some pointer trickery so we can operate on the                          //    // points in a direction-agnostic manner                          //    TouchState touchMask;                            //    if (opcode == OpCode.IUP0)                          //    {                          //        //y -axis                          //        touchMask = TouchState.Y;                            //        //                          //        for (int i = 0; i < cnt_count; ++i)                          //        {                          //            int endPoint = contours[i];                          //            int firstPoint = point;                          //            int firstTouched = -1;                          //            int lastTouched = -1;                            //            for (; point <= endPoint; point++)                          //            {                          //                // check whether this point has been touched                          //                if ((points.TouchState[point] & touchMask) != 0)                          //                {                          //                    // if this is the first touched point in the contour' note it and continue                          //                    if (firstTouched < 0)                          //                    {                          //                        firstTouched = point;                          //                        lastTouched = point;                          //                        continue;                          //                    }                            //                    // otherwise' interpolate all untouched points                          //                    // between this point and our last touched point                          //                    InterpolatePointsYAxis(currentPnts' originalPnts' lastTouched + 1' point - 1' lastTouched' point);                          //                    lastTouched = point;                          //                }                          //            }                            //            // check if we had any touched points at all in this contour                          //            if (firstTouched >= 0)                          //            {                          //                // there are two cases left to handle:                          //                // 1. there was only one touched point in the whole contour' in                          //                //    which case we want to shift everything relative to that one                          //                // 2. several touched points' in which case handle the gap from the                          //                //    beginning to the first touched point and the gap from the last                          //                //    touched point to the end of the contour                          //                if (lastTouched == firstTouched)                          //                {                          //                    float delta = currentPnts[lastTouched].Y - originalPnts[lastTouched].Y;                          //                    if (delta != 0.0f)                          //                    {                          //                        for (int n = firstPoint; n < lastTouched; n++)                          //                        {                          //                            currentPnts[n].OffsetY(delta);                          //                        }                          //                        for (int n = lastTouched + 1; n <= endPoint; n++)                          //                        {                          //                            currentPnts[n].OffsetY(delta);                          //                        }                            //                    }                          //                }                          //                else                          //                {                          //                    InterpolatePointsYAxis(currentPnts' originalPnts' lastTouched + 1' endPoint' lastTouched' firstTouched);                          //                    if (firstTouched > 0)                          //                    {                          //                        InterpolatePointsYAxis(currentPnts' originalPnts' firstPoint' firstTouched - 1' lastTouched' firstTouched);                          //                    }                          //                }                          //            }                            //        }                          //    }                          //    else                          //    {                          //        //x-axis                          //        touchMask = TouchState.X;                          //        //                          //        for (int i = 0; i < cnt_count; ++i)                          //        {                          //            int endPoint = contours[i];                          //            int firstPoint = point;                          //            int firstTouched = -1;                          //            int lastTouched = -1;                            //            for (; point <= endPoint; point++)                          //            {                          //                // check whether this point has been touched                          //                if ((points.TouchState[point] & touchMask) != 0)                          //                {                          //                    // if this is the first touched point in the contour' note it and continue                          //                    if (firstTouched < 0)                          //                    {                          //                        firstTouched = point;                          //                        lastTouched = point;                          //                        continue;                          //                    }                            //                    // otherwise' interpolate all untouched points                          //                    // between this point and our last touched point                          //                    InterpolatePointsXAxis(currentPnts' originalPnts' lastTouched + 1' point - 1' lastTouched' point);                          //                    lastTouched = point;                          //                }                          //            }                            //            // check if we had any touched points at all in this contour                          //            if (firstTouched >= 0)                          //            {                          //                // there are two cases left to handle:                          //                // 1. there was only one touched point in the whole contour' in                          //                //    which case we want to shift everything relative to that one                          //                // 2. several touched points' in which case handle the gap from the                          //                //    beginning to the first touched point and the gap from the last                          //                //    touched point to the end of the contour                          //                if (lastTouched == firstTouched)                          //                {                          //                    float delta = currentPnts[lastTouched].X - originalPnts[lastTouched].X;                          //                    if (delta != 0.0f)                          //                    {                          //                        for (int n = firstPoint; n < lastTouched; ++n)                          //                        {                          //                            currentPnts[n].OffsetX(delta);                          //                        }                          //                        for (int n = lastTouched + 1; n <= endPoint; ++n)                          //                        {                          //                            currentPnts[n].OffsetX(delta);                          //                        }                          //                    }                          //                }                          //                else                          //                {                          //                    InterpolatePointsXAxis(currentPnts' originalPnts' lastTouched + 1' endPoint' lastTouched' firstTouched);                          //                    if (firstTouched > 0)                          //                    {                          //                        InterpolatePointsXAxis(currentPnts' originalPnts' firstPoint' firstTouched - 1' lastTouched' firstTouched);                          //                    }                          //                }                          //            }                          //        }                          //    }                          //}                          //-----------------------------------------                          unsafe                          {                                //unsafe version                               //TODO: provide manage version                               fixed (GlyphPointF* currentPtr = _points.Current)                              fixed (GlyphPointF* originalPtr = _points.Original)                              {                                  // opcode controls whether we care about X or Y direction                                  // do some pointer trickery so we can operate on the                                  // points in a direction-agnostic manner                                  TouchState touchMask;                                  byte* current;                                  byte* original;                                  if (opcode == OpCode.IUP0)                                  {                                      touchMask = TouchState.Y;                                      current = (byte*)&currentPtr->P.Y;                                      original = (byte*)&originalPtr->P.Y;                                  }                                  else                                  {                                      touchMask = TouchState.X;                                      current = (byte*)&currentPtr->P.X;                                      original = (byte*)&originalPtr->P.X;                                  }                                    var point = 0;                                  for (int i = 0; i < _contours.Length; i++)                                  {                                      var endPoint = _contours[i];                                      var firstPoint = point;                                      var firstTouched = -1;                                      var lastTouched = -1;                                        for (; point <= endPoint; point++)                                      {                                          // check whether this point has been touched                                          if ((_points.TouchState[point] & touchMask) != 0)                                          {                                              // if this is the first touched point in the contour' note it and continue                                              if (firstTouched < 0)                                              {                                                  firstTouched = point;                                                  lastTouched = point;                                                  continue;                                              }                                                // otherwise' interpolate all untouched points                                              // between this point and our last touched point                                              InterpolatePoints(current' original' lastTouched + 1' point - 1' lastTouched' point);                                              lastTouched = point;                                          }                                      }                                        // check if we had any touched points at all in this contour                                      if (firstTouched >= 0)                                      {                                          // there are two cases left to handle:                                          // 1. there was only one touched point in the whole contour' in                                          //    which case we want to shift everything relative to that one                                          // 2. several touched points' in which case handle the gap from the                                          //    beginning to the first touched point and the gap from the last                                          //    touched point to the end of the contour                                          if (lastTouched == firstTouched)                                          {                                              var delta = *GetPoint(current' lastTouched) - *GetPoint(original' lastTouched);                                              if (delta != 0.0f)                                              {                                                  for (int j = firstPoint; j < lastTouched; j++)                                                      *GetPoint(current' j) += delta;                                                  for (int j = lastTouched + 1; j <= endPoint; j++)                                                      *GetPoint(current' j) += delta;                                              }                                          }                                          else                                          {                                              InterpolatePoints(current' original' lastTouched + 1' endPoint' lastTouched' firstTouched);                                              if (firstTouched > 0)                                                  InterpolatePoints(current' original' firstPoint' firstTouched - 1' lastTouched' firstTouched);                                          }                                      }                                  }                              }                          }                          break;                      case OpCode.ISECT:                          {                              // move point P to the intersection of lines A and B                              var b1 = _zp0.GetCurrent(_stack.Pop());                              var b0 = _zp0.GetCurrent(_stack.Pop());                              var a1 = _zp1.GetCurrent(_stack.Pop());                              var a0 = _zp1.GetCurrent(_stack.Pop());                              var index = _stack.Pop();                                // calculate intersection using determinants: https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line                              var da = a0 - a1;                              var db = b0 - b1;                              var den = (da.X * db.Y) - (da.Y * db.X);                              if (Math.Abs(den) <= Epsilon)                              {                                  // parallel lines; spec says to put the ppoint "into the middle of the two lines"                                  _zp2.Current[index].P = (a0 + a1 + b0 + b1) / 4;                              }                              else                              {                                  var t = (a0.X * a1.Y) - (a0.Y * a1.X);                                  var u = (b0.X * b1.Y) - (b0.Y * b1.X);                                  var p = new Vector2(                                      (t * db.X) - (da.X * u)'                                      (t * db.Y) - (da.Y * u)                                  );                                  _zp2.Current[index].P = p / den;                              }                              _zp2.TouchState[index] = TouchState.Both;                          }                          break;                        // ==== STACK MANAGEMENT ====                      case OpCode.DUP: _stack.Duplicate(); break;                      case OpCode.POP: _stack.Pop(); break;                      case OpCode.CLEAR: _stack.Clear(); break;                      case OpCode.SWAP: _stack.Swap(); break;                      case OpCode.DEPTH: _stack.Depth(); break;                      case OpCode.CINDEX: _stack.Copy(); break;                      case OpCode.MINDEX: _stack.Move(); break;                      case OpCode.ROLL: _stack.Roll(); break;                        // ==== FLOW CONTROL ====                      case OpCode.IF:                          {                              // value is false; jump to the next else block or endif marker                              // otherwise' we don't have to do anything; we'll keep executing this block                              if (!_stack.PopBool())                              {                                  int indent = 1;                                  while (indent > 0)                                  {                                      opcode = SkipNext(ref stream);                                      switch (opcode)                                      {                                          case OpCode.IF: indent++; break;                                          case OpCode.EIF: indent--; break;                                          case OpCode.ELSE:                                              if (indent == 1)                                                  indent = 0;                                              break;                                      }                                  }                              }                          }                          break;                      case OpCode.ELSE:                          {                              // assume we hit the true statement of some previous if block                              // if we had hit false' we would have jumped over this                              int indent = 1;                              while (indent > 0)                              {                                  opcode = SkipNext(ref stream);                                  switch (opcode)                                  {                                      case OpCode.IF: indent++; break;                                      case OpCode.EIF: indent--; break;                                  }                              }                          }                          break;                      case OpCode.EIF: /* nothing to do */ break;                      case OpCode.JROT:                      case OpCode.JROF:                          {                              if (_stack.PopBool() == (opcode == OpCode.JROT))                                  stream.Jump(_stack.Pop() - 1);                              else                                  _stack.Pop();    // ignore the offset                          }                          break;                      case OpCode.JMPR: stream.Jump(_stack.Pop() - 1); break;                        // ==== LOGICAL OPS ====                      case OpCode.LT:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a < b);                          }                          break;                      case OpCode.LTEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a <= b);                          }                          break;                      case OpCode.GT:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a > b);                          }                          break;                      case OpCode.GTEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a >= b);                          }                          break;                      case OpCode.EQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a == b);                          }                          break;                      case OpCode.NEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a != b);                          }                          break;                      case OpCode.AND:                          {                              var b = _stack.PopBool();                              var a = _stack.PopBool();                              _stack.Push(a && b);                          }                          break;                      case OpCode.OR:                          {                              var b = _stack.PopBool();                              var a = _stack.PopBool();                              _stack.Push(a || b);                          }                          break;                      case OpCode.NOT: _stack.Push(!_stack.PopBool()); break;                      case OpCode.ODD:                          {                              var value = (int)Round(_stack.PopFloat());                              _stack.Push(value % 2 != 0);                          }                          break;                      case OpCode.EVEN:                          {                              var value = (int)Round(_stack.PopFloat());                              _stack.Push(value % 2 == 0);                          }                          break;                        // ==== ARITHMETIC ====                      case OpCode.ADD:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a + b);                          }                          break;                      case OpCode.SUB:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a - b);                          }                          break;                      case OpCode.DIV:                          {                              var b = _stack.Pop();                              if (b == 0)                                  throw new InvalidFontException("Division by zero.");                                var a = _stack.Pop();                              var result = ((long)a << 6) / b;                              _stack.Push((int)result);                          }                          break;                      case OpCode.MUL:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              var result = ((long)a * b) >> 6;                              _stack.Push((int)result);                          }                          break;                      case OpCode.ABS: _stack.Push(Math.Abs(_stack.Pop())); break;                      case OpCode.NEG: _stack.Push(-_stack.Pop()); break;                      case OpCode.FLOOR: _stack.Push(_stack.Pop() & ~63); break;                      case OpCode.CEILING: _stack.Push((_stack.Pop() + 63) & ~63); break;                      case OpCode.MAX: _stack.Push(Math.Max(_stack.Pop()' _stack.Pop())); break;                      case OpCode.MIN: _stack.Push(Math.Min(_stack.Pop()' _stack.Pop())); break;                        // ==== FUNCTIONS ====                      case OpCode.FDEF:                          {                              if (!allowFunctionDefs || inFunction)                                  throw new InvalidFontException("Can't define functions here.");                                _functions[_stack.Pop()] = stream;                              while (SkipNext(ref stream) != OpCode.ENDF) ;                          }                          break;                      case OpCode.IDEF:                          {                              if (!allowFunctionDefs || inFunction)                                  throw new InvalidFontException("Can't define functions here.");                                _instructionDefs[_stack.Pop()] = stream;                              while (SkipNext(ref stream) != OpCode.ENDF) ;                          }                          break;                      case OpCode.ENDF:                          {                              if (!inFunction)                                  throw new InvalidFontException("Found invalid ENDF marker outside of a function definition.");                              return;                          }                      case OpCode.CALL:                      case OpCode.LOOPCALL:                          {                              _callStackSize++;                              if (_callStackSize > MaxCallStack)                                  throw new InvalidFontException("Stack overflow; infinite recursion?");                                var function = _functions[_stack.Pop()];                              var count = opcode == OpCode.LOOPCALL ? _stack.Pop() : 1;                              for (int i = 0; i < count; i++)                                  Execute(function' true' false);                              _callStackSize--;                          }                          break;                        // ==== ROUNDING ====                      // we don't have "engine compensation" so the variants are unnecessary                      case OpCode.ROUND0:                      case OpCode.ROUND1:                      case OpCode.ROUND2:                      case OpCode.ROUND3: _stack.Push(Round(_stack.PopFloat())); break;                      case OpCode.NROUND0:                      case OpCode.NROUND1:                      case OpCode.NROUND2:                      case OpCode.NROUND3: break;                        // ==== DELTA EXCEPTIONS ====                      case OpCode.DELTAC1:                      case OpCode.DELTAC2:                      case OpCode.DELTAC3:                          {                              var last = _stack.Pop();                              for (int i = 1; i <= last; i++)                              {                                  var cvtIndex = _stack.Pop();                                  var arg = _stack.Pop();                                    // upper 4 bits of the 8-bit arg is the relative ppem                                  // the opcode specifies the base to add to the ppem                                  var triggerPpem = (arg >> 4) & 0xF;                                  triggerPpem += (opcode - OpCode.DELTAC1) * 16;                                  triggerPpem += _state.DeltaBase;                                    // if the current ppem matches the trigger' apply the exception                                  if (_ppem == triggerPpem)                                  {                                      // the lower 4 bits of the arg is the amount to shift                                      // it's encoded such that 0 isn't an allowable value (who wants to shift by 0 anyway?)                                      var amount = (arg & 0xF) - 8;                                      if (amount >= 0)                                          amount++;                                      amount *= 1 << (6 - _state.DeltaShift);                                        // update the CVT                                      CheckIndex(cvtIndex' _controlValueTable.Length);                                      _controlValueTable[cvtIndex] += F26Dot6ToFloat(amount);                                  }                              }                          }                          break;                      case OpCode.DELTAP1:                      case OpCode.DELTAP2:                      case OpCode.DELTAP3:                          {                              var last = _stack.Pop();                              for (int i = 1; i <= last; i++)                              {                                  var pointIndex = _stack.Pop();                                  var arg = _stack.Pop();                                    // upper 4 bits of the 8-bit arg is the relative ppem                                  // the opcode specifies the base to add to the ppem                                  var triggerPpem = (arg >> 4) & 0xF;                                  triggerPpem += _state.DeltaBase;                                  if (opcode != OpCode.DELTAP1)                                      triggerPpem += (opcode - OpCode.DELTAP2 + 1) * 16;                                    // if the current ppem matches the trigger' apply the exception                                  if (_ppem == triggerPpem)                                  {                                      // the lower 4 bits of the arg is the amount to shift                                      // it's encoded such that 0 isn't an allowable value (who wants to shift by 0 anyway?)                                      var amount = (arg & 0xF) - 8;                                      if (amount >= 0)                                          amount++;                                      amount *= 1 << (6 - _state.DeltaShift);                                        MovePoint(_zp0' pointIndex' F26Dot6ToFloat(amount));                                  }                              }                          }                          break;                        // ==== MISCELLANEOUS ====                      case OpCode.DEBUG: _stack.Pop(); break;                      case OpCode.GETINFO:                          {                              var selector = _stack.Pop();                              var result = 0;                              if ((selector & 0x1) != 0)                              {                                  // pretend we are MS Rasterizer v35                                  result = 35;                              }                                // TODO: rotation and stretching                              //if ((selector & 0x2) != 0)                              //if ((selector & 0x4) != 0)                                // we're always rendering in grayscale                              if ((selector & 0x20) != 0)                                  result |= 1 << 12;                                // TODO: ClearType flags                                _stack.Push(result);                          }                          break;                        default:                          if (opcode >= OpCode.MIRP)                              MoveIndirectRelative(opcode - OpCode.MIRP);                          else if (opcode >= OpCode.MDRP)                              MoveDirectRelative(opcode - OpCode.MDRP);                          else                          {                              // check if this is a runtime-defined opcode                              var index = (int)opcode;                              if (index > _instructionDefs.Length || !_instructionDefs[index].IsValid)                                  throw new InvalidFontException("Unknown opcode in font program.");                                _callStackSize++;                              if (_callStackSize > MaxCallStack)                                  throw new InvalidFontException("Stack overflow; infinite recursion?");                                Execute(_instructionDefs[index]' true' false);                              _callStackSize--;                          }                          break;                  }
Magic Number,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,Execute,The following statement contains a magic number: switch (opcode)                  {                      // ==== PUSH INSTRUCTIONS ====                      case OpCode.NPUSHB:                      case OpCode.PUSHB1:                      case OpCode.PUSHB2:                      case OpCode.PUSHB3:                      case OpCode.PUSHB4:                      case OpCode.PUSHB5:                      case OpCode.PUSHB6:                      case OpCode.PUSHB7:                      case OpCode.PUSHB8:                          {                              var count = opcode == OpCode.NPUSHB ? stream.NextByte() : opcode - OpCode.PUSHB1 + 1;                              for (int i = count - 1; i >= 0; --i)                                  _stack.Push(stream.NextByte());                          }                          break;                      case OpCode.NPUSHW:                      case OpCode.PUSHW1:                      case OpCode.PUSHW2:                      case OpCode.PUSHW3:                      case OpCode.PUSHW4:                      case OpCode.PUSHW5:                      case OpCode.PUSHW6:                      case OpCode.PUSHW7:                      case OpCode.PUSHW8:                          {                              var count = opcode == OpCode.NPUSHW ? stream.NextByte() : opcode - OpCode.PUSHW1 + 1;                              for (int i = count - 1; i >= 0; --i)                                  _stack.Push(stream.NextWord());                          }                          break;                        // ==== STORAGE MANAGEMENT ====                      case OpCode.RS:                          {                              var loc = CheckIndex(_stack.Pop()' _storage.Length);                              _stack.Push(_storage[loc]);                          }                          break;                      case OpCode.WS:                          {                              var value = _stack.Pop();                              var loc = CheckIndex(_stack.Pop()' _storage.Length);                              _storage[loc] = value;                          }                          break;                        // ==== CONTROL VALUE TABLE ====                      case OpCode.WCVTP:                          {                              var value = _stack.PopFloat();                              var loc = CheckIndex(_stack.Pop()' _controlValueTable.Length);                              _controlValueTable[loc] = value;                          }                          break;                      case OpCode.WCVTF:                          {                              var value = _stack.Pop();                              var loc = CheckIndex(_stack.Pop()' _controlValueTable.Length);                              _controlValueTable[loc] = value * _scale;                          }                          break;                      case OpCode.RCVT: _stack.Push(ReadCvt()); break;                        // ==== STATE VECTORS ====                      case OpCode.SVTCA0:                      case OpCode.SVTCA1:                          {                              var axis = opcode - OpCode.SVTCA0;                              SetFreedomVectorToAxis(axis);                              SetProjectionVectorToAxis(axis);                          }                          break;                      case OpCode.SFVTPV: _state.Freedom = _state.Projection; OnVectorsUpdated(); break;                      case OpCode.SPVTCA0:                      case OpCode.SPVTCA1: SetProjectionVectorToAxis(opcode - OpCode.SPVTCA0); break;                      case OpCode.SFVTCA0:                      case OpCode.SFVTCA1: SetFreedomVectorToAxis(opcode - OpCode.SFVTCA0); break;                      case OpCode.SPVTL0:                      case OpCode.SPVTL1:                      case OpCode.SFVTL0:                      case OpCode.SFVTL1: SetVectorToLine(opcode - OpCode.SPVTL0' false); break;                      case OpCode.SDPVTL0:                      case OpCode.SDPVTL1: SetVectorToLine(opcode - OpCode.SDPVTL0' true); break;                      case OpCode.SPVFS:                      case OpCode.SFVFS:                          {                              var y = _stack.Pop();                              var x = _stack.Pop();                              var vec = Vector2.Normalize(new Vector2(F2Dot14ToFloat(x)' F2Dot14ToFloat(y)));                              if (opcode == OpCode.SFVFS)                                  _state.Freedom = vec;                              else                              {                                  _state.Projection = vec;                                  _state.DualProjection = vec;                              }                              OnVectorsUpdated();                          }                          break;                      case OpCode.GPV:                      case OpCode.GFV:                          {                              var vec = opcode == OpCode.GPV ? _state.Projection : _state.Freedom;                              _stack.Push(FloatToF2Dot14(vec.X));                              _stack.Push(FloatToF2Dot14(vec.Y));                          }                          break;                        // ==== GRAPHICS STATE ====                      case OpCode.SRP0: _state.Rp0 = _stack.Pop(); break;                      case OpCode.SRP1: _state.Rp1 = _stack.Pop(); break;                      case OpCode.SRP2: _state.Rp2 = _stack.Pop(); break;                      case OpCode.SZP0: _zp0 = GetZoneFromStack(); break;                      case OpCode.SZP1: _zp1 = GetZoneFromStack(); break;                      case OpCode.SZP2: _zp2 = GetZoneFromStack(); break;                      case OpCode.SZPS: _zp0 = _zp1 = _zp2 = GetZoneFromStack(); break;                      case OpCode.RTHG: _state.RoundState = RoundMode.ToHalfGrid; break;                      case OpCode.RTG: _state.RoundState = RoundMode.ToGrid; break;                      case OpCode.RTDG: _state.RoundState = RoundMode.ToDoubleGrid; break;                      case OpCode.RDTG: _state.RoundState = RoundMode.DownToGrid; break;                      case OpCode.RUTG: _state.RoundState = RoundMode.UpToGrid; break;                      case OpCode.ROFF: _state.RoundState = RoundMode.Off; break;                      case OpCode.SROUND: _state.RoundState = RoundMode.Super; SetSuperRound(1.0f); break;                      case OpCode.S45ROUND: _state.RoundState = RoundMode.Super45; SetSuperRound(Sqrt2Over2); break;                      case OpCode.INSTCTRL:                          {                              var selector = _stack.Pop();                              if (selector >= 1 && selector <= 2)                              {                                  // value is false if zero' otherwise shift the right bit into the flags                                  var bit = 1 << (selector - 1);                                  if (_stack.Pop() == 0)                                      _state.InstructionControl = (InstructionControlFlags)((int)_state.InstructionControl & ~bit);                                  else                                      _state.InstructionControl = (InstructionControlFlags)((int)_state.InstructionControl | bit);                              }                          }                          break;                      case OpCode.SCANCTRL: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SCANTYPE: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SANGW: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SLOOP: _state.Loop = _stack.Pop(); break;                      case OpCode.SMD: _state.MinDistance = _stack.PopFloat(); break;                      case OpCode.SCVTCI: _state.ControlValueCutIn = _stack.PopFloat(); break;                      case OpCode.SSWCI: _state.SingleWidthCutIn = _stack.PopFloat(); break;                      case OpCode.SSW: _state.SingleWidthValue = _stack.Pop() * _scale; break;                      case OpCode.FLIPON: _state.AutoFlip = true; break;                      case OpCode.FLIPOFF: _state.AutoFlip = false; break;                      case OpCode.SDB: _state.DeltaBase = _stack.Pop(); break;                      case OpCode.SDS: _state.DeltaShift = _stack.Pop(); break;                        // ==== POINT MEASUREMENT ====                      case OpCode.GC0: _stack.Push(Project(_zp2.GetCurrent(_stack.Pop()))); break;                      case OpCode.GC1: _stack.Push(DualProject(_zp2.GetOriginal(_stack.Pop()))); break;                      case OpCode.SCFS:                          {                              var value = _stack.PopFloat();                              var index = _stack.Pop();                              var point = _zp2.GetCurrent(index);                              MovePoint(_zp2' index' value - Project(point));                                // moving twilight points moves their "original" value also                              if (_zp2.IsTwilight)                                  _zp2.Original[index].P = _zp2.Current[index].P;                          }                          break;                      case OpCode.MD0:                          {                              var p1 = _zp1.GetOriginal(_stack.Pop());                              var p2 = _zp0.GetOriginal(_stack.Pop());                              _stack.Push(DualProject(p2 - p1));                          }                          break;                      case OpCode.MD1:                          {                              var p1 = _zp1.GetCurrent(_stack.Pop());                              var p2 = _zp0.GetCurrent(_stack.Pop());                              _stack.Push(Project(p2 - p1));                          }                          break;                      case OpCode.MPS: // MPS should return point size' but we assume DPI so it's the same as pixel size                      case OpCode.MPPEM: _stack.Push(_ppem); break;                      case OpCode.AA: /* deprecated instruction */ _stack.Pop(); break;                        // ==== POINT MODIFICATION ====                      case OpCode.FLIPPT:                          {                              for (int i = 0; i < _state.Loop; i++)                              {                                  var index = _stack.Pop();                                  //review here again!                                  _points.Current[index].onCurve = !_points.Current[index].onCurve;                                  //if (points.Current[index].onCurve)                                  //    points.Current[index].onCurve = false;                                  //else                                  //    points.Current[index].onCurve = true;                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.FLIPRGON:                          {                              var end = _stack.Pop();                              for (int i = _stack.Pop(); i <= end; i++)                                  //points.Current[i].Type = PointType.OnCurve;                                  _points.Current[i].onCurve = true;                          }                          break;                      case OpCode.FLIPRGOFF:                          {                              var end = _stack.Pop();                              for (int i = _stack.Pop(); i <= end; i++)                                  //points.Current[i].Type = PointType.Quadratic;                                  _points.Current[i].onCurve = false;                          }                          break;                      case OpCode.SHP0:                      case OpCode.SHP1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              ShiftPoints(displacement);                          }                          break;                      case OpCode.SHPIX: ShiftPoints(_stack.PopFloat() * _state.Freedom); break;                      case OpCode.SHC0:                      case OpCode.SHC1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              var touch = GetTouchState();                              var contour = _stack.Pop();                              var start = contour == 0 ? 0 : _contours[contour - 1] + 1;                              var count = _zp2.IsTwilight ? _zp2.Current.Length : _contours[contour] + 1;                                for (int i = start; i < count; i++)                              {                                  // don't move the reference point                                  if (zone.Current != _zp2.Current || point != i)                                  {                                      _zp2.Current[i].P += displacement;                                      _zp2.TouchState[i] |= touch;                                  }                              }                          }                          break;                      case OpCode.SHZ0:                      case OpCode.SHZ1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              var count = 0;                              if (_zp2.IsTwilight)                                  count = _zp2.Current.Length;                              else if (_contours.Length > 0)                                  count = _contours[_contours.Length - 1] + 1;                                for (int i = 0; i < count; i++)                              {                                  // don't move the reference point                                  if (zone.Current != _zp2.Current || point != i)                                      _zp2.Current[i].P += displacement;                              }                          }                          break;                      case OpCode.MIAP0:                      case OpCode.MIAP1:                          {                              var distance = ReadCvt();                              var pointIndex = _stack.Pop();                                // this instruction is used in the CVT to set up twilight points with original values                              if (_zp0.IsTwilight)                              {                                  var original = _state.Freedom * distance;                                  _zp0.Original[pointIndex].P = original;                                  _zp0.Current[pointIndex].P = original;                              }                                // current position of the point along the projection vector                              var point = _zp0.GetCurrent(pointIndex);                              var currentPos = Project(point);                              if (opcode == OpCode.MIAP1)                              {                                  // only use the CVT if we are above the cut-in point                                  if (Math.Abs(distance - currentPos) > _state.ControlValueCutIn)                                      distance = currentPos;                                  distance = Round(distance);                              }                                MovePoint(_zp0' pointIndex' distance - currentPos);                              _state.Rp0 = pointIndex;                              _state.Rp1 = pointIndex;                          }                          break;                      case OpCode.MDAP0:                      case OpCode.MDAP1:                          {                              var pointIndex = _stack.Pop();                              var point = _zp0.GetCurrent(pointIndex);                              var distance = 0.0f;                              if (opcode == OpCode.MDAP1)                              {                                  distance = Project(point);                                  distance = Round(distance) - distance;                              }                                MovePoint(_zp0' pointIndex' distance);                              _state.Rp0 = pointIndex;                              _state.Rp1 = pointIndex;                          }                          break;                      case OpCode.MSIRP0:                      case OpCode.MSIRP1:                          {                              var targetDistance = _stack.PopFloat();                              var pointIndex = _stack.Pop();                                // if we're operating on the twilight zone' initialize the points                              if (_zp1.IsTwilight)                              {                                  _zp1.Original[pointIndex].P = _zp0.Original[_state.Rp0].P + targetDistance * _state.Freedom / _fdotp;                                  _zp1.Current[pointIndex].P = _zp1.Original[pointIndex].P;                              }                                var currentDistance = Project(_zp1.GetCurrent(pointIndex) - _zp0.GetCurrent(_state.Rp0));                              MovePoint(_zp1' pointIndex' targetDistance - currentDistance);                                _state.Rp1 = _state.Rp0;                              _state.Rp2 = pointIndex;                              if (opcode == OpCode.MSIRP1)                                  _state.Rp0 = pointIndex;                          }                          break;                      case OpCode.IP:                          {                              var originalBase = _zp0.GetOriginal(_state.Rp1);                              var currentBase = _zp0.GetCurrent(_state.Rp1);                              var originalRange = DualProject(_zp1.GetOriginal(_state.Rp2) - originalBase);                              var currentRange = Project(_zp1.GetCurrent(_state.Rp2) - currentBase);                                for (int i = 0; i < _state.Loop; i++)                              {                                  var pointIndex = _stack.Pop();                                  var point = _zp2.GetCurrent(pointIndex);                                  var currentDistance = Project(point - currentBase);                                  var originalDistance = DualProject(_zp2.GetOriginal(pointIndex) - originalBase);                                    var newDistance = 0.0f;                                  if (originalDistance != 0.0f)                                  {                                      // a range of 0.0f is invalid according to the spec (would result in a div by zero)                                      if (originalRange == 0.0f)                                          newDistance = originalDistance;                                      else                                          newDistance = originalDistance * currentRange / originalRange;                                  }                                    MovePoint(_zp2' pointIndex' newDistance - currentDistance);                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.ALIGNRP:                          {                              for (int i = 0; i < _state.Loop; i++)                              {                                  var pointIndex = _stack.Pop();                                  var p1 = _zp1.GetCurrent(pointIndex);                                  var p2 = _zp0.GetCurrent(_state.Rp0);                                  MovePoint(_zp1' pointIndex' -Project(p1 - p2));                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.ALIGNPTS:                          {                              var p1 = _stack.Pop();                              var p2 = _stack.Pop();                              var distance = Project(_zp0.GetCurrent(p2) - _zp1.GetCurrent(p1)) / 2;                              MovePoint(_zp1' p1' distance);                              MovePoint(_zp0' p2' -distance);                          }                          break;                      case OpCode.UTP: _zp0.TouchState[_stack.Pop()] &= ~GetTouchState(); break;                      case OpCode.IUP0:                      case OpCode.IUP1:                          // bail if no contours (empty outline)                          if (_contours.Length == 0)                          {                              break;                          }                            //{                            //    //WinterDev's new managed version                          //    GlyphPointF[] currentPnts = points.Current;                          //    GlyphPointF[] originalPnts = points.Original;                            //    int cnt_count = contours.Length;                          //    int point = 0;                          //    // opcode controls whether we care about X or Y direction                          //    // do some pointer trickery so we can operate on the                          //    // points in a direction-agnostic manner                          //    TouchState touchMask;                            //    if (opcode == OpCode.IUP0)                          //    {                          //        //y -axis                          //        touchMask = TouchState.Y;                            //        //                          //        for (int i = 0; i < cnt_count; ++i)                          //        {                          //            int endPoint = contours[i];                          //            int firstPoint = point;                          //            int firstTouched = -1;                          //            int lastTouched = -1;                            //            for (; point <= endPoint; point++)                          //            {                          //                // check whether this point has been touched                          //                if ((points.TouchState[point] & touchMask) != 0)                          //                {                          //                    // if this is the first touched point in the contour' note it and continue                          //                    if (firstTouched < 0)                          //                    {                          //                        firstTouched = point;                          //                        lastTouched = point;                          //                        continue;                          //                    }                            //                    // otherwise' interpolate all untouched points                          //                    // between this point and our last touched point                          //                    InterpolatePointsYAxis(currentPnts' originalPnts' lastTouched + 1' point - 1' lastTouched' point);                          //                    lastTouched = point;                          //                }                          //            }                            //            // check if we had any touched points at all in this contour                          //            if (firstTouched >= 0)                          //            {                          //                // there are two cases left to handle:                          //                // 1. there was only one touched point in the whole contour' in                          //                //    which case we want to shift everything relative to that one                          //                // 2. several touched points' in which case handle the gap from the                          //                //    beginning to the first touched point and the gap from the last                          //                //    touched point to the end of the contour                          //                if (lastTouched == firstTouched)                          //                {                          //                    float delta = currentPnts[lastTouched].Y - originalPnts[lastTouched].Y;                          //                    if (delta != 0.0f)                          //                    {                          //                        for (int n = firstPoint; n < lastTouched; n++)                          //                        {                          //                            currentPnts[n].OffsetY(delta);                          //                        }                          //                        for (int n = lastTouched + 1; n <= endPoint; n++)                          //                        {                          //                            currentPnts[n].OffsetY(delta);                          //                        }                            //                    }                          //                }                          //                else                          //                {                          //                    InterpolatePointsYAxis(currentPnts' originalPnts' lastTouched + 1' endPoint' lastTouched' firstTouched);                          //                    if (firstTouched > 0)                          //                    {                          //                        InterpolatePointsYAxis(currentPnts' originalPnts' firstPoint' firstTouched - 1' lastTouched' firstTouched);                          //                    }                          //                }                          //            }                            //        }                          //    }                          //    else                          //    {                          //        //x-axis                          //        touchMask = TouchState.X;                          //        //                          //        for (int i = 0; i < cnt_count; ++i)                          //        {                          //            int endPoint = contours[i];                          //            int firstPoint = point;                          //            int firstTouched = -1;                          //            int lastTouched = -1;                            //            for (; point <= endPoint; point++)                          //            {                          //                // check whether this point has been touched                          //                if ((points.TouchState[point] & touchMask) != 0)                          //                {                          //                    // if this is the first touched point in the contour' note it and continue                          //                    if (firstTouched < 0)                          //                    {                          //                        firstTouched = point;                          //                        lastTouched = point;                          //                        continue;                          //                    }                            //                    // otherwise' interpolate all untouched points                          //                    // between this point and our last touched point                          //                    InterpolatePointsXAxis(currentPnts' originalPnts' lastTouched + 1' point - 1' lastTouched' point);                          //                    lastTouched = point;                          //                }                          //            }                            //            // check if we had any touched points at all in this contour                          //            if (firstTouched >= 0)                          //            {                          //                // there are two cases left to handle:                          //                // 1. there was only one touched point in the whole contour' in                          //                //    which case we want to shift everything relative to that one                          //                // 2. several touched points' in which case handle the gap from the                          //                //    beginning to the first touched point and the gap from the last                          //                //    touched point to the end of the contour                          //                if (lastTouched == firstTouched)                          //                {                          //                    float delta = currentPnts[lastTouched].X - originalPnts[lastTouched].X;                          //                    if (delta != 0.0f)                          //                    {                          //                        for (int n = firstPoint; n < lastTouched; ++n)                          //                        {                          //                            currentPnts[n].OffsetX(delta);                          //                        }                          //                        for (int n = lastTouched + 1; n <= endPoint; ++n)                          //                        {                          //                            currentPnts[n].OffsetX(delta);                          //                        }                          //                    }                          //                }                          //                else                          //                {                          //                    InterpolatePointsXAxis(currentPnts' originalPnts' lastTouched + 1' endPoint' lastTouched' firstTouched);                          //                    if (firstTouched > 0)                          //                    {                          //                        InterpolatePointsXAxis(currentPnts' originalPnts' firstPoint' firstTouched - 1' lastTouched' firstTouched);                          //                    }                          //                }                          //            }                          //        }                          //    }                          //}                          //-----------------------------------------                          unsafe                          {                                //unsafe version                               //TODO: provide manage version                               fixed (GlyphPointF* currentPtr = _points.Current)                              fixed (GlyphPointF* originalPtr = _points.Original)                              {                                  // opcode controls whether we care about X or Y direction                                  // do some pointer trickery so we can operate on the                                  // points in a direction-agnostic manner                                  TouchState touchMask;                                  byte* current;                                  byte* original;                                  if (opcode == OpCode.IUP0)                                  {                                      touchMask = TouchState.Y;                                      current = (byte*)&currentPtr->P.Y;                                      original = (byte*)&originalPtr->P.Y;                                  }                                  else                                  {                                      touchMask = TouchState.X;                                      current = (byte*)&currentPtr->P.X;                                      original = (byte*)&originalPtr->P.X;                                  }                                    var point = 0;                                  for (int i = 0; i < _contours.Length; i++)                                  {                                      var endPoint = _contours[i];                                      var firstPoint = point;                                      var firstTouched = -1;                                      var lastTouched = -1;                                        for (; point <= endPoint; point++)                                      {                                          // check whether this point has been touched                                          if ((_points.TouchState[point] & touchMask) != 0)                                          {                                              // if this is the first touched point in the contour' note it and continue                                              if (firstTouched < 0)                                              {                                                  firstTouched = point;                                                  lastTouched = point;                                                  continue;                                              }                                                // otherwise' interpolate all untouched points                                              // between this point and our last touched point                                              InterpolatePoints(current' original' lastTouched + 1' point - 1' lastTouched' point);                                              lastTouched = point;                                          }                                      }                                        // check if we had any touched points at all in this contour                                      if (firstTouched >= 0)                                      {                                          // there are two cases left to handle:                                          // 1. there was only one touched point in the whole contour' in                                          //    which case we want to shift everything relative to that one                                          // 2. several touched points' in which case handle the gap from the                                          //    beginning to the first touched point and the gap from the last                                          //    touched point to the end of the contour                                          if (lastTouched == firstTouched)                                          {                                              var delta = *GetPoint(current' lastTouched) - *GetPoint(original' lastTouched);                                              if (delta != 0.0f)                                              {                                                  for (int j = firstPoint; j < lastTouched; j++)                                                      *GetPoint(current' j) += delta;                                                  for (int j = lastTouched + 1; j <= endPoint; j++)                                                      *GetPoint(current' j) += delta;                                              }                                          }                                          else                                          {                                              InterpolatePoints(current' original' lastTouched + 1' endPoint' lastTouched' firstTouched);                                              if (firstTouched > 0)                                                  InterpolatePoints(current' original' firstPoint' firstTouched - 1' lastTouched' firstTouched);                                          }                                      }                                  }                              }                          }                          break;                      case OpCode.ISECT:                          {                              // move point P to the intersection of lines A and B                              var b1 = _zp0.GetCurrent(_stack.Pop());                              var b0 = _zp0.GetCurrent(_stack.Pop());                              var a1 = _zp1.GetCurrent(_stack.Pop());                              var a0 = _zp1.GetCurrent(_stack.Pop());                              var index = _stack.Pop();                                // calculate intersection using determinants: https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line                              var da = a0 - a1;                              var db = b0 - b1;                              var den = (da.X * db.Y) - (da.Y * db.X);                              if (Math.Abs(den) <= Epsilon)                              {                                  // parallel lines; spec says to put the ppoint "into the middle of the two lines"                                  _zp2.Current[index].P = (a0 + a1 + b0 + b1) / 4;                              }                              else                              {                                  var t = (a0.X * a1.Y) - (a0.Y * a1.X);                                  var u = (b0.X * b1.Y) - (b0.Y * b1.X);                                  var p = new Vector2(                                      (t * db.X) - (da.X * u)'                                      (t * db.Y) - (da.Y * u)                                  );                                  _zp2.Current[index].P = p / den;                              }                              _zp2.TouchState[index] = TouchState.Both;                          }                          break;                        // ==== STACK MANAGEMENT ====                      case OpCode.DUP: _stack.Duplicate(); break;                      case OpCode.POP: _stack.Pop(); break;                      case OpCode.CLEAR: _stack.Clear(); break;                      case OpCode.SWAP: _stack.Swap(); break;                      case OpCode.DEPTH: _stack.Depth(); break;                      case OpCode.CINDEX: _stack.Copy(); break;                      case OpCode.MINDEX: _stack.Move(); break;                      case OpCode.ROLL: _stack.Roll(); break;                        // ==== FLOW CONTROL ====                      case OpCode.IF:                          {                              // value is false; jump to the next else block or endif marker                              // otherwise' we don't have to do anything; we'll keep executing this block                              if (!_stack.PopBool())                              {                                  int indent = 1;                                  while (indent > 0)                                  {                                      opcode = SkipNext(ref stream);                                      switch (opcode)                                      {                                          case OpCode.IF: indent++; break;                                          case OpCode.EIF: indent--; break;                                          case OpCode.ELSE:                                              if (indent == 1)                                                  indent = 0;                                              break;                                      }                                  }                              }                          }                          break;                      case OpCode.ELSE:                          {                              // assume we hit the true statement of some previous if block                              // if we had hit false' we would have jumped over this                              int indent = 1;                              while (indent > 0)                              {                                  opcode = SkipNext(ref stream);                                  switch (opcode)                                  {                                      case OpCode.IF: indent++; break;                                      case OpCode.EIF: indent--; break;                                  }                              }                          }                          break;                      case OpCode.EIF: /* nothing to do */ break;                      case OpCode.JROT:                      case OpCode.JROF:                          {                              if (_stack.PopBool() == (opcode == OpCode.JROT))                                  stream.Jump(_stack.Pop() - 1);                              else                                  _stack.Pop();    // ignore the offset                          }                          break;                      case OpCode.JMPR: stream.Jump(_stack.Pop() - 1); break;                        // ==== LOGICAL OPS ====                      case OpCode.LT:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a < b);                          }                          break;                      case OpCode.LTEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a <= b);                          }                          break;                      case OpCode.GT:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a > b);                          }                          break;                      case OpCode.GTEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a >= b);                          }                          break;                      case OpCode.EQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a == b);                          }                          break;                      case OpCode.NEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a != b);                          }                          break;                      case OpCode.AND:                          {                              var b = _stack.PopBool();                              var a = _stack.PopBool();                              _stack.Push(a && b);                          }                          break;                      case OpCode.OR:                          {                              var b = _stack.PopBool();                              var a = _stack.PopBool();                              _stack.Push(a || b);                          }                          break;                      case OpCode.NOT: _stack.Push(!_stack.PopBool()); break;                      case OpCode.ODD:                          {                              var value = (int)Round(_stack.PopFloat());                              _stack.Push(value % 2 != 0);                          }                          break;                      case OpCode.EVEN:                          {                              var value = (int)Round(_stack.PopFloat());                              _stack.Push(value % 2 == 0);                          }                          break;                        // ==== ARITHMETIC ====                      case OpCode.ADD:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a + b);                          }                          break;                      case OpCode.SUB:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a - b);                          }                          break;                      case OpCode.DIV:                          {                              var b = _stack.Pop();                              if (b == 0)                                  throw new InvalidFontException("Division by zero.");                                var a = _stack.Pop();                              var result = ((long)a << 6) / b;                              _stack.Push((int)result);                          }                          break;                      case OpCode.MUL:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              var result = ((long)a * b) >> 6;                              _stack.Push((int)result);                          }                          break;                      case OpCode.ABS: _stack.Push(Math.Abs(_stack.Pop())); break;                      case OpCode.NEG: _stack.Push(-_stack.Pop()); break;                      case OpCode.FLOOR: _stack.Push(_stack.Pop() & ~63); break;                      case OpCode.CEILING: _stack.Push((_stack.Pop() + 63) & ~63); break;                      case OpCode.MAX: _stack.Push(Math.Max(_stack.Pop()' _stack.Pop())); break;                      case OpCode.MIN: _stack.Push(Math.Min(_stack.Pop()' _stack.Pop())); break;                        // ==== FUNCTIONS ====                      case OpCode.FDEF:                          {                              if (!allowFunctionDefs || inFunction)                                  throw new InvalidFontException("Can't define functions here.");                                _functions[_stack.Pop()] = stream;                              while (SkipNext(ref stream) != OpCode.ENDF) ;                          }                          break;                      case OpCode.IDEF:                          {                              if (!allowFunctionDefs || inFunction)                                  throw new InvalidFontException("Can't define functions here.");                                _instructionDefs[_stack.Pop()] = stream;                              while (SkipNext(ref stream) != OpCode.ENDF) ;                          }                          break;                      case OpCode.ENDF:                          {                              if (!inFunction)                                  throw new InvalidFontException("Found invalid ENDF marker outside of a function definition.");                              return;                          }                      case OpCode.CALL:                      case OpCode.LOOPCALL:                          {                              _callStackSize++;                              if (_callStackSize > MaxCallStack)                                  throw new InvalidFontException("Stack overflow; infinite recursion?");                                var function = _functions[_stack.Pop()];                              var count = opcode == OpCode.LOOPCALL ? _stack.Pop() : 1;                              for (int i = 0; i < count; i++)                                  Execute(function' true' false);                              _callStackSize--;                          }                          break;                        // ==== ROUNDING ====                      // we don't have "engine compensation" so the variants are unnecessary                      case OpCode.ROUND0:                      case OpCode.ROUND1:                      case OpCode.ROUND2:                      case OpCode.ROUND3: _stack.Push(Round(_stack.PopFloat())); break;                      case OpCode.NROUND0:                      case OpCode.NROUND1:                      case OpCode.NROUND2:                      case OpCode.NROUND3: break;                        // ==== DELTA EXCEPTIONS ====                      case OpCode.DELTAC1:                      case OpCode.DELTAC2:                      case OpCode.DELTAC3:                          {                              var last = _stack.Pop();                              for (int i = 1; i <= last; i++)                              {                                  var cvtIndex = _stack.Pop();                                  var arg = _stack.Pop();                                    // upper 4 bits of the 8-bit arg is the relative ppem                                  // the opcode specifies the base to add to the ppem                                  var triggerPpem = (arg >> 4) & 0xF;                                  triggerPpem += (opcode - OpCode.DELTAC1) * 16;                                  triggerPpem += _state.DeltaBase;                                    // if the current ppem matches the trigger' apply the exception                                  if (_ppem == triggerPpem)                                  {                                      // the lower 4 bits of the arg is the amount to shift                                      // it's encoded such that 0 isn't an allowable value (who wants to shift by 0 anyway?)                                      var amount = (arg & 0xF) - 8;                                      if (amount >= 0)                                          amount++;                                      amount *= 1 << (6 - _state.DeltaShift);                                        // update the CVT                                      CheckIndex(cvtIndex' _controlValueTable.Length);                                      _controlValueTable[cvtIndex] += F26Dot6ToFloat(amount);                                  }                              }                          }                          break;                      case OpCode.DELTAP1:                      case OpCode.DELTAP2:                      case OpCode.DELTAP3:                          {                              var last = _stack.Pop();                              for (int i = 1; i <= last; i++)                              {                                  var pointIndex = _stack.Pop();                                  var arg = _stack.Pop();                                    // upper 4 bits of the 8-bit arg is the relative ppem                                  // the opcode specifies the base to add to the ppem                                  var triggerPpem = (arg >> 4) & 0xF;                                  triggerPpem += _state.DeltaBase;                                  if (opcode != OpCode.DELTAP1)                                      triggerPpem += (opcode - OpCode.DELTAP2 + 1) * 16;                                    // if the current ppem matches the trigger' apply the exception                                  if (_ppem == triggerPpem)                                  {                                      // the lower 4 bits of the arg is the amount to shift                                      // it's encoded such that 0 isn't an allowable value (who wants to shift by 0 anyway?)                                      var amount = (arg & 0xF) - 8;                                      if (amount >= 0)                                          amount++;                                      amount *= 1 << (6 - _state.DeltaShift);                                        MovePoint(_zp0' pointIndex' F26Dot6ToFloat(amount));                                  }                              }                          }                          break;                        // ==== MISCELLANEOUS ====                      case OpCode.DEBUG: _stack.Pop(); break;                      case OpCode.GETINFO:                          {                              var selector = _stack.Pop();                              var result = 0;                              if ((selector & 0x1) != 0)                              {                                  // pretend we are MS Rasterizer v35                                  result = 35;                              }                                // TODO: rotation and stretching                              //if ((selector & 0x2) != 0)                              //if ((selector & 0x4) != 0)                                // we're always rendering in grayscale                              if ((selector & 0x20) != 0)                                  result |= 1 << 12;                                // TODO: ClearType flags                                _stack.Push(result);                          }                          break;                        default:                          if (opcode >= OpCode.MIRP)                              MoveIndirectRelative(opcode - OpCode.MIRP);                          else if (opcode >= OpCode.MDRP)                              MoveDirectRelative(opcode - OpCode.MDRP);                          else                          {                              // check if this is a runtime-defined opcode                              var index = (int)opcode;                              if (index > _instructionDefs.Length || !_instructionDefs[index].IsValid)                                  throw new InvalidFontException("Unknown opcode in font program.");                                _callStackSize++;                              if (_callStackSize > MaxCallStack)                                  throw new InvalidFontException("Stack overflow; infinite recursion?");                                Execute(_instructionDefs[index]' true' false);                              _callStackSize--;                          }                          break;                  }
Magic Number,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,Execute,The following statement contains a magic number: switch (opcode)                  {                      // ==== PUSH INSTRUCTIONS ====                      case OpCode.NPUSHB:                      case OpCode.PUSHB1:                      case OpCode.PUSHB2:                      case OpCode.PUSHB3:                      case OpCode.PUSHB4:                      case OpCode.PUSHB5:                      case OpCode.PUSHB6:                      case OpCode.PUSHB7:                      case OpCode.PUSHB8:                          {                              var count = opcode == OpCode.NPUSHB ? stream.NextByte() : opcode - OpCode.PUSHB1 + 1;                              for (int i = count - 1; i >= 0; --i)                                  _stack.Push(stream.NextByte());                          }                          break;                      case OpCode.NPUSHW:                      case OpCode.PUSHW1:                      case OpCode.PUSHW2:                      case OpCode.PUSHW3:                      case OpCode.PUSHW4:                      case OpCode.PUSHW5:                      case OpCode.PUSHW6:                      case OpCode.PUSHW7:                      case OpCode.PUSHW8:                          {                              var count = opcode == OpCode.NPUSHW ? stream.NextByte() : opcode - OpCode.PUSHW1 + 1;                              for (int i = count - 1; i >= 0; --i)                                  _stack.Push(stream.NextWord());                          }                          break;                        // ==== STORAGE MANAGEMENT ====                      case OpCode.RS:                          {                              var loc = CheckIndex(_stack.Pop()' _storage.Length);                              _stack.Push(_storage[loc]);                          }                          break;                      case OpCode.WS:                          {                              var value = _stack.Pop();                              var loc = CheckIndex(_stack.Pop()' _storage.Length);                              _storage[loc] = value;                          }                          break;                        // ==== CONTROL VALUE TABLE ====                      case OpCode.WCVTP:                          {                              var value = _stack.PopFloat();                              var loc = CheckIndex(_stack.Pop()' _controlValueTable.Length);                              _controlValueTable[loc] = value;                          }                          break;                      case OpCode.WCVTF:                          {                              var value = _stack.Pop();                              var loc = CheckIndex(_stack.Pop()' _controlValueTable.Length);                              _controlValueTable[loc] = value * _scale;                          }                          break;                      case OpCode.RCVT: _stack.Push(ReadCvt()); break;                        // ==== STATE VECTORS ====                      case OpCode.SVTCA0:                      case OpCode.SVTCA1:                          {                              var axis = opcode - OpCode.SVTCA0;                              SetFreedomVectorToAxis(axis);                              SetProjectionVectorToAxis(axis);                          }                          break;                      case OpCode.SFVTPV: _state.Freedom = _state.Projection; OnVectorsUpdated(); break;                      case OpCode.SPVTCA0:                      case OpCode.SPVTCA1: SetProjectionVectorToAxis(opcode - OpCode.SPVTCA0); break;                      case OpCode.SFVTCA0:                      case OpCode.SFVTCA1: SetFreedomVectorToAxis(opcode - OpCode.SFVTCA0); break;                      case OpCode.SPVTL0:                      case OpCode.SPVTL1:                      case OpCode.SFVTL0:                      case OpCode.SFVTL1: SetVectorToLine(opcode - OpCode.SPVTL0' false); break;                      case OpCode.SDPVTL0:                      case OpCode.SDPVTL1: SetVectorToLine(opcode - OpCode.SDPVTL0' true); break;                      case OpCode.SPVFS:                      case OpCode.SFVFS:                          {                              var y = _stack.Pop();                              var x = _stack.Pop();                              var vec = Vector2.Normalize(new Vector2(F2Dot14ToFloat(x)' F2Dot14ToFloat(y)));                              if (opcode == OpCode.SFVFS)                                  _state.Freedom = vec;                              else                              {                                  _state.Projection = vec;                                  _state.DualProjection = vec;                              }                              OnVectorsUpdated();                          }                          break;                      case OpCode.GPV:                      case OpCode.GFV:                          {                              var vec = opcode == OpCode.GPV ? _state.Projection : _state.Freedom;                              _stack.Push(FloatToF2Dot14(vec.X));                              _stack.Push(FloatToF2Dot14(vec.Y));                          }                          break;                        // ==== GRAPHICS STATE ====                      case OpCode.SRP0: _state.Rp0 = _stack.Pop(); break;                      case OpCode.SRP1: _state.Rp1 = _stack.Pop(); break;                      case OpCode.SRP2: _state.Rp2 = _stack.Pop(); break;                      case OpCode.SZP0: _zp0 = GetZoneFromStack(); break;                      case OpCode.SZP1: _zp1 = GetZoneFromStack(); break;                      case OpCode.SZP2: _zp2 = GetZoneFromStack(); break;                      case OpCode.SZPS: _zp0 = _zp1 = _zp2 = GetZoneFromStack(); break;                      case OpCode.RTHG: _state.RoundState = RoundMode.ToHalfGrid; break;                      case OpCode.RTG: _state.RoundState = RoundMode.ToGrid; break;                      case OpCode.RTDG: _state.RoundState = RoundMode.ToDoubleGrid; break;                      case OpCode.RDTG: _state.RoundState = RoundMode.DownToGrid; break;                      case OpCode.RUTG: _state.RoundState = RoundMode.UpToGrid; break;                      case OpCode.ROFF: _state.RoundState = RoundMode.Off; break;                      case OpCode.SROUND: _state.RoundState = RoundMode.Super; SetSuperRound(1.0f); break;                      case OpCode.S45ROUND: _state.RoundState = RoundMode.Super45; SetSuperRound(Sqrt2Over2); break;                      case OpCode.INSTCTRL:                          {                              var selector = _stack.Pop();                              if (selector >= 1 && selector <= 2)                              {                                  // value is false if zero' otherwise shift the right bit into the flags                                  var bit = 1 << (selector - 1);                                  if (_stack.Pop() == 0)                                      _state.InstructionControl = (InstructionControlFlags)((int)_state.InstructionControl & ~bit);                                  else                                      _state.InstructionControl = (InstructionControlFlags)((int)_state.InstructionControl | bit);                              }                          }                          break;                      case OpCode.SCANCTRL: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SCANTYPE: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SANGW: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SLOOP: _state.Loop = _stack.Pop(); break;                      case OpCode.SMD: _state.MinDistance = _stack.PopFloat(); break;                      case OpCode.SCVTCI: _state.ControlValueCutIn = _stack.PopFloat(); break;                      case OpCode.SSWCI: _state.SingleWidthCutIn = _stack.PopFloat(); break;                      case OpCode.SSW: _state.SingleWidthValue = _stack.Pop() * _scale; break;                      case OpCode.FLIPON: _state.AutoFlip = true; break;                      case OpCode.FLIPOFF: _state.AutoFlip = false; break;                      case OpCode.SDB: _state.DeltaBase = _stack.Pop(); break;                      case OpCode.SDS: _state.DeltaShift = _stack.Pop(); break;                        // ==== POINT MEASUREMENT ====                      case OpCode.GC0: _stack.Push(Project(_zp2.GetCurrent(_stack.Pop()))); break;                      case OpCode.GC1: _stack.Push(DualProject(_zp2.GetOriginal(_stack.Pop()))); break;                      case OpCode.SCFS:                          {                              var value = _stack.PopFloat();                              var index = _stack.Pop();                              var point = _zp2.GetCurrent(index);                              MovePoint(_zp2' index' value - Project(point));                                // moving twilight points moves their "original" value also                              if (_zp2.IsTwilight)                                  _zp2.Original[index].P = _zp2.Current[index].P;                          }                          break;                      case OpCode.MD0:                          {                              var p1 = _zp1.GetOriginal(_stack.Pop());                              var p2 = _zp0.GetOriginal(_stack.Pop());                              _stack.Push(DualProject(p2 - p1));                          }                          break;                      case OpCode.MD1:                          {                              var p1 = _zp1.GetCurrent(_stack.Pop());                              var p2 = _zp0.GetCurrent(_stack.Pop());                              _stack.Push(Project(p2 - p1));                          }                          break;                      case OpCode.MPS: // MPS should return point size' but we assume DPI so it's the same as pixel size                      case OpCode.MPPEM: _stack.Push(_ppem); break;                      case OpCode.AA: /* deprecated instruction */ _stack.Pop(); break;                        // ==== POINT MODIFICATION ====                      case OpCode.FLIPPT:                          {                              for (int i = 0; i < _state.Loop; i++)                              {                                  var index = _stack.Pop();                                  //review here again!                                  _points.Current[index].onCurve = !_points.Current[index].onCurve;                                  //if (points.Current[index].onCurve)                                  //    points.Current[index].onCurve = false;                                  //else                                  //    points.Current[index].onCurve = true;                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.FLIPRGON:                          {                              var end = _stack.Pop();                              for (int i = _stack.Pop(); i <= end; i++)                                  //points.Current[i].Type = PointType.OnCurve;                                  _points.Current[i].onCurve = true;                          }                          break;                      case OpCode.FLIPRGOFF:                          {                              var end = _stack.Pop();                              for (int i = _stack.Pop(); i <= end; i++)                                  //points.Current[i].Type = PointType.Quadratic;                                  _points.Current[i].onCurve = false;                          }                          break;                      case OpCode.SHP0:                      case OpCode.SHP1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              ShiftPoints(displacement);                          }                          break;                      case OpCode.SHPIX: ShiftPoints(_stack.PopFloat() * _state.Freedom); break;                      case OpCode.SHC0:                      case OpCode.SHC1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              var touch = GetTouchState();                              var contour = _stack.Pop();                              var start = contour == 0 ? 0 : _contours[contour - 1] + 1;                              var count = _zp2.IsTwilight ? _zp2.Current.Length : _contours[contour] + 1;                                for (int i = start; i < count; i++)                              {                                  // don't move the reference point                                  if (zone.Current != _zp2.Current || point != i)                                  {                                      _zp2.Current[i].P += displacement;                                      _zp2.TouchState[i] |= touch;                                  }                              }                          }                          break;                      case OpCode.SHZ0:                      case OpCode.SHZ1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              var count = 0;                              if (_zp2.IsTwilight)                                  count = _zp2.Current.Length;                              else if (_contours.Length > 0)                                  count = _contours[_contours.Length - 1] + 1;                                for (int i = 0; i < count; i++)                              {                                  // don't move the reference point                                  if (zone.Current != _zp2.Current || point != i)                                      _zp2.Current[i].P += displacement;                              }                          }                          break;                      case OpCode.MIAP0:                      case OpCode.MIAP1:                          {                              var distance = ReadCvt();                              var pointIndex = _stack.Pop();                                // this instruction is used in the CVT to set up twilight points with original values                              if (_zp0.IsTwilight)                              {                                  var original = _state.Freedom * distance;                                  _zp0.Original[pointIndex].P = original;                                  _zp0.Current[pointIndex].P = original;                              }                                // current position of the point along the projection vector                              var point = _zp0.GetCurrent(pointIndex);                              var currentPos = Project(point);                              if (opcode == OpCode.MIAP1)                              {                                  // only use the CVT if we are above the cut-in point                                  if (Math.Abs(distance - currentPos) > _state.ControlValueCutIn)                                      distance = currentPos;                                  distance = Round(distance);                              }                                MovePoint(_zp0' pointIndex' distance - currentPos);                              _state.Rp0 = pointIndex;                              _state.Rp1 = pointIndex;                          }                          break;                      case OpCode.MDAP0:                      case OpCode.MDAP1:                          {                              var pointIndex = _stack.Pop();                              var point = _zp0.GetCurrent(pointIndex);                              var distance = 0.0f;                              if (opcode == OpCode.MDAP1)                              {                                  distance = Project(point);                                  distance = Round(distance) - distance;                              }                                MovePoint(_zp0' pointIndex' distance);                              _state.Rp0 = pointIndex;                              _state.Rp1 = pointIndex;                          }                          break;                      case OpCode.MSIRP0:                      case OpCode.MSIRP1:                          {                              var targetDistance = _stack.PopFloat();                              var pointIndex = _stack.Pop();                                // if we're operating on the twilight zone' initialize the points                              if (_zp1.IsTwilight)                              {                                  _zp1.Original[pointIndex].P = _zp0.Original[_state.Rp0].P + targetDistance * _state.Freedom / _fdotp;                                  _zp1.Current[pointIndex].P = _zp1.Original[pointIndex].P;                              }                                var currentDistance = Project(_zp1.GetCurrent(pointIndex) - _zp0.GetCurrent(_state.Rp0));                              MovePoint(_zp1' pointIndex' targetDistance - currentDistance);                                _state.Rp1 = _state.Rp0;                              _state.Rp2 = pointIndex;                              if (opcode == OpCode.MSIRP1)                                  _state.Rp0 = pointIndex;                          }                          break;                      case OpCode.IP:                          {                              var originalBase = _zp0.GetOriginal(_state.Rp1);                              var currentBase = _zp0.GetCurrent(_state.Rp1);                              var originalRange = DualProject(_zp1.GetOriginal(_state.Rp2) - originalBase);                              var currentRange = Project(_zp1.GetCurrent(_state.Rp2) - currentBase);                                for (int i = 0; i < _state.Loop; i++)                              {                                  var pointIndex = _stack.Pop();                                  var point = _zp2.GetCurrent(pointIndex);                                  var currentDistance = Project(point - currentBase);                                  var originalDistance = DualProject(_zp2.GetOriginal(pointIndex) - originalBase);                                    var newDistance = 0.0f;                                  if (originalDistance != 0.0f)                                  {                                      // a range of 0.0f is invalid according to the spec (would result in a div by zero)                                      if (originalRange == 0.0f)                                          newDistance = originalDistance;                                      else                                          newDistance = originalDistance * currentRange / originalRange;                                  }                                    MovePoint(_zp2' pointIndex' newDistance - currentDistance);                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.ALIGNRP:                          {                              for (int i = 0; i < _state.Loop; i++)                              {                                  var pointIndex = _stack.Pop();                                  var p1 = _zp1.GetCurrent(pointIndex);                                  var p2 = _zp0.GetCurrent(_state.Rp0);                                  MovePoint(_zp1' pointIndex' -Project(p1 - p2));                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.ALIGNPTS:                          {                              var p1 = _stack.Pop();                              var p2 = _stack.Pop();                              var distance = Project(_zp0.GetCurrent(p2) - _zp1.GetCurrent(p1)) / 2;                              MovePoint(_zp1' p1' distance);                              MovePoint(_zp0' p2' -distance);                          }                          break;                      case OpCode.UTP: _zp0.TouchState[_stack.Pop()] &= ~GetTouchState(); break;                      case OpCode.IUP0:                      case OpCode.IUP1:                          // bail if no contours (empty outline)                          if (_contours.Length == 0)                          {                              break;                          }                            //{                            //    //WinterDev's new managed version                          //    GlyphPointF[] currentPnts = points.Current;                          //    GlyphPointF[] originalPnts = points.Original;                            //    int cnt_count = contours.Length;                          //    int point = 0;                          //    // opcode controls whether we care about X or Y direction                          //    // do some pointer trickery so we can operate on the                          //    // points in a direction-agnostic manner                          //    TouchState touchMask;                            //    if (opcode == OpCode.IUP0)                          //    {                          //        //y -axis                          //        touchMask = TouchState.Y;                            //        //                          //        for (int i = 0; i < cnt_count; ++i)                          //        {                          //            int endPoint = contours[i];                          //            int firstPoint = point;                          //            int firstTouched = -1;                          //            int lastTouched = -1;                            //            for (; point <= endPoint; point++)                          //            {                          //                // check whether this point has been touched                          //                if ((points.TouchState[point] & touchMask) != 0)                          //                {                          //                    // if this is the first touched point in the contour' note it and continue                          //                    if (firstTouched < 0)                          //                    {                          //                        firstTouched = point;                          //                        lastTouched = point;                          //                        continue;                          //                    }                            //                    // otherwise' interpolate all untouched points                          //                    // between this point and our last touched point                          //                    InterpolatePointsYAxis(currentPnts' originalPnts' lastTouched + 1' point - 1' lastTouched' point);                          //                    lastTouched = point;                          //                }                          //            }                            //            // check if we had any touched points at all in this contour                          //            if (firstTouched >= 0)                          //            {                          //                // there are two cases left to handle:                          //                // 1. there was only one touched point in the whole contour' in                          //                //    which case we want to shift everything relative to that one                          //                // 2. several touched points' in which case handle the gap from the                          //                //    beginning to the first touched point and the gap from the last                          //                //    touched point to the end of the contour                          //                if (lastTouched == firstTouched)                          //                {                          //                    float delta = currentPnts[lastTouched].Y - originalPnts[lastTouched].Y;                          //                    if (delta != 0.0f)                          //                    {                          //                        for (int n = firstPoint; n < lastTouched; n++)                          //                        {                          //                            currentPnts[n].OffsetY(delta);                          //                        }                          //                        for (int n = lastTouched + 1; n <= endPoint; n++)                          //                        {                          //                            currentPnts[n].OffsetY(delta);                          //                        }                            //                    }                          //                }                          //                else                          //                {                          //                    InterpolatePointsYAxis(currentPnts' originalPnts' lastTouched + 1' endPoint' lastTouched' firstTouched);                          //                    if (firstTouched > 0)                          //                    {                          //                        InterpolatePointsYAxis(currentPnts' originalPnts' firstPoint' firstTouched - 1' lastTouched' firstTouched);                          //                    }                          //                }                          //            }                            //        }                          //    }                          //    else                          //    {                          //        //x-axis                          //        touchMask = TouchState.X;                          //        //                          //        for (int i = 0; i < cnt_count; ++i)                          //        {                          //            int endPoint = contours[i];                          //            int firstPoint = point;                          //            int firstTouched = -1;                          //            int lastTouched = -1;                            //            for (; point <= endPoint; point++)                          //            {                          //                // check whether this point has been touched                          //                if ((points.TouchState[point] & touchMask) != 0)                          //                {                          //                    // if this is the first touched point in the contour' note it and continue                          //                    if (firstTouched < 0)                          //                    {                          //                        firstTouched = point;                          //                        lastTouched = point;                          //                        continue;                          //                    }                            //                    // otherwise' interpolate all untouched points                          //                    // between this point and our last touched point                          //                    InterpolatePointsXAxis(currentPnts' originalPnts' lastTouched + 1' point - 1' lastTouched' point);                          //                    lastTouched = point;                          //                }                          //            }                            //            // check if we had any touched points at all in this contour                          //            if (firstTouched >= 0)                          //            {                          //                // there are two cases left to handle:                          //                // 1. there was only one touched point in the whole contour' in                          //                //    which case we want to shift everything relative to that one                          //                // 2. several touched points' in which case handle the gap from the                          //                //    beginning to the first touched point and the gap from the last                          //                //    touched point to the end of the contour                          //                if (lastTouched == firstTouched)                          //                {                          //                    float delta = currentPnts[lastTouched].X - originalPnts[lastTouched].X;                          //                    if (delta != 0.0f)                          //                    {                          //                        for (int n = firstPoint; n < lastTouched; ++n)                          //                        {                          //                            currentPnts[n].OffsetX(delta);                          //                        }                          //                        for (int n = lastTouched + 1; n <= endPoint; ++n)                          //                        {                          //                            currentPnts[n].OffsetX(delta);                          //                        }                          //                    }                          //                }                          //                else                          //                {                          //                    InterpolatePointsXAxis(currentPnts' originalPnts' lastTouched + 1' endPoint' lastTouched' firstTouched);                          //                    if (firstTouched > 0)                          //                    {                          //                        InterpolatePointsXAxis(currentPnts' originalPnts' firstPoint' firstTouched - 1' lastTouched' firstTouched);                          //                    }                          //                }                          //            }                          //        }                          //    }                          //}                          //-----------------------------------------                          unsafe                          {                                //unsafe version                               //TODO: provide manage version                               fixed (GlyphPointF* currentPtr = _points.Current)                              fixed (GlyphPointF* originalPtr = _points.Original)                              {                                  // opcode controls whether we care about X or Y direction                                  // do some pointer trickery so we can operate on the                                  // points in a direction-agnostic manner                                  TouchState touchMask;                                  byte* current;                                  byte* original;                                  if (opcode == OpCode.IUP0)                                  {                                      touchMask = TouchState.Y;                                      current = (byte*)&currentPtr->P.Y;                                      original = (byte*)&originalPtr->P.Y;                                  }                                  else                                  {                                      touchMask = TouchState.X;                                      current = (byte*)&currentPtr->P.X;                                      original = (byte*)&originalPtr->P.X;                                  }                                    var point = 0;                                  for (int i = 0; i < _contours.Length; i++)                                  {                                      var endPoint = _contours[i];                                      var firstPoint = point;                                      var firstTouched = -1;                                      var lastTouched = -1;                                        for (; point <= endPoint; point++)                                      {                                          // check whether this point has been touched                                          if ((_points.TouchState[point] & touchMask) != 0)                                          {                                              // if this is the first touched point in the contour' note it and continue                                              if (firstTouched < 0)                                              {                                                  firstTouched = point;                                                  lastTouched = point;                                                  continue;                                              }                                                // otherwise' interpolate all untouched points                                              // between this point and our last touched point                                              InterpolatePoints(current' original' lastTouched + 1' point - 1' lastTouched' point);                                              lastTouched = point;                                          }                                      }                                        // check if we had any touched points at all in this contour                                      if (firstTouched >= 0)                                      {                                          // there are two cases left to handle:                                          // 1. there was only one touched point in the whole contour' in                                          //    which case we want to shift everything relative to that one                                          // 2. several touched points' in which case handle the gap from the                                          //    beginning to the first touched point and the gap from the last                                          //    touched point to the end of the contour                                          if (lastTouched == firstTouched)                                          {                                              var delta = *GetPoint(current' lastTouched) - *GetPoint(original' lastTouched);                                              if (delta != 0.0f)                                              {                                                  for (int j = firstPoint; j < lastTouched; j++)                                                      *GetPoint(current' j) += delta;                                                  for (int j = lastTouched + 1; j <= endPoint; j++)                                                      *GetPoint(current' j) += delta;                                              }                                          }                                          else                                          {                                              InterpolatePoints(current' original' lastTouched + 1' endPoint' lastTouched' firstTouched);                                              if (firstTouched > 0)                                                  InterpolatePoints(current' original' firstPoint' firstTouched - 1' lastTouched' firstTouched);                                          }                                      }                                  }                              }                          }                          break;                      case OpCode.ISECT:                          {                              // move point P to the intersection of lines A and B                              var b1 = _zp0.GetCurrent(_stack.Pop());                              var b0 = _zp0.GetCurrent(_stack.Pop());                              var a1 = _zp1.GetCurrent(_stack.Pop());                              var a0 = _zp1.GetCurrent(_stack.Pop());                              var index = _stack.Pop();                                // calculate intersection using determinants: https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line                              var da = a0 - a1;                              var db = b0 - b1;                              var den = (da.X * db.Y) - (da.Y * db.X);                              if (Math.Abs(den) <= Epsilon)                              {                                  // parallel lines; spec says to put the ppoint "into the middle of the two lines"                                  _zp2.Current[index].P = (a0 + a1 + b0 + b1) / 4;                              }                              else                              {                                  var t = (a0.X * a1.Y) - (a0.Y * a1.X);                                  var u = (b0.X * b1.Y) - (b0.Y * b1.X);                                  var p = new Vector2(                                      (t * db.X) - (da.X * u)'                                      (t * db.Y) - (da.Y * u)                                  );                                  _zp2.Current[index].P = p / den;                              }                              _zp2.TouchState[index] = TouchState.Both;                          }                          break;                        // ==== STACK MANAGEMENT ====                      case OpCode.DUP: _stack.Duplicate(); break;                      case OpCode.POP: _stack.Pop(); break;                      case OpCode.CLEAR: _stack.Clear(); break;                      case OpCode.SWAP: _stack.Swap(); break;                      case OpCode.DEPTH: _stack.Depth(); break;                      case OpCode.CINDEX: _stack.Copy(); break;                      case OpCode.MINDEX: _stack.Move(); break;                      case OpCode.ROLL: _stack.Roll(); break;                        // ==== FLOW CONTROL ====                      case OpCode.IF:                          {                              // value is false; jump to the next else block or endif marker                              // otherwise' we don't have to do anything; we'll keep executing this block                              if (!_stack.PopBool())                              {                                  int indent = 1;                                  while (indent > 0)                                  {                                      opcode = SkipNext(ref stream);                                      switch (opcode)                                      {                                          case OpCode.IF: indent++; break;                                          case OpCode.EIF: indent--; break;                                          case OpCode.ELSE:                                              if (indent == 1)                                                  indent = 0;                                              break;                                      }                                  }                              }                          }                          break;                      case OpCode.ELSE:                          {                              // assume we hit the true statement of some previous if block                              // if we had hit false' we would have jumped over this                              int indent = 1;                              while (indent > 0)                              {                                  opcode = SkipNext(ref stream);                                  switch (opcode)                                  {                                      case OpCode.IF: indent++; break;                                      case OpCode.EIF: indent--; break;                                  }                              }                          }                          break;                      case OpCode.EIF: /* nothing to do */ break;                      case OpCode.JROT:                      case OpCode.JROF:                          {                              if (_stack.PopBool() == (opcode == OpCode.JROT))                                  stream.Jump(_stack.Pop() - 1);                              else                                  _stack.Pop();    // ignore the offset                          }                          break;                      case OpCode.JMPR: stream.Jump(_stack.Pop() - 1); break;                        // ==== LOGICAL OPS ====                      case OpCode.LT:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a < b);                          }                          break;                      case OpCode.LTEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a <= b);                          }                          break;                      case OpCode.GT:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a > b);                          }                          break;                      case OpCode.GTEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a >= b);                          }                          break;                      case OpCode.EQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a == b);                          }                          break;                      case OpCode.NEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a != b);                          }                          break;                      case OpCode.AND:                          {                              var b = _stack.PopBool();                              var a = _stack.PopBool();                              _stack.Push(a && b);                          }                          break;                      case OpCode.OR:                          {                              var b = _stack.PopBool();                              var a = _stack.PopBool();                              _stack.Push(a || b);                          }                          break;                      case OpCode.NOT: _stack.Push(!_stack.PopBool()); break;                      case OpCode.ODD:                          {                              var value = (int)Round(_stack.PopFloat());                              _stack.Push(value % 2 != 0);                          }                          break;                      case OpCode.EVEN:                          {                              var value = (int)Round(_stack.PopFloat());                              _stack.Push(value % 2 == 0);                          }                          break;                        // ==== ARITHMETIC ====                      case OpCode.ADD:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a + b);                          }                          break;                      case OpCode.SUB:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a - b);                          }                          break;                      case OpCode.DIV:                          {                              var b = _stack.Pop();                              if (b == 0)                                  throw new InvalidFontException("Division by zero.");                                var a = _stack.Pop();                              var result = ((long)a << 6) / b;                              _stack.Push((int)result);                          }                          break;                      case OpCode.MUL:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              var result = ((long)a * b) >> 6;                              _stack.Push((int)result);                          }                          break;                      case OpCode.ABS: _stack.Push(Math.Abs(_stack.Pop())); break;                      case OpCode.NEG: _stack.Push(-_stack.Pop()); break;                      case OpCode.FLOOR: _stack.Push(_stack.Pop() & ~63); break;                      case OpCode.CEILING: _stack.Push((_stack.Pop() + 63) & ~63); break;                      case OpCode.MAX: _stack.Push(Math.Max(_stack.Pop()' _stack.Pop())); break;                      case OpCode.MIN: _stack.Push(Math.Min(_stack.Pop()' _stack.Pop())); break;                        // ==== FUNCTIONS ====                      case OpCode.FDEF:                          {                              if (!allowFunctionDefs || inFunction)                                  throw new InvalidFontException("Can't define functions here.");                                _functions[_stack.Pop()] = stream;                              while (SkipNext(ref stream) != OpCode.ENDF) ;                          }                          break;                      case OpCode.IDEF:                          {                              if (!allowFunctionDefs || inFunction)                                  throw new InvalidFontException("Can't define functions here.");                                _instructionDefs[_stack.Pop()] = stream;                              while (SkipNext(ref stream) != OpCode.ENDF) ;                          }                          break;                      case OpCode.ENDF:                          {                              if (!inFunction)                                  throw new InvalidFontException("Found invalid ENDF marker outside of a function definition.");                              return;                          }                      case OpCode.CALL:                      case OpCode.LOOPCALL:                          {                              _callStackSize++;                              if (_callStackSize > MaxCallStack)                                  throw new InvalidFontException("Stack overflow; infinite recursion?");                                var function = _functions[_stack.Pop()];                              var count = opcode == OpCode.LOOPCALL ? _stack.Pop() : 1;                              for (int i = 0; i < count; i++)                                  Execute(function' true' false);                              _callStackSize--;                          }                          break;                        // ==== ROUNDING ====                      // we don't have "engine compensation" so the variants are unnecessary                      case OpCode.ROUND0:                      case OpCode.ROUND1:                      case OpCode.ROUND2:                      case OpCode.ROUND3: _stack.Push(Round(_stack.PopFloat())); break;                      case OpCode.NROUND0:                      case OpCode.NROUND1:                      case OpCode.NROUND2:                      case OpCode.NROUND3: break;                        // ==== DELTA EXCEPTIONS ====                      case OpCode.DELTAC1:                      case OpCode.DELTAC2:                      case OpCode.DELTAC3:                          {                              var last = _stack.Pop();                              for (int i = 1; i <= last; i++)                              {                                  var cvtIndex = _stack.Pop();                                  var arg = _stack.Pop();                                    // upper 4 bits of the 8-bit arg is the relative ppem                                  // the opcode specifies the base to add to the ppem                                  var triggerPpem = (arg >> 4) & 0xF;                                  triggerPpem += (opcode - OpCode.DELTAC1) * 16;                                  triggerPpem += _state.DeltaBase;                                    // if the current ppem matches the trigger' apply the exception                                  if (_ppem == triggerPpem)                                  {                                      // the lower 4 bits of the arg is the amount to shift                                      // it's encoded such that 0 isn't an allowable value (who wants to shift by 0 anyway?)                                      var amount = (arg & 0xF) - 8;                                      if (amount >= 0)                                          amount++;                                      amount *= 1 << (6 - _state.DeltaShift);                                        // update the CVT                                      CheckIndex(cvtIndex' _controlValueTable.Length);                                      _controlValueTable[cvtIndex] += F26Dot6ToFloat(amount);                                  }                              }                          }                          break;                      case OpCode.DELTAP1:                      case OpCode.DELTAP2:                      case OpCode.DELTAP3:                          {                              var last = _stack.Pop();                              for (int i = 1; i <= last; i++)                              {                                  var pointIndex = _stack.Pop();                                  var arg = _stack.Pop();                                    // upper 4 bits of the 8-bit arg is the relative ppem                                  // the opcode specifies the base to add to the ppem                                  var triggerPpem = (arg >> 4) & 0xF;                                  triggerPpem += _state.DeltaBase;                                  if (opcode != OpCode.DELTAP1)                                      triggerPpem += (opcode - OpCode.DELTAP2 + 1) * 16;                                    // if the current ppem matches the trigger' apply the exception                                  if (_ppem == triggerPpem)                                  {                                      // the lower 4 bits of the arg is the amount to shift                                      // it's encoded such that 0 isn't an allowable value (who wants to shift by 0 anyway?)                                      var amount = (arg & 0xF) - 8;                                      if (amount >= 0)                                          amount++;                                      amount *= 1 << (6 - _state.DeltaShift);                                        MovePoint(_zp0' pointIndex' F26Dot6ToFloat(amount));                                  }                              }                          }                          break;                        // ==== MISCELLANEOUS ====                      case OpCode.DEBUG: _stack.Pop(); break;                      case OpCode.GETINFO:                          {                              var selector = _stack.Pop();                              var result = 0;                              if ((selector & 0x1) != 0)                              {                                  // pretend we are MS Rasterizer v35                                  result = 35;                              }                                // TODO: rotation and stretching                              //if ((selector & 0x2) != 0)                              //if ((selector & 0x4) != 0)                                // we're always rendering in grayscale                              if ((selector & 0x20) != 0)                                  result |= 1 << 12;                                // TODO: ClearType flags                                _stack.Push(result);                          }                          break;                        default:                          if (opcode >= OpCode.MIRP)                              MoveIndirectRelative(opcode - OpCode.MIRP);                          else if (opcode >= OpCode.MDRP)                              MoveDirectRelative(opcode - OpCode.MDRP);                          else                          {                              // check if this is a runtime-defined opcode                              var index = (int)opcode;                              if (index > _instructionDefs.Length || !_instructionDefs[index].IsValid)                                  throw new InvalidFontException("Unknown opcode in font program.");                                _callStackSize++;                              if (_callStackSize > MaxCallStack)                                  throw new InvalidFontException("Stack overflow; infinite recursion?");                                Execute(_instructionDefs[index]' true' false);                              _callStackSize--;                          }                          break;                  }
Magic Number,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,Execute,The following statement contains a magic number: switch (opcode)                  {                      // ==== PUSH INSTRUCTIONS ====                      case OpCode.NPUSHB:                      case OpCode.PUSHB1:                      case OpCode.PUSHB2:                      case OpCode.PUSHB3:                      case OpCode.PUSHB4:                      case OpCode.PUSHB5:                      case OpCode.PUSHB6:                      case OpCode.PUSHB7:                      case OpCode.PUSHB8:                          {                              var count = opcode == OpCode.NPUSHB ? stream.NextByte() : opcode - OpCode.PUSHB1 + 1;                              for (int i = count - 1; i >= 0; --i)                                  _stack.Push(stream.NextByte());                          }                          break;                      case OpCode.NPUSHW:                      case OpCode.PUSHW1:                      case OpCode.PUSHW2:                      case OpCode.PUSHW3:                      case OpCode.PUSHW4:                      case OpCode.PUSHW5:                      case OpCode.PUSHW6:                      case OpCode.PUSHW7:                      case OpCode.PUSHW8:                          {                              var count = opcode == OpCode.NPUSHW ? stream.NextByte() : opcode - OpCode.PUSHW1 + 1;                              for (int i = count - 1; i >= 0; --i)                                  _stack.Push(stream.NextWord());                          }                          break;                        // ==== STORAGE MANAGEMENT ====                      case OpCode.RS:                          {                              var loc = CheckIndex(_stack.Pop()' _storage.Length);                              _stack.Push(_storage[loc]);                          }                          break;                      case OpCode.WS:                          {                              var value = _stack.Pop();                              var loc = CheckIndex(_stack.Pop()' _storage.Length);                              _storage[loc] = value;                          }                          break;                        // ==== CONTROL VALUE TABLE ====                      case OpCode.WCVTP:                          {                              var value = _stack.PopFloat();                              var loc = CheckIndex(_stack.Pop()' _controlValueTable.Length);                              _controlValueTable[loc] = value;                          }                          break;                      case OpCode.WCVTF:                          {                              var value = _stack.Pop();                              var loc = CheckIndex(_stack.Pop()' _controlValueTable.Length);                              _controlValueTable[loc] = value * _scale;                          }                          break;                      case OpCode.RCVT: _stack.Push(ReadCvt()); break;                        // ==== STATE VECTORS ====                      case OpCode.SVTCA0:                      case OpCode.SVTCA1:                          {                              var axis = opcode - OpCode.SVTCA0;                              SetFreedomVectorToAxis(axis);                              SetProjectionVectorToAxis(axis);                          }                          break;                      case OpCode.SFVTPV: _state.Freedom = _state.Projection; OnVectorsUpdated(); break;                      case OpCode.SPVTCA0:                      case OpCode.SPVTCA1: SetProjectionVectorToAxis(opcode - OpCode.SPVTCA0); break;                      case OpCode.SFVTCA0:                      case OpCode.SFVTCA1: SetFreedomVectorToAxis(opcode - OpCode.SFVTCA0); break;                      case OpCode.SPVTL0:                      case OpCode.SPVTL1:                      case OpCode.SFVTL0:                      case OpCode.SFVTL1: SetVectorToLine(opcode - OpCode.SPVTL0' false); break;                      case OpCode.SDPVTL0:                      case OpCode.SDPVTL1: SetVectorToLine(opcode - OpCode.SDPVTL0' true); break;                      case OpCode.SPVFS:                      case OpCode.SFVFS:                          {                              var y = _stack.Pop();                              var x = _stack.Pop();                              var vec = Vector2.Normalize(new Vector2(F2Dot14ToFloat(x)' F2Dot14ToFloat(y)));                              if (opcode == OpCode.SFVFS)                                  _state.Freedom = vec;                              else                              {                                  _state.Projection = vec;                                  _state.DualProjection = vec;                              }                              OnVectorsUpdated();                          }                          break;                      case OpCode.GPV:                      case OpCode.GFV:                          {                              var vec = opcode == OpCode.GPV ? _state.Projection : _state.Freedom;                              _stack.Push(FloatToF2Dot14(vec.X));                              _stack.Push(FloatToF2Dot14(vec.Y));                          }                          break;                        // ==== GRAPHICS STATE ====                      case OpCode.SRP0: _state.Rp0 = _stack.Pop(); break;                      case OpCode.SRP1: _state.Rp1 = _stack.Pop(); break;                      case OpCode.SRP2: _state.Rp2 = _stack.Pop(); break;                      case OpCode.SZP0: _zp0 = GetZoneFromStack(); break;                      case OpCode.SZP1: _zp1 = GetZoneFromStack(); break;                      case OpCode.SZP2: _zp2 = GetZoneFromStack(); break;                      case OpCode.SZPS: _zp0 = _zp1 = _zp2 = GetZoneFromStack(); break;                      case OpCode.RTHG: _state.RoundState = RoundMode.ToHalfGrid; break;                      case OpCode.RTG: _state.RoundState = RoundMode.ToGrid; break;                      case OpCode.RTDG: _state.RoundState = RoundMode.ToDoubleGrid; break;                      case OpCode.RDTG: _state.RoundState = RoundMode.DownToGrid; break;                      case OpCode.RUTG: _state.RoundState = RoundMode.UpToGrid; break;                      case OpCode.ROFF: _state.RoundState = RoundMode.Off; break;                      case OpCode.SROUND: _state.RoundState = RoundMode.Super; SetSuperRound(1.0f); break;                      case OpCode.S45ROUND: _state.RoundState = RoundMode.Super45; SetSuperRound(Sqrt2Over2); break;                      case OpCode.INSTCTRL:                          {                              var selector = _stack.Pop();                              if (selector >= 1 && selector <= 2)                              {                                  // value is false if zero' otherwise shift the right bit into the flags                                  var bit = 1 << (selector - 1);                                  if (_stack.Pop() == 0)                                      _state.InstructionControl = (InstructionControlFlags)((int)_state.InstructionControl & ~bit);                                  else                                      _state.InstructionControl = (InstructionControlFlags)((int)_state.InstructionControl | bit);                              }                          }                          break;                      case OpCode.SCANCTRL: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SCANTYPE: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SANGW: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SLOOP: _state.Loop = _stack.Pop(); break;                      case OpCode.SMD: _state.MinDistance = _stack.PopFloat(); break;                      case OpCode.SCVTCI: _state.ControlValueCutIn = _stack.PopFloat(); break;                      case OpCode.SSWCI: _state.SingleWidthCutIn = _stack.PopFloat(); break;                      case OpCode.SSW: _state.SingleWidthValue = _stack.Pop() * _scale; break;                      case OpCode.FLIPON: _state.AutoFlip = true; break;                      case OpCode.FLIPOFF: _state.AutoFlip = false; break;                      case OpCode.SDB: _state.DeltaBase = _stack.Pop(); break;                      case OpCode.SDS: _state.DeltaShift = _stack.Pop(); break;                        // ==== POINT MEASUREMENT ====                      case OpCode.GC0: _stack.Push(Project(_zp2.GetCurrent(_stack.Pop()))); break;                      case OpCode.GC1: _stack.Push(DualProject(_zp2.GetOriginal(_stack.Pop()))); break;                      case OpCode.SCFS:                          {                              var value = _stack.PopFloat();                              var index = _stack.Pop();                              var point = _zp2.GetCurrent(index);                              MovePoint(_zp2' index' value - Project(point));                                // moving twilight points moves their "original" value also                              if (_zp2.IsTwilight)                                  _zp2.Original[index].P = _zp2.Current[index].P;                          }                          break;                      case OpCode.MD0:                          {                              var p1 = _zp1.GetOriginal(_stack.Pop());                              var p2 = _zp0.GetOriginal(_stack.Pop());                              _stack.Push(DualProject(p2 - p1));                          }                          break;                      case OpCode.MD1:                          {                              var p1 = _zp1.GetCurrent(_stack.Pop());                              var p2 = _zp0.GetCurrent(_stack.Pop());                              _stack.Push(Project(p2 - p1));                          }                          break;                      case OpCode.MPS: // MPS should return point size' but we assume DPI so it's the same as pixel size                      case OpCode.MPPEM: _stack.Push(_ppem); break;                      case OpCode.AA: /* deprecated instruction */ _stack.Pop(); break;                        // ==== POINT MODIFICATION ====                      case OpCode.FLIPPT:                          {                              for (int i = 0; i < _state.Loop; i++)                              {                                  var index = _stack.Pop();                                  //review here again!                                  _points.Current[index].onCurve = !_points.Current[index].onCurve;                                  //if (points.Current[index].onCurve)                                  //    points.Current[index].onCurve = false;                                  //else                                  //    points.Current[index].onCurve = true;                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.FLIPRGON:                          {                              var end = _stack.Pop();                              for (int i = _stack.Pop(); i <= end; i++)                                  //points.Current[i].Type = PointType.OnCurve;                                  _points.Current[i].onCurve = true;                          }                          break;                      case OpCode.FLIPRGOFF:                          {                              var end = _stack.Pop();                              for (int i = _stack.Pop(); i <= end; i++)                                  //points.Current[i].Type = PointType.Quadratic;                                  _points.Current[i].onCurve = false;                          }                          break;                      case OpCode.SHP0:                      case OpCode.SHP1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              ShiftPoints(displacement);                          }                          break;                      case OpCode.SHPIX: ShiftPoints(_stack.PopFloat() * _state.Freedom); break;                      case OpCode.SHC0:                      case OpCode.SHC1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              var touch = GetTouchState();                              var contour = _stack.Pop();                              var start = contour == 0 ? 0 : _contours[contour - 1] + 1;                              var count = _zp2.IsTwilight ? _zp2.Current.Length : _contours[contour] + 1;                                for (int i = start; i < count; i++)                              {                                  // don't move the reference point                                  if (zone.Current != _zp2.Current || point != i)                                  {                                      _zp2.Current[i].P += displacement;                                      _zp2.TouchState[i] |= touch;                                  }                              }                          }                          break;                      case OpCode.SHZ0:                      case OpCode.SHZ1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              var count = 0;                              if (_zp2.IsTwilight)                                  count = _zp2.Current.Length;                              else if (_contours.Length > 0)                                  count = _contours[_contours.Length - 1] + 1;                                for (int i = 0; i < count; i++)                              {                                  // don't move the reference point                                  if (zone.Current != _zp2.Current || point != i)                                      _zp2.Current[i].P += displacement;                              }                          }                          break;                      case OpCode.MIAP0:                      case OpCode.MIAP1:                          {                              var distance = ReadCvt();                              var pointIndex = _stack.Pop();                                // this instruction is used in the CVT to set up twilight points with original values                              if (_zp0.IsTwilight)                              {                                  var original = _state.Freedom * distance;                                  _zp0.Original[pointIndex].P = original;                                  _zp0.Current[pointIndex].P = original;                              }                                // current position of the point along the projection vector                              var point = _zp0.GetCurrent(pointIndex);                              var currentPos = Project(point);                              if (opcode == OpCode.MIAP1)                              {                                  // only use the CVT if we are above the cut-in point                                  if (Math.Abs(distance - currentPos) > _state.ControlValueCutIn)                                      distance = currentPos;                                  distance = Round(distance);                              }                                MovePoint(_zp0' pointIndex' distance - currentPos);                              _state.Rp0 = pointIndex;                              _state.Rp1 = pointIndex;                          }                          break;                      case OpCode.MDAP0:                      case OpCode.MDAP1:                          {                              var pointIndex = _stack.Pop();                              var point = _zp0.GetCurrent(pointIndex);                              var distance = 0.0f;                              if (opcode == OpCode.MDAP1)                              {                                  distance = Project(point);                                  distance = Round(distance) - distance;                              }                                MovePoint(_zp0' pointIndex' distance);                              _state.Rp0 = pointIndex;                              _state.Rp1 = pointIndex;                          }                          break;                      case OpCode.MSIRP0:                      case OpCode.MSIRP1:                          {                              var targetDistance = _stack.PopFloat();                              var pointIndex = _stack.Pop();                                // if we're operating on the twilight zone' initialize the points                              if (_zp1.IsTwilight)                              {                                  _zp1.Original[pointIndex].P = _zp0.Original[_state.Rp0].P + targetDistance * _state.Freedom / _fdotp;                                  _zp1.Current[pointIndex].P = _zp1.Original[pointIndex].P;                              }                                var currentDistance = Project(_zp1.GetCurrent(pointIndex) - _zp0.GetCurrent(_state.Rp0));                              MovePoint(_zp1' pointIndex' targetDistance - currentDistance);                                _state.Rp1 = _state.Rp0;                              _state.Rp2 = pointIndex;                              if (opcode == OpCode.MSIRP1)                                  _state.Rp0 = pointIndex;                          }                          break;                      case OpCode.IP:                          {                              var originalBase = _zp0.GetOriginal(_state.Rp1);                              var currentBase = _zp0.GetCurrent(_state.Rp1);                              var originalRange = DualProject(_zp1.GetOriginal(_state.Rp2) - originalBase);                              var currentRange = Project(_zp1.GetCurrent(_state.Rp2) - currentBase);                                for (int i = 0; i < _state.Loop; i++)                              {                                  var pointIndex = _stack.Pop();                                  var point = _zp2.GetCurrent(pointIndex);                                  var currentDistance = Project(point - currentBase);                                  var originalDistance = DualProject(_zp2.GetOriginal(pointIndex) - originalBase);                                    var newDistance = 0.0f;                                  if (originalDistance != 0.0f)                                  {                                      // a range of 0.0f is invalid according to the spec (would result in a div by zero)                                      if (originalRange == 0.0f)                                          newDistance = originalDistance;                                      else                                          newDistance = originalDistance * currentRange / originalRange;                                  }                                    MovePoint(_zp2' pointIndex' newDistance - currentDistance);                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.ALIGNRP:                          {                              for (int i = 0; i < _state.Loop; i++)                              {                                  var pointIndex = _stack.Pop();                                  var p1 = _zp1.GetCurrent(pointIndex);                                  var p2 = _zp0.GetCurrent(_state.Rp0);                                  MovePoint(_zp1' pointIndex' -Project(p1 - p2));                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.ALIGNPTS:                          {                              var p1 = _stack.Pop();                              var p2 = _stack.Pop();                              var distance = Project(_zp0.GetCurrent(p2) - _zp1.GetCurrent(p1)) / 2;                              MovePoint(_zp1' p1' distance);                              MovePoint(_zp0' p2' -distance);                          }                          break;                      case OpCode.UTP: _zp0.TouchState[_stack.Pop()] &= ~GetTouchState(); break;                      case OpCode.IUP0:                      case OpCode.IUP1:                          // bail if no contours (empty outline)                          if (_contours.Length == 0)                          {                              break;                          }                            //{                            //    //WinterDev's new managed version                          //    GlyphPointF[] currentPnts = points.Current;                          //    GlyphPointF[] originalPnts = points.Original;                            //    int cnt_count = contours.Length;                          //    int point = 0;                          //    // opcode controls whether we care about X or Y direction                          //    // do some pointer trickery so we can operate on the                          //    // points in a direction-agnostic manner                          //    TouchState touchMask;                            //    if (opcode == OpCode.IUP0)                          //    {                          //        //y -axis                          //        touchMask = TouchState.Y;                            //        //                          //        for (int i = 0; i < cnt_count; ++i)                          //        {                          //            int endPoint = contours[i];                          //            int firstPoint = point;                          //            int firstTouched = -1;                          //            int lastTouched = -1;                            //            for (; point <= endPoint; point++)                          //            {                          //                // check whether this point has been touched                          //                if ((points.TouchState[point] & touchMask) != 0)                          //                {                          //                    // if this is the first touched point in the contour' note it and continue                          //                    if (firstTouched < 0)                          //                    {                          //                        firstTouched = point;                          //                        lastTouched = point;                          //                        continue;                          //                    }                            //                    // otherwise' interpolate all untouched points                          //                    // between this point and our last touched point                          //                    InterpolatePointsYAxis(currentPnts' originalPnts' lastTouched + 1' point - 1' lastTouched' point);                          //                    lastTouched = point;                          //                }                          //            }                            //            // check if we had any touched points at all in this contour                          //            if (firstTouched >= 0)                          //            {                          //                // there are two cases left to handle:                          //                // 1. there was only one touched point in the whole contour' in                          //                //    which case we want to shift everything relative to that one                          //                // 2. several touched points' in which case handle the gap from the                          //                //    beginning to the first touched point and the gap from the last                          //                //    touched point to the end of the contour                          //                if (lastTouched == firstTouched)                          //                {                          //                    float delta = currentPnts[lastTouched].Y - originalPnts[lastTouched].Y;                          //                    if (delta != 0.0f)                          //                    {                          //                        for (int n = firstPoint; n < lastTouched; n++)                          //                        {                          //                            currentPnts[n].OffsetY(delta);                          //                        }                          //                        for (int n = lastTouched + 1; n <= endPoint; n++)                          //                        {                          //                            currentPnts[n].OffsetY(delta);                          //                        }                            //                    }                          //                }                          //                else                          //                {                          //                    InterpolatePointsYAxis(currentPnts' originalPnts' lastTouched + 1' endPoint' lastTouched' firstTouched);                          //                    if (firstTouched > 0)                          //                    {                          //                        InterpolatePointsYAxis(currentPnts' originalPnts' firstPoint' firstTouched - 1' lastTouched' firstTouched);                          //                    }                          //                }                          //            }                            //        }                          //    }                          //    else                          //    {                          //        //x-axis                          //        touchMask = TouchState.X;                          //        //                          //        for (int i = 0; i < cnt_count; ++i)                          //        {                          //            int endPoint = contours[i];                          //            int firstPoint = point;                          //            int firstTouched = -1;                          //            int lastTouched = -1;                            //            for (; point <= endPoint; point++)                          //            {                          //                // check whether this point has been touched                          //                if ((points.TouchState[point] & touchMask) != 0)                          //                {                          //                    // if this is the first touched point in the contour' note it and continue                          //                    if (firstTouched < 0)                          //                    {                          //                        firstTouched = point;                          //                        lastTouched = point;                          //                        continue;                          //                    }                            //                    // otherwise' interpolate all untouched points                          //                    // between this point and our last touched point                          //                    InterpolatePointsXAxis(currentPnts' originalPnts' lastTouched + 1' point - 1' lastTouched' point);                          //                    lastTouched = point;                          //                }                          //            }                            //            // check if we had any touched points at all in this contour                          //            if (firstTouched >= 0)                          //            {                          //                // there are two cases left to handle:                          //                // 1. there was only one touched point in the whole contour' in                          //                //    which case we want to shift everything relative to that one                          //                // 2. several touched points' in which case handle the gap from the                          //                //    beginning to the first touched point and the gap from the last                          //                //    touched point to the end of the contour                          //                if (lastTouched == firstTouched)                          //                {                          //                    float delta = currentPnts[lastTouched].X - originalPnts[lastTouched].X;                          //                    if (delta != 0.0f)                          //                    {                          //                        for (int n = firstPoint; n < lastTouched; ++n)                          //                        {                          //                            currentPnts[n].OffsetX(delta);                          //                        }                          //                        for (int n = lastTouched + 1; n <= endPoint; ++n)                          //                        {                          //                            currentPnts[n].OffsetX(delta);                          //                        }                          //                    }                          //                }                          //                else                          //                {                          //                    InterpolatePointsXAxis(currentPnts' originalPnts' lastTouched + 1' endPoint' lastTouched' firstTouched);                          //                    if (firstTouched > 0)                          //                    {                          //                        InterpolatePointsXAxis(currentPnts' originalPnts' firstPoint' firstTouched - 1' lastTouched' firstTouched);                          //                    }                          //                }                          //            }                          //        }                          //    }                          //}                          //-----------------------------------------                          unsafe                          {                                //unsafe version                               //TODO: provide manage version                               fixed (GlyphPointF* currentPtr = _points.Current)                              fixed (GlyphPointF* originalPtr = _points.Original)                              {                                  // opcode controls whether we care about X or Y direction                                  // do some pointer trickery so we can operate on the                                  // points in a direction-agnostic manner                                  TouchState touchMask;                                  byte* current;                                  byte* original;                                  if (opcode == OpCode.IUP0)                                  {                                      touchMask = TouchState.Y;                                      current = (byte*)&currentPtr->P.Y;                                      original = (byte*)&originalPtr->P.Y;                                  }                                  else                                  {                                      touchMask = TouchState.X;                                      current = (byte*)&currentPtr->P.X;                                      original = (byte*)&originalPtr->P.X;                                  }                                    var point = 0;                                  for (int i = 0; i < _contours.Length; i++)                                  {                                      var endPoint = _contours[i];                                      var firstPoint = point;                                      var firstTouched = -1;                                      var lastTouched = -1;                                        for (; point <= endPoint; point++)                                      {                                          // check whether this point has been touched                                          if ((_points.TouchState[point] & touchMask) != 0)                                          {                                              // if this is the first touched point in the contour' note it and continue                                              if (firstTouched < 0)                                              {                                                  firstTouched = point;                                                  lastTouched = point;                                                  continue;                                              }                                                // otherwise' interpolate all untouched points                                              // between this point and our last touched point                                              InterpolatePoints(current' original' lastTouched + 1' point - 1' lastTouched' point);                                              lastTouched = point;                                          }                                      }                                        // check if we had any touched points at all in this contour                                      if (firstTouched >= 0)                                      {                                          // there are two cases left to handle:                                          // 1. there was only one touched point in the whole contour' in                                          //    which case we want to shift everything relative to that one                                          // 2. several touched points' in which case handle the gap from the                                          //    beginning to the first touched point and the gap from the last                                          //    touched point to the end of the contour                                          if (lastTouched == firstTouched)                                          {                                              var delta = *GetPoint(current' lastTouched) - *GetPoint(original' lastTouched);                                              if (delta != 0.0f)                                              {                                                  for (int j = firstPoint; j < lastTouched; j++)                                                      *GetPoint(current' j) += delta;                                                  for (int j = lastTouched + 1; j <= endPoint; j++)                                                      *GetPoint(current' j) += delta;                                              }                                          }                                          else                                          {                                              InterpolatePoints(current' original' lastTouched + 1' endPoint' lastTouched' firstTouched);                                              if (firstTouched > 0)                                                  InterpolatePoints(current' original' firstPoint' firstTouched - 1' lastTouched' firstTouched);                                          }                                      }                                  }                              }                          }                          break;                      case OpCode.ISECT:                          {                              // move point P to the intersection of lines A and B                              var b1 = _zp0.GetCurrent(_stack.Pop());                              var b0 = _zp0.GetCurrent(_stack.Pop());                              var a1 = _zp1.GetCurrent(_stack.Pop());                              var a0 = _zp1.GetCurrent(_stack.Pop());                              var index = _stack.Pop();                                // calculate intersection using determinants: https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line                              var da = a0 - a1;                              var db = b0 - b1;                              var den = (da.X * db.Y) - (da.Y * db.X);                              if (Math.Abs(den) <= Epsilon)                              {                                  // parallel lines; spec says to put the ppoint "into the middle of the two lines"                                  _zp2.Current[index].P = (a0 + a1 + b0 + b1) / 4;                              }                              else                              {                                  var t = (a0.X * a1.Y) - (a0.Y * a1.X);                                  var u = (b0.X * b1.Y) - (b0.Y * b1.X);                                  var p = new Vector2(                                      (t * db.X) - (da.X * u)'                                      (t * db.Y) - (da.Y * u)                                  );                                  _zp2.Current[index].P = p / den;                              }                              _zp2.TouchState[index] = TouchState.Both;                          }                          break;                        // ==== STACK MANAGEMENT ====                      case OpCode.DUP: _stack.Duplicate(); break;                      case OpCode.POP: _stack.Pop(); break;                      case OpCode.CLEAR: _stack.Clear(); break;                      case OpCode.SWAP: _stack.Swap(); break;                      case OpCode.DEPTH: _stack.Depth(); break;                      case OpCode.CINDEX: _stack.Copy(); break;                      case OpCode.MINDEX: _stack.Move(); break;                      case OpCode.ROLL: _stack.Roll(); break;                        // ==== FLOW CONTROL ====                      case OpCode.IF:                          {                              // value is false; jump to the next else block or endif marker                              // otherwise' we don't have to do anything; we'll keep executing this block                              if (!_stack.PopBool())                              {                                  int indent = 1;                                  while (indent > 0)                                  {                                      opcode = SkipNext(ref stream);                                      switch (opcode)                                      {                                          case OpCode.IF: indent++; break;                                          case OpCode.EIF: indent--; break;                                          case OpCode.ELSE:                                              if (indent == 1)                                                  indent = 0;                                              break;                                      }                                  }                              }                          }                          break;                      case OpCode.ELSE:                          {                              // assume we hit the true statement of some previous if block                              // if we had hit false' we would have jumped over this                              int indent = 1;                              while (indent > 0)                              {                                  opcode = SkipNext(ref stream);                                  switch (opcode)                                  {                                      case OpCode.IF: indent++; break;                                      case OpCode.EIF: indent--; break;                                  }                              }                          }                          break;                      case OpCode.EIF: /* nothing to do */ break;                      case OpCode.JROT:                      case OpCode.JROF:                          {                              if (_stack.PopBool() == (opcode == OpCode.JROT))                                  stream.Jump(_stack.Pop() - 1);                              else                                  _stack.Pop();    // ignore the offset                          }                          break;                      case OpCode.JMPR: stream.Jump(_stack.Pop() - 1); break;                        // ==== LOGICAL OPS ====                      case OpCode.LT:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a < b);                          }                          break;                      case OpCode.LTEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a <= b);                          }                          break;                      case OpCode.GT:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a > b);                          }                          break;                      case OpCode.GTEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a >= b);                          }                          break;                      case OpCode.EQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a == b);                          }                          break;                      case OpCode.NEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a != b);                          }                          break;                      case OpCode.AND:                          {                              var b = _stack.PopBool();                              var a = _stack.PopBool();                              _stack.Push(a && b);                          }                          break;                      case OpCode.OR:                          {                              var b = _stack.PopBool();                              var a = _stack.PopBool();                              _stack.Push(a || b);                          }                          break;                      case OpCode.NOT: _stack.Push(!_stack.PopBool()); break;                      case OpCode.ODD:                          {                              var value = (int)Round(_stack.PopFloat());                              _stack.Push(value % 2 != 0);                          }                          break;                      case OpCode.EVEN:                          {                              var value = (int)Round(_stack.PopFloat());                              _stack.Push(value % 2 == 0);                          }                          break;                        // ==== ARITHMETIC ====                      case OpCode.ADD:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a + b);                          }                          break;                      case OpCode.SUB:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a - b);                          }                          break;                      case OpCode.DIV:                          {                              var b = _stack.Pop();                              if (b == 0)                                  throw new InvalidFontException("Division by zero.");                                var a = _stack.Pop();                              var result = ((long)a << 6) / b;                              _stack.Push((int)result);                          }                          break;                      case OpCode.MUL:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              var result = ((long)a * b) >> 6;                              _stack.Push((int)result);                          }                          break;                      case OpCode.ABS: _stack.Push(Math.Abs(_stack.Pop())); break;                      case OpCode.NEG: _stack.Push(-_stack.Pop()); break;                      case OpCode.FLOOR: _stack.Push(_stack.Pop() & ~63); break;                      case OpCode.CEILING: _stack.Push((_stack.Pop() + 63) & ~63); break;                      case OpCode.MAX: _stack.Push(Math.Max(_stack.Pop()' _stack.Pop())); break;                      case OpCode.MIN: _stack.Push(Math.Min(_stack.Pop()' _stack.Pop())); break;                        // ==== FUNCTIONS ====                      case OpCode.FDEF:                          {                              if (!allowFunctionDefs || inFunction)                                  throw new InvalidFontException("Can't define functions here.");                                _functions[_stack.Pop()] = stream;                              while (SkipNext(ref stream) != OpCode.ENDF) ;                          }                          break;                      case OpCode.IDEF:                          {                              if (!allowFunctionDefs || inFunction)                                  throw new InvalidFontException("Can't define functions here.");                                _instructionDefs[_stack.Pop()] = stream;                              while (SkipNext(ref stream) != OpCode.ENDF) ;                          }                          break;                      case OpCode.ENDF:                          {                              if (!inFunction)                                  throw new InvalidFontException("Found invalid ENDF marker outside of a function definition.");                              return;                          }                      case OpCode.CALL:                      case OpCode.LOOPCALL:                          {                              _callStackSize++;                              if (_callStackSize > MaxCallStack)                                  throw new InvalidFontException("Stack overflow; infinite recursion?");                                var function = _functions[_stack.Pop()];                              var count = opcode == OpCode.LOOPCALL ? _stack.Pop() : 1;                              for (int i = 0; i < count; i++)                                  Execute(function' true' false);                              _callStackSize--;                          }                          break;                        // ==== ROUNDING ====                      // we don't have "engine compensation" so the variants are unnecessary                      case OpCode.ROUND0:                      case OpCode.ROUND1:                      case OpCode.ROUND2:                      case OpCode.ROUND3: _stack.Push(Round(_stack.PopFloat())); break;                      case OpCode.NROUND0:                      case OpCode.NROUND1:                      case OpCode.NROUND2:                      case OpCode.NROUND3: break;                        // ==== DELTA EXCEPTIONS ====                      case OpCode.DELTAC1:                      case OpCode.DELTAC2:                      case OpCode.DELTAC3:                          {                              var last = _stack.Pop();                              for (int i = 1; i <= last; i++)                              {                                  var cvtIndex = _stack.Pop();                                  var arg = _stack.Pop();                                    // upper 4 bits of the 8-bit arg is the relative ppem                                  // the opcode specifies the base to add to the ppem                                  var triggerPpem = (arg >> 4) & 0xF;                                  triggerPpem += (opcode - OpCode.DELTAC1) * 16;                                  triggerPpem += _state.DeltaBase;                                    // if the current ppem matches the trigger' apply the exception                                  if (_ppem == triggerPpem)                                  {                                      // the lower 4 bits of the arg is the amount to shift                                      // it's encoded such that 0 isn't an allowable value (who wants to shift by 0 anyway?)                                      var amount = (arg & 0xF) - 8;                                      if (amount >= 0)                                          amount++;                                      amount *= 1 << (6 - _state.DeltaShift);                                        // update the CVT                                      CheckIndex(cvtIndex' _controlValueTable.Length);                                      _controlValueTable[cvtIndex] += F26Dot6ToFloat(amount);                                  }                              }                          }                          break;                      case OpCode.DELTAP1:                      case OpCode.DELTAP2:                      case OpCode.DELTAP3:                          {                              var last = _stack.Pop();                              for (int i = 1; i <= last; i++)                              {                                  var pointIndex = _stack.Pop();                                  var arg = _stack.Pop();                                    // upper 4 bits of the 8-bit arg is the relative ppem                                  // the opcode specifies the base to add to the ppem                                  var triggerPpem = (arg >> 4) & 0xF;                                  triggerPpem += _state.DeltaBase;                                  if (opcode != OpCode.DELTAP1)                                      triggerPpem += (opcode - OpCode.DELTAP2 + 1) * 16;                                    // if the current ppem matches the trigger' apply the exception                                  if (_ppem == triggerPpem)                                  {                                      // the lower 4 bits of the arg is the amount to shift                                      // it's encoded such that 0 isn't an allowable value (who wants to shift by 0 anyway?)                                      var amount = (arg & 0xF) - 8;                                      if (amount >= 0)                                          amount++;                                      amount *= 1 << (6 - _state.DeltaShift);                                        MovePoint(_zp0' pointIndex' F26Dot6ToFloat(amount));                                  }                              }                          }                          break;                        // ==== MISCELLANEOUS ====                      case OpCode.DEBUG: _stack.Pop(); break;                      case OpCode.GETINFO:                          {                              var selector = _stack.Pop();                              var result = 0;                              if ((selector & 0x1) != 0)                              {                                  // pretend we are MS Rasterizer v35                                  result = 35;                              }                                // TODO: rotation and stretching                              //if ((selector & 0x2) != 0)                              //if ((selector & 0x4) != 0)                                // we're always rendering in grayscale                              if ((selector & 0x20) != 0)                                  result |= 1 << 12;                                // TODO: ClearType flags                                _stack.Push(result);                          }                          break;                        default:                          if (opcode >= OpCode.MIRP)                              MoveIndirectRelative(opcode - OpCode.MIRP);                          else if (opcode >= OpCode.MDRP)                              MoveDirectRelative(opcode - OpCode.MDRP);                          else                          {                              // check if this is a runtime-defined opcode                              var index = (int)opcode;                              if (index > _instructionDefs.Length || !_instructionDefs[index].IsValid)                                  throw new InvalidFontException("Unknown opcode in font program.");                                _callStackSize++;                              if (_callStackSize > MaxCallStack)                                  throw new InvalidFontException("Stack overflow; infinite recursion?");                                Execute(_instructionDefs[index]' true' false);                              _callStackSize--;                          }                          break;                  }
Magic Number,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,Execute,The following statement contains a magic number: switch (opcode)                  {                      // ==== PUSH INSTRUCTIONS ====                      case OpCode.NPUSHB:                      case OpCode.PUSHB1:                      case OpCode.PUSHB2:                      case OpCode.PUSHB3:                      case OpCode.PUSHB4:                      case OpCode.PUSHB5:                      case OpCode.PUSHB6:                      case OpCode.PUSHB7:                      case OpCode.PUSHB8:                          {                              var count = opcode == OpCode.NPUSHB ? stream.NextByte() : opcode - OpCode.PUSHB1 + 1;                              for (int i = count - 1; i >= 0; --i)                                  _stack.Push(stream.NextByte());                          }                          break;                      case OpCode.NPUSHW:                      case OpCode.PUSHW1:                      case OpCode.PUSHW2:                      case OpCode.PUSHW3:                      case OpCode.PUSHW4:                      case OpCode.PUSHW5:                      case OpCode.PUSHW6:                      case OpCode.PUSHW7:                      case OpCode.PUSHW8:                          {                              var count = opcode == OpCode.NPUSHW ? stream.NextByte() : opcode - OpCode.PUSHW1 + 1;                              for (int i = count - 1; i >= 0; --i)                                  _stack.Push(stream.NextWord());                          }                          break;                        // ==== STORAGE MANAGEMENT ====                      case OpCode.RS:                          {                              var loc = CheckIndex(_stack.Pop()' _storage.Length);                              _stack.Push(_storage[loc]);                          }                          break;                      case OpCode.WS:                          {                              var value = _stack.Pop();                              var loc = CheckIndex(_stack.Pop()' _storage.Length);                              _storage[loc] = value;                          }                          break;                        // ==== CONTROL VALUE TABLE ====                      case OpCode.WCVTP:                          {                              var value = _stack.PopFloat();                              var loc = CheckIndex(_stack.Pop()' _controlValueTable.Length);                              _controlValueTable[loc] = value;                          }                          break;                      case OpCode.WCVTF:                          {                              var value = _stack.Pop();                              var loc = CheckIndex(_stack.Pop()' _controlValueTable.Length);                              _controlValueTable[loc] = value * _scale;                          }                          break;                      case OpCode.RCVT: _stack.Push(ReadCvt()); break;                        // ==== STATE VECTORS ====                      case OpCode.SVTCA0:                      case OpCode.SVTCA1:                          {                              var axis = opcode - OpCode.SVTCA0;                              SetFreedomVectorToAxis(axis);                              SetProjectionVectorToAxis(axis);                          }                          break;                      case OpCode.SFVTPV: _state.Freedom = _state.Projection; OnVectorsUpdated(); break;                      case OpCode.SPVTCA0:                      case OpCode.SPVTCA1: SetProjectionVectorToAxis(opcode - OpCode.SPVTCA0); break;                      case OpCode.SFVTCA0:                      case OpCode.SFVTCA1: SetFreedomVectorToAxis(opcode - OpCode.SFVTCA0); break;                      case OpCode.SPVTL0:                      case OpCode.SPVTL1:                      case OpCode.SFVTL0:                      case OpCode.SFVTL1: SetVectorToLine(opcode - OpCode.SPVTL0' false); break;                      case OpCode.SDPVTL0:                      case OpCode.SDPVTL1: SetVectorToLine(opcode - OpCode.SDPVTL0' true); break;                      case OpCode.SPVFS:                      case OpCode.SFVFS:                          {                              var y = _stack.Pop();                              var x = _stack.Pop();                              var vec = Vector2.Normalize(new Vector2(F2Dot14ToFloat(x)' F2Dot14ToFloat(y)));                              if (opcode == OpCode.SFVFS)                                  _state.Freedom = vec;                              else                              {                                  _state.Projection = vec;                                  _state.DualProjection = vec;                              }                              OnVectorsUpdated();                          }                          break;                      case OpCode.GPV:                      case OpCode.GFV:                          {                              var vec = opcode == OpCode.GPV ? _state.Projection : _state.Freedom;                              _stack.Push(FloatToF2Dot14(vec.X));                              _stack.Push(FloatToF2Dot14(vec.Y));                          }                          break;                        // ==== GRAPHICS STATE ====                      case OpCode.SRP0: _state.Rp0 = _stack.Pop(); break;                      case OpCode.SRP1: _state.Rp1 = _stack.Pop(); break;                      case OpCode.SRP2: _state.Rp2 = _stack.Pop(); break;                      case OpCode.SZP0: _zp0 = GetZoneFromStack(); break;                      case OpCode.SZP1: _zp1 = GetZoneFromStack(); break;                      case OpCode.SZP2: _zp2 = GetZoneFromStack(); break;                      case OpCode.SZPS: _zp0 = _zp1 = _zp2 = GetZoneFromStack(); break;                      case OpCode.RTHG: _state.RoundState = RoundMode.ToHalfGrid; break;                      case OpCode.RTG: _state.RoundState = RoundMode.ToGrid; break;                      case OpCode.RTDG: _state.RoundState = RoundMode.ToDoubleGrid; break;                      case OpCode.RDTG: _state.RoundState = RoundMode.DownToGrid; break;                      case OpCode.RUTG: _state.RoundState = RoundMode.UpToGrid; break;                      case OpCode.ROFF: _state.RoundState = RoundMode.Off; break;                      case OpCode.SROUND: _state.RoundState = RoundMode.Super; SetSuperRound(1.0f); break;                      case OpCode.S45ROUND: _state.RoundState = RoundMode.Super45; SetSuperRound(Sqrt2Over2); break;                      case OpCode.INSTCTRL:                          {                              var selector = _stack.Pop();                              if (selector >= 1 && selector <= 2)                              {                                  // value is false if zero' otherwise shift the right bit into the flags                                  var bit = 1 << (selector - 1);                                  if (_stack.Pop() == 0)                                      _state.InstructionControl = (InstructionControlFlags)((int)_state.InstructionControl & ~bit);                                  else                                      _state.InstructionControl = (InstructionControlFlags)((int)_state.InstructionControl | bit);                              }                          }                          break;                      case OpCode.SCANCTRL: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SCANTYPE: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SANGW: /* instruction unspported */ _stack.Pop(); break;                      case OpCode.SLOOP: _state.Loop = _stack.Pop(); break;                      case OpCode.SMD: _state.MinDistance = _stack.PopFloat(); break;                      case OpCode.SCVTCI: _state.ControlValueCutIn = _stack.PopFloat(); break;                      case OpCode.SSWCI: _state.SingleWidthCutIn = _stack.PopFloat(); break;                      case OpCode.SSW: _state.SingleWidthValue = _stack.Pop() * _scale; break;                      case OpCode.FLIPON: _state.AutoFlip = true; break;                      case OpCode.FLIPOFF: _state.AutoFlip = false; break;                      case OpCode.SDB: _state.DeltaBase = _stack.Pop(); break;                      case OpCode.SDS: _state.DeltaShift = _stack.Pop(); break;                        // ==== POINT MEASUREMENT ====                      case OpCode.GC0: _stack.Push(Project(_zp2.GetCurrent(_stack.Pop()))); break;                      case OpCode.GC1: _stack.Push(DualProject(_zp2.GetOriginal(_stack.Pop()))); break;                      case OpCode.SCFS:                          {                              var value = _stack.PopFloat();                              var index = _stack.Pop();                              var point = _zp2.GetCurrent(index);                              MovePoint(_zp2' index' value - Project(point));                                // moving twilight points moves their "original" value also                              if (_zp2.IsTwilight)                                  _zp2.Original[index].P = _zp2.Current[index].P;                          }                          break;                      case OpCode.MD0:                          {                              var p1 = _zp1.GetOriginal(_stack.Pop());                              var p2 = _zp0.GetOriginal(_stack.Pop());                              _stack.Push(DualProject(p2 - p1));                          }                          break;                      case OpCode.MD1:                          {                              var p1 = _zp1.GetCurrent(_stack.Pop());                              var p2 = _zp0.GetCurrent(_stack.Pop());                              _stack.Push(Project(p2 - p1));                          }                          break;                      case OpCode.MPS: // MPS should return point size' but we assume DPI so it's the same as pixel size                      case OpCode.MPPEM: _stack.Push(_ppem); break;                      case OpCode.AA: /* deprecated instruction */ _stack.Pop(); break;                        // ==== POINT MODIFICATION ====                      case OpCode.FLIPPT:                          {                              for (int i = 0; i < _state.Loop; i++)                              {                                  var index = _stack.Pop();                                  //review here again!                                  _points.Current[index].onCurve = !_points.Current[index].onCurve;                                  //if (points.Current[index].onCurve)                                  //    points.Current[index].onCurve = false;                                  //else                                  //    points.Current[index].onCurve = true;                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.FLIPRGON:                          {                              var end = _stack.Pop();                              for (int i = _stack.Pop(); i <= end; i++)                                  //points.Current[i].Type = PointType.OnCurve;                                  _points.Current[i].onCurve = true;                          }                          break;                      case OpCode.FLIPRGOFF:                          {                              var end = _stack.Pop();                              for (int i = _stack.Pop(); i <= end; i++)                                  //points.Current[i].Type = PointType.Quadratic;                                  _points.Current[i].onCurve = false;                          }                          break;                      case OpCode.SHP0:                      case OpCode.SHP1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              ShiftPoints(displacement);                          }                          break;                      case OpCode.SHPIX: ShiftPoints(_stack.PopFloat() * _state.Freedom); break;                      case OpCode.SHC0:                      case OpCode.SHC1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              var touch = GetTouchState();                              var contour = _stack.Pop();                              var start = contour == 0 ? 0 : _contours[contour - 1] + 1;                              var count = _zp2.IsTwilight ? _zp2.Current.Length : _contours[contour] + 1;                                for (int i = start; i < count; i++)                              {                                  // don't move the reference point                                  if (zone.Current != _zp2.Current || point != i)                                  {                                      _zp2.Current[i].P += displacement;                                      _zp2.TouchState[i] |= touch;                                  }                              }                          }                          break;                      case OpCode.SHZ0:                      case OpCode.SHZ1:                          {                              Zone zone;                              int point;                              var displacement = ComputeDisplacement((int)opcode' out zone' out point);                              var count = 0;                              if (_zp2.IsTwilight)                                  count = _zp2.Current.Length;                              else if (_contours.Length > 0)                                  count = _contours[_contours.Length - 1] + 1;                                for (int i = 0; i < count; i++)                              {                                  // don't move the reference point                                  if (zone.Current != _zp2.Current || point != i)                                      _zp2.Current[i].P += displacement;                              }                          }                          break;                      case OpCode.MIAP0:                      case OpCode.MIAP1:                          {                              var distance = ReadCvt();                              var pointIndex = _stack.Pop();                                // this instruction is used in the CVT to set up twilight points with original values                              if (_zp0.IsTwilight)                              {                                  var original = _state.Freedom * distance;                                  _zp0.Original[pointIndex].P = original;                                  _zp0.Current[pointIndex].P = original;                              }                                // current position of the point along the projection vector                              var point = _zp0.GetCurrent(pointIndex);                              var currentPos = Project(point);                              if (opcode == OpCode.MIAP1)                              {                                  // only use the CVT if we are above the cut-in point                                  if (Math.Abs(distance - currentPos) > _state.ControlValueCutIn)                                      distance = currentPos;                                  distance = Round(distance);                              }                                MovePoint(_zp0' pointIndex' distance - currentPos);                              _state.Rp0 = pointIndex;                              _state.Rp1 = pointIndex;                          }                          break;                      case OpCode.MDAP0:                      case OpCode.MDAP1:                          {                              var pointIndex = _stack.Pop();                              var point = _zp0.GetCurrent(pointIndex);                              var distance = 0.0f;                              if (opcode == OpCode.MDAP1)                              {                                  distance = Project(point);                                  distance = Round(distance) - distance;                              }                                MovePoint(_zp0' pointIndex' distance);                              _state.Rp0 = pointIndex;                              _state.Rp1 = pointIndex;                          }                          break;                      case OpCode.MSIRP0:                      case OpCode.MSIRP1:                          {                              var targetDistance = _stack.PopFloat();                              var pointIndex = _stack.Pop();                                // if we're operating on the twilight zone' initialize the points                              if (_zp1.IsTwilight)                              {                                  _zp1.Original[pointIndex].P = _zp0.Original[_state.Rp0].P + targetDistance * _state.Freedom / _fdotp;                                  _zp1.Current[pointIndex].P = _zp1.Original[pointIndex].P;                              }                                var currentDistance = Project(_zp1.GetCurrent(pointIndex) - _zp0.GetCurrent(_state.Rp0));                              MovePoint(_zp1' pointIndex' targetDistance - currentDistance);                                _state.Rp1 = _state.Rp0;                              _state.Rp2 = pointIndex;                              if (opcode == OpCode.MSIRP1)                                  _state.Rp0 = pointIndex;                          }                          break;                      case OpCode.IP:                          {                              var originalBase = _zp0.GetOriginal(_state.Rp1);                              var currentBase = _zp0.GetCurrent(_state.Rp1);                              var originalRange = DualProject(_zp1.GetOriginal(_state.Rp2) - originalBase);                              var currentRange = Project(_zp1.GetCurrent(_state.Rp2) - currentBase);                                for (int i = 0; i < _state.Loop; i++)                              {                                  var pointIndex = _stack.Pop();                                  var point = _zp2.GetCurrent(pointIndex);                                  var currentDistance = Project(point - currentBase);                                  var originalDistance = DualProject(_zp2.GetOriginal(pointIndex) - originalBase);                                    var newDistance = 0.0f;                                  if (originalDistance != 0.0f)                                  {                                      // a range of 0.0f is invalid according to the spec (would result in a div by zero)                                      if (originalRange == 0.0f)                                          newDistance = originalDistance;                                      else                                          newDistance = originalDistance * currentRange / originalRange;                                  }                                    MovePoint(_zp2' pointIndex' newDistance - currentDistance);                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.ALIGNRP:                          {                              for (int i = 0; i < _state.Loop; i++)                              {                                  var pointIndex = _stack.Pop();                                  var p1 = _zp1.GetCurrent(pointIndex);                                  var p2 = _zp0.GetCurrent(_state.Rp0);                                  MovePoint(_zp1' pointIndex' -Project(p1 - p2));                              }                              _state.Loop = 1;                          }                          break;                      case OpCode.ALIGNPTS:                          {                              var p1 = _stack.Pop();                              var p2 = _stack.Pop();                              var distance = Project(_zp0.GetCurrent(p2) - _zp1.GetCurrent(p1)) / 2;                              MovePoint(_zp1' p1' distance);                              MovePoint(_zp0' p2' -distance);                          }                          break;                      case OpCode.UTP: _zp0.TouchState[_stack.Pop()] &= ~GetTouchState(); break;                      case OpCode.IUP0:                      case OpCode.IUP1:                          // bail if no contours (empty outline)                          if (_contours.Length == 0)                          {                              break;                          }                            //{                            //    //WinterDev's new managed version                          //    GlyphPointF[] currentPnts = points.Current;                          //    GlyphPointF[] originalPnts = points.Original;                            //    int cnt_count = contours.Length;                          //    int point = 0;                          //    // opcode controls whether we care about X or Y direction                          //    // do some pointer trickery so we can operate on the                          //    // points in a direction-agnostic manner                          //    TouchState touchMask;                            //    if (opcode == OpCode.IUP0)                          //    {                          //        //y -axis                          //        touchMask = TouchState.Y;                            //        //                          //        for (int i = 0; i < cnt_count; ++i)                          //        {                          //            int endPoint = contours[i];                          //            int firstPoint = point;                          //            int firstTouched = -1;                          //            int lastTouched = -1;                            //            for (; point <= endPoint; point++)                          //            {                          //                // check whether this point has been touched                          //                if ((points.TouchState[point] & touchMask) != 0)                          //                {                          //                    // if this is the first touched point in the contour' note it and continue                          //                    if (firstTouched < 0)                          //                    {                          //                        firstTouched = point;                          //                        lastTouched = point;                          //                        continue;                          //                    }                            //                    // otherwise' interpolate all untouched points                          //                    // between this point and our last touched point                          //                    InterpolatePointsYAxis(currentPnts' originalPnts' lastTouched + 1' point - 1' lastTouched' point);                          //                    lastTouched = point;                          //                }                          //            }                            //            // check if we had any touched points at all in this contour                          //            if (firstTouched >= 0)                          //            {                          //                // there are two cases left to handle:                          //                // 1. there was only one touched point in the whole contour' in                          //                //    which case we want to shift everything relative to that one                          //                // 2. several touched points' in which case handle the gap from the                          //                //    beginning to the first touched point and the gap from the last                          //                //    touched point to the end of the contour                          //                if (lastTouched == firstTouched)                          //                {                          //                    float delta = currentPnts[lastTouched].Y - originalPnts[lastTouched].Y;                          //                    if (delta != 0.0f)                          //                    {                          //                        for (int n = firstPoint; n < lastTouched; n++)                          //                        {                          //                            currentPnts[n].OffsetY(delta);                          //                        }                          //                        for (int n = lastTouched + 1; n <= endPoint; n++)                          //                        {                          //                            currentPnts[n].OffsetY(delta);                          //                        }                            //                    }                          //                }                          //                else                          //                {                          //                    InterpolatePointsYAxis(currentPnts' originalPnts' lastTouched + 1' endPoint' lastTouched' firstTouched);                          //                    if (firstTouched > 0)                          //                    {                          //                        InterpolatePointsYAxis(currentPnts' originalPnts' firstPoint' firstTouched - 1' lastTouched' firstTouched);                          //                    }                          //                }                          //            }                            //        }                          //    }                          //    else                          //    {                          //        //x-axis                          //        touchMask = TouchState.X;                          //        //                          //        for (int i = 0; i < cnt_count; ++i)                          //        {                          //            int endPoint = contours[i];                          //            int firstPoint = point;                          //            int firstTouched = -1;                          //            int lastTouched = -1;                            //            for (; point <= endPoint; point++)                          //            {                          //                // check whether this point has been touched                          //                if ((points.TouchState[point] & touchMask) != 0)                          //                {                          //                    // if this is the first touched point in the contour' note it and continue                          //                    if (firstTouched < 0)                          //                    {                          //                        firstTouched = point;                          //                        lastTouched = point;                          //                        continue;                          //                    }                            //                    // otherwise' interpolate all untouched points                          //                    // between this point and our last touched point                          //                    InterpolatePointsXAxis(currentPnts' originalPnts' lastTouched + 1' point - 1' lastTouched' point);                          //                    lastTouched = point;                          //                }                          //            }                            //            // check if we had any touched points at all in this contour                          //            if (firstTouched >= 0)                          //            {                          //                // there are two cases left to handle:                          //                // 1. there was only one touched point in the whole contour' in                          //                //    which case we want to shift everything relative to that one                          //                // 2. several touched points' in which case handle the gap from the                          //                //    beginning to the first touched point and the gap from the last                          //                //    touched point to the end of the contour                          //                if (lastTouched == firstTouched)                          //                {                          //                    float delta = currentPnts[lastTouched].X - originalPnts[lastTouched].X;                          //                    if (delta != 0.0f)                          //                    {                          //                        for (int n = firstPoint; n < lastTouched; ++n)                          //                        {                          //                            currentPnts[n].OffsetX(delta);                          //                        }                          //                        for (int n = lastTouched + 1; n <= endPoint; ++n)                          //                        {                          //                            currentPnts[n].OffsetX(delta);                          //                        }                          //                    }                          //                }                          //                else                          //                {                          //                    InterpolatePointsXAxis(currentPnts' originalPnts' lastTouched + 1' endPoint' lastTouched' firstTouched);                          //                    if (firstTouched > 0)                          //                    {                          //                        InterpolatePointsXAxis(currentPnts' originalPnts' firstPoint' firstTouched - 1' lastTouched' firstTouched);                          //                    }                          //                }                          //            }                          //        }                          //    }                          //}                          //-----------------------------------------                          unsafe                          {                                //unsafe version                               //TODO: provide manage version                               fixed (GlyphPointF* currentPtr = _points.Current)                              fixed (GlyphPointF* originalPtr = _points.Original)                              {                                  // opcode controls whether we care about X or Y direction                                  // do some pointer trickery so we can operate on the                                  // points in a direction-agnostic manner                                  TouchState touchMask;                                  byte* current;                                  byte* original;                                  if (opcode == OpCode.IUP0)                                  {                                      touchMask = TouchState.Y;                                      current = (byte*)&currentPtr->P.Y;                                      original = (byte*)&originalPtr->P.Y;                                  }                                  else                                  {                                      touchMask = TouchState.X;                                      current = (byte*)&currentPtr->P.X;                                      original = (byte*)&originalPtr->P.X;                                  }                                    var point = 0;                                  for (int i = 0; i < _contours.Length; i++)                                  {                                      var endPoint = _contours[i];                                      var firstPoint = point;                                      var firstTouched = -1;                                      var lastTouched = -1;                                        for (; point <= endPoint; point++)                                      {                                          // check whether this point has been touched                                          if ((_points.TouchState[point] & touchMask) != 0)                                          {                                              // if this is the first touched point in the contour' note it and continue                                              if (firstTouched < 0)                                              {                                                  firstTouched = point;                                                  lastTouched = point;                                                  continue;                                              }                                                // otherwise' interpolate all untouched points                                              // between this point and our last touched point                                              InterpolatePoints(current' original' lastTouched + 1' point - 1' lastTouched' point);                                              lastTouched = point;                                          }                                      }                                        // check if we had any touched points at all in this contour                                      if (firstTouched >= 0)                                      {                                          // there are two cases left to handle:                                          // 1. there was only one touched point in the whole contour' in                                          //    which case we want to shift everything relative to that one                                          // 2. several touched points' in which case handle the gap from the                                          //    beginning to the first touched point and the gap from the last                                          //    touched point to the end of the contour                                          if (lastTouched == firstTouched)                                          {                                              var delta = *GetPoint(current' lastTouched) - *GetPoint(original' lastTouched);                                              if (delta != 0.0f)                                              {                                                  for (int j = firstPoint; j < lastTouched; j++)                                                      *GetPoint(current' j) += delta;                                                  for (int j = lastTouched + 1; j <= endPoint; j++)                                                      *GetPoint(current' j) += delta;                                              }                                          }                                          else                                          {                                              InterpolatePoints(current' original' lastTouched + 1' endPoint' lastTouched' firstTouched);                                              if (firstTouched > 0)                                                  InterpolatePoints(current' original' firstPoint' firstTouched - 1' lastTouched' firstTouched);                                          }                                      }                                  }                              }                          }                          break;                      case OpCode.ISECT:                          {                              // move point P to the intersection of lines A and B                              var b1 = _zp0.GetCurrent(_stack.Pop());                              var b0 = _zp0.GetCurrent(_stack.Pop());                              var a1 = _zp1.GetCurrent(_stack.Pop());                              var a0 = _zp1.GetCurrent(_stack.Pop());                              var index = _stack.Pop();                                // calculate intersection using determinants: https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line                              var da = a0 - a1;                              var db = b0 - b1;                              var den = (da.X * db.Y) - (da.Y * db.X);                              if (Math.Abs(den) <= Epsilon)                              {                                  // parallel lines; spec says to put the ppoint "into the middle of the two lines"                                  _zp2.Current[index].P = (a0 + a1 + b0 + b1) / 4;                              }                              else                              {                                  var t = (a0.X * a1.Y) - (a0.Y * a1.X);                                  var u = (b0.X * b1.Y) - (b0.Y * b1.X);                                  var p = new Vector2(                                      (t * db.X) - (da.X * u)'                                      (t * db.Y) - (da.Y * u)                                  );                                  _zp2.Current[index].P = p / den;                              }                              _zp2.TouchState[index] = TouchState.Both;                          }                          break;                        // ==== STACK MANAGEMENT ====                      case OpCode.DUP: _stack.Duplicate(); break;                      case OpCode.POP: _stack.Pop(); break;                      case OpCode.CLEAR: _stack.Clear(); break;                      case OpCode.SWAP: _stack.Swap(); break;                      case OpCode.DEPTH: _stack.Depth(); break;                      case OpCode.CINDEX: _stack.Copy(); break;                      case OpCode.MINDEX: _stack.Move(); break;                      case OpCode.ROLL: _stack.Roll(); break;                        // ==== FLOW CONTROL ====                      case OpCode.IF:                          {                              // value is false; jump to the next else block or endif marker                              // otherwise' we don't have to do anything; we'll keep executing this block                              if (!_stack.PopBool())                              {                                  int indent = 1;                                  while (indent > 0)                                  {                                      opcode = SkipNext(ref stream);                                      switch (opcode)                                      {                                          case OpCode.IF: indent++; break;                                          case OpCode.EIF: indent--; break;                                          case OpCode.ELSE:                                              if (indent == 1)                                                  indent = 0;                                              break;                                      }                                  }                              }                          }                          break;                      case OpCode.ELSE:                          {                              // assume we hit the true statement of some previous if block                              // if we had hit false' we would have jumped over this                              int indent = 1;                              while (indent > 0)                              {                                  opcode = SkipNext(ref stream);                                  switch (opcode)                                  {                                      case OpCode.IF: indent++; break;                                      case OpCode.EIF: indent--; break;                                  }                              }                          }                          break;                      case OpCode.EIF: /* nothing to do */ break;                      case OpCode.JROT:                      case OpCode.JROF:                          {                              if (_stack.PopBool() == (opcode == OpCode.JROT))                                  stream.Jump(_stack.Pop() - 1);                              else                                  _stack.Pop();    // ignore the offset                          }                          break;                      case OpCode.JMPR: stream.Jump(_stack.Pop() - 1); break;                        // ==== LOGICAL OPS ====                      case OpCode.LT:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a < b);                          }                          break;                      case OpCode.LTEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a <= b);                          }                          break;                      case OpCode.GT:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a > b);                          }                          break;                      case OpCode.GTEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a >= b);                          }                          break;                      case OpCode.EQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a == b);                          }                          break;                      case OpCode.NEQ:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a != b);                          }                          break;                      case OpCode.AND:                          {                              var b = _stack.PopBool();                              var a = _stack.PopBool();                              _stack.Push(a && b);                          }                          break;                      case OpCode.OR:                          {                              var b = _stack.PopBool();                              var a = _stack.PopBool();                              _stack.Push(a || b);                          }                          break;                      case OpCode.NOT: _stack.Push(!_stack.PopBool()); break;                      case OpCode.ODD:                          {                              var value = (int)Round(_stack.PopFloat());                              _stack.Push(value % 2 != 0);                          }                          break;                      case OpCode.EVEN:                          {                              var value = (int)Round(_stack.PopFloat());                              _stack.Push(value % 2 == 0);                          }                          break;                        // ==== ARITHMETIC ====                      case OpCode.ADD:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a + b);                          }                          break;                      case OpCode.SUB:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              _stack.Push(a - b);                          }                          break;                      case OpCode.DIV:                          {                              var b = _stack.Pop();                              if (b == 0)                                  throw new InvalidFontException("Division by zero.");                                var a = _stack.Pop();                              var result = ((long)a << 6) / b;                              _stack.Push((int)result);                          }                          break;                      case OpCode.MUL:                          {                              var b = _stack.Pop();                              var a = _stack.Pop();                              var result = ((long)a * b) >> 6;                              _stack.Push((int)result);                          }                          break;                      case OpCode.ABS: _stack.Push(Math.Abs(_stack.Pop())); break;                      case OpCode.NEG: _stack.Push(-_stack.Pop()); break;                      case OpCode.FLOOR: _stack.Push(_stack.Pop() & ~63); break;                      case OpCode.CEILING: _stack.Push((_stack.Pop() + 63) & ~63); break;                      case OpCode.MAX: _stack.Push(Math.Max(_stack.Pop()' _stack.Pop())); break;                      case OpCode.MIN: _stack.Push(Math.Min(_stack.Pop()' _stack.Pop())); break;                        // ==== FUNCTIONS ====                      case OpCode.FDEF:                          {                              if (!allowFunctionDefs || inFunction)                                  throw new InvalidFontException("Can't define functions here.");                                _functions[_stack.Pop()] = stream;                              while (SkipNext(ref stream) != OpCode.ENDF) ;                          }                          break;                      case OpCode.IDEF:                          {                              if (!allowFunctionDefs || inFunction)                                  throw new InvalidFontException("Can't define functions here.");                                _instructionDefs[_stack.Pop()] = stream;                              while (SkipNext(ref stream) != OpCode.ENDF) ;                          }                          break;                      case OpCode.ENDF:                          {                              if (!inFunction)                                  throw new InvalidFontException("Found invalid ENDF marker outside of a function definition.");                              return;                          }                      case OpCode.CALL:                      case OpCode.LOOPCALL:                          {                              _callStackSize++;                              if (_callStackSize > MaxCallStack)                                  throw new InvalidFontException("Stack overflow; infinite recursion?");                                var function = _functions[_stack.Pop()];                              var count = opcode == OpCode.LOOPCALL ? _stack.Pop() : 1;                              for (int i = 0; i < count; i++)                                  Execute(function' true' false);                              _callStackSize--;                          }                          break;                        // ==== ROUNDING ====                      // we don't have "engine compensation" so the variants are unnecessary                      case OpCode.ROUND0:                      case OpCode.ROUND1:                      case OpCode.ROUND2:                      case OpCode.ROUND3: _stack.Push(Round(_stack.PopFloat())); break;                      case OpCode.NROUND0:                      case OpCode.NROUND1:                      case OpCode.NROUND2:                      case OpCode.NROUND3: break;                        // ==== DELTA EXCEPTIONS ====                      case OpCode.DELTAC1:                      case OpCode.DELTAC2:                      case OpCode.DELTAC3:                          {                              var last = _stack.Pop();                              for (int i = 1; i <= last; i++)                              {                                  var cvtIndex = _stack.Pop();                                  var arg = _stack.Pop();                                    // upper 4 bits of the 8-bit arg is the relative ppem                                  // the opcode specifies the base to add to the ppem                                  var triggerPpem = (arg >> 4) & 0xF;                                  triggerPpem += (opcode - OpCode.DELTAC1) * 16;                                  triggerPpem += _state.DeltaBase;                                    // if the current ppem matches the trigger' apply the exception                                  if (_ppem == triggerPpem)                                  {                                      // the lower 4 bits of the arg is the amount to shift                                      // it's encoded such that 0 isn't an allowable value (who wants to shift by 0 anyway?)                                      var amount = (arg & 0xF) - 8;                                      if (amount >= 0)                                          amount++;                                      amount *= 1 << (6 - _state.DeltaShift);                                        // update the CVT                                      CheckIndex(cvtIndex' _controlValueTable.Length);                                      _controlValueTable[cvtIndex] += F26Dot6ToFloat(amount);                                  }                              }                          }                          break;                      case OpCode.DELTAP1:                      case OpCode.DELTAP2:                      case OpCode.DELTAP3:                          {                              var last = _stack.Pop();                              for (int i = 1; i <= last; i++)                              {                                  var pointIndex = _stack.Pop();                                  var arg = _stack.Pop();                                    // upper 4 bits of the 8-bit arg is the relative ppem                                  // the opcode specifies the base to add to the ppem                                  var triggerPpem = (arg >> 4) & 0xF;                                  triggerPpem += _state.DeltaBase;                                  if (opcode != OpCode.DELTAP1)                                      triggerPpem += (opcode - OpCode.DELTAP2 + 1) * 16;                                    // if the current ppem matches the trigger' apply the exception                                  if (_ppem == triggerPpem)                                  {                                      // the lower 4 bits of the arg is the amount to shift                                      // it's encoded such that 0 isn't an allowable value (who wants to shift by 0 anyway?)                                      var amount = (arg & 0xF) - 8;                                      if (amount >= 0)                                          amount++;                                      amount *= 1 << (6 - _state.DeltaShift);                                        MovePoint(_zp0' pointIndex' F26Dot6ToFloat(amount));                                  }                              }                          }                          break;                        // ==== MISCELLANEOUS ====                      case OpCode.DEBUG: _stack.Pop(); break;                      case OpCode.GETINFO:                          {                              var selector = _stack.Pop();                              var result = 0;                              if ((selector & 0x1) != 0)                              {                                  // pretend we are MS Rasterizer v35                                  result = 35;                              }                                // TODO: rotation and stretching                              //if ((selector & 0x2) != 0)                              //if ((selector & 0x4) != 0)                                // we're always rendering in grayscale                              if ((selector & 0x20) != 0)                                  result |= 1 << 12;                                // TODO: ClearType flags                                _stack.Push(result);                          }                          break;                        default:                          if (opcode >= OpCode.MIRP)                              MoveIndirectRelative(opcode - OpCode.MIRP);                          else if (opcode >= OpCode.MDRP)                              MoveDirectRelative(opcode - OpCode.MDRP);                          else                          {                              // check if this is a runtime-defined opcode                              var index = (int)opcode;                              if (index > _instructionDefs.Length || !_instructionDefs[index].IsValid)                                  throw new InvalidFontException("Unknown opcode in font program.");                                _callStackSize++;                              if (_callStackSize > MaxCallStack)                                  throw new InvalidFontException("Stack overflow; infinite recursion?");                                Execute(_instructionDefs[index]' true' false);                              _callStackSize--;                          }                          break;                  }
Magic Number,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,SetVectorToLine,The following statement contains a magic number: mode >= 2
Magic Number,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,SetSuperRound,The following statement contains a magic number: switch (mode & 0xC0)              {                  case 0: roundPeriod = period / 2; break;                  case 0x40: roundPeriod = period; break;                  case 0x80: roundPeriod = period * 2; break;                  default: throw new InvalidFontException("Unknown rounding period multiplier.");              }
Magic Number,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,SetSuperRound,The following statement contains a magic number: switch (mode & 0xC0)              {                  case 0: roundPeriod = period / 2; break;                  case 0x40: roundPeriod = period; break;                  case 0x80: roundPeriod = period * 2; break;                  default: throw new InvalidFontException("Unknown rounding period multiplier.");              }
Magic Number,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,SetSuperRound,The following statement contains a magic number: switch (mode & 0x30)              {                  case 0: _roundPhase = 0; break;                  case 0x10: _roundPhase = roundPeriod / 4; break;                  case 0x20: _roundPhase = roundPeriod / 2; break;                  case 0x30: _roundPhase = roundPeriod * 3 / 4; break;              }
Magic Number,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,SetSuperRound,The following statement contains a magic number: switch (mode & 0x30)              {                  case 0: _roundPhase = 0; break;                  case 0x10: _roundPhase = roundPeriod / 4; break;                  case 0x20: _roundPhase = roundPeriod / 2; break;                  case 0x30: _roundPhase = roundPeriod * 3 / 4; break;              }
Magic Number,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,SetSuperRound,The following statement contains a magic number: switch (mode & 0x30)              {                  case 0: _roundPhase = 0; break;                  case 0x10: _roundPhase = roundPeriod / 4; break;                  case 0x20: _roundPhase = roundPeriod / 2; break;                  case 0x30: _roundPhase = roundPeriod * 3 / 4; break;              }
Magic Number,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,SetSuperRound,The following statement contains a magic number: switch (mode & 0x30)              {                  case 0: _roundPhase = 0; break;                  case 0x10: _roundPhase = roundPeriod / 4; break;                  case 0x20: _roundPhase = roundPeriod / 2; break;                  case 0x30: _roundPhase = roundPeriod * 3 / 4; break;              }
Magic Number,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,Round,The following statement contains a magic number: switch (_state.RoundState)              {                  case RoundMode.ToGrid: return value >= 0 ? (float)Math.Round(value) : -(float)Math.Round(-value);                  case RoundMode.ToHalfGrid: return value >= 0 ? (float)Math.Floor(value) + 0.5f : -((float)Math.Floor(-value) + 0.5f);                  case RoundMode.ToDoubleGrid: return value >= 0 ? (float)(Math.Round(value * 2' MidpointRounding.AwayFromZero) / 2) : -(float)(Math.Round(-value * 2' MidpointRounding.AwayFromZero) / 2);                  case RoundMode.DownToGrid: return value >= 0 ? (float)Math.Floor(value) : -(float)Math.Floor(-value);                  case RoundMode.UpToGrid: return value >= 0 ? (float)Math.Ceiling(value) : -(float)Math.Ceiling(-value);                  case RoundMode.Super:                  case RoundMode.Super45:                      float result;                      if (value >= 0)                      {                          result = value - _roundPhase + _roundThreshold;                          result = (float)Math.Truncate(result / roundPeriod) * roundPeriod;                          result += _roundPhase;                          if (result < 0)                              result = _roundPhase;                      }                      else                      {                          result = -value - _roundPhase + _roundThreshold;                          result = -(float)Math.Truncate(result / roundPeriod) * roundPeriod;                          result -= _roundPhase;                          if (result > 0)                              result = -_roundPhase;                      }                      return result;                    default: return value;              }
Magic Number,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,Round,The following statement contains a magic number: switch (_state.RoundState)              {                  case RoundMode.ToGrid: return value >= 0 ? (float)Math.Round(value) : -(float)Math.Round(-value);                  case RoundMode.ToHalfGrid: return value >= 0 ? (float)Math.Floor(value) + 0.5f : -((float)Math.Floor(-value) + 0.5f);                  case RoundMode.ToDoubleGrid: return value >= 0 ? (float)(Math.Round(value * 2' MidpointRounding.AwayFromZero) / 2) : -(float)(Math.Round(-value * 2' MidpointRounding.AwayFromZero) / 2);                  case RoundMode.DownToGrid: return value >= 0 ? (float)Math.Floor(value) : -(float)Math.Floor(-value);                  case RoundMode.UpToGrid: return value >= 0 ? (float)Math.Ceiling(value) : -(float)Math.Ceiling(-value);                  case RoundMode.Super:                  case RoundMode.Super45:                      float result;                      if (value >= 0)                      {                          result = value - _roundPhase + _roundThreshold;                          result = (float)Math.Truncate(result / roundPeriod) * roundPeriod;                          result += _roundPhase;                          if (result < 0)                              result = _roundPhase;                      }                      else                      {                          result = -value - _roundPhase + _roundThreshold;                          result = -(float)Math.Truncate(result / roundPeriod) * roundPeriod;                          result -= _roundPhase;                          if (result > 0)                              result = -_roundPhase;                      }                      return result;                    default: return value;              }
Magic Number,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,Round,The following statement contains a magic number: switch (_state.RoundState)              {                  case RoundMode.ToGrid: return value >= 0 ? (float)Math.Round(value) : -(float)Math.Round(-value);                  case RoundMode.ToHalfGrid: return value >= 0 ? (float)Math.Floor(value) + 0.5f : -((float)Math.Floor(-value) + 0.5f);                  case RoundMode.ToDoubleGrid: return value >= 0 ? (float)(Math.Round(value * 2' MidpointRounding.AwayFromZero) / 2) : -(float)(Math.Round(-value * 2' MidpointRounding.AwayFromZero) / 2);                  case RoundMode.DownToGrid: return value >= 0 ? (float)Math.Floor(value) : -(float)Math.Floor(-value);                  case RoundMode.UpToGrid: return value >= 0 ? (float)Math.Ceiling(value) : -(float)Math.Ceiling(-value);                  case RoundMode.Super:                  case RoundMode.Super45:                      float result;                      if (value >= 0)                      {                          result = value - _roundPhase + _roundThreshold;                          result = (float)Math.Truncate(result / roundPeriod) * roundPeriod;                          result += _roundPhase;                          if (result < 0)                              result = _roundPhase;                      }                      else                      {                          result = -value - _roundPhase + _roundThreshold;                          result = -(float)Math.Truncate(result / roundPeriod) * roundPeriod;                          result -= _roundPhase;                          if (result > 0)                              result = -_roundPhase;                      }                      return result;                    default: return value;              }
Magic Number,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,Round,The following statement contains a magic number: switch (_state.RoundState)              {                  case RoundMode.ToGrid: return value >= 0 ? (float)Math.Round(value) : -(float)Math.Round(-value);                  case RoundMode.ToHalfGrid: return value >= 0 ? (float)Math.Floor(value) + 0.5f : -((float)Math.Floor(-value) + 0.5f);                  case RoundMode.ToDoubleGrid: return value >= 0 ? (float)(Math.Round(value * 2' MidpointRounding.AwayFromZero) / 2) : -(float)(Math.Round(-value * 2' MidpointRounding.AwayFromZero) / 2);                  case RoundMode.DownToGrid: return value >= 0 ? (float)Math.Floor(value) : -(float)Math.Floor(-value);                  case RoundMode.UpToGrid: return value >= 0 ? (float)Math.Ceiling(value) : -(float)Math.Ceiling(-value);                  case RoundMode.Super:                  case RoundMode.Super45:                      float result;                      if (value >= 0)                      {                          result = value - _roundPhase + _roundThreshold;                          result = (float)Math.Truncate(result / roundPeriod) * roundPeriod;                          result += _roundPhase;                          if (result < 0)                              result = _roundPhase;                      }                      else                      {                          result = -value - _roundPhase + _roundThreshold;                          result = -(float)Math.Truncate(result / roundPeriod) * roundPeriod;                          result -= _roundPhase;                          if (result > 0)                              result = -_roundPhase;                      }                      return result;                    default: return value;              }
Magic Number,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,Round,The following statement contains a magic number: switch (_state.RoundState)              {                  case RoundMode.ToGrid: return value >= 0 ? (float)Math.Round(value) : -(float)Math.Round(-value);                  case RoundMode.ToHalfGrid: return value >= 0 ? (float)Math.Floor(value) + 0.5f : -((float)Math.Floor(-value) + 0.5f);                  case RoundMode.ToDoubleGrid: return value >= 0 ? (float)(Math.Round(value * 2' MidpointRounding.AwayFromZero) / 2) : -(float)(Math.Round(-value * 2' MidpointRounding.AwayFromZero) / 2);                  case RoundMode.DownToGrid: return value >= 0 ? (float)Math.Floor(value) : -(float)Math.Floor(-value);                  case RoundMode.UpToGrid: return value >= 0 ? (float)Math.Ceiling(value) : -(float)Math.Ceiling(-value);                  case RoundMode.Super:                  case RoundMode.Super45:                      float result;                      if (value >= 0)                      {                          result = value - _roundPhase + _roundThreshold;                          result = (float)Math.Truncate(result / roundPeriod) * roundPeriod;                          result += _roundPhase;                          if (result < 0)                              result = _roundPhase;                      }                      else                      {                          result = -value - _roundPhase + _roundThreshold;                          result = -(float)Math.Truncate(result / roundPeriod) * roundPeriod;                          result -= _roundPhase;                          if (result > 0)                              result = -_roundPhase;                      }                      return result;                    default: return value;              }
Magic Number,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,Round,The following statement contains a magic number: switch (_state.RoundState)              {                  case RoundMode.ToGrid: return value >= 0 ? (float)Math.Round(value) : -(float)Math.Round(-value);                  case RoundMode.ToHalfGrid: return value >= 0 ? (float)Math.Floor(value) + 0.5f : -((float)Math.Floor(-value) + 0.5f);                  case RoundMode.ToDoubleGrid: return value >= 0 ? (float)(Math.Round(value * 2' MidpointRounding.AwayFromZero) / 2) : -(float)(Math.Round(-value * 2' MidpointRounding.AwayFromZero) / 2);                  case RoundMode.DownToGrid: return value >= 0 ? (float)Math.Floor(value) : -(float)Math.Floor(-value);                  case RoundMode.UpToGrid: return value >= 0 ? (float)Math.Ceiling(value) : -(float)Math.Ceiling(-value);                  case RoundMode.Super:                  case RoundMode.Super45:                      float result;                      if (value >= 0)                      {                          result = value - _roundPhase + _roundThreshold;                          result = (float)Math.Truncate(result / roundPeriod) * roundPeriod;                          result += _roundPhase;                          if (result < 0)                              result = _roundPhase;                      }                      else                      {                          result = -value - _roundPhase + _roundThreshold;                          result = -(float)Math.Truncate(result / roundPeriod) * roundPeriod;                          result -= _roundPhase;                          if (result > 0)                              result = -_roundPhase;                      }                      return result;                    default: return value;              }
Magic Number,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,F2Dot14ToFloat,The following statement contains a magic number: return (short)value / 16384.0f;
Magic Number,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,FloatToF2Dot14,The following statement contains a magic number: return (int)(uint)(short)Math.Round(value * 16384.0f);
Magic Number,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,F26Dot6ToFloat,The following statement contains a magic number: return value / 64.0f;
Magic Number,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,FloatToF26Dot6,The following statement contains a magic number: return (int)Math.Round(value * 64.0f);
Magic Number,Typography.OpenFont,InstructionStream,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,NextWord,The following statement contains a magic number: return (short)(ushort)(NextByte() << 8 | NextByte());
Magic Number,Typography.OpenFont,GraphicsState,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,Reset,The following statement contains a magic number: ControlValueCutIn = 17.0f / 16.0f;
Magic Number,Typography.OpenFont,GraphicsState,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,Reset,The following statement contains a magic number: ControlValueCutIn = 17.0f / 16.0f;
Magic Number,Typography.OpenFont,GraphicsState,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,Reset,The following statement contains a magic number: DeltaBase = 9;
Magic Number,Typography.OpenFont,GraphicsState,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,Reset,The following statement contains a magic number: DeltaShift = 3;
Magic Number,Typography.OpenFont,ExecutionStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,Roll,The following statement contains a magic number: Move(2);
Magic Number,Typography.OpenFont,ExecutionStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,Swap,The following statement contains a magic number: _count < 2
Magic Number,Typography.OpenFont,ExecutionStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,Swap,The following statement contains a magic number: _s[_count - 1] = _s[_count - 2];
Magic Number,Typography.OpenFont,ExecutionStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,Swap,The following statement contains a magic number: _s[_count - 2] = tmp;
Magic Number,Typography.OpenFont,CffBoundFinder,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Typeface.cs,Curve3,The following statement contains a magic number: UpdateMinMax(                           (c * c * _curX) + (2 * t * c * x1) + (t * t * x2)'  //x                           (c * c * _curY) + (2 * t * c * y1) + (t * t * y2));
Magic Number,Typography.OpenFont,CffBoundFinder,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Typeface.cs,Curve3,The following statement contains a magic number: UpdateMinMax(                           (c * c * _curX) + (2 * t * c * x1) + (t * t * x2)'  //x                           (c * c * _curY) + (2 * t * c * y1) + (t * t * y2));
Magic Number,Typography.OpenFont,CffBoundFinder,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Typeface.cs,Curve4,The following statement contains a magic number: UpdateMinMax(                          (_curX * c * c * c) + (x1 * 3 * t * c * c) + (x2 * 3 * t * t * c) + x3 * t * t * t'  //x                          (_curY * c * c * c) + (y1 * 3 * t * c * c) + (y2 * 3 * t * t * c) + y3 * t * t * t);
Magic Number,Typography.OpenFont,CffBoundFinder,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Typeface.cs,Curve4,The following statement contains a magic number: UpdateMinMax(                          (_curX * c * c * c) + (x1 * 3 * t * c * c) + (x2 * 3 * t * t * c) + x3 * t * t * t'  //x                          (_curY * c * c * c) + (y1 * 3 * t * c * c) + (y2 * 3 * t * t * c) + y3 * t * t * t);
Magic Number,Typography.OpenFont,CffBoundFinder,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Typeface.cs,Curve4,The following statement contains a magic number: UpdateMinMax(                          (_curX * c * c * c) + (x1 * 3 * t * c * c) + (x2 * 3 * t * t * c) + x3 * t * t * t'  //x                          (_curY * c * c * c) + (y1 * 3 * t * c * c) + (y2 * 3 * t * t * c) + y3 * t * t * t);
Magic Number,Typography.OpenFont,CffBoundFinder,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Typeface.cs,Curve4,The following statement contains a magic number: UpdateMinMax(                          (_curX * c * c * c) + (x1 * 3 * t * c * c) + (x2 * 3 * t * t * c) + x3 * t * t * t'  //x                          (_curY * c * c * c) + (y1 * 3 * t * c * c) + (y2 * 3 * t * t * c) + y3 * t * t * t);
Magic Number,Typography.OpenFont.Tables,BASE,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\Base.cs,ConvertToTagString,The following statement contains a magic number: return new string(new char[] {                   (char)iden_tag_bytes[0]'                   (char)iden_tag_bytes[1]'                   (char)iden_tag_bytes[2]'                   (char)iden_tag_bytes[3]});
Magic Number,Typography.OpenFont.Tables,BASE,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\Base.cs,ConvertToTagString,The following statement contains a magic number: return new string(new char[] {                   (char)iden_tag_bytes[0]'                   (char)iden_tag_bytes[1]'                   (char)iden_tag_bytes[2]'                   (char)iden_tag_bytes[3]});
Magic Number,Typography.OpenFont.Tables,BASE,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\Base.cs,ReadBaseTagList,The following statement contains a magic number: baselineTags[i] = ConvertToTagString(reader.ReadBytes(4));
Magic Number,Typography.OpenFont.Tables,BASE,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\Base.cs,ReadBaseScriptList,The following statement contains a magic number: baseScriptRecord_offsets[i] = new BaseScriptRecord(ConvertToTagString(reader.ReadBytes(4))' reader.ReadUInt16());
Magic Number,Typography.OpenFont.Tables,BASE,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\Base.cs,ReadBaseScriptTable,The following statement contains a magic number: baseLangSysRecords[i] = new BaseLangSysRecord(ConvertToTagString(reader.ReadBytes(4))' reader.ReadUInt16());
Magic Number,Typography.OpenFont.Tables,BASE,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\Base.cs,ReadBaseCoordTable,The following statement contains a magic number: switch (baseCoordFormat)              {                  default: throw new System.NotSupportedException();                  case 1:                      return new BaseCoord(1'                          reader.ReadInt16());//coord                  case 2:                      return new BaseCoord(2'                          reader.ReadInt16()' //coordinate                          reader.ReadUInt16()' //referenceGlyph                          reader.ReadUInt16()); //baseCoordPoint                  case 3:  #if DEBUG    #endif                      return new BaseCoord();                      //    //TODO: implement this...                      //    break;              }
Magic Number,Typography.OpenFont.Tables,BASE,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\Base.cs,ReadBaseCoordTable,The following statement contains a magic number: switch (baseCoordFormat)              {                  default: throw new System.NotSupportedException();                  case 1:                      return new BaseCoord(1'                          reader.ReadInt16());//coord                  case 2:                      return new BaseCoord(2'                          reader.ReadInt16()' //coordinate                          reader.ReadUInt16()' //referenceGlyph                          reader.ReadUInt16()); //baseCoordPoint                  case 3:  #if DEBUG    #endif                      return new BaseCoord();                      //    //TODO: implement this...                      //    break;              }
Magic Number,Typography.OpenFont.Tables,BASE,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\Base.cs,ReadBaseCoordTable,The following statement contains a magic number: switch (baseCoordFormat)              {                  default: throw new System.NotSupportedException();                  case 1:                      return new BaseCoord(1'                          reader.ReadInt16());//coord                  case 2:                      return new BaseCoord(2'                          reader.ReadInt16()' //coordinate                          reader.ReadUInt16()' //referenceGlyph                          reader.ReadUInt16()); //baseCoordPoint                  case 3:  #if DEBUG    #endif                      return new BaseCoord();                      //    //TODO: implement this...                      //    break;              }
Magic Number,Typography.OpenFont.Tables,BASE,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\Base.cs,ReadMinMaxTable,The following statement contains a magic number: minMaxFeatureOffsets[i] = new FeatureMinMaxOffset(                          ConvertToTagString(reader.ReadBytes(4))' //featureTableTag                          reader.ReadUInt16()' //minCoord offset                          reader.ReadUInt16() //maxCoord offset                          );
Magic Number,Typography.OpenFont.Tables,ClassDefTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\ClassDefTable.cs,CreateFrom,The following statement contains a magic number: switch (classDefTable.Format = reader.ReadUInt16())              {                  default: throw new NotSupportedException();                  case 1:                      {                          classDefTable.startGlyph = reader.ReadUInt16();                          ushort glyphCount = reader.ReadUInt16();                          classDefTable.classValueArray = Utils.ReadUInt16Array(reader' glyphCount);                      }                      break;                  case 2:                      {                          ushort classRangeCount = reader.ReadUInt16();                          ClassRangeRecord[] records = new ClassRangeRecord[classRangeCount];                          for (int i = 0; i < classRangeCount; ++i)                          {                              records[i] = new ClassRangeRecord(                                  reader.ReadUInt16()' //start glyph id                                  reader.ReadUInt16()' //end glyph id                                  reader.ReadUInt16()); //classNo                          }                          classDefTable.records = records;                      }                      break;              }
Magic Number,Typography.OpenFont.Tables,ClassDefTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\ClassDefTable.cs,GetClassValue,The following statement contains a magic number: switch (Format)              {                  default: throw new NotSupportedException();                  case 1:                      {                          if (glyphIndex >= startGlyph &&                              glyphIndex < classValueArray.Length)                          {                              return classValueArray[startGlyph + (glyphIndex - startGlyph)];                          }                          return -1;                      }                  case 2:                      {                                                    for (int i = 0; i < records.Length; ++i)                          {                              //TODO: review a proper method here again                              //esp. binary search                              ClassRangeRecord rec = records[i];                              if (rec.startGlyphId <= glyphIndex)                              {                                  if (glyphIndex <= rec.endGlyphId)                                  {                                      return rec.classNo;                                  }                              }                              else                              {                                  return -1;//no need to go further                              }                          }                          return -1;                      }              }
Magic Number,Typography.OpenFont.Tables,CoverageTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\CoverageTable.cs,CreateFrom,The following statement contains a magic number: switch (format)              {                  default: throw new NotSupportedException();                  case 1: return CoverageFmt1.CreateFrom(reader);                  case 2: return CoverageFmt2.CreateFrom(reader);              }
Magic Number,Typography.OpenFont.Tables,GDEF,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GDEF.cs,ReadContentFrom,The following statement contains a magic number: switch (MinorVersion)              {                  default:                      Utils.WarnUnimplemented("GDEF Minor Version {0}"' MinorVersion);                      return;                  case 0:                      break;                  case 2:                      markGlyphSetsDefOffset = reader.ReadUInt16();                      break;                  case 3:                      markGlyphSetsDefOffset = reader.ReadUInt16();                      itemVarStoreOffset = reader.ReadUInt32();                      break;              }
Magic Number,Typography.OpenFont.Tables,GDEF,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GDEF.cs,ReadContentFrom,The following statement contains a magic number: switch (MinorVersion)              {                  default:                      Utils.WarnUnimplemented("GDEF Minor Version {0}"' MinorVersion);                      return;                  case 0:                      break;                  case 2:                      markGlyphSetsDefOffset = reader.ReadUInt16();                      break;                  case 3:                      markGlyphSetsDefOffset = reader.ReadUInt16();                      itemVarStoreOffset = reader.ReadUInt32();                      break;              }
Magic Number,Typography.OpenFont.Tables,GDEF,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GDEF.cs,ReadContentFrom,The following statement contains a magic number: markAttachClassDefOffset == 2
Magic Number,Typography.OpenFont.Tables,GDEF,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GDEF.cs,FillClassDefs,The following statement contains a magic number: switch (classDef.Format)              {                  default:                      Utils.WarnUnimplemented("GDEF GlyphClassDef Format {0}"' classDef.Format);                      break;                  case 1:                      {                          ushort startGlyph = classDef.startGlyph;                          ushort[] classValues = classDef.classValueArray;                          int gIndex = startGlyph;                          for (int i = 0; i < classValues.Length; ++i)                          {  #if DEBUG                              ushort classV = classValues[i];                              if (classV > (ushort)GlyphClassKind.Component)                              {                                }  #endif                                inputGlyphs[gIndex].GlyphClass = (GlyphClassKind)classValues[i];                              gIndex++;                          }                        }                      break;                  case 2:                      {                          ClassDefTable.ClassRangeRecord[] records = classDef.records;                          for (int n = 0; n < records.Length; ++n)                          {                              ClassDefTable.ClassRangeRecord rec = records[n];    #if DEBUG                                if (rec.classNo > (ushort)GlyphClassKind.Component)                              {                                }  #endif                                GlyphClassKind glyphKind = (GlyphClassKind)rec.classNo;                              for (int i = rec.startGlyphId; i <= rec.endGlyphId; ++i)                              {                                  inputGlyphs[i].GlyphClass = glyphKind;                              }                          }                      }                      break;              }
Magic Number,Typography.OpenFont.Tables,GDEF,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GDEF.cs,FillMarkAttachmentClassDefs,The following statement contains a magic number: switch (markAttachmentClassDef.Format)              {                  default:                      Utils.WarnUnimplemented("GDEF MarkAttachmentClassDef Table Format {0}"' markAttachmentClassDef.Format);                      break;                  case 1:                      {                          ushort startGlyph = markAttachmentClassDef.startGlyph;                          ushort[] classValues = markAttachmentClassDef.classValueArray;                            int len = classValues.Length;                          int gIndex = startGlyph;                          for (int i = 0; i < len; ++i)                          {  #if DEBUG                              Glyph dbugTestGlyph = inputGlyphs[gIndex];  #endif                              inputGlyphs[gIndex].MarkClassDef = classValues[i];                              gIndex++;                          }                        }                      break;                  case 2:                      {                          ClassDefTable.ClassRangeRecord[] records = markAttachmentClassDef.records;                          int len = records.Length;                          for (int n = 0; n < len; ++n)                          {                              ClassDefTable.ClassRangeRecord rec = records[n];                              for (int i = rec.startGlyphId; i <= rec.endGlyphId; ++i)                              {  #if DEBUG                                  Glyph dbugTestGlyph = inputGlyphs[i];  #endif                                  inputGlyphs[i].MarkClassDef = rec.classNo;                              }                          }                      }                      break;              }
Magic Number,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadSubTable,The following statement contains a magic number: switch (lookupType)                  {                      case 1: return ReadLookupType1(reader' subTableStartAt);                      case 2: return ReadLookupType2(reader' subTableStartAt);                      case 3: return ReadLookupType3(reader' subTableStartAt);                      case 4: return ReadLookupType4(reader' subTableStartAt);                      case 5: return ReadLookupType5(reader' subTableStartAt);                      case 6: return ReadLookupType6(reader' subTableStartAt);                      case 7: return ReadLookupType7(reader' subTableStartAt);                      case 8: return ReadLookupType8(reader' subTableStartAt);                      case 9: return ReadLookupType9(reader' subTableStartAt);                  }
Magic Number,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadSubTable,The following statement contains a magic number: switch (lookupType)                  {                      case 1: return ReadLookupType1(reader' subTableStartAt);                      case 2: return ReadLookupType2(reader' subTableStartAt);                      case 3: return ReadLookupType3(reader' subTableStartAt);                      case 4: return ReadLookupType4(reader' subTableStartAt);                      case 5: return ReadLookupType5(reader' subTableStartAt);                      case 6: return ReadLookupType6(reader' subTableStartAt);                      case 7: return ReadLookupType7(reader' subTableStartAt);                      case 8: return ReadLookupType8(reader' subTableStartAt);                      case 9: return ReadLookupType9(reader' subTableStartAt);                  }
Magic Number,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadSubTable,The following statement contains a magic number: switch (lookupType)                  {                      case 1: return ReadLookupType1(reader' subTableStartAt);                      case 2: return ReadLookupType2(reader' subTableStartAt);                      case 3: return ReadLookupType3(reader' subTableStartAt);                      case 4: return ReadLookupType4(reader' subTableStartAt);                      case 5: return ReadLookupType5(reader' subTableStartAt);                      case 6: return ReadLookupType6(reader' subTableStartAt);                      case 7: return ReadLookupType7(reader' subTableStartAt);                      case 8: return ReadLookupType8(reader' subTableStartAt);                      case 9: return ReadLookupType9(reader' subTableStartAt);                  }
Magic Number,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadSubTable,The following statement contains a magic number: switch (lookupType)                  {                      case 1: return ReadLookupType1(reader' subTableStartAt);                      case 2: return ReadLookupType2(reader' subTableStartAt);                      case 3: return ReadLookupType3(reader' subTableStartAt);                      case 4: return ReadLookupType4(reader' subTableStartAt);                      case 5: return ReadLookupType5(reader' subTableStartAt);                      case 6: return ReadLookupType6(reader' subTableStartAt);                      case 7: return ReadLookupType7(reader' subTableStartAt);                      case 8: return ReadLookupType8(reader' subTableStartAt);                      case 9: return ReadLookupType9(reader' subTableStartAt);                  }
Magic Number,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadSubTable,The following statement contains a magic number: switch (lookupType)                  {                      case 1: return ReadLookupType1(reader' subTableStartAt);                      case 2: return ReadLookupType2(reader' subTableStartAt);                      case 3: return ReadLookupType3(reader' subTableStartAt);                      case 4: return ReadLookupType4(reader' subTableStartAt);                      case 5: return ReadLookupType5(reader' subTableStartAt);                      case 6: return ReadLookupType6(reader' subTableStartAt);                      case 7: return ReadLookupType7(reader' subTableStartAt);                      case 8: return ReadLookupType8(reader' subTableStartAt);                      case 9: return ReadLookupType9(reader' subTableStartAt);                  }
Magic Number,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadSubTable,The following statement contains a magic number: switch (lookupType)                  {                      case 1: return ReadLookupType1(reader' subTableStartAt);                      case 2: return ReadLookupType2(reader' subTableStartAt);                      case 3: return ReadLookupType3(reader' subTableStartAt);                      case 4: return ReadLookupType4(reader' subTableStartAt);                      case 5: return ReadLookupType5(reader' subTableStartAt);                      case 6: return ReadLookupType6(reader' subTableStartAt);                      case 7: return ReadLookupType7(reader' subTableStartAt);                      case 8: return ReadLookupType8(reader' subTableStartAt);                      case 9: return ReadLookupType9(reader' subTableStartAt);                  }
Magic Number,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadSubTable,The following statement contains a magic number: switch (lookupType)                  {                      case 1: return ReadLookupType1(reader' subTableStartAt);                      case 2: return ReadLookupType2(reader' subTableStartAt);                      case 3: return ReadLookupType3(reader' subTableStartAt);                      case 4: return ReadLookupType4(reader' subTableStartAt);                      case 5: return ReadLookupType5(reader' subTableStartAt);                      case 6: return ReadLookupType6(reader' subTableStartAt);                      case 7: return ReadLookupType7(reader' subTableStartAt);                      case 8: return ReadLookupType8(reader' subTableStartAt);                      case 9: return ReadLookupType9(reader' subTableStartAt);                  }
Magic Number,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadSubTable,The following statement contains a magic number: switch (lookupType)                  {                      case 1: return ReadLookupType1(reader' subTableStartAt);                      case 2: return ReadLookupType2(reader' subTableStartAt);                      case 3: return ReadLookupType3(reader' subTableStartAt);                      case 4: return ReadLookupType4(reader' subTableStartAt);                      case 5: return ReadLookupType5(reader' subTableStartAt);                      case 6: return ReadLookupType6(reader' subTableStartAt);                      case 7: return ReadLookupType7(reader' subTableStartAt);                      case 8: return ReadLookupType8(reader' subTableStartAt);                      case 9: return ReadLookupType9(reader' subTableStartAt);                  }
Magic Number,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType1,The following statement contains a magic number: switch (format)                  {                      default: throw new NotSupportedException();                      case 1:                          {                              //Single Adjustment Positioning: Format 1                              //Value 	    Type 	        Description                              //uint16 	    PosFormat 	    Format identifier-format = 1                              //Offset16 	    Coverage 	    Offset to Coverage table-from beginning of SinglePos subtable                              //uint16 	    ValueFormat     Defines the types of data in the ValueRecord                              //ValueRecord 	Value 	        Defines positioning value(s)-applied to all glyphs in the Coverage table                               ushort coverage = reader.ReadUInt16();                              ushort valueFormat = reader.ReadUInt16();                              var subTable = new LkSubTableType1(ValueRecord.CreateFrom(reader' valueFormat));                              //-------                              subTable.CoverageTable = CoverageTable.CreateFrom(reader' subTableStartAt + coverage);                              //-------                              return subTable;                          }                      case 2:                          {                              //Single Adjustment Positioning: Format 2                              //Value 	    Type 	        Description                              //USHORT 	    PosFormat 	    Format identifier-format = 2                              //Offset16 	    Coverage 	    Offset to Coverage table-from beginning of SinglePos subtable                              //uint16 	    ValueFormat 	Defines the types of data in the ValueRecord                              //uint16 	    ValueCount 	    Number of ValueRecords                              //ValueRecord 	Value[ValueCount] 	Array of ValueRecords-positioning values applied to glyphs                              ushort coverage = reader.ReadUInt16();                              ushort valueFormat = reader.ReadUInt16();                              ushort valueCount = reader.ReadUInt16();                              var values = new ValueRecord[valueCount];                              for (int n = 0; n < valueCount; ++n)                              {                                  values[n] = ValueRecord.CreateFrom(reader' valueFormat);                              }                              var subTable = new LkSubTableType1(values);                              subTable.CoverageTable = CoverageTable.CreateFrom(reader' subTableStartAt + coverage);                              //-------                              return subTable;                          }                  }
Magic Number,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType2,The following statement contains a magic number: switch (format)                  {                      default:                          return new UnImplementedLookupSubTable(string.Format("GPOS Lookup Table Type 2 Format {0}"' format));                      case 1:                          {                              ushort coverage = reader.ReadUInt16();                              ushort value1Format = reader.ReadUInt16();                              ushort value2Format = reader.ReadUInt16();                              ushort pairSetCount = reader.ReadUInt16();                              ushort[] pairSetOffsetArray = Utils.ReadUInt16Array(reader' pairSetCount);                              PairSetTable[] pairSetTables = new PairSetTable[pairSetCount];                              for (int n = 0; n < pairSetCount; ++n)                              {                                  reader.BaseStream.Seek(subTableStartAt + pairSetOffsetArray[n]' SeekOrigin.Begin);                                  var pairSetTable = new PairSetTable();                                  pairSetTable.ReadFrom(reader' value1Format' value2Format);                                  pairSetTables[n] = pairSetTable;                              }                              var subTable = new LkSubTableType2Fmt1(pairSetTables);                              //coverage                              subTable.CoverageTable = CoverageTable.CreateFrom(reader' subTableStartAt + coverage);                              return subTable;                          }                      case 2:                          {                              ushort coverage = reader.ReadUInt16();                              ushort value1Format = reader.ReadUInt16();                              ushort value2Format = reader.ReadUInt16();                              ushort classDef1_offset = reader.ReadUInt16();                              ushort classDef2_offset = reader.ReadUInt16();                              ushort class1Count = reader.ReadUInt16();                              ushort class2Count = reader.ReadUInt16();                                Lk2Class1Record[] class1Records = new Lk2Class1Record[class1Count];                              for (int c1 = 0; c1 < class1Count; ++c1)                              {                                  //for each c1 record                                    Lk2Class2Record[] class2Records = new Lk2Class2Record[class2Count];                                  for (int c2 = 0; c2 < class2Count; ++c2)                                  {                                      class2Records[c2] = new Lk2Class2Record(                                            ValueRecord.CreateFrom(reader' value1Format)'                                            ValueRecord.CreateFrom(reader' value2Format));                                  }                                  class1Records[c1] = new Lk2Class1Record(class2Records);                              }                                var subTable = new LkSubTableType2Fmt2(class1Records'                                                  ClassDefTable.CreateFrom(reader' subTableStartAt + classDef1_offset)'                                                  ClassDefTable.CreateFrom(reader' subTableStartAt + classDef2_offset));                                  subTable.CoverageTable = CoverageTable.CreateFrom(reader' subTableStartAt + coverage);                              return subTable;                          }                  }
Magic Number,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType7,The following statement contains a magic number: switch (format)                  {                      default:                          return new UnImplementedLookupSubTable(string.Format("GPOS Lookup Sub Table Type 7 Format {0}"' format));                      case 1:                          {                              //Context Positioning Subtable: Format 1                              //ContextPosFormat1 subtable: Simple context positioning                              //Value 	Type 	            Description                              //uint16 	PosFormat 	        Format identifier-format = 1                              //Offset16 	Coverage 	        Offset to Coverage table-from beginning of ContextPos subtable                              //uint16 	PosRuleSetCount 	Number of PosRuleSet tables                              //Offset16 	PosRuleSet[PosRuleSetCount]                              //                              ushort coverageOffset = reader.ReadUInt16();                              ushort posRuleSetCount = reader.ReadUInt16();                              ushort[] posRuleSetOffsets = Utils.ReadUInt16Array(reader' posRuleSetCount);                                LkSubTableType7Fmt1 subTable = new LkSubTableType7Fmt1();                              subTable.PosRuleSetTables = CreateMultiplePosRuleSetTables(subTableStartAt' posRuleSetOffsets' reader);                              subTable.CoverageTable = CoverageTable.CreateFrom(reader' subTableStartAt + coverageOffset);                              return subTable;                          }                      case 2:                          {                              //Context Positioning Subtable: Format 2                              //uint16 	PosFormat 	        Format identifier-format = 2                              //Offset16 	Coverage 	        Offset to Coverage table-from beginning of ContextPos subtable                              //Offset16 	ClassDef 	        Offset to ClassDef table-from beginning of ContextPos subtable                              //uint16 	PosClassSetCnt      Number of PosClassSet tables                              //Offset16 	PosClassSet[PosClassSetCnt] 	Array of offsets to PosClassSet tables-from beginning of ContextPos subtable-ordered by class-may be NULL                                ushort coverageOffset = reader.ReadUInt16();                              ushort classDefOffset = reader.ReadUInt16();                              ushort posClassSetCount = reader.ReadUInt16();                              ushort[] posClassSetOffsets = Utils.ReadUInt16Array(reader' posClassSetCount);                                var subTable = new LkSubTableType7Fmt2();                              subTable.ClassDefOffset = classDefOffset;                                PosClassSetTable[] posClassSetTables = new PosClassSetTable[posClassSetCount];                              subTable.PosClassSetTables = posClassSetTables;                              for (int n = 0; n < posClassSetCount; ++n)                              {                                  posClassSetTables[n] = PosClassSetTable.CreateFrom(reader' subTableStartAt + posClassSetOffsets[n]);                              }                              subTable.CoverageTable = CoverageTable.CreateFrom(reader' subTableStartAt + coverageOffset);                              return subTable;                          }                      case 3:                          {                              //ContextPosFormat3 subtable: Coverage-based context glyph positioning                              //Value 	Type 	    Description                              //uint16 	PosFormat 	Format identifier-format = 3                              //uint16 	GlyphCount 	Number of glyphs in the input sequence                              //uint16 	PosCount 	Number of PosLookupRecords                              //Offset16 	Coverage[GlyphCount] 	Array of offsets to Coverage tables-from beginning of ContextPos subtable                              //struct 	PosLookupRecord[PosCount] Array of positioning lookups-in design order                              var subTable = new LkSubTableType7Fmt3();                              ushort glyphCount = reader.ReadUInt16();                              ushort posCount = reader.ReadUInt16();                              //read each lookahead record                              ushort[] coverageOffsets = Utils.ReadUInt16Array(reader' glyphCount);                              subTable.PosLookupRecords = CreateMultiplePosLookupRecords(reader' posCount);                              subTable.CoverageTables = CoverageTable.CreateMultipleCoverageTables(subTableStartAt' coverageOffsets' reader);                                return subTable;                          }                  }
Magic Number,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType7,The following statement contains a magic number: switch (format)                  {                      default:                          return new UnImplementedLookupSubTable(string.Format("GPOS Lookup Sub Table Type 7 Format {0}"' format));                      case 1:                          {                              //Context Positioning Subtable: Format 1                              //ContextPosFormat1 subtable: Simple context positioning                              //Value 	Type 	            Description                              //uint16 	PosFormat 	        Format identifier-format = 1                              //Offset16 	Coverage 	        Offset to Coverage table-from beginning of ContextPos subtable                              //uint16 	PosRuleSetCount 	Number of PosRuleSet tables                              //Offset16 	PosRuleSet[PosRuleSetCount]                              //                              ushort coverageOffset = reader.ReadUInt16();                              ushort posRuleSetCount = reader.ReadUInt16();                              ushort[] posRuleSetOffsets = Utils.ReadUInt16Array(reader' posRuleSetCount);                                LkSubTableType7Fmt1 subTable = new LkSubTableType7Fmt1();                              subTable.PosRuleSetTables = CreateMultiplePosRuleSetTables(subTableStartAt' posRuleSetOffsets' reader);                              subTable.CoverageTable = CoverageTable.CreateFrom(reader' subTableStartAt + coverageOffset);                              return subTable;                          }                      case 2:                          {                              //Context Positioning Subtable: Format 2                              //uint16 	PosFormat 	        Format identifier-format = 2                              //Offset16 	Coverage 	        Offset to Coverage table-from beginning of ContextPos subtable                              //Offset16 	ClassDef 	        Offset to ClassDef table-from beginning of ContextPos subtable                              //uint16 	PosClassSetCnt      Number of PosClassSet tables                              //Offset16 	PosClassSet[PosClassSetCnt] 	Array of offsets to PosClassSet tables-from beginning of ContextPos subtable-ordered by class-may be NULL                                ushort coverageOffset = reader.ReadUInt16();                              ushort classDefOffset = reader.ReadUInt16();                              ushort posClassSetCount = reader.ReadUInt16();                              ushort[] posClassSetOffsets = Utils.ReadUInt16Array(reader' posClassSetCount);                                var subTable = new LkSubTableType7Fmt2();                              subTable.ClassDefOffset = classDefOffset;                                PosClassSetTable[] posClassSetTables = new PosClassSetTable[posClassSetCount];                              subTable.PosClassSetTables = posClassSetTables;                              for (int n = 0; n < posClassSetCount; ++n)                              {                                  posClassSetTables[n] = PosClassSetTable.CreateFrom(reader' subTableStartAt + posClassSetOffsets[n]);                              }                              subTable.CoverageTable = CoverageTable.CreateFrom(reader' subTableStartAt + coverageOffset);                              return subTable;                          }                      case 3:                          {                              //ContextPosFormat3 subtable: Coverage-based context glyph positioning                              //Value 	Type 	    Description                              //uint16 	PosFormat 	Format identifier-format = 3                              //uint16 	GlyphCount 	Number of glyphs in the input sequence                              //uint16 	PosCount 	Number of PosLookupRecords                              //Offset16 	Coverage[GlyphCount] 	Array of offsets to Coverage tables-from beginning of ContextPos subtable                              //struct 	PosLookupRecord[PosCount] Array of positioning lookups-in design order                              var subTable = new LkSubTableType7Fmt3();                              ushort glyphCount = reader.ReadUInt16();                              ushort posCount = reader.ReadUInt16();                              //read each lookahead record                              ushort[] coverageOffsets = Utils.ReadUInt16Array(reader' glyphCount);                              subTable.PosLookupRecords = CreateMultiplePosLookupRecords(reader' posCount);                              subTable.CoverageTables = CoverageTable.CreateMultipleCoverageTables(subTableStartAt' coverageOffsets' reader);                                return subTable;                          }                  }
Magic Number,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType8,The following statement contains a magic number: switch (format)                  {                      default:                          return new UnImplementedLookupSubTable(string.Format("GPOS Lookup Table Type 8 Format {0}"' format));                      case 1:                          {                              //Chaining Context Positioning  Format 1: Simple Chaining Context Glyph Positioning                              //uint16 	PosFormat 	        Format identifier-format = 1                              //Offset16 	Coverage 	        Offset to Coverage table-from beginning of ContextPos subtable                              //uint16 	ChainPosRuleSetCount 	Number of ChainPosRuleSet tables                              //Offset16 	ChainPosRuleSet[ChainPosRuleSetCount] 	Array of offsets to ChainPosRuleSet tables-from beginning of ContextPos subtable-ordered by Coverage Index                                ushort coverageOffset = reader.ReadUInt16();                              ushort chainPosRuleSetCount = reader.ReadUInt16();                              ushort[] chainPosRuleSetOffsetList = Utils.ReadUInt16Array(reader' chainPosRuleSetCount);                                LkSubTableType8Fmt1 subTable = new LkSubTableType8Fmt1();                              subTable.PosRuleSetTables = CreateMultiplePosRuleSetTables(subTableStartAt' chainPosRuleSetOffsetList' reader);                              subTable.CoverageTable = CoverageTable.CreateFrom(reader' subTableStartAt + coverageOffset);                              return subTable;                          }                      case 2:                          {                              //Chaining Context Positioning Format 2: Class-based Chaining Context Glyph Positioning                              //uint16 	PosFormat 	                Format identifier-format = 2                              //Offset16 	Coverage 	                Offset to Coverage table-from beginning of ChainContextPos subtable                              //Offset16 	BacktrackClassDef 	        Offset to ClassDef table containing backtrack sequence context-from beginning of ChainContextPos subtable                              //Offset16 	InputClassDef 	            Offset to ClassDef table containing input sequence context-from beginning of ChainContextPos subtable                              //Offset16 	LookaheadClassDef                   	Offset to ClassDef table containing lookahead sequence context-from beginning of ChainContextPos subtable                              //uint16 	ChainPosClassSetCnt 	                Number of ChainPosClassSet tables                              //Offset16 	ChainPosClassSet[ChainPosClassSetCnt] 	Array of offsets to ChainPosClassSet tables-from beginning of ChainContextPos subtable-ordered by input class-may be NULL                                ushort coverageOffset = reader.ReadUInt16();                              ushort backTrackClassDefOffset = reader.ReadUInt16();                              ushort inpuClassDefOffset = reader.ReadUInt16();                              ushort lookadheadClassDefOffset = reader.ReadUInt16();                              ushort chainPosClassSetCnt = reader.ReadUInt16();                              ushort[] chainPosClassSetOffsetArray = Utils.ReadUInt16Array(reader' chainPosClassSetCnt);                                LkSubTableType8Fmt2 subTable = new LkSubTableType8Fmt2(chainPosClassSetOffsetArray);                              subTable.BacktrackClassDefOffset = backTrackClassDefOffset;                              subTable.InputClassDefOffset = inpuClassDefOffset;                              subTable.LookaheadClassDefOffset = lookadheadClassDefOffset;                              //----------                              PosClassSetTable[] posClassSetTables = new PosClassSetTable[chainPosClassSetCnt];                              for (int n = 0; n < chainPosClassSetCnt; ++n)                              {                                  posClassSetTables[n] = PosClassSetTable.CreateFrom(reader' subTableStartAt + chainPosClassSetOffsetArray[n]);                              }                              subTable.PosClassSetTables = posClassSetTables;                                subTable.CoverageTable = CoverageTable.CreateFrom(reader' subTableStartAt + coverageOffset);                              return subTable;                          }                      case 3:                          {                              //Chaining Context Positioning Format 3: Coverage-based Chaining Context Glyph Positioning                              //uint16 	PosFormat 	                    Format identifier-format = 3                              //uint16 	BacktrackGlyphCount 	        Number of glyphs in the backtracking sequence                              //Offset16 	Coverage[BacktrackGlyphCount] 	Array of offsets to coverage tables in backtracking sequence' in glyph sequence order                              //uint16 	InputGlyphCount 	            Number of glyphs in input sequence                              //Offset16 	Coverage[InputGlyphCount] 	    Array of offsets to coverage tables in input sequence' in glyph sequence order                              //uint16 	LookaheadGlyphCount 	        Number of glyphs in lookahead sequence                              //Offset16 	Coverage[LookaheadGlyphCount] 	Array of offsets to coverage tables in lookahead sequence' in glyph sequence order                              //uint16 	PosCount 	                    Number of PosLookupRecords                              //struct 	PosLookupRecord[PosCount] 	    Array of PosLookupRecords'in design order                                var subTable = new LkSubTableType8Fmt3();                                ushort backtrackGlyphCount = reader.ReadUInt16();                              ushort[] backtrackCoverageOffsets = Utils.ReadUInt16Array(reader' backtrackGlyphCount);                              ushort inputGlyphCount = reader.ReadUInt16();                              ushort[] inputGlyphCoverageOffsets = Utils.ReadUInt16Array(reader' inputGlyphCount);                                ushort lookaheadGlyphCount = reader.ReadUInt16();                              ushort[] lookaheadCoverageOffsets = Utils.ReadUInt16Array(reader' lookaheadGlyphCount);                                ushort posCount = reader.ReadUInt16();                              subTable.PosLookupRecords = CreateMultiplePosLookupRecords(reader' posCount);                                subTable.BacktrackCoverages = CoverageTable.CreateMultipleCoverageTables(subTableStartAt' backtrackCoverageOffsets' reader);                              subTable.InputGlyphCoverages = CoverageTable.CreateMultipleCoverageTables(subTableStartAt' inputGlyphCoverageOffsets' reader);                              subTable.LookaheadCoverages = CoverageTable.CreateMultipleCoverageTables(subTableStartAt' lookaheadCoverageOffsets' reader);                                return subTable;                          }                  }
Magic Number,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType8,The following statement contains a magic number: switch (format)                  {                      default:                          return new UnImplementedLookupSubTable(string.Format("GPOS Lookup Table Type 8 Format {0}"' format));                      case 1:                          {                              //Chaining Context Positioning  Format 1: Simple Chaining Context Glyph Positioning                              //uint16 	PosFormat 	        Format identifier-format = 1                              //Offset16 	Coverage 	        Offset to Coverage table-from beginning of ContextPos subtable                              //uint16 	ChainPosRuleSetCount 	Number of ChainPosRuleSet tables                              //Offset16 	ChainPosRuleSet[ChainPosRuleSetCount] 	Array of offsets to ChainPosRuleSet tables-from beginning of ContextPos subtable-ordered by Coverage Index                                ushort coverageOffset = reader.ReadUInt16();                              ushort chainPosRuleSetCount = reader.ReadUInt16();                              ushort[] chainPosRuleSetOffsetList = Utils.ReadUInt16Array(reader' chainPosRuleSetCount);                                LkSubTableType8Fmt1 subTable = new LkSubTableType8Fmt1();                              subTable.PosRuleSetTables = CreateMultiplePosRuleSetTables(subTableStartAt' chainPosRuleSetOffsetList' reader);                              subTable.CoverageTable = CoverageTable.CreateFrom(reader' subTableStartAt + coverageOffset);                              return subTable;                          }                      case 2:                          {                              //Chaining Context Positioning Format 2: Class-based Chaining Context Glyph Positioning                              //uint16 	PosFormat 	                Format identifier-format = 2                              //Offset16 	Coverage 	                Offset to Coverage table-from beginning of ChainContextPos subtable                              //Offset16 	BacktrackClassDef 	        Offset to ClassDef table containing backtrack sequence context-from beginning of ChainContextPos subtable                              //Offset16 	InputClassDef 	            Offset to ClassDef table containing input sequence context-from beginning of ChainContextPos subtable                              //Offset16 	LookaheadClassDef                   	Offset to ClassDef table containing lookahead sequence context-from beginning of ChainContextPos subtable                              //uint16 	ChainPosClassSetCnt 	                Number of ChainPosClassSet tables                              //Offset16 	ChainPosClassSet[ChainPosClassSetCnt] 	Array of offsets to ChainPosClassSet tables-from beginning of ChainContextPos subtable-ordered by input class-may be NULL                                ushort coverageOffset = reader.ReadUInt16();                              ushort backTrackClassDefOffset = reader.ReadUInt16();                              ushort inpuClassDefOffset = reader.ReadUInt16();                              ushort lookadheadClassDefOffset = reader.ReadUInt16();                              ushort chainPosClassSetCnt = reader.ReadUInt16();                              ushort[] chainPosClassSetOffsetArray = Utils.ReadUInt16Array(reader' chainPosClassSetCnt);                                LkSubTableType8Fmt2 subTable = new LkSubTableType8Fmt2(chainPosClassSetOffsetArray);                              subTable.BacktrackClassDefOffset = backTrackClassDefOffset;                              subTable.InputClassDefOffset = inpuClassDefOffset;                              subTable.LookaheadClassDefOffset = lookadheadClassDefOffset;                              //----------                              PosClassSetTable[] posClassSetTables = new PosClassSetTable[chainPosClassSetCnt];                              for (int n = 0; n < chainPosClassSetCnt; ++n)                              {                                  posClassSetTables[n] = PosClassSetTable.CreateFrom(reader' subTableStartAt + chainPosClassSetOffsetArray[n]);                              }                              subTable.PosClassSetTables = posClassSetTables;                                subTable.CoverageTable = CoverageTable.CreateFrom(reader' subTableStartAt + coverageOffset);                              return subTable;                          }                      case 3:                          {                              //Chaining Context Positioning Format 3: Coverage-based Chaining Context Glyph Positioning                              //uint16 	PosFormat 	                    Format identifier-format = 3                              //uint16 	BacktrackGlyphCount 	        Number of glyphs in the backtracking sequence                              //Offset16 	Coverage[BacktrackGlyphCount] 	Array of offsets to coverage tables in backtracking sequence' in glyph sequence order                              //uint16 	InputGlyphCount 	            Number of glyphs in input sequence                              //Offset16 	Coverage[InputGlyphCount] 	    Array of offsets to coverage tables in input sequence' in glyph sequence order                              //uint16 	LookaheadGlyphCount 	        Number of glyphs in lookahead sequence                              //Offset16 	Coverage[LookaheadGlyphCount] 	Array of offsets to coverage tables in lookahead sequence' in glyph sequence order                              //uint16 	PosCount 	                    Number of PosLookupRecords                              //struct 	PosLookupRecord[PosCount] 	    Array of PosLookupRecords'in design order                                var subTable = new LkSubTableType8Fmt3();                                ushort backtrackGlyphCount = reader.ReadUInt16();                              ushort[] backtrackCoverageOffsets = Utils.ReadUInt16Array(reader' backtrackGlyphCount);                              ushort inputGlyphCount = reader.ReadUInt16();                              ushort[] inputGlyphCoverageOffsets = Utils.ReadUInt16Array(reader' inputGlyphCount);                                ushort lookaheadGlyphCount = reader.ReadUInt16();                              ushort[] lookaheadCoverageOffsets = Utils.ReadUInt16Array(reader' lookaheadGlyphCount);                                ushort posCount = reader.ReadUInt16();                              subTable.PosLookupRecords = CreateMultiplePosLookupRecords(reader' posCount);                                subTable.BacktrackCoverages = CoverageTable.CreateMultipleCoverageTables(subTableStartAt' backtrackCoverageOffsets' reader);                              subTable.InputGlyphCoverages = CoverageTable.CreateMultipleCoverageTables(subTableStartAt' inputGlyphCoverageOffsets' reader);                              subTable.LookaheadCoverages = CoverageTable.CreateMultipleCoverageTables(subTableStartAt' lookaheadCoverageOffsets' reader);                                return subTable;                          }                  }
Magic Number,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType9,The following statement contains a magic number: extensionLookupType == 9
Magic Number,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType9,The following statement contains a magic number: lookupType = 9;
Magic Number,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadSubTable,The following statement contains a magic number: switch (lookupType)                  {                      case 1: return ReadLookupType1(reader' subTableStartAt);                      case 2: return ReadLookupType2(reader' subTableStartAt);                      case 3: return ReadLookupType3(reader' subTableStartAt);                      case 4: return ReadLookupType4(reader' subTableStartAt);                      case 5: return ReadLookupType5(reader' subTableStartAt);                      case 6: return ReadLookupType6(reader' subTableStartAt);                      case 7: return ReadLookupType7(reader' subTableStartAt);                      case 8: return ReadLookupType8(reader' subTableStartAt);                  }
Magic Number,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadSubTable,The following statement contains a magic number: switch (lookupType)                  {                      case 1: return ReadLookupType1(reader' subTableStartAt);                      case 2: return ReadLookupType2(reader' subTableStartAt);                      case 3: return ReadLookupType3(reader' subTableStartAt);                      case 4: return ReadLookupType4(reader' subTableStartAt);                      case 5: return ReadLookupType5(reader' subTableStartAt);                      case 6: return ReadLookupType6(reader' subTableStartAt);                      case 7: return ReadLookupType7(reader' subTableStartAt);                      case 8: return ReadLookupType8(reader' subTableStartAt);                  }
Magic Number,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadSubTable,The following statement contains a magic number: switch (lookupType)                  {                      case 1: return ReadLookupType1(reader' subTableStartAt);                      case 2: return ReadLookupType2(reader' subTableStartAt);                      case 3: return ReadLookupType3(reader' subTableStartAt);                      case 4: return ReadLookupType4(reader' subTableStartAt);                      case 5: return ReadLookupType5(reader' subTableStartAt);                      case 6: return ReadLookupType6(reader' subTableStartAt);                      case 7: return ReadLookupType7(reader' subTableStartAt);                      case 8: return ReadLookupType8(reader' subTableStartAt);                  }
Magic Number,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadSubTable,The following statement contains a magic number: switch (lookupType)                  {                      case 1: return ReadLookupType1(reader' subTableStartAt);                      case 2: return ReadLookupType2(reader' subTableStartAt);                      case 3: return ReadLookupType3(reader' subTableStartAt);                      case 4: return ReadLookupType4(reader' subTableStartAt);                      case 5: return ReadLookupType5(reader' subTableStartAt);                      case 6: return ReadLookupType6(reader' subTableStartAt);                      case 7: return ReadLookupType7(reader' subTableStartAt);                      case 8: return ReadLookupType8(reader' subTableStartAt);                  }
Magic Number,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadSubTable,The following statement contains a magic number: switch (lookupType)                  {                      case 1: return ReadLookupType1(reader' subTableStartAt);                      case 2: return ReadLookupType2(reader' subTableStartAt);                      case 3: return ReadLookupType3(reader' subTableStartAt);                      case 4: return ReadLookupType4(reader' subTableStartAt);                      case 5: return ReadLookupType5(reader' subTableStartAt);                      case 6: return ReadLookupType6(reader' subTableStartAt);                      case 7: return ReadLookupType7(reader' subTableStartAt);                      case 8: return ReadLookupType8(reader' subTableStartAt);                  }
Magic Number,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadSubTable,The following statement contains a magic number: switch (lookupType)                  {                      case 1: return ReadLookupType1(reader' subTableStartAt);                      case 2: return ReadLookupType2(reader' subTableStartAt);                      case 3: return ReadLookupType3(reader' subTableStartAt);                      case 4: return ReadLookupType4(reader' subTableStartAt);                      case 5: return ReadLookupType5(reader' subTableStartAt);                      case 6: return ReadLookupType6(reader' subTableStartAt);                      case 7: return ReadLookupType7(reader' subTableStartAt);                      case 8: return ReadLookupType8(reader' subTableStartAt);                  }
Magic Number,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadSubTable,The following statement contains a magic number: switch (lookupType)                  {                      case 1: return ReadLookupType1(reader' subTableStartAt);                      case 2: return ReadLookupType2(reader' subTableStartAt);                      case 3: return ReadLookupType3(reader' subTableStartAt);                      case 4: return ReadLookupType4(reader' subTableStartAt);                      case 5: return ReadLookupType5(reader' subTableStartAt);                      case 6: return ReadLookupType6(reader' subTableStartAt);                      case 7: return ReadLookupType7(reader' subTableStartAt);                      case 8: return ReadLookupType8(reader' subTableStartAt);                  }
Magic Number,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType1,The following statement contains a magic number: switch (format)                  {                      default: throw new NotSupportedException();                      case 1:                          {                              short deltaGlyph = reader.ReadInt16();                              CoverageTable coverageTable = CoverageTable.CreateFrom(reader' subTableStartAt + coverage);                              return new LkSubTableT1Fmt1(coverageTable' deltaGlyph);                          }                      case 2:                          {                              ushort glyphCount = reader.ReadUInt16();                              ushort[] substituteGlyphs = Utils.ReadUInt16Array(reader' glyphCount); // 	Array of substitute GlyphIDs-ordered by Coverage Index                                                               CoverageTable coverageTable = CoverageTable.CreateFrom(reader' subTableStartAt + coverage);                              return new LkSubTableT1Fmt2(coverageTable' substituteGlyphs);                          }                  }
Magic Number,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType6,The following statement contains a magic number: switch (format)                  {                      default: throw new NotSupportedException();                      case 1:                          {                              //6.1 Chaining Context Substitution Format 1: Simple Chaining Context Glyph Substitution                               //-------------------------------                              //ChainContextSubstFormat1 subtable: Simple context glyph substitution                              //-------------------------------                              //Type  	Name 	                Description                              //uint16 	SubstFormat 	        Format identifier-format = 1                              //Offset16 	Coverage 	            Offset to Coverage table-from beginning of Substitution table                              //uint16 	ChainSubRuleSetCount 	Number of ChainSubRuleSet tables-must equal GlyphCount in Coverage table                              //Offset16 	ChainSubRuleSet[ChainSubRuleSetCount] 	Array of offsets to ChainSubRuleSet tables-from beginning of Substitution table-ordered by Coverage Index                              //-------------------------------                                var subTable = new LkSubTableT6Fmt1();                              ushort coverage = reader.ReadUInt16();                              ushort chainSubRulesetCount = reader.ReadUInt16();                              ushort[] chainSubRulesetOffsets = Utils.ReadUInt16Array(reader' chainSubRulesetCount);                              ChainSubRuleSetTable[] subRuleSets = subTable.SubRuleSets = new ChainSubRuleSetTable[chainSubRulesetCount];                              for (int n = 0; n < chainSubRulesetCount; ++n)                              {                                  subRuleSets[n] = ChainSubRuleSetTable.CreateFrom(reader' subTableStartAt + chainSubRulesetOffsets[n]);                              }                              //----------------------------                              subTable.CoverageTable = CoverageTable.CreateFrom(reader' subTableStartAt + coverage);                              return subTable;                          }                      case 2:                          {                              //-------------------                              //ChainContextSubstFormat2 subtable: Class-based chaining context glyph substitution                              //-------------------                              //Type 	    Name 	            Description                              //uint16 	SubstFormat 	    Format identifier-format = 2                              //Offset16 	Coverage 	        Offset to Coverage table-from beginning of Substitution table                              //Offset16 	BacktrackClassDef 	Offset to glyph ClassDef table containing backtrack sequence data-from beginning of Substitution table                              //Offset16 	InputClassDef 	    Offset to glyph ClassDef table containing input sequence data-from beginning of Substitution table                              //Offset16 	LookaheadClassDef 	Offset to glyph ClassDef table containing lookahead sequence data-from beginning of Substitution table                              //uint16 	ChainSubClassSetCnt 	Number of ChainSubClassSet tables                              //Offset16 	ChainSubClassSet[ChainSubClassSetCnt] 	Array of offsets to ChainSubClassSet tables-from beginning of Substitution table-ordered by input class-may be NULL                              //-------------------                              var subTable = new LkSubTableT6Fmt2();                              ushort coverage = reader.ReadUInt16();                              ushort backtrackClassDefOffset = reader.ReadUInt16();                              ushort inputClassDefOffset = reader.ReadUInt16();                              ushort lookaheadClassDefOffset = reader.ReadUInt16();                              ushort chainSubClassSetCount = reader.ReadUInt16();                              ushort[] chainSubClassSetOffsets = Utils.ReadUInt16Array(reader' chainSubClassSetCount);                              //                              subTable.BacktrackClassDef = ClassDefTable.CreateFrom(reader' subTableStartAt + backtrackClassDefOffset);                              subTable.InputClassDef = ClassDefTable.CreateFrom(reader' subTableStartAt + inputClassDefOffset);                              subTable.LookaheadClassDef = ClassDefTable.CreateFrom(reader' subTableStartAt + lookaheadClassDefOffset);                              if (chainSubClassSetCount != 0)                              {                                  ChainSubClassSet[] chainSubClassSets = subTable.ChainSubClassSets = new ChainSubClassSet[chainSubClassSetCount];                                  for (int n = 0; n < chainSubClassSetCount; ++n)                                  {                                      chainSubClassSets[n] = ChainSubClassSet.CreateFrom(reader' subTableStartAt + chainSubClassSetOffsets[n]);                                  }                              }                                subTable.CoverageTable = CoverageTable.CreateFrom(reader' subTableStartAt + coverage);                              return subTable;                          }                      case 3:                          {                              //-------------------                              //6.3 Chaining Context Substitution Format 3: Coverage-based Chaining Context Glyph Substitution                              //-------------------                              //uint16 	BacktrackGlyphCount 	        Number of glyphs in the backtracking sequence                              //Offset16 	Coverage[BacktrackGlyphCount] 	Array of offsets to coverage tables in backtracking sequence' in glyph sequence order                              //uint16 	InputGlyphCount 	            Number of glyphs in input sequence                              //Offset16 	Coverage[InputGlyphCount] 	    Array of offsets to coverage tables in input sequence' in glyph sequence order                              //uint16 	LookaheadGlyphCount 	        Number of glyphs in lookahead sequence                              //Offset16 	Coverage[LookaheadGlyphCount] 	Array of offsets to coverage tables in lookahead sequence' in glyph sequence order                              //uint16 	SubstCount 	                    Number of SubstLookupRecords                              //struct 	SubstLookupRecord[SubstCount] 	Array of SubstLookupRecords' in design order                              //-------------------                              LkSubTableT6Fmt3 subTable = new LkSubTableT6Fmt3();                              ushort backtrackingGlyphCount = reader.ReadUInt16();                              ushort[] backtrackingCoverageOffsets = Utils.ReadUInt16Array(reader' backtrackingGlyphCount);                              ushort inputGlyphCount = reader.ReadUInt16();                              ushort[] inputGlyphCoverageOffsets = Utils.ReadUInt16Array(reader' inputGlyphCount);                              ushort lookAheadGlyphCount = reader.ReadUInt16();                              ushort[] lookAheadCoverageOffsets = Utils.ReadUInt16Array(reader' lookAheadGlyphCount);                              ushort substCount = reader.ReadUInt16();                              subTable.SubstLookupRecords = SubstLookupRecord.CreateSubstLookupRecords(reader' substCount);                                subTable.BacktrackingCoverages = CoverageTable.CreateMultipleCoverageTables(subTableStartAt' backtrackingCoverageOffsets' reader);                              subTable.InputCoverages = CoverageTable.CreateMultipleCoverageTables(subTableStartAt' inputGlyphCoverageOffsets' reader);                              subTable.LookaheadCoverages = CoverageTable.CreateMultipleCoverageTables(subTableStartAt' lookAheadCoverageOffsets' reader);                                return subTable;                          }                  }
Magic Number,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType6,The following statement contains a magic number: switch (format)                  {                      default: throw new NotSupportedException();                      case 1:                          {                              //6.1 Chaining Context Substitution Format 1: Simple Chaining Context Glyph Substitution                               //-------------------------------                              //ChainContextSubstFormat1 subtable: Simple context glyph substitution                              //-------------------------------                              //Type  	Name 	                Description                              //uint16 	SubstFormat 	        Format identifier-format = 1                              //Offset16 	Coverage 	            Offset to Coverage table-from beginning of Substitution table                              //uint16 	ChainSubRuleSetCount 	Number of ChainSubRuleSet tables-must equal GlyphCount in Coverage table                              //Offset16 	ChainSubRuleSet[ChainSubRuleSetCount] 	Array of offsets to ChainSubRuleSet tables-from beginning of Substitution table-ordered by Coverage Index                              //-------------------------------                                var subTable = new LkSubTableT6Fmt1();                              ushort coverage = reader.ReadUInt16();                              ushort chainSubRulesetCount = reader.ReadUInt16();                              ushort[] chainSubRulesetOffsets = Utils.ReadUInt16Array(reader' chainSubRulesetCount);                              ChainSubRuleSetTable[] subRuleSets = subTable.SubRuleSets = new ChainSubRuleSetTable[chainSubRulesetCount];                              for (int n = 0; n < chainSubRulesetCount; ++n)                              {                                  subRuleSets[n] = ChainSubRuleSetTable.CreateFrom(reader' subTableStartAt + chainSubRulesetOffsets[n]);                              }                              //----------------------------                              subTable.CoverageTable = CoverageTable.CreateFrom(reader' subTableStartAt + coverage);                              return subTable;                          }                      case 2:                          {                              //-------------------                              //ChainContextSubstFormat2 subtable: Class-based chaining context glyph substitution                              //-------------------                              //Type 	    Name 	            Description                              //uint16 	SubstFormat 	    Format identifier-format = 2                              //Offset16 	Coverage 	        Offset to Coverage table-from beginning of Substitution table                              //Offset16 	BacktrackClassDef 	Offset to glyph ClassDef table containing backtrack sequence data-from beginning of Substitution table                              //Offset16 	InputClassDef 	    Offset to glyph ClassDef table containing input sequence data-from beginning of Substitution table                              //Offset16 	LookaheadClassDef 	Offset to glyph ClassDef table containing lookahead sequence data-from beginning of Substitution table                              //uint16 	ChainSubClassSetCnt 	Number of ChainSubClassSet tables                              //Offset16 	ChainSubClassSet[ChainSubClassSetCnt] 	Array of offsets to ChainSubClassSet tables-from beginning of Substitution table-ordered by input class-may be NULL                              //-------------------                              var subTable = new LkSubTableT6Fmt2();                              ushort coverage = reader.ReadUInt16();                              ushort backtrackClassDefOffset = reader.ReadUInt16();                              ushort inputClassDefOffset = reader.ReadUInt16();                              ushort lookaheadClassDefOffset = reader.ReadUInt16();                              ushort chainSubClassSetCount = reader.ReadUInt16();                              ushort[] chainSubClassSetOffsets = Utils.ReadUInt16Array(reader' chainSubClassSetCount);                              //                              subTable.BacktrackClassDef = ClassDefTable.CreateFrom(reader' subTableStartAt + backtrackClassDefOffset);                              subTable.InputClassDef = ClassDefTable.CreateFrom(reader' subTableStartAt + inputClassDefOffset);                              subTable.LookaheadClassDef = ClassDefTable.CreateFrom(reader' subTableStartAt + lookaheadClassDefOffset);                              if (chainSubClassSetCount != 0)                              {                                  ChainSubClassSet[] chainSubClassSets = subTable.ChainSubClassSets = new ChainSubClassSet[chainSubClassSetCount];                                  for (int n = 0; n < chainSubClassSetCount; ++n)                                  {                                      chainSubClassSets[n] = ChainSubClassSet.CreateFrom(reader' subTableStartAt + chainSubClassSetOffsets[n]);                                  }                              }                                subTable.CoverageTable = CoverageTable.CreateFrom(reader' subTableStartAt + coverage);                              return subTable;                          }                      case 3:                          {                              //-------------------                              //6.3 Chaining Context Substitution Format 3: Coverage-based Chaining Context Glyph Substitution                              //-------------------                              //uint16 	BacktrackGlyphCount 	        Number of glyphs in the backtracking sequence                              //Offset16 	Coverage[BacktrackGlyphCount] 	Array of offsets to coverage tables in backtracking sequence' in glyph sequence order                              //uint16 	InputGlyphCount 	            Number of glyphs in input sequence                              //Offset16 	Coverage[InputGlyphCount] 	    Array of offsets to coverage tables in input sequence' in glyph sequence order                              //uint16 	LookaheadGlyphCount 	        Number of glyphs in lookahead sequence                              //Offset16 	Coverage[LookaheadGlyphCount] 	Array of offsets to coverage tables in lookahead sequence' in glyph sequence order                              //uint16 	SubstCount 	                    Number of SubstLookupRecords                              //struct 	SubstLookupRecord[SubstCount] 	Array of SubstLookupRecords' in design order                              //-------------------                              LkSubTableT6Fmt3 subTable = new LkSubTableT6Fmt3();                              ushort backtrackingGlyphCount = reader.ReadUInt16();                              ushort[] backtrackingCoverageOffsets = Utils.ReadUInt16Array(reader' backtrackingGlyphCount);                              ushort inputGlyphCount = reader.ReadUInt16();                              ushort[] inputGlyphCoverageOffsets = Utils.ReadUInt16Array(reader' inputGlyphCount);                              ushort lookAheadGlyphCount = reader.ReadUInt16();                              ushort[] lookAheadCoverageOffsets = Utils.ReadUInt16Array(reader' lookAheadGlyphCount);                              ushort substCount = reader.ReadUInt16();                              subTable.SubstLookupRecords = SubstLookupRecord.CreateSubstLookupRecords(reader' substCount);                                subTable.BacktrackingCoverages = CoverageTable.CreateMultipleCoverageTables(subTableStartAt' backtrackingCoverageOffsets' reader);                              subTable.InputCoverages = CoverageTable.CreateMultipleCoverageTables(subTableStartAt' inputGlyphCoverageOffsets' reader);                              subTable.LookaheadCoverages = CoverageTable.CreateMultipleCoverageTables(subTableStartAt' lookAheadCoverageOffsets' reader);                                return subTable;                          }                  }
Magic Number,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType7,The following statement contains a magic number: extensionLookupType == 7
Magic Number,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadLookupType7,The following statement contains a magic number: lookupType = 7;
Magic Number,Typography.OpenFont.Tables,LkSubTableType1,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,LkSubTableType1,The following statement contains a magic number: this.Format = 2;
Magic Number,Typography.OpenFont.Tables,AnchorPoint,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.Others.cs,CreateFrom,The following statement contains a magic number: switch (anchorPoint.format = reader.ReadUInt16())                  {                      default: throw new NotSupportedException();                      case 1:                          {                              // AnchorFormat1 table: Design units only                              //AnchorFormat1 consists of a format identifier (AnchorFormat) and a pair of design unit coordinates (XCoordinate and YCoordinate)                              //that specify the location of the anchor point.                               //This format has the benefits of small size and simplicity'                              //but the anchor point cannot be hinted to adjust its position for different device resolutions.                              //Value 	Type 	        Description                              //uint16 	AnchorFormat 	Format identifier' = 1                              //int16 	XCoordinate 	Horizontal value' in design units                              //int16 	YCoordinate 	Vertical value' in design units                              anchorPoint.xcoord = reader.ReadInt16();                              anchorPoint.ycoord = reader.ReadInt16();                          }                          break;                      case 2:                          {                              //Anchor Table: Format 2                                //Like AnchorFormat1' AnchorFormat2 specifies a format identifier (AnchorFormat) and                              //a pair of design unit coordinates for the anchor point (Xcoordinate and Ycoordinate).                                //For fine-tuning the location of the anchor point'                              //AnchorFormat2 also provides an index to a glyph contour point (AnchorPoint)                               //that is on the outline of a glyph (AnchorPoint).***                              //Hinting can be used to move the AnchorPoint. In the rendered text'                              //the AnchorPoint will provide the final positioning data for a given ppem size.                                //Example 16 at the end of this chapter uses AnchorFormat2.                                  //AnchorFormat2 table: Design units plus contour point                              //Value 	Type 	        Description                              //uint16 	AnchorFormat 	Format identifier' = 2                              //int16 	XCoordinate 	Horizontal value' in design units                              //int16 	YCoordinate 	Vertical value' in design units                              //uint16 	AnchorPoint 	Index to glyph contour point                                anchorPoint.xcoord = reader.ReadInt16();                              anchorPoint.ycoord = reader.ReadInt16();                              anchorPoint.refGlyphContourPoint = reader.ReadUInt16();                            }                          break;                      case 3:                          {                                //Anchor Table: Format 3                                //Like AnchorFormat1' AnchorFormat3 specifies a format identifier (AnchorFormat) and                               //locates an anchor point (Xcoordinate and Ycoordinate).                              //And' like AnchorFormat 2' it permits fine adjustments in variable fonts to the coordinate values.                               //However' AnchorFormat3 uses Device tables' rather than a contour point' for this adjustment.                                //With a Device table' a client can adjust the position of the anchor point for any font size and device resolution.                              //AnchorFormat3 can specify offsets to Device tables for the the X coordinate (XDeviceTable)                               //and the Y coordinate (YDeviceTable).                               //If only one coordinate requires adjustment'                               //the offset to the Device table may be set to NULL for the other coordinate.                                //In variable fonts' AnchorFormat3 must be used to reference variation data to adjust anchor points for different variation instances'                              //if needed.                              //In this case' AnchorFormat3 specifies an offset to a VariationIndex table'                              //which is a variant of the Device table used for variations.                              //If no VariationIndex table is used for a particular anchor point X or Y coordinate'                               //then that value is used for all variation instances.                              //While separate VariationIndex table references are required for each value that requires variation'                              //two or more values that require the same variation-data values can have offsets that point to the same VariationIndex table' and two or more VariationIndex tables can reference the same variation data entries.                                //Example 17 at the end of the chapter shows an AnchorFormat3 table.                                  //AnchorFormat3 table: Design units plus Device or VariationIndex tables                              //Value 	Type 	        Description                              //uint16 	AnchorFormat 	Format identifier' = 3                              //int16 	XCoordinate 	Horizontal value' in design units                              //int16 	YCoordinate 	Vertical value' in design units                              //Offset16 	XDeviceTable 	Offset to Device table (non-variable font) / VariationIndex table (variable font) for X coordinate' from beginning of Anchor table (may be NULL)                              //Offset16 	YDeviceTable 	Offset to Device table (non-variable font) / VariationIndex table (variable font) for Y coordinate' from beginning of Anchor table (may be NULL)                                anchorPoint.xcoord = reader.ReadInt16();                              anchorPoint.ycoord = reader.ReadInt16();                              anchorPoint.xdeviceTableOffset = reader.ReadUInt16();                              anchorPoint.ydeviceTableOffset = reader.ReadUInt16();                          }                          break;                  }
Magic Number,Typography.OpenFont.Tables,AnchorPoint,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.Others.cs,CreateFrom,The following statement contains a magic number: switch (anchorPoint.format = reader.ReadUInt16())                  {                      default: throw new NotSupportedException();                      case 1:                          {                              // AnchorFormat1 table: Design units only                              //AnchorFormat1 consists of a format identifier (AnchorFormat) and a pair of design unit coordinates (XCoordinate and YCoordinate)                              //that specify the location of the anchor point.                               //This format has the benefits of small size and simplicity'                              //but the anchor point cannot be hinted to adjust its position for different device resolutions.                              //Value 	Type 	        Description                              //uint16 	AnchorFormat 	Format identifier' = 1                              //int16 	XCoordinate 	Horizontal value' in design units                              //int16 	YCoordinate 	Vertical value' in design units                              anchorPoint.xcoord = reader.ReadInt16();                              anchorPoint.ycoord = reader.ReadInt16();                          }                          break;                      case 2:                          {                              //Anchor Table: Format 2                                //Like AnchorFormat1' AnchorFormat2 specifies a format identifier (AnchorFormat) and                              //a pair of design unit coordinates for the anchor point (Xcoordinate and Ycoordinate).                                //For fine-tuning the location of the anchor point'                              //AnchorFormat2 also provides an index to a glyph contour point (AnchorPoint)                               //that is on the outline of a glyph (AnchorPoint).***                              //Hinting can be used to move the AnchorPoint. In the rendered text'                              //the AnchorPoint will provide the final positioning data for a given ppem size.                                //Example 16 at the end of this chapter uses AnchorFormat2.                                  //AnchorFormat2 table: Design units plus contour point                              //Value 	Type 	        Description                              //uint16 	AnchorFormat 	Format identifier' = 2                              //int16 	XCoordinate 	Horizontal value' in design units                              //int16 	YCoordinate 	Vertical value' in design units                              //uint16 	AnchorPoint 	Index to glyph contour point                                anchorPoint.xcoord = reader.ReadInt16();                              anchorPoint.ycoord = reader.ReadInt16();                              anchorPoint.refGlyphContourPoint = reader.ReadUInt16();                            }                          break;                      case 3:                          {                                //Anchor Table: Format 3                                //Like AnchorFormat1' AnchorFormat3 specifies a format identifier (AnchorFormat) and                               //locates an anchor point (Xcoordinate and Ycoordinate).                              //And' like AnchorFormat 2' it permits fine adjustments in variable fonts to the coordinate values.                               //However' AnchorFormat3 uses Device tables' rather than a contour point' for this adjustment.                                //With a Device table' a client can adjust the position of the anchor point for any font size and device resolution.                              //AnchorFormat3 can specify offsets to Device tables for the the X coordinate (XDeviceTable)                               //and the Y coordinate (YDeviceTable).                               //If only one coordinate requires adjustment'                               //the offset to the Device table may be set to NULL for the other coordinate.                                //In variable fonts' AnchorFormat3 must be used to reference variation data to adjust anchor points for different variation instances'                              //if needed.                              //In this case' AnchorFormat3 specifies an offset to a VariationIndex table'                              //which is a variant of the Device table used for variations.                              //If no VariationIndex table is used for a particular anchor point X or Y coordinate'                               //then that value is used for all variation instances.                              //While separate VariationIndex table references are required for each value that requires variation'                              //two or more values that require the same variation-data values can have offsets that point to the same VariationIndex table' and two or more VariationIndex tables can reference the same variation data entries.                                //Example 17 at the end of the chapter shows an AnchorFormat3 table.                                  //AnchorFormat3 table: Design units plus Device or VariationIndex tables                              //Value 	Type 	        Description                              //uint16 	AnchorFormat 	Format identifier' = 3                              //int16 	XCoordinate 	Horizontal value' in design units                              //int16 	YCoordinate 	Vertical value' in design units                              //Offset16 	XDeviceTable 	Offset to Device table (non-variable font) / VariationIndex table (variable font) for X coordinate' from beginning of Anchor table (may be NULL)                              //Offset16 	YDeviceTable 	Offset to Device table (non-variable font) / VariationIndex table (variable font) for Y coordinate' from beginning of Anchor table (may be NULL)                                anchorPoint.xcoord = reader.ReadInt16();                              anchorPoint.ycoord = reader.ReadInt16();                              anchorPoint.xdeviceTableOffset = reader.ReadUInt16();                              anchorPoint.ydeviceTableOffset = reader.ReadUInt16();                          }                          break;                  }
Magic Number,Typography.OpenFont.Tables,AnchorPoint,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.Others.cs,ToString,The following statement contains a magic number: switch (format)                  {                      default: return "";                      case 1:                          return format + "(" + xcoord + "'" + ycoord + ")";                      case 2:                          return format + "(" + xcoord + "'" + ycoord + ")' ref_point=" + refGlyphContourPoint;                      case 3:                          return format + "(" + xcoord + "'" + ycoord + ")' xy_device(" + xdeviceTableOffset + "'" + ydeviceTableOffset + ")";                  }
Magic Number,Typography.OpenFont.Tables,AnchorPoint,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.Others.cs,ToString,The following statement contains a magic number: switch (format)                  {                      default: return "";                      case 1:                          return format + "(" + xcoord + "'" + ycoord + ")";                      case 2:                          return format + "(" + xcoord + "'" + ycoord + ")' ref_point=" + refGlyphContourPoint;                      case 3:                          return format + "(" + xcoord + "'" + ycoord + ")' xy_device(" + xdeviceTableOffset + "'" + ydeviceTableOffset + ")";                  }
Magic Number,Typography.OpenFont.Tables,MathTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,ReadMathKernInfoTable,The following statement contains a magic number: ushort[] allKernRecOffset = Utils.ReadUInt16Array(reader' 4 * mathKernCount);
Magic Number,Typography.OpenFont.Tables,MathTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,ReadMathKernInfoTable,The following statement contains a magic number: m_kern_offset = allKernRecOffset[index + 2];
Magic Number,Typography.OpenFont.Tables,MathTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,ReadMathKernInfoTable,The following statement contains a magic number: m_kern_offset = allKernRecOffset[index + 3];
Magic Number,Typography.OpenFont.Tables,MathTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\MathTable.cs,ReadMathKernInfoTable,The following statement contains a magic number: index += 4;
Magic Number,Typography.OpenFont.Tables,CPAL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\CPAL.cs,ReadContentFrom,The following statement contains a magic number: _colorBGRABuffer = reader.ReadBytes(4 * ColorCount);
Magic Number,Typography.OpenFont.Tables,CPAL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\CPAL.cs,GetColor,The following statement contains a magic number: int startAt = colorIndex * 4;
Magic Number,Typography.OpenFont.Tables,CPAL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\CPAL.cs,GetColor,The following statement contains a magic number: r = colorBGRABuffer[startAt + 2];
Magic Number,Typography.OpenFont.Tables,CPAL,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\CPAL.cs,GetColor,The following statement contains a magic number: a = colorBGRABuffer[startAt + 3];
Magic Number,Typography.OpenFont.Tables,CFFTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFFTable.cs,ReadContentFrom,The following statement contains a magic number: byte[] header = reader.ReadBytes(4);
Magic Number,Typography.OpenFont.Tables,CFFTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFFTable.cs,ReadContentFrom,The following statement contains a magic number: byte hdrSize = header[2];
Magic Number,Typography.OpenFont.Tables,CFFTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFFTable.cs,ReadContentFrom,The following statement contains a magic number: byte offSize = header[3];
Magic Number,Typography.OpenFont.Tables,CFFTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFFTable.cs,ReadContentFrom,The following statement contains a magic number: switch (major)              {                  default: throw new NotSupportedException();                  case 1:                      {                          Cff1Parser cff1 = new Cff1Parser();                          cff1.ParseAfterHeader(tableOffset' reader);                          _cff1FontSet = cff1.ResultCff1FontSet;                      }                      break;                  case 2:                      {                          Cff2Parser cff2 = new Cff2Parser();                          cff2.ParseAfterHeader(reader);                      }                      break;              }
Magic Number,Typography.OpenFont.Tables,EBLCTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.Others\EBLCTable.cs,ReadContentFrom,The following statement contains a magic number: reader.BaseStream.Position += (12 * 2);
Magic Number,Typography.OpenFont.Tables,EBLCTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.Others\EBLCTable.cs,ReadContentFrom,The following statement contains a magic number: reader.BaseStream.Position += (12 * 2);
Magic Number,Typography.OpenFont.Tables,Kern,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.Others\Kern.cs,ReadContentFrom,The following statement contains a magic number: switch (kerCoverage.format)                  {                      case 0:                          ReadSubTableFormat0(reader' len - (3 * 2));//3 header field * 2 byte each                          break;                      case 2:                      //TODO: implement                      default:                          Utils.WarnUnimplemented("Kerning Coverage Format {0}"' kerCoverage.format);                          break;                  }
Magic Number,Typography.OpenFont.Tables,Kern,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.Others\Kern.cs,ReadContentFrom,The following statement contains a magic number: switch (kerCoverage.format)                  {                      case 0:                          ReadSubTableFormat0(reader' len - (3 * 2));//3 header field * 2 byte each                          break;                      case 2:                      //TODO: implement                      default:                          Utils.WarnUnimplemented("Kerning Coverage Format {0}"' kerCoverage.format);                          break;                  }
Magic Number,Typography.OpenFont.Tables,Kern,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.Others\Kern.cs,ReadContentFrom,The following statement contains a magic number: switch (kerCoverage.format)                  {                      case 0:                          ReadSubTableFormat0(reader' len - (3 * 2));//3 header field * 2 byte each                          break;                      case 2:                      //TODO: implement                      default:                          Utils.WarnUnimplemented("Kerning Coverage Format {0}"' kerCoverage.format);                          break;                  }
Magic Number,Typography.OpenFont.Tables,KernCoverage,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.Others\Kern.cs,KernCoverage,The following statement contains a magic number: crossStream = ((coverage >> 2) & 0x1) == 1;
Magic Number,Typography.OpenFont.Tables,KernCoverage,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.Others\Kern.cs,KernCoverage,The following statement contains a magic number: _override = ((coverage >> 3) & 0x1) == 1;
Magic Number,Typography.OpenFont.Tables,KernCoverage,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.Others\Kern.cs,KernCoverage,The following statement contains a magic number: format = (byte)((coverage >> 8) & 0xff);
Magic Number,Typography.OpenFont.Tables,KerningSubTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.Others\Kern.cs,AddKernPair,The following statement contains a magic number: uint key = (uint)((left << 16) | right);
Magic Number,Typography.OpenFont.Tables,KerningSubTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.Others\Kern.cs,GetKernDistance,The following statement contains a magic number: uint key = (uint)((left << 16) | right);
Magic Number,Typography.OpenFont.Tables,VerticalHeader,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.Others\VerticalMetricsHeader.cs,ReadContentFrom,The following statement contains a magic number: VersionMajor = (byte)(version >> 16);
Magic Number,Typography.OpenFont.Tables,VerticalHeader,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.Others\VerticalMetricsHeader.cs,ReadContentFrom,The following statement contains a magic number: VersionMinor = (byte)(version >> 8);
Magic Number,Typography.OpenFont.Tables,VerticalHeader,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.Others\VerticalMetricsHeader.cs,ReadContentFrom,The following statement contains a magic number: reader.BaseStream.Position += (2 * (4 + 1));
Magic Number,Typography.OpenFont.Tables,VerticalHeader,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.Others\VerticalMetricsHeader.cs,ReadContentFrom,The following statement contains a magic number: reader.BaseStream.Position += (2 * (4 + 1));
Magic Number,Typography.OpenFont.Tables,Glyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.TrueType\Glyf.cs,ReadContentFrom,The following statement contains a magic number: glyphIndex == 7
Magic Number,Typography.OpenFont.Tables,Cmap,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables\Cmap.cs,LookupIndex,The following statement contains a magic number: found == 0 || (gid != 0 && cmap.PlatformId == 3 && cmap.EncodingId == 1)
Magic Number,Typography.OpenFont.Tables,Cmap,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables\Cmap.cs,ReadFormat_0,The following statement contains a magic number: byte[] only256Glyphs = input.ReadBytes(256);
Magic Number,Typography.OpenFont.Tables,Cmap,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables\Cmap.cs,ReadFormat_0,The following statement contains a magic number: ushort[] only256UInt16Glyphs = new ushort[256];
Magic Number,Typography.OpenFont.Tables,Cmap,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables\Cmap.cs,ReadFormat_0,The following statement contains a magic number: ushort[] endArray = new ushort[] { 255' 0xFFFF };
Magic Number,Typography.OpenFont.Tables,Cmap,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables\Cmap.cs,ReadFormat_0,The following statement contains a magic number: ushort[] offsetArray = new ushort[] { 4' 0 };
Magic Number,Typography.OpenFont.Tables,Cmap,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables\Cmap.cs,ReadFormat_4,The following statement contains a magic number: int segCount = segCountX2 / 2;
Magic Number,Typography.OpenFont.Tables,Cmap,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables\Cmap.cs,ReadFormat_4,The following statement contains a magic number: int recordNum2 = (int)(remainingLen / 2);
Magic Number,Typography.OpenFont.Tables,Cmap,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables\Cmap.cs,ReadCharacterMap,The following statement contains a magic number: switch (format)              {                  default:                      Utils.WarnUnimplemented("cmap subtable format {0}"' format);                      return new NullCharMap();                  case 0: return ReadFormat_0(input);                  case 2: return ReadFormat_2(input);                  case 4: return ReadFormat_4(input);                  case 6: return ReadFormat_6(input);                  case 12: return ReadFormat_12(input);                  case 14: return CharMapFormat14.Create(input);              }
Magic Number,Typography.OpenFont.Tables,Cmap,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables\Cmap.cs,ReadCharacterMap,The following statement contains a magic number: switch (format)              {                  default:                      Utils.WarnUnimplemented("cmap subtable format {0}"' format);                      return new NullCharMap();                  case 0: return ReadFormat_0(input);                  case 2: return ReadFormat_2(input);                  case 4: return ReadFormat_4(input);                  case 6: return ReadFormat_6(input);                  case 12: return ReadFormat_12(input);                  case 14: return CharMapFormat14.Create(input);              }
Magic Number,Typography.OpenFont.Tables,Cmap,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables\Cmap.cs,ReadCharacterMap,The following statement contains a magic number: switch (format)              {                  default:                      Utils.WarnUnimplemented("cmap subtable format {0}"' format);                      return new NullCharMap();                  case 0: return ReadFormat_0(input);                  case 2: return ReadFormat_2(input);                  case 4: return ReadFormat_4(input);                  case 6: return ReadFormat_6(input);                  case 12: return ReadFormat_12(input);                  case 14: return CharMapFormat14.Create(input);              }
Magic Number,Typography.OpenFont.Tables,Cmap,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables\Cmap.cs,ReadCharacterMap,The following statement contains a magic number: switch (format)              {                  default:                      Utils.WarnUnimplemented("cmap subtable format {0}"' format);                      return new NullCharMap();                  case 0: return ReadFormat_0(input);                  case 2: return ReadFormat_2(input);                  case 4: return ReadFormat_4(input);                  case 6: return ReadFormat_6(input);                  case 12: return ReadFormat_12(input);                  case 14: return CharMapFormat14.Create(input);              }
Magic Number,Typography.OpenFont.Tables,Cmap,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables\Cmap.cs,ReadCharacterMap,The following statement contains a magic number: switch (format)              {                  default:                      Utils.WarnUnimplemented("cmap subtable format {0}"' format);                      return new NullCharMap();                  case 0: return ReadFormat_0(input);                  case 2: return ReadFormat_2(input);                  case 4: return ReadFormat_4(input);                  case 6: return ReadFormat_6(input);                  case 12: return ReadFormat_12(input);                  case 14: return CharMapFormat14.Create(input);              }
Magic Number,Typography.OpenFont.Tables,NameEntry,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables\NameEntry.cs,ReadContentFrom,The following statement contains a magic number: ttRecord.uEncodingID == 3 || ttRecord.uEncodingID == 1
Magic Number,Typography.OpenFont.Tables,OS2Table,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables\OS2.cs,ReadContentFrom,The following statement contains a magic number: switch (this.version = reader.ReadUInt16())              {                  default: throw new System.NotSupportedException();                  case 0: //defined in TrueType revision 1.5                      ReadVersion0(reader);                      break;                  case 1: // defined in TrueType revision 1.66                      ReadVersion1(reader);                      break;                  case 2: //defined in OpenType version 1.2                      ReadVersion2(reader);                      break;                  case 3: //defined in OpenType version 1.4                      ReadVersion3(reader);                      break;                  case 4: //defined in OpenType version 1.6                      ReadVersion4(reader);                      break;                  case 5:                      ReadVersion5(reader);                      break;              }
Magic Number,Typography.OpenFont.Tables,OS2Table,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables\OS2.cs,ReadContentFrom,The following statement contains a magic number: switch (this.version = reader.ReadUInt16())              {                  default: throw new System.NotSupportedException();                  case 0: //defined in TrueType revision 1.5                      ReadVersion0(reader);                      break;                  case 1: // defined in TrueType revision 1.66                      ReadVersion1(reader);                      break;                  case 2: //defined in OpenType version 1.2                      ReadVersion2(reader);                      break;                  case 3: //defined in OpenType version 1.4                      ReadVersion3(reader);                      break;                  case 4: //defined in OpenType version 1.6                      ReadVersion4(reader);                      break;                  case 5:                      ReadVersion5(reader);                      break;              }
Magic Number,Typography.OpenFont.Tables,OS2Table,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables\OS2.cs,ReadContentFrom,The following statement contains a magic number: switch (this.version = reader.ReadUInt16())              {                  default: throw new System.NotSupportedException();                  case 0: //defined in TrueType revision 1.5                      ReadVersion0(reader);                      break;                  case 1: // defined in TrueType revision 1.66                      ReadVersion1(reader);                      break;                  case 2: //defined in OpenType version 1.2                      ReadVersion2(reader);                      break;                  case 3: //defined in OpenType version 1.4                      ReadVersion3(reader);                      break;                  case 4: //defined in OpenType version 1.6                      ReadVersion4(reader);                      break;                  case 5:                      ReadVersion5(reader);                      break;              }
Magic Number,Typography.OpenFont.Tables,OS2Table,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables\OS2.cs,ReadContentFrom,The following statement contains a magic number: switch (this.version = reader.ReadUInt16())              {                  default: throw new System.NotSupportedException();                  case 0: //defined in TrueType revision 1.5                      ReadVersion0(reader);                      break;                  case 1: // defined in TrueType revision 1.66                      ReadVersion1(reader);                      break;                  case 2: //defined in OpenType version 1.2                      ReadVersion2(reader);                      break;                  case 3: //defined in OpenType version 1.4                      ReadVersion3(reader);                      break;                  case 4: //defined in OpenType version 1.6                      ReadVersion4(reader);                      break;                  case 5:                      ReadVersion5(reader);                      break;              }
Magic Number,Typography.OpenFont.Tables,OS2Table,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables\OS2.cs,ReadVersion0,The following statement contains a magic number: this.panose = reader.ReadBytes(10);
Magic Number,Typography.OpenFont.Tables,OS2Table,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables\OS2.cs,ReadVersion1,The following statement contains a magic number: this.panose = reader.ReadBytes(10);
Magic Number,Typography.OpenFont.Tables,OS2Table,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables\OS2.cs,ReadVersion2,The following statement contains a magic number: this.panose = reader.ReadBytes(10);
Magic Number,Typography.OpenFont.Tables,OS2Table,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables\OS2.cs,ReadVersion3,The following statement contains a magic number: this.panose = reader.ReadBytes(10);
Magic Number,Typography.OpenFont.Tables,OS2Table,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables\OS2.cs,ReadVersion4,The following statement contains a magic number: this.panose = reader.ReadBytes(10);
Magic Number,Typography.OpenFont.Tables,OS2Table,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables\OS2.cs,ReadVersion5,The following statement contains a magic number: this.panose = reader.ReadBytes(10);
Magic Number,Typography.OpenFont.Tables,PostTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables\Post.cs,ReadContentFrom,The following statement contains a magic number: switch (version)              {                  case 0x00010000: //version 1                  case 0x00030000: //version3                      Version = 1;                      break;                  case 0x00020000: //version 2                      {                          Version = 2;                            //Version 2.0                            //This is the version required in order to supply PostScript glyph names for fonts which do not supply them elsewhere.                          //A version 2.0 'post' table can be used in fonts with TrueType or CFF version 2 outlines.                          //Type 	    Name 	                        Description                          //uint16 	numberOfGlyphs 	                Number of glyphs (this should be the same as numGlyphs in 'maxp' table).                          //uint16 	glyphNameIndex[numGlyphs]. 	    This is not an offset' but is the ordinal number of the glyph in 'post' string tables.                          //int8 	    names[numberNewGlyphs] 	        Glyph names with length bytes [variable] (a Pascal string).                            //This font file contains glyphs not in the standard Macintosh set'                          //or the ordering of the glyphs in the font file differs from the standard Macintosh set.                           //The glyph name array maps the glyphs in this font to name index.                          //....                          //If you do not want to associate a PostScript name with a particular glyph' use index number 0 which points to the name .notdef.                            _glyphNames = new Dictionary<ushort' string>();                          ushort numOfGlyphs = reader.ReadUInt16();                          ushort[] glyphNameIndice = Utils.ReadUInt16Array(reader' numOfGlyphs);//***                            string[] stdMacGlyphNames = MacPostFormat1.GetStdMacGlyphNames();                            for (ushort i = 0; i < numOfGlyphs; ++i)                          {                              ushort glyphNameIndex = glyphNameIndice[i];                              if (glyphNameIndex < 258)                              {                                  //If the name index is between 0 and 257' treat the name index as a glyph index in the Macintosh standard order.                                    //replace?                                   _glyphNames[i] = stdMacGlyphNames[glyphNameIndex];                              }                              else                              {                                  //If the name index is between 258 and 65535'                                   //then subtract 258 and use that to index into the list of Pascal strings at the end of the table.                                   //Thus a given font may map some of its glyphs to the standard glyph names' and some to its own names.                                    //258 and 65535'                                   int len = reader.ReadByte(); //name len                                   _glyphNames.Add(i' System.Text.Encoding.UTF8.GetString(reader.ReadBytes(len)' 0' len));                              }                          }                        }                      break;                  default:                      {                          return;                          throw new System.NotSupportedException();                      }                  case 0x00025000:                      //deprecated ??                      throw new System.NotSupportedException();              }
Magic Number,Typography.OpenFont.Tables,PostTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables\Post.cs,ReadContentFrom,The following statement contains a magic number: switch (version)              {                  case 0x00010000: //version 1                  case 0x00030000: //version3                      Version = 1;                      break;                  case 0x00020000: //version 2                      {                          Version = 2;                            //Version 2.0                            //This is the version required in order to supply PostScript glyph names for fonts which do not supply them elsewhere.                          //A version 2.0 'post' table can be used in fonts with TrueType or CFF version 2 outlines.                          //Type 	    Name 	                        Description                          //uint16 	numberOfGlyphs 	                Number of glyphs (this should be the same as numGlyphs in 'maxp' table).                          //uint16 	glyphNameIndex[numGlyphs]. 	    This is not an offset' but is the ordinal number of the glyph in 'post' string tables.                          //int8 	    names[numberNewGlyphs] 	        Glyph names with length bytes [variable] (a Pascal string).                            //This font file contains glyphs not in the standard Macintosh set'                          //or the ordering of the glyphs in the font file differs from the standard Macintosh set.                           //The glyph name array maps the glyphs in this font to name index.                          //....                          //If you do not want to associate a PostScript name with a particular glyph' use index number 0 which points to the name .notdef.                            _glyphNames = new Dictionary<ushort' string>();                          ushort numOfGlyphs = reader.ReadUInt16();                          ushort[] glyphNameIndice = Utils.ReadUInt16Array(reader' numOfGlyphs);//***                            string[] stdMacGlyphNames = MacPostFormat1.GetStdMacGlyphNames();                            for (ushort i = 0; i < numOfGlyphs; ++i)                          {                              ushort glyphNameIndex = glyphNameIndice[i];                              if (glyphNameIndex < 258)                              {                                  //If the name index is between 0 and 257' treat the name index as a glyph index in the Macintosh standard order.                                    //replace?                                   _glyphNames[i] = stdMacGlyphNames[glyphNameIndex];                              }                              else                              {                                  //If the name index is between 258 and 65535'                                   //then subtract 258 and use that to index into the list of Pascal strings at the end of the table.                                   //Thus a given font may map some of its glyphs to the standard glyph names' and some to its own names.                                    //258 and 65535'                                   int len = reader.ReadByte(); //name len                                   _glyphNames.Add(i' System.Text.Encoding.UTF8.GetString(reader.ReadBytes(len)' 0' len));                              }                          }                        }                      break;                  default:                      {                          return;                          throw new System.NotSupportedException();                      }                  case 0x00025000:                      //deprecated ??                      throw new System.NotSupportedException();              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,R_MoveTo,The following statement contains a magic number: dbugGlyphIndex == 207
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,R_MoveTo,The following statement contains a magic number: (_currentIndex % 2) != 0
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,R_MoveTo,The following statement contains a magic number: i += 2;
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,R_LineTo,The following statement contains a magic number: (_currentIndex % 2) != 0
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,R_LineTo,The following statement contains a magic number: i += 2;
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,H_LineTo,The following statement contains a magic number: i += 2;
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,H_LineTo,The following statement contains a magic number: (_currentIndex % 2) != 0
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,V_LineTo,The following statement contains a magic number: i += 2;
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,V_LineTo,The following statement contains a magic number: (_currentIndex % 2) != 0
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,RR_CurveTo,The following statement contains a magic number: (_currentIndex % 6) != 0
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,RR_CurveTo,The following statement contains a magic number: dbugGlyphIndex == 192
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,RR_CurveTo,The following statement contains a magic number: _glyphTranslator.Curve4(                      (float)(curX += _argStack[i + 0])' (float)(curY += _argStack[i + 1])' //dxa'dya                      (float)(curX += _argStack[i + 2])' (float)(curY += _argStack[i + 3])' //dxb'dyb                      (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 5])  //dxc'dyc                      );
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,RR_CurveTo,The following statement contains a magic number: _glyphTranslator.Curve4(                      (float)(curX += _argStack[i + 0])' (float)(curY += _argStack[i + 1])' //dxa'dya                      (float)(curX += _argStack[i + 2])' (float)(curY += _argStack[i + 3])' //dxb'dyb                      (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 5])  //dxc'dyc                      );
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,RR_CurveTo,The following statement contains a magic number: _glyphTranslator.Curve4(                      (float)(curX += _argStack[i + 0])' (float)(curY += _argStack[i + 1])' //dxa'dya                      (float)(curX += _argStack[i + 2])' (float)(curY += _argStack[i + 3])' //dxb'dyb                      (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 5])  //dxc'dyc                      );
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,RR_CurveTo,The following statement contains a magic number: _glyphTranslator.Curve4(                      (float)(curX += _argStack[i + 0])' (float)(curY += _argStack[i + 1])' //dxa'dya                      (float)(curX += _argStack[i + 2])' (float)(curY += _argStack[i + 3])' //dxb'dyb                      (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 5])  //dxc'dyc                      );
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,RR_CurveTo,The following statement contains a magic number: i += 6;
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HH_CurveTo,The following statement contains a magic number: _glyphTranslator.Curve4(                     (float)(curX += _argStack[1])' (float)(curY += _argStack[0])' //dxa'+dy1?                     (float)(curX += _argStack[2])' (float)(curY += _argStack[3])' //dxb'dyb                     (float)(curX += _argStack[4])' (float)(curY)  //dxc'+0                     );
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HH_CurveTo,The following statement contains a magic number: _glyphTranslator.Curve4(                     (float)(curX += _argStack[1])' (float)(curY += _argStack[0])' //dxa'+dy1?                     (float)(curX += _argStack[2])' (float)(curY += _argStack[3])' //dxb'dyb                     (float)(curX += _argStack[4])' (float)(curY)  //dxc'+0                     );
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HH_CurveTo,The following statement contains a magic number: _glyphTranslator.Curve4(                     (float)(curX += _argStack[1])' (float)(curY += _argStack[0])' //dxa'+dy1?                     (float)(curX += _argStack[2])' (float)(curY += _argStack[3])' //dxb'dyb                     (float)(curX += _argStack[4])' (float)(curY)  //dxc'+0                     );
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HH_CurveTo,The following statement contains a magic number: i += 5;
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HH_CurveTo,The following statement contains a magic number: count -= 5;
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HH_CurveTo,The following statement contains a magic number: (count % 2) != 0
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HH_CurveTo,The following statement contains a magic number: _glyphTranslator.Curve4(                      (float)(curX += _argStack[i + 0])' (float)(curY)' //dxa'+0                      (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                      (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc'+0                      );
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HH_CurveTo,The following statement contains a magic number: _glyphTranslator.Curve4(                      (float)(curX += _argStack[i + 0])' (float)(curY)' //dxa'+0                      (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                      (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc'+0                      );
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HH_CurveTo,The following statement contains a magic number: i += 4;
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HH_CurveTo,The following statement contains a magic number: count -= 4;
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HV_CurveTo,The following statement contains a magic number: dbugGlyphIndex == 496
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HV_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dxa dxb dyb dyc dyd dxe dye dxf}+ dyf? hvcurveto (31) |-                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                          while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //+dxa'0                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0'dyc                                  );                                  if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'+dyf                                   );                                  //                                  count -= 9;                                  i += 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'+0                                  );                                  //                                  count -= 8;                                  i += 8;                              }                            }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dx1 dx2 dy2 dy3 {dya dxb dyb dxc dxd dxe dye dyf}* dxf? hvcurveto (31) |-                            //If there is a multiple of four arguments' the curve starts                          //horizontal and ends vertical.                          //Note that the curves alternate between start horizontal' end vertical' and start vertical' and                          //end horizontal.The last curve(the odd argument case) need not                          //end horizontal/ vertical.                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                            if (count == 5)                          {                              //last one                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 3])  //dx3'dy3                                 );                                count -= 5;                              i += 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX)' (float)(curY += _argStack[i + 3])  //dy3                                 );                                count -= 4;                              i += 4;                          }                              while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc' +0                                  );                                if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //dxf'dyf                                   );                                  i += 9;                                  count -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX)' (float)(curY += _argStack[i + 7])  //0'dyf                                  );                                  //                                  i += 8;                                  count -= 8;                              }                            }                            _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HV_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dxa dxb dyb dyc dyd dxe dye dxf}+ dyf? hvcurveto (31) |-                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                          while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //+dxa'0                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0'dyc                                  );                                  if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'+dyf                                   );                                  //                                  count -= 9;                                  i += 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'+0                                  );                                  //                                  count -= 8;                                  i += 8;                              }                            }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dx1 dx2 dy2 dy3 {dya dxb dyb dxc dxd dxe dye dyf}* dxf? hvcurveto (31) |-                            //If there is a multiple of four arguments' the curve starts                          //horizontal and ends vertical.                          //Note that the curves alternate between start horizontal' end vertical' and start vertical' and                          //end horizontal.The last curve(the odd argument case) need not                          //end horizontal/ vertical.                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                            if (count == 5)                          {                              //last one                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 3])  //dx3'dy3                                 );                                count -= 5;                              i += 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX)' (float)(curY += _argStack[i + 3])  //dy3                                 );                                count -= 4;                              i += 4;                          }                              while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc' +0                                  );                                if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //dxf'dyf                                   );                                  i += 9;                                  count -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX)' (float)(curY += _argStack[i + 7])  //0'dyf                                  );                                  //                                  i += 8;                                  count -= 8;                              }                            }                            _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HV_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dxa dxb dyb dyc dyd dxe dye dxf}+ dyf? hvcurveto (31) |-                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                          while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //+dxa'0                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0'dyc                                  );                                  if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'+dyf                                   );                                  //                                  count -= 9;                                  i += 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'+0                                  );                                  //                                  count -= 8;                                  i += 8;                              }                            }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dx1 dx2 dy2 dy3 {dya dxb dyb dxc dxd dxe dye dyf}* dxf? hvcurveto (31) |-                            //If there is a multiple of four arguments' the curve starts                          //horizontal and ends vertical.                          //Note that the curves alternate between start horizontal' end vertical' and start vertical' and                          //end horizontal.The last curve(the odd argument case) need not                          //end horizontal/ vertical.                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                            if (count == 5)                          {                              //last one                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 3])  //dx3'dy3                                 );                                count -= 5;                              i += 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX)' (float)(curY += _argStack[i + 3])  //dy3                                 );                                count -= 4;                              i += 4;                          }                              while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc' +0                                  );                                if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //dxf'dyf                                   );                                  i += 9;                                  count -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX)' (float)(curY += _argStack[i + 7])  //0'dyf                                  );                                  //                                  i += 8;                                  count -= 8;                              }                            }                            _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HV_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dxa dxb dyb dyc dyd dxe dye dxf}+ dyf? hvcurveto (31) |-                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                          while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //+dxa'0                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0'dyc                                  );                                  if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'+dyf                                   );                                  //                                  count -= 9;                                  i += 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'+0                                  );                                  //                                  count -= 8;                                  i += 8;                              }                            }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dx1 dx2 dy2 dy3 {dya dxb dyb dxc dxd dxe dye dyf}* dxf? hvcurveto (31) |-                            //If there is a multiple of four arguments' the curve starts                          //horizontal and ends vertical.                          //Note that the curves alternate between start horizontal' end vertical' and start vertical' and                          //end horizontal.The last curve(the odd argument case) need not                          //end horizontal/ vertical.                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                            if (count == 5)                          {                              //last one                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 3])  //dx3'dy3                                 );                                count -= 5;                              i += 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX)' (float)(curY += _argStack[i + 3])  //dy3                                 );                                count -= 4;                              i += 4;                          }                              while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc' +0                                  );                                if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //dxf'dyf                                   );                                  i += 9;                                  count -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX)' (float)(curY += _argStack[i + 7])  //0'dyf                                  );                                  //                                  i += 8;                                  count -= 8;                              }                            }                            _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HV_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dxa dxb dyb dyc dyd dxe dye dxf}+ dyf? hvcurveto (31) |-                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                          while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //+dxa'0                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0'dyc                                  );                                  if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'+dyf                                   );                                  //                                  count -= 9;                                  i += 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'+0                                  );                                  //                                  count -= 8;                                  i += 8;                              }                            }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dx1 dx2 dy2 dy3 {dya dxb dyb dxc dxd dxe dye dyf}* dxf? hvcurveto (31) |-                            //If there is a multiple of four arguments' the curve starts                          //horizontal and ends vertical.                          //Note that the curves alternate between start horizontal' end vertical' and start vertical' and                          //end horizontal.The last curve(the odd argument case) need not                          //end horizontal/ vertical.                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                            if (count == 5)                          {                              //last one                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 3])  //dx3'dy3                                 );                                count -= 5;                              i += 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX)' (float)(curY += _argStack[i + 3])  //dy3                                 );                                count -= 4;                              i += 4;                          }                              while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc' +0                                  );                                if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //dxf'dyf                                   );                                  i += 9;                                  count -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX)' (float)(curY += _argStack[i + 7])  //0'dyf                                  );                                  //                                  i += 8;                                  count -= 8;                              }                            }                            _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HV_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dxa dxb dyb dyc dyd dxe dye dxf}+ dyf? hvcurveto (31) |-                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                          while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //+dxa'0                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0'dyc                                  );                                  if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'+dyf                                   );                                  //                                  count -= 9;                                  i += 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'+0                                  );                                  //                                  count -= 8;                                  i += 8;                              }                            }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dx1 dx2 dy2 dy3 {dya dxb dyb dxc dxd dxe dye dyf}* dxf? hvcurveto (31) |-                            //If there is a multiple of four arguments' the curve starts                          //horizontal and ends vertical.                          //Note that the curves alternate between start horizontal' end vertical' and start vertical' and                          //end horizontal.The last curve(the odd argument case) need not                          //end horizontal/ vertical.                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                            if (count == 5)                          {                              //last one                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 3])  //dx3'dy3                                 );                                count -= 5;                              i += 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX)' (float)(curY += _argStack[i + 3])  //dy3                                 );                                count -= 4;                              i += 4;                          }                              while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc' +0                                  );                                if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //dxf'dyf                                   );                                  i += 9;                                  count -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX)' (float)(curY += _argStack[i + 7])  //0'dyf                                  );                                  //                                  i += 8;                                  count -= 8;                              }                            }                            _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HV_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dxa dxb dyb dyc dyd dxe dye dxf}+ dyf? hvcurveto (31) |-                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                          while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //+dxa'0                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0'dyc                                  );                                  if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'+dyf                                   );                                  //                                  count -= 9;                                  i += 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'+0                                  );                                  //                                  count -= 8;                                  i += 8;                              }                            }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dx1 dx2 dy2 dy3 {dya dxb dyb dxc dxd dxe dye dyf}* dxf? hvcurveto (31) |-                            //If there is a multiple of four arguments' the curve starts                          //horizontal and ends vertical.                          //Note that the curves alternate between start horizontal' end vertical' and start vertical' and                          //end horizontal.The last curve(the odd argument case) need not                          //end horizontal/ vertical.                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                            if (count == 5)                          {                              //last one                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 3])  //dx3'dy3                                 );                                count -= 5;                              i += 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX)' (float)(curY += _argStack[i + 3])  //dy3                                 );                                count -= 4;                              i += 4;                          }                              while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc' +0                                  );                                if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //dxf'dyf                                   );                                  i += 9;                                  count -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX)' (float)(curY += _argStack[i + 7])  //0'dyf                                  );                                  //                                  i += 8;                                  count -= 8;                              }                            }                            _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HV_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dxa dxb dyb dyc dyd dxe dye dxf}+ dyf? hvcurveto (31) |-                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                          while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //+dxa'0                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0'dyc                                  );                                  if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'+dyf                                   );                                  //                                  count -= 9;                                  i += 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'+0                                  );                                  //                                  count -= 8;                                  i += 8;                              }                            }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dx1 dx2 dy2 dy3 {dya dxb dyb dxc dxd dxe dye dyf}* dxf? hvcurveto (31) |-                            //If there is a multiple of four arguments' the curve starts                          //horizontal and ends vertical.                          //Note that the curves alternate between start horizontal' end vertical' and start vertical' and                          //end horizontal.The last curve(the odd argument case) need not                          //end horizontal/ vertical.                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                            if (count == 5)                          {                              //last one                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 3])  //dx3'dy3                                 );                                count -= 5;                              i += 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX)' (float)(curY += _argStack[i + 3])  //dy3                                 );                                count -= 4;                              i += 4;                          }                              while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc' +0                                  );                                if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //dxf'dyf                                   );                                  i += 9;                                  count -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX)' (float)(curY += _argStack[i + 7])  //0'dyf                                  );                                  //                                  i += 8;                                  count -= 8;                              }                            }                            _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HV_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dxa dxb dyb dyc dyd dxe dye dxf}+ dyf? hvcurveto (31) |-                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                          while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //+dxa'0                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0'dyc                                  );                                  if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'+dyf                                   );                                  //                                  count -= 9;                                  i += 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'+0                                  );                                  //                                  count -= 8;                                  i += 8;                              }                            }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dx1 dx2 dy2 dy3 {dya dxb dyb dxc dxd dxe dye dyf}* dxf? hvcurveto (31) |-                            //If there is a multiple of four arguments' the curve starts                          //horizontal and ends vertical.                          //Note that the curves alternate between start horizontal' end vertical' and start vertical' and                          //end horizontal.The last curve(the odd argument case) need not                          //end horizontal/ vertical.                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                            if (count == 5)                          {                              //last one                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 3])  //dx3'dy3                                 );                                count -= 5;                              i += 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX)' (float)(curY += _argStack[i + 3])  //dy3                                 );                                count -= 4;                              i += 4;                          }                              while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc' +0                                  );                                if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //dxf'dyf                                   );                                  i += 9;                                  count -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX)' (float)(curY += _argStack[i + 7])  //0'dyf                                  );                                  //                                  i += 8;                                  count -= 8;                              }                            }                            _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HV_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dxa dxb dyb dyc dyd dxe dye dxf}+ dyf? hvcurveto (31) |-                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                          while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //+dxa'0                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0'dyc                                  );                                  if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'+dyf                                   );                                  //                                  count -= 9;                                  i += 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'+0                                  );                                  //                                  count -= 8;                                  i += 8;                              }                            }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dx1 dx2 dy2 dy3 {dya dxb dyb dxc dxd dxe dye dyf}* dxf? hvcurveto (31) |-                            //If there is a multiple of four arguments' the curve starts                          //horizontal and ends vertical.                          //Note that the curves alternate between start horizontal' end vertical' and start vertical' and                          //end horizontal.The last curve(the odd argument case) need not                          //end horizontal/ vertical.                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                            if (count == 5)                          {                              //last one                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 3])  //dx3'dy3                                 );                                count -= 5;                              i += 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX)' (float)(curY += _argStack[i + 3])  //dy3                                 );                                count -= 4;                              i += 4;                          }                              while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc' +0                                  );                                if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //dxf'dyf                                   );                                  i += 9;                                  count -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX)' (float)(curY += _argStack[i + 7])  //0'dyf                                  );                                  //                                  i += 8;                                  count -= 8;                              }                            }                            _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HV_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dxa dxb dyb dyc dyd dxe dye dxf}+ dyf? hvcurveto (31) |-                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                          while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //+dxa'0                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0'dyc                                  );                                  if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'+dyf                                   );                                  //                                  count -= 9;                                  i += 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'+0                                  );                                  //                                  count -= 8;                                  i += 8;                              }                            }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dx1 dx2 dy2 dy3 {dya dxb dyb dxc dxd dxe dye dyf}* dxf? hvcurveto (31) |-                            //If there is a multiple of four arguments' the curve starts                          //horizontal and ends vertical.                          //Note that the curves alternate between start horizontal' end vertical' and start vertical' and                          //end horizontal.The last curve(the odd argument case) need not                          //end horizontal/ vertical.                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                            if (count == 5)                          {                              //last one                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 3])  //dx3'dy3                                 );                                count -= 5;                              i += 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX)' (float)(curY += _argStack[i + 3])  //dy3                                 );                                count -= 4;                              i += 4;                          }                              while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc' +0                                  );                                if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //dxf'dyf                                   );                                  i += 9;                                  count -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX)' (float)(curY += _argStack[i + 7])  //0'dyf                                  );                                  //                                  i += 8;                                  count -= 8;                              }                            }                            _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HV_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dxa dxb dyb dyc dyd dxe dye dxf}+ dyf? hvcurveto (31) |-                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                          while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //+dxa'0                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0'dyc                                  );                                  if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'+dyf                                   );                                  //                                  count -= 9;                                  i += 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'+0                                  );                                  //                                  count -= 8;                                  i += 8;                              }                            }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dx1 dx2 dy2 dy3 {dya dxb dyb dxc dxd dxe dye dyf}* dxf? hvcurveto (31) |-                            //If there is a multiple of four arguments' the curve starts                          //horizontal and ends vertical.                          //Note that the curves alternate between start horizontal' end vertical' and start vertical' and                          //end horizontal.The last curve(the odd argument case) need not                          //end horizontal/ vertical.                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                            if (count == 5)                          {                              //last one                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 3])  //dx3'dy3                                 );                                count -= 5;                              i += 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX)' (float)(curY += _argStack[i + 3])  //dy3                                 );                                count -= 4;                              i += 4;                          }                              while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc' +0                                  );                                if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //dxf'dyf                                   );                                  i += 9;                                  count -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX)' (float)(curY += _argStack[i + 7])  //0'dyf                                  );                                  //                                  i += 8;                                  count -= 8;                              }                            }                            _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HV_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dxa dxb dyb dyc dyd dxe dye dxf}+ dyf? hvcurveto (31) |-                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                          while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //+dxa'0                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0'dyc                                  );                                  if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'+dyf                                   );                                  //                                  count -= 9;                                  i += 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'+0                                  );                                  //                                  count -= 8;                                  i += 8;                              }                            }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dx1 dx2 dy2 dy3 {dya dxb dyb dxc dxd dxe dye dyf}* dxf? hvcurveto (31) |-                            //If there is a multiple of four arguments' the curve starts                          //horizontal and ends vertical.                          //Note that the curves alternate between start horizontal' end vertical' and start vertical' and                          //end horizontal.The last curve(the odd argument case) need not                          //end horizontal/ vertical.                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                            if (count == 5)                          {                              //last one                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 3])  //dx3'dy3                                 );                                count -= 5;                              i += 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX)' (float)(curY += _argStack[i + 3])  //dy3                                 );                                count -= 4;                              i += 4;                          }                              while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc' +0                                  );                                if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //dxf'dyf                                   );                                  i += 9;                                  count -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX)' (float)(curY += _argStack[i + 7])  //0'dyf                                  );                                  //                                  i += 8;                                  count -= 8;                              }                            }                            _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HV_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dxa dxb dyb dyc dyd dxe dye dxf}+ dyf? hvcurveto (31) |-                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                          while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //+dxa'0                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0'dyc                                  );                                  if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'+dyf                                   );                                  //                                  count -= 9;                                  i += 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'+0                                  );                                  //                                  count -= 8;                                  i += 8;                              }                            }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dx1 dx2 dy2 dy3 {dya dxb dyb dxc dxd dxe dye dyf}* dxf? hvcurveto (31) |-                            //If there is a multiple of four arguments' the curve starts                          //horizontal and ends vertical.                          //Note that the curves alternate between start horizontal' end vertical' and start vertical' and                          //end horizontal.The last curve(the odd argument case) need not                          //end horizontal/ vertical.                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                            if (count == 5)                          {                              //last one                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 3])  //dx3'dy3                                 );                                count -= 5;                              i += 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX)' (float)(curY += _argStack[i + 3])  //dy3                                 );                                count -= 4;                              i += 4;                          }                              while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc' +0                                  );                                if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //dxf'dyf                                   );                                  i += 9;                                  count -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX)' (float)(curY += _argStack[i + 7])  //0'dyf                                  );                                  //                                  i += 8;                                  count -= 8;                              }                            }                            _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HV_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dxa dxb dyb dyc dyd dxe dye dxf}+ dyf? hvcurveto (31) |-                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                          while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //+dxa'0                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0'dyc                                  );                                  if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'+dyf                                   );                                  //                                  count -= 9;                                  i += 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'+0                                  );                                  //                                  count -= 8;                                  i += 8;                              }                            }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dx1 dx2 dy2 dy3 {dya dxb dyb dxc dxd dxe dye dyf}* dxf? hvcurveto (31) |-                            //If there is a multiple of four arguments' the curve starts                          //horizontal and ends vertical.                          //Note that the curves alternate between start horizontal' end vertical' and start vertical' and                          //end horizontal.The last curve(the odd argument case) need not                          //end horizontal/ vertical.                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                            if (count == 5)                          {                              //last one                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 3])  //dx3'dy3                                 );                                count -= 5;                              i += 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX)' (float)(curY += _argStack[i + 3])  //dy3                                 );                                count -= 4;                              i += 4;                          }                              while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc' +0                                  );                                if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //dxf'dyf                                   );                                  i += 9;                                  count -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX)' (float)(curY += _argStack[i + 7])  //0'dyf                                  );                                  //                                  i += 8;                                  count -= 8;                              }                            }                            _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HV_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dxa dxb dyb dyc dyd dxe dye dxf}+ dyf? hvcurveto (31) |-                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                          while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //+dxa'0                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0'dyc                                  );                                  if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'+dyf                                   );                                  //                                  count -= 9;                                  i += 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'+0                                  );                                  //                                  count -= 8;                                  i += 8;                              }                            }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dx1 dx2 dy2 dy3 {dya dxb dyb dxc dxd dxe dye dyf}* dxf? hvcurveto (31) |-                            //If there is a multiple of four arguments' the curve starts                          //horizontal and ends vertical.                          //Note that the curves alternate between start horizontal' end vertical' and start vertical' and                          //end horizontal.The last curve(the odd argument case) need not                          //end horizontal/ vertical.                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                            if (count == 5)                          {                              //last one                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 3])  //dx3'dy3                                 );                                count -= 5;                              i += 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX)' (float)(curY += _argStack[i + 3])  //dy3                                 );                                count -= 4;                              i += 4;                          }                              while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc' +0                                  );                                if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //dxf'dyf                                   );                                  i += 9;                                  count -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX)' (float)(curY += _argStack[i + 7])  //0'dyf                                  );                                  //                                  i += 8;                                  count -= 8;                              }                            }                            _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HV_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dxa dxb dyb dyc dyd dxe dye dxf}+ dyf? hvcurveto (31) |-                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                          while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //+dxa'0                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0'dyc                                  );                                  if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'+dyf                                   );                                  //                                  count -= 9;                                  i += 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'+0                                  );                                  //                                  count -= 8;                                  i += 8;                              }                            }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dx1 dx2 dy2 dy3 {dya dxb dyb dxc dxd dxe dye dyf}* dxf? hvcurveto (31) |-                            //If there is a multiple of four arguments' the curve starts                          //horizontal and ends vertical.                          //Note that the curves alternate between start horizontal' end vertical' and start vertical' and                          //end horizontal.The last curve(the odd argument case) need not                          //end horizontal/ vertical.                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                            if (count == 5)                          {                              //last one                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 3])  //dx3'dy3                                 );                                count -= 5;                              i += 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX)' (float)(curY += _argStack[i + 3])  //dy3                                 );                                count -= 4;                              i += 4;                          }                              while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc' +0                                  );                                if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //dxf'dyf                                   );                                  i += 9;                                  count -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX)' (float)(curY += _argStack[i + 7])  //0'dyf                                  );                                  //                                  i += 8;                                  count -= 8;                              }                            }                            _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HV_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dxa dxb dyb dyc dyd dxe dye dxf}+ dyf? hvcurveto (31) |-                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                          while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //+dxa'0                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0'dyc                                  );                                  if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'+dyf                                   );                                  //                                  count -= 9;                                  i += 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'+0                                  );                                  //                                  count -= 8;                                  i += 8;                              }                            }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dx1 dx2 dy2 dy3 {dya dxb dyb dxc dxd dxe dye dyf}* dxf? hvcurveto (31) |-                            //If there is a multiple of four arguments' the curve starts                          //horizontal and ends vertical.                          //Note that the curves alternate between start horizontal' end vertical' and start vertical' and                          //end horizontal.The last curve(the odd argument case) need not                          //end horizontal/ vertical.                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                            if (count == 5)                          {                              //last one                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 3])  //dx3'dy3                                 );                                count -= 5;                              i += 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX)' (float)(curY += _argStack[i + 3])  //dy3                                 );                                count -= 4;                              i += 4;                          }                              while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc' +0                                  );                                if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //dxf'dyf                                   );                                  i += 9;                                  count -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX)' (float)(curY += _argStack[i + 7])  //0'dyf                                  );                                  //                                  i += 8;                                  count -= 8;                              }                            }                            _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HV_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dxa dxb dyb dyc dyd dxe dye dxf}+ dyf? hvcurveto (31) |-                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                          while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //+dxa'0                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0'dyc                                  );                                  if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'+dyf                                   );                                  //                                  count -= 9;                                  i += 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'+0                                  );                                  //                                  count -= 8;                                  i += 8;                              }                            }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dx1 dx2 dy2 dy3 {dya dxb dyb dxc dxd dxe dye dyf}* dxf? hvcurveto (31) |-                            //If there is a multiple of four arguments' the curve starts                          //horizontal and ends vertical.                          //Note that the curves alternate between start horizontal' end vertical' and start vertical' and                          //end horizontal.The last curve(the odd argument case) need not                          //end horizontal/ vertical.                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                            if (count == 5)                          {                              //last one                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 3])  //dx3'dy3                                 );                                count -= 5;                              i += 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX)' (float)(curY += _argStack[i + 3])  //dy3                                 );                                count -= 4;                              i += 4;                          }                              while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc' +0                                  );                                if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //dxf'dyf                                   );                                  i += 9;                                  count -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX)' (float)(curY += _argStack[i + 7])  //0'dyf                                  );                                  //                                  i += 8;                                  count -= 8;                              }                            }                            _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HV_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dxa dxb dyb dyc dyd dxe dye dxf}+ dyf? hvcurveto (31) |-                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                          while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //+dxa'0                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0'dyc                                  );                                  if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'+dyf                                   );                                  //                                  count -= 9;                                  i += 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'+0                                  );                                  //                                  count -= 8;                                  i += 8;                              }                            }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dx1 dx2 dy2 dy3 {dya dxb dyb dxc dxd dxe dye dyf}* dxf? hvcurveto (31) |-                            //If there is a multiple of four arguments' the curve starts                          //horizontal and ends vertical.                          //Note that the curves alternate between start horizontal' end vertical' and start vertical' and                          //end horizontal.The last curve(the odd argument case) need not                          //end horizontal/ vertical.                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                            if (count == 5)                          {                              //last one                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 3])  //dx3'dy3                                 );                                count -= 5;                              i += 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX)' (float)(curY += _argStack[i + 3])  //dy3                                 );                                count -= 4;                              i += 4;                          }                              while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc' +0                                  );                                if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //dxf'dyf                                   );                                  i += 9;                                  count -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX)' (float)(curY += _argStack[i + 7])  //0'dyf                                  );                                  //                                  i += 8;                                  count -= 8;                              }                            }                            _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HV_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dxa dxb dyb dyc dyd dxe dye dxf}+ dyf? hvcurveto (31) |-                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                          while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //+dxa'0                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0'dyc                                  );                                  if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'+dyf                                   );                                  //                                  count -= 9;                                  i += 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'+0                                  );                                  //                                  count -= 8;                                  i += 8;                              }                            }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dx1 dx2 dy2 dy3 {dya dxb dyb dxc dxd dxe dye dyf}* dxf? hvcurveto (31) |-                            //If there is a multiple of four arguments' the curve starts                          //horizontal and ends vertical.                          //Note that the curves alternate between start horizontal' end vertical' and start vertical' and                          //end horizontal.The last curve(the odd argument case) need not                          //end horizontal/ vertical.                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                            if (count == 5)                          {                              //last one                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 3])  //dx3'dy3                                 );                                count -= 5;                              i += 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX)' (float)(curY += _argStack[i + 3])  //dy3                                 );                                count -= 4;                              i += 4;                          }                              while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc' +0                                  );                                if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //dxf'dyf                                   );                                  i += 9;                                  count -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX)' (float)(curY += _argStack[i + 7])  //0'dyf                                  );                                  //                                  i += 8;                                  count -= 8;                              }                            }                            _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HV_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dxa dxb dyb dyc dyd dxe dye dxf}+ dyf? hvcurveto (31) |-                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                          while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //+dxa'0                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0'dyc                                  );                                  if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'+dyf                                   );                                  //                                  count -= 9;                                  i += 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'+0                                  );                                  //                                  count -= 8;                                  i += 8;                              }                            }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dx1 dx2 dy2 dy3 {dya dxb dyb dxc dxd dxe dye dyf}* dxf? hvcurveto (31) |-                            //If there is a multiple of four arguments' the curve starts                          //horizontal and ends vertical.                          //Note that the curves alternate between start horizontal' end vertical' and start vertical' and                          //end horizontal.The last curve(the odd argument case) need not                          //end horizontal/ vertical.                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                            if (count == 5)                          {                              //last one                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 3])  //dx3'dy3                                 );                                count -= 5;                              i += 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX)' (float)(curY += _argStack[i + 3])  //dy3                                 );                                count -= 4;                              i += 4;                          }                              while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc' +0                                  );                                if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //dxf'dyf                                   );                                  i += 9;                                  count -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX)' (float)(curY += _argStack[i + 7])  //0'dyf                                  );                                  //                                  i += 8;                                  count -= 8;                              }                            }                            _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HV_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dxa dxb dyb dyc dyd dxe dye dxf}+ dyf? hvcurveto (31) |-                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                          while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //+dxa'0                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0'dyc                                  );                                  if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'+dyf                                   );                                  //                                  count -= 9;                                  i += 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'+0                                  );                                  //                                  count -= 8;                                  i += 8;                              }                            }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dx1 dx2 dy2 dy3 {dya dxb dyb dxc dxd dxe dye dyf}* dxf? hvcurveto (31) |-                            //If there is a multiple of four arguments' the curve starts                          //horizontal and ends vertical.                          //Note that the curves alternate between start horizontal' end vertical' and start vertical' and                          //end horizontal.The last curve(the odd argument case) need not                          //end horizontal/ vertical.                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                            if (count == 5)                          {                              //last one                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 3])  //dx3'dy3                                 );                                count -= 5;                              i += 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX)' (float)(curY += _argStack[i + 3])  //dy3                                 );                                count -= 4;                              i += 4;                          }                              while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc' +0                                  );                                if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //dxf'dyf                                   );                                  i += 9;                                  count -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX)' (float)(curY += _argStack[i + 7])  //0'dyf                                  );                                  //                                  i += 8;                                  count -= 8;                              }                            }                            _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HV_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dxa dxb dyb dyc dyd dxe dye dxf}+ dyf? hvcurveto (31) |-                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                          while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //+dxa'0                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0'dyc                                  );                                  if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'+dyf                                   );                                  //                                  count -= 9;                                  i += 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'+0                                  );                                  //                                  count -= 8;                                  i += 8;                              }                            }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dx1 dx2 dy2 dy3 {dya dxb dyb dxc dxd dxe dye dyf}* dxf? hvcurveto (31) |-                            //If there is a multiple of four arguments' the curve starts                          //horizontal and ends vertical.                          //Note that the curves alternate between start horizontal' end vertical' and start vertical' and                          //end horizontal.The last curve(the odd argument case) need not                          //end horizontal/ vertical.                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                            if (count == 5)                          {                              //last one                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 3])  //dx3'dy3                                 );                                count -= 5;                              i += 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX)' (float)(curY += _argStack[i + 3])  //dy3                                 );                                count -= 4;                              i += 4;                          }                              while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc' +0                                  );                                if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //dxf'dyf                                   );                                  i += 9;                                  count -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX)' (float)(curY += _argStack[i + 7])  //0'dyf                                  );                                  //                                  i += 8;                                  count -= 8;                              }                            }                            _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HV_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dxa dxb dyb dyc dyd dxe dye dxf}+ dyf? hvcurveto (31) |-                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                          while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //+dxa'0                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0'dyc                                  );                                  if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'+dyf                                   );                                  //                                  count -= 9;                                  i += 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'+0                                  );                                  //                                  count -= 8;                                  i += 8;                              }                            }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dx1 dx2 dy2 dy3 {dya dxb dyb dxc dxd dxe dye dyf}* dxf? hvcurveto (31) |-                            //If there is a multiple of four arguments' the curve starts                          //horizontal and ends vertical.                          //Note that the curves alternate between start horizontal' end vertical' and start vertical' and                          //end horizontal.The last curve(the odd argument case) need not                          //end horizontal/ vertical.                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                            if (count == 5)                          {                              //last one                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 3])  //dx3'dy3                                 );                                count -= 5;                              i += 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX)' (float)(curY += _argStack[i + 3])  //dy3                                 );                                count -= 4;                              i += 4;                          }                              while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc' +0                                  );                                if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //dxf'dyf                                   );                                  i += 9;                                  count -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX)' (float)(curY += _argStack[i + 7])  //0'dyf                                  );                                  //                                  i += 8;                                  count -= 8;                              }                            }                            _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HV_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dxa dxb dyb dyc dyd dxe dye dxf}+ dyf? hvcurveto (31) |-                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                          while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //+dxa'0                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0'dyc                                  );                                  if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'+dyf                                   );                                  //                                  count -= 9;                                  i += 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'+0                                  );                                  //                                  count -= 8;                                  i += 8;                              }                            }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dx1 dx2 dy2 dy3 {dya dxb dyb dxc dxd dxe dye dyf}* dxf? hvcurveto (31) |-                            //If there is a multiple of four arguments' the curve starts                          //horizontal and ends vertical.                          //Note that the curves alternate between start horizontal' end vertical' and start vertical' and                          //end horizontal.The last curve(the odd argument case) need not                          //end horizontal/ vertical.                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                            if (count == 5)                          {                              //last one                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 3])  //dx3'dy3                                 );                                count -= 5;                              i += 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX)' (float)(curY += _argStack[i + 3])  //dy3                                 );                                count -= 4;                              i += 4;                          }                              while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc' +0                                  );                                if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //dxf'dyf                                   );                                  i += 9;                                  count -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX)' (float)(curY += _argStack[i + 7])  //0'dyf                                  );                                  //                                  i += 8;                                  count -= 8;                              }                            }                            _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HV_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dxa dxb dyb dyc dyd dxe dye dxf}+ dyf? hvcurveto (31) |-                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                          while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //+dxa'0                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0'dyc                                  );                                  if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'+dyf                                   );                                  //                                  count -= 9;                                  i += 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'+0                                  );                                  //                                  count -= 8;                                  i += 8;                              }                            }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dx1 dx2 dy2 dy3 {dya dxb dyb dxc dxd dxe dye dyf}* dxf? hvcurveto (31) |-                            //If there is a multiple of four arguments' the curve starts                          //horizontal and ends vertical.                          //Note that the curves alternate between start horizontal' end vertical' and start vertical' and                          //end horizontal.The last curve(the odd argument case) need not                          //end horizontal/ vertical.                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                            if (count == 5)                          {                              //last one                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 3])  //dx3'dy3                                 );                                count -= 5;                              i += 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX)' (float)(curY += _argStack[i + 3])  //dy3                                 );                                count -= 4;                              i += 4;                          }                              while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc' +0                                  );                                if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //dxf'dyf                                   );                                  i += 9;                                  count -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX)' (float)(curY += _argStack[i + 7])  //0'dyf                                  );                                  //                                  i += 8;                                  count -= 8;                              }                            }                            _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HV_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dxa dxb dyb dyc dyd dxe dye dxf}+ dyf? hvcurveto (31) |-                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                          while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //+dxa'0                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0'dyc                                  );                                  if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'+dyf                                   );                                  //                                  count -= 9;                                  i += 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'+0                                  );                                  //                                  count -= 8;                                  i += 8;                              }                            }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dx1 dx2 dy2 dy3 {dya dxb dyb dxc dxd dxe dye dyf}* dxf? hvcurveto (31) |-                            //If there is a multiple of four arguments' the curve starts                          //horizontal and ends vertical.                          //Note that the curves alternate between start horizontal' end vertical' and start vertical' and                          //end horizontal.The last curve(the odd argument case) need not                          //end horizontal/ vertical.                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                            if (count == 5)                          {                              //last one                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 3])  //dx3'dy3                                 );                                count -= 5;                              i += 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX)' (float)(curY += _argStack[i + 3])  //dy3                                 );                                count -= 4;                              i += 4;                          }                              while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc' +0                                  );                                if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //dxf'dyf                                   );                                  i += 9;                                  count -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX)' (float)(curY += _argStack[i + 7])  //0'dyf                                  );                                  //                                  i += 8;                                  count -= 8;                              }                            }                            _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HV_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dxa dxb dyb dyc dyd dxe dye dxf}+ dyf? hvcurveto (31) |-                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                          while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //+dxa'0                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0'dyc                                  );                                  if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'+dyf                                   );                                  //                                  count -= 9;                                  i += 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'+0                                  );                                  //                                  count -= 8;                                  i += 8;                              }                            }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dx1 dx2 dy2 dy3 {dya dxb dyb dxc dxd dxe dye dyf}* dxf? hvcurveto (31) |-                            //If there is a multiple of four arguments' the curve starts                          //horizontal and ends vertical.                          //Note that the curves alternate between start horizontal' end vertical' and start vertical' and                          //end horizontal.The last curve(the odd argument case) need not                          //end horizontal/ vertical.                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                            if (count == 5)                          {                              //last one                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 3])  //dx3'dy3                                 );                                count -= 5;                              i += 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX)' (float)(curY += _argStack[i + 3])  //dy3                                 );                                count -= 4;                              i += 4;                          }                              while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc' +0                                  );                                if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //dxf'dyf                                   );                                  i += 9;                                  count -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX)' (float)(curY += _argStack[i + 7])  //0'dyf                                  );                                  //                                  i += 8;                                  count -= 8;                              }                            }                            _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HV_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dxa dxb dyb dyc dyd dxe dye dxf}+ dyf? hvcurveto (31) |-                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                          while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //+dxa'0                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0'dyc                                  );                                  if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'+dyf                                   );                                  //                                  count -= 9;                                  i += 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'+0                                  );                                  //                                  count -= 8;                                  i += 8;                              }                            }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dx1 dx2 dy2 dy3 {dya dxb dyb dxc dxd dxe dye dyf}* dxf? hvcurveto (31) |-                            //If there is a multiple of four arguments' the curve starts                          //horizontal and ends vertical.                          //Note that the curves alternate between start horizontal' end vertical' and start vertical' and                          //end horizontal.The last curve(the odd argument case) need not                          //end horizontal/ vertical.                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                            if (count == 5)                          {                              //last one                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 3])  //dx3'dy3                                 );                                count -= 5;                              i += 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX)' (float)(curY += _argStack[i + 3])  //dy3                                 );                                count -= 4;                              i += 4;                          }                              while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc' +0                                  );                                if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //dxf'dyf                                   );                                  i += 9;                                  count -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX)' (float)(curY += _argStack[i + 7])  //0'dyf                                  );                                  //                                  i += 8;                                  count -= 8;                              }                            }                            _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HV_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dxa dxb dyb dyc dyd dxe dye dxf}+ dyf? hvcurveto (31) |-                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                          while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //+dxa'0                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0'dyc                                  );                                  if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'+dyf                                   );                                  //                                  count -= 9;                                  i += 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'+0                                  );                                  //                                  count -= 8;                                  i += 8;                              }                            }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dx1 dx2 dy2 dy3 {dya dxb dyb dxc dxd dxe dye dyf}* dxf? hvcurveto (31) |-                            //If there is a multiple of four arguments' the curve starts                          //horizontal and ends vertical.                          //Note that the curves alternate between start horizontal' end vertical' and start vertical' and                          //end horizontal.The last curve(the odd argument case) need not                          //end horizontal/ vertical.                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                            if (count == 5)                          {                              //last one                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 3])  //dx3'dy3                                 );                                count -= 5;                              i += 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX)' (float)(curY += _argStack[i + 3])  //dy3                                 );                                count -= 4;                              i += 4;                          }                              while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc' +0                                  );                                if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //dxf'dyf                                   );                                  i += 9;                                  count -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX)' (float)(curY += _argStack[i + 7])  //0'dyf                                  );                                  //                                  i += 8;                                  count -= 8;                              }                            }                            _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HV_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dxa dxb dyb dyc dyd dxe dye dxf}+ dyf? hvcurveto (31) |-                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                          while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //+dxa'0                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0'dyc                                  );                                  if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'+dyf                                   );                                  //                                  count -= 9;                                  i += 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'+0                                  );                                  //                                  count -= 8;                                  i += 8;                              }                            }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dx1 dx2 dy2 dy3 {dya dxb dyb dxc dxd dxe dye dyf}* dxf? hvcurveto (31) |-                            //If there is a multiple of four arguments' the curve starts                          //horizontal and ends vertical.                          //Note that the curves alternate between start horizontal' end vertical' and start vertical' and                          //end horizontal.The last curve(the odd argument case) need not                          //end horizontal/ vertical.                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                            if (count == 5)                          {                              //last one                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 3])  //dx3'dy3                                 );                                count -= 5;                              i += 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX)' (float)(curY += _argStack[i + 3])  //dy3                                 );                                count -= 4;                              i += 4;                          }                              while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc' +0                                  );                                if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //dxf'dyf                                   );                                  i += 9;                                  count -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX)' (float)(curY += _argStack[i + 7])  //0'dyf                                  );                                  //                                  i += 8;                                  count -= 8;                              }                            }                            _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HV_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dxa dxb dyb dyc dyd dxe dye dxf}+ dyf? hvcurveto (31) |-                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                          while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //+dxa'0                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0'dyc                                  );                                  if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'+dyf                                   );                                  //                                  count -= 9;                                  i += 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'+0                                  );                                  //                                  count -= 8;                                  i += 8;                              }                            }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dx1 dx2 dy2 dy3 {dya dxb dyb dxc dxd dxe dye dyf}* dxf? hvcurveto (31) |-                            //If there is a multiple of four arguments' the curve starts                          //horizontal and ends vertical.                          //Note that the curves alternate between start horizontal' end vertical' and start vertical' and                          //end horizontal.The last curve(the odd argument case) need not                          //end horizontal/ vertical.                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                            if (count == 5)                          {                              //last one                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 3])  //dx3'dy3                                 );                                count -= 5;                              i += 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX)' (float)(curY += _argStack[i + 3])  //dy3                                 );                                count -= 4;                              i += 4;                          }                              while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc' +0                                  );                                if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //dxf'dyf                                   );                                  i += 9;                                  count -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX)' (float)(curY += _argStack[i + 7])  //0'dyf                                  );                                  //                                  i += 8;                                  count -= 8;                              }                            }                            _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HV_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dxa dxb dyb dyc dyd dxe dye dxf}+ dyf? hvcurveto (31) |-                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                          while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //+dxa'0                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0'dyc                                  );                                  if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'+dyf                                   );                                  //                                  count -= 9;                                  i += 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'+0                                  );                                  //                                  count -= 8;                                  i += 8;                              }                            }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dx1 dx2 dy2 dy3 {dya dxb dyb dxc dxd dxe dye dyf}* dxf? hvcurveto (31) |-                            //If there is a multiple of four arguments' the curve starts                          //horizontal and ends vertical.                          //Note that the curves alternate between start horizontal' end vertical' and start vertical' and                          //end horizontal.The last curve(the odd argument case) need not                          //end horizontal/ vertical.                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                            if (count == 5)                          {                              //last one                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 3])  //dx3'dy3                                 );                                count -= 5;                              i += 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX)' (float)(curY += _argStack[i + 3])  //dy3                                 );                                count -= 4;                              i += 4;                          }                              while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc' +0                                  );                                if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //dxf'dyf                                   );                                  i += 9;                                  count -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX)' (float)(curY += _argStack[i + 7])  //0'dyf                                  );                                  //                                  i += 8;                                  count -= 8;                              }                            }                            _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HV_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dxa dxb dyb dyc dyd dxe dye dxf}+ dyf? hvcurveto (31) |-                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                          while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //+dxa'0                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0'dyc                                  );                                  if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'+dyf                                   );                                  //                                  count -= 9;                                  i += 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'+0                                  );                                  //                                  count -= 8;                                  i += 8;                              }                            }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dx1 dx2 dy2 dy3 {dya dxb dyb dxc dxd dxe dye dyf}* dxf? hvcurveto (31) |-                            //If there is a multiple of four arguments' the curve starts                          //horizontal and ends vertical.                          //Note that the curves alternate between start horizontal' end vertical' and start vertical' and                          //end horizontal.The last curve(the odd argument case) need not                          //end horizontal/ vertical.                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                            if (count == 5)                          {                              //last one                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 3])  //dx3'dy3                                 );                                count -= 5;                              i += 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX)' (float)(curY += _argStack[i + 3])  //dy3                                 );                                count -= 4;                              i += 4;                          }                              while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc' +0                                  );                                if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //dxf'dyf                                   );                                  i += 9;                                  count -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX)' (float)(curY += _argStack[i + 7])  //0'dyf                                  );                                  //                                  i += 8;                                  count -= 8;                              }                            }                            _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HV_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dxa dxb dyb dyc dyd dxe dye dxf}+ dyf? hvcurveto (31) |-                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                          while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //+dxa'0                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0'dyc                                  );                                  if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'+dyf                                   );                                  //                                  count -= 9;                                  i += 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'+0                                  );                                  //                                  count -= 8;                                  i += 8;                              }                            }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dx1 dx2 dy2 dy3 {dya dxb dyb dxc dxd dxe dye dyf}* dxf? hvcurveto (31) |-                            //If there is a multiple of four arguments' the curve starts                          //horizontal and ends vertical.                          //Note that the curves alternate between start horizontal' end vertical' and start vertical' and                          //end horizontal.The last curve(the odd argument case) need not                          //end horizontal/ vertical.                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                            if (count == 5)                          {                              //last one                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 3])  //dx3'dy3                                 );                                count -= 5;                              i += 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX)' (float)(curY += _argStack[i + 3])  //dy3                                 );                                count -= 4;                              i += 4;                          }                              while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc' +0                                  );                                if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //dxf'dyf                                   );                                  i += 9;                                  count -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX)' (float)(curY += _argStack[i + 7])  //0'dyf                                  );                                  //                                  i += 8;                                  count -= 8;                              }                            }                            _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HV_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dxa dxb dyb dyc dyd dxe dye dxf}+ dyf? hvcurveto (31) |-                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                          while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //+dxa'0                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0'dyc                                  );                                  if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'+dyf                                   );                                  //                                  count -= 9;                                  i += 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'+0                                  );                                  //                                  count -= 8;                                  i += 8;                              }                            }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dx1 dx2 dy2 dy3 {dya dxb dyb dxc dxd dxe dye dyf}* dxf? hvcurveto (31) |-                            //If there is a multiple of four arguments' the curve starts                          //horizontal and ends vertical.                          //Note that the curves alternate between start horizontal' end vertical' and start vertical' and                          //end horizontal.The last curve(the odd argument case) need not                          //end horizontal/ vertical.                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                            if (count == 5)                          {                              //last one                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 3])  //dx3'dy3                                 );                                count -= 5;                              i += 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX)' (float)(curY += _argStack[i + 3])  //dy3                                 );                                count -= 4;                              i += 4;                          }                              while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc' +0                                  );                                if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //dxf'dyf                                   );                                  i += 9;                                  count -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX)' (float)(curY += _argStack[i + 7])  //0'dyf                                  );                                  //                                  i += 8;                                  count -= 8;                              }                            }                            _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HV_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dxa dxb dyb dyc dyd dxe dye dxf}+ dyf? hvcurveto (31) |-                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                          while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //+dxa'0                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0'dyc                                  );                                  if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'+dyf                                   );                                  //                                  count -= 9;                                  i += 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'+0                                  );                                  //                                  count -= 8;                                  i += 8;                              }                            }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dx1 dx2 dy2 dy3 {dya dxb dyb dxc dxd dxe dye dyf}* dxf? hvcurveto (31) |-                            //If there is a multiple of four arguments' the curve starts                          //horizontal and ends vertical.                          //Note that the curves alternate between start horizontal' end vertical' and start vertical' and                          //end horizontal.The last curve(the odd argument case) need not                          //end horizontal/ vertical.                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                            if (count == 5)                          {                              //last one                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 3])  //dx3'dy3                                 );                                count -= 5;                              i += 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX)' (float)(curY += _argStack[i + 3])  //dy3                                 );                                count -= 4;                              i += 4;                          }                              while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc' +0                                  );                                if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //dxf'dyf                                   );                                  i += 9;                                  count -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX)' (float)(curY += _argStack[i + 7])  //0'dyf                                  );                                  //                                  i += 8;                                  count -= 8;                              }                            }                            _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HV_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dxa dxb dyb dyc dyd dxe dye dxf}+ dyf? hvcurveto (31) |-                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                          while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //+dxa'0                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0'dyc                                  );                                  if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'+dyf                                   );                                  //                                  count -= 9;                                  i += 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'+0                                  );                                  //                                  count -= 8;                                  i += 8;                              }                            }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dx1 dx2 dy2 dy3 {dya dxb dyb dxc dxd dxe dye dyf}* dxf? hvcurveto (31) |-                            //If there is a multiple of four arguments' the curve starts                          //horizontal and ends vertical.                          //Note that the curves alternate between start horizontal' end vertical' and start vertical' and                          //end horizontal.The last curve(the odd argument case) need not                          //end horizontal/ vertical.                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                            if (count == 5)                          {                              //last one                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 3])  //dx3'dy3                                 );                                count -= 5;                              i += 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX)' (float)(curY += _argStack[i + 3])  //dy3                                 );                                count -= 4;                              i += 4;                          }                              while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc' +0                                  );                                if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //dxf'dyf                                   );                                  i += 9;                                  count -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX)' (float)(curY += _argStack[i + 7])  //0'dyf                                  );                                  //                                  i += 8;                                  count -= 8;                              }                            }                            _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HV_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dxa dxb dyb dyc dyd dxe dye dxf}+ dyf? hvcurveto (31) |-                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                          while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //+dxa'0                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0'dyc                                  );                                  if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'+dyf                                   );                                  //                                  count -= 9;                                  i += 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'+0                                  );                                  //                                  count -= 8;                                  i += 8;                              }                            }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dx1 dx2 dy2 dy3 {dya dxb dyb dxc dxd dxe dye dyf}* dxf? hvcurveto (31) |-                            //If there is a multiple of four arguments' the curve starts                          //horizontal and ends vertical.                          //Note that the curves alternate between start horizontal' end vertical' and start vertical' and                          //end horizontal.The last curve(the odd argument case) need not                          //end horizontal/ vertical.                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                            if (count == 5)                          {                              //last one                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 3])  //dx3'dy3                                 );                                count -= 5;                              i += 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX)' (float)(curY += _argStack[i + 3])  //dy3                                 );                                count -= 4;                              i += 4;                          }                              while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc' +0                                  );                                if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //dxf'dyf                                   );                                  i += 9;                                  count -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX)' (float)(curY += _argStack[i + 7])  //0'dyf                                  );                                  //                                  i += 8;                                  count -= 8;                              }                            }                            _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HV_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dxa dxb dyb dyc dyd dxe dye dxf}+ dyf? hvcurveto (31) |-                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                          while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //+dxa'0                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0'dyc                                  );                                  if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'+dyf                                   );                                  //                                  count -= 9;                                  i += 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'+0                                  );                                  //                                  count -= 8;                                  i += 8;                              }                            }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dx1 dx2 dy2 dy3 {dya dxb dyb dxc dxd dxe dye dyf}* dxf? hvcurveto (31) |-                            //If there is a multiple of four arguments' the curve starts                          //horizontal and ends vertical.                          //Note that the curves alternate between start horizontal' end vertical' and start vertical' and                          //end horizontal.The last curve(the odd argument case) need not                          //end horizontal/ vertical.                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                            if (count == 5)                          {                              //last one                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 3])  //dx3'dy3                                 );                                count -= 5;                              i += 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX)' (float)(curY += _argStack[i + 3])  //dy3                                 );                                count -= 4;                              i += 4;                          }                              while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc' +0                                  );                                if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //dxf'dyf                                   );                                  i += 9;                                  count -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX)' (float)(curY += _argStack[i + 7])  //0'dyf                                  );                                  //                                  i += 8;                                  count -= 8;                              }                            }                            _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HV_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dxa dxb dyb dyc dyd dxe dye dxf}+ dyf? hvcurveto (31) |-                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                          while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //+dxa'0                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0'dyc                                  );                                  if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'+dyf                                   );                                  //                                  count -= 9;                                  i += 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'+0                                  );                                  //                                  count -= 8;                                  i += 8;                              }                            }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dx1 dx2 dy2 dy3 {dya dxb dyb dxc dxd dxe dye dyf}* dxf? hvcurveto (31) |-                            //If there is a multiple of four arguments' the curve starts                          //horizontal and ends vertical.                          //Note that the curves alternate between start horizontal' end vertical' and start vertical' and                          //end horizontal.The last curve(the odd argument case) need not                          //end horizontal/ vertical.                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                            if (count == 5)                          {                              //last one                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 3])  //dx3'dy3                                 );                                count -= 5;                              i += 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX)' (float)(curY += _argStack[i + 3])  //dy3                                 );                                count -= 4;                              i += 4;                          }                              while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc' +0                                  );                                if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //dxf'dyf                                   );                                  i += 9;                                  count -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX)' (float)(curY += _argStack[i + 7])  //0'dyf                                  );                                  //                                  i += 8;                                  count -= 8;                              }                            }                            _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HV_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dxa dxb dyb dyc dyd dxe dye dxf}+ dyf? hvcurveto (31) |-                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                          while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //+dxa'0                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0'dyc                                  );                                  if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'+dyf                                   );                                  //                                  count -= 9;                                  i += 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'+0                                  );                                  //                                  count -= 8;                                  i += 8;                              }                            }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dx1 dx2 dy2 dy3 {dya dxb dyb dxc dxd dxe dye dyf}* dxf? hvcurveto (31) |-                            //If there is a multiple of four arguments' the curve starts                          //horizontal and ends vertical.                          //Note that the curves alternate between start horizontal' end vertical' and start vertical' and                          //end horizontal.The last curve(the odd argument case) need not                          //end horizontal/ vertical.                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                            if (count == 5)                          {                              //last one                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 3])  //dx3'dy3                                 );                                count -= 5;                              i += 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX)' (float)(curY += _argStack[i + 3])  //dy3                                 );                                count -= 4;                              i += 4;                          }                              while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc' +0                                  );                                if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //dxf'dyf                                   );                                  i += 9;                                  count -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX)' (float)(curY += _argStack[i + 7])  //0'dyf                                  );                                  //                                  i += 8;                                  count -= 8;                              }                            }                            _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HV_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dxa dxb dyb dyc dyd dxe dye dxf}+ dyf? hvcurveto (31) |-                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                          while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //+dxa'0                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0'dyc                                  );                                  if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'+dyf                                   );                                  //                                  count -= 9;                                  i += 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'+0                                  );                                  //                                  count -= 8;                                  i += 8;                              }                            }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dx1 dx2 dy2 dy3 {dya dxb dyb dxc dxd dxe dye dyf}* dxf? hvcurveto (31) |-                            //If there is a multiple of four arguments' the curve starts                          //horizontal and ends vertical.                          //Note that the curves alternate between start horizontal' end vertical' and start vertical' and                          //end horizontal.The last curve(the odd argument case) need not                          //end horizontal/ vertical.                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                            if (count == 5)                          {                              //last one                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 3])  //dx3'dy3                                 );                                count -= 5;                              i += 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX)' (float)(curY += _argStack[i + 3])  //dy3                                 );                                count -= 4;                              i += 4;                          }                              while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc' +0                                  );                                if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //dxf'dyf                                   );                                  i += 9;                                  count -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX)' (float)(curY += _argStack[i + 7])  //0'dyf                                  );                                  //                                  i += 8;                                  count -= 8;                              }                            }                            _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HV_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dxa dxb dyb dyc dyd dxe dye dxf}+ dyf? hvcurveto (31) |-                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                          while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //+dxa'0                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0'dyc                                  );                                  if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'+dyf                                   );                                  //                                  count -= 9;                                  i += 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'+0                                  );                                  //                                  count -= 8;                                  i += 8;                              }                            }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dx1 dx2 dy2 dy3 {dya dxb dyb dxc dxd dxe dye dyf}* dxf? hvcurveto (31) |-                            //If there is a multiple of four arguments' the curve starts                          //horizontal and ends vertical.                          //Note that the curves alternate between start horizontal' end vertical' and start vertical' and                          //end horizontal.The last curve(the odd argument case) need not                          //end horizontal/ vertical.                            double curX = _currentX;                          double curY = _currentY;                            int count = _currentIndex;                            if (count == 5)                          {                              //last one                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 3])  //dx3'dy3                                 );                                count -= 5;                              i += 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                 (float)(curX += _argStack[i + 0])' (float)(curY)' //dx1                                 (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                 (float)(curX)' (float)(curY += _argStack[i + 3])  //dy3                                 );                                count -= 4;                              i += 4;                          }                              while (count > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc' +0                                  );                                if (count == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //dxf'dyf                                   );                                  i += 9;                                  count -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'0                                  (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                  (float)(curX)' (float)(curY += _argStack[i + 7])  //0'dyf                                  );                                  //                                  i += 8;                                  count -= 8;                              }                            }                            _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,R_CurveLine,The following statement contains a magic number: dbugGlyphIndex == 192
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,R_CurveLine,The following statement contains a magic number: _glyphTranslator.Curve4(                      (float)(curX += _argStack[i + 0])' (float)(curY += _argStack[i + 1])' //dxa'dya                      (float)(curX += _argStack[i + 2])' (float)(curY += _argStack[i + 3])' //dxb'dyb                      (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 5])  //dxc'dyc                      );
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,R_CurveLine,The following statement contains a magic number: _glyphTranslator.Curve4(                      (float)(curX += _argStack[i + 0])' (float)(curY += _argStack[i + 1])' //dxa'dya                      (float)(curX += _argStack[i + 2])' (float)(curY += _argStack[i + 3])' //dxb'dyb                      (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 5])  //dxc'dyc                      );
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,R_CurveLine,The following statement contains a magic number: _glyphTranslator.Curve4(                      (float)(curX += _argStack[i + 0])' (float)(curY += _argStack[i + 1])' //dxa'dya                      (float)(curX += _argStack[i + 2])' (float)(curY += _argStack[i + 3])' //dxb'dyb                      (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 5])  //dxc'dyc                      );
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,R_CurveLine,The following statement contains a magic number: _glyphTranslator.Curve4(                      (float)(curX += _argStack[i + 0])' (float)(curY += _argStack[i + 1])' //dxa'dya                      (float)(curX += _argStack[i + 2])' (float)(curY += _argStack[i + 3])' //dxb'dyb                      (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 5])  //dxc'dyc                      );
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,R_CurveLine,The following statement contains a magic number: i += 6;
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,R_CurveLine,The following statement contains a magic number: count -= 6;
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,R_CurveLine,The following statement contains a magic number: count == 2
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,R_LineCurve,The following statement contains a magic number: dbugGlyphIndex == 192
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,R_LineCurve,The following statement contains a magic number: i += 2;
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,R_LineCurve,The following statement contains a magic number: count -= 2;
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,R_LineCurve,The following statement contains a magic number: _glyphTranslator.Curve4(                      (float)(curX += _argStack[i + 0])' (float)(curY += _argStack[i + 1])' //dxa'dya                      (float)(curX += _argStack[i + 2])' (float)(curY += _argStack[i + 3])' //dxb'dyb                      (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 5])  //dxc'dyc                      );
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,R_LineCurve,The following statement contains a magic number: _glyphTranslator.Curve4(                      (float)(curX += _argStack[i + 0])' (float)(curY += _argStack[i + 1])' //dxa'dya                      (float)(curX += _argStack[i + 2])' (float)(curY += _argStack[i + 3])' //dxb'dyb                      (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 5])  //dxc'dyc                      );
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,R_LineCurve,The following statement contains a magic number: _glyphTranslator.Curve4(                      (float)(curX += _argStack[i + 0])' (float)(curY += _argStack[i + 1])' //dxa'dya                      (float)(curX += _argStack[i + 2])' (float)(curY += _argStack[i + 3])' //dxb'dyb                      (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 5])  //dxc'dyc                      );
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,R_LineCurve,The following statement contains a magic number: _glyphTranslator.Curve4(                      (float)(curX += _argStack[i + 0])' (float)(curY += _argStack[i + 1])' //dxa'dya                      (float)(curX += _argStack[i + 2])' (float)(curY += _argStack[i + 3])' //dxb'dyb                      (float)(curX += _argStack[i + 4])' (float)(curY += _argStack[i + 5])  //dxc'dyc                      );
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,R_LineCurve,The following statement contains a magic number: count == 6
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VH_CurveTo,The following statement contains a magic number: dbugGlyphIndex == 207
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VH_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dya dxb dyb dxc dxd dxe dye dyf}+ dxf? vhcurveto (30) |-                            double curX = _currentX;                          double curY = _currentY;                          int ncount = _currentIndex;                          while (ncount > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //+0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc'+0                                  );                                if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //+dxf'dyf                                   );                                  //                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX)' (float)(curY += _argStack[i + 7])  //+0'dyf                                   );                                  //                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dy1 dx2 dy2 dx3 {dxa dxb dyb dyc dyd dxe dye dxf}* dyf? vhcurveto (30) |-                          double curX = _currentX;                          double curY = _currentY;                            int ncount = _currentIndex;                          if (ncount == 5)                          {                              //only 1                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY += _argStack[i + 4]) //dx3'dyf                                );                              i += 5;                              ncount -= 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY) //dx3                                );                              i += 4;                              ncount -= 4;                          }                            while (ncount > 0)                          {                              //line to                                _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //dxa'                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0' dyc                                  );                              if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'dyf                                      );                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'0                                      );                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VH_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dya dxb dyb dxc dxd dxe dye dyf}+ dxf? vhcurveto (30) |-                            double curX = _currentX;                          double curY = _currentY;                          int ncount = _currentIndex;                          while (ncount > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //+0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc'+0                                  );                                if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //+dxf'dyf                                   );                                  //                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX)' (float)(curY += _argStack[i + 7])  //+0'dyf                                   );                                  //                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dy1 dx2 dy2 dx3 {dxa dxb dyb dyc dyd dxe dye dxf}* dyf? vhcurveto (30) |-                          double curX = _currentX;                          double curY = _currentY;                            int ncount = _currentIndex;                          if (ncount == 5)                          {                              //only 1                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY += _argStack[i + 4]) //dx3'dyf                                );                              i += 5;                              ncount -= 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY) //dx3                                );                              i += 4;                              ncount -= 4;                          }                            while (ncount > 0)                          {                              //line to                                _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //dxa'                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0' dyc                                  );                              if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'dyf                                      );                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'0                                      );                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VH_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dya dxb dyb dxc dxd dxe dye dyf}+ dxf? vhcurveto (30) |-                            double curX = _currentX;                          double curY = _currentY;                          int ncount = _currentIndex;                          while (ncount > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //+0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc'+0                                  );                                if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //+dxf'dyf                                   );                                  //                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX)' (float)(curY += _argStack[i + 7])  //+0'dyf                                   );                                  //                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dy1 dx2 dy2 dx3 {dxa dxb dyb dyc dyd dxe dye dxf}* dyf? vhcurveto (30) |-                          double curX = _currentX;                          double curY = _currentY;                            int ncount = _currentIndex;                          if (ncount == 5)                          {                              //only 1                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY += _argStack[i + 4]) //dx3'dyf                                );                              i += 5;                              ncount -= 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY) //dx3                                );                              i += 4;                              ncount -= 4;                          }                            while (ncount > 0)                          {                              //line to                                _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //dxa'                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0' dyc                                  );                              if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'dyf                                      );                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'0                                      );                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VH_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dya dxb dyb dxc dxd dxe dye dyf}+ dxf? vhcurveto (30) |-                            double curX = _currentX;                          double curY = _currentY;                          int ncount = _currentIndex;                          while (ncount > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //+0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc'+0                                  );                                if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //+dxf'dyf                                   );                                  //                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX)' (float)(curY += _argStack[i + 7])  //+0'dyf                                   );                                  //                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dy1 dx2 dy2 dx3 {dxa dxb dyb dyc dyd dxe dye dxf}* dyf? vhcurveto (30) |-                          double curX = _currentX;                          double curY = _currentY;                            int ncount = _currentIndex;                          if (ncount == 5)                          {                              //only 1                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY += _argStack[i + 4]) //dx3'dyf                                );                              i += 5;                              ncount -= 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY) //dx3                                );                              i += 4;                              ncount -= 4;                          }                            while (ncount > 0)                          {                              //line to                                _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //dxa'                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0' dyc                                  );                              if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'dyf                                      );                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'0                                      );                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VH_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dya dxb dyb dxc dxd dxe dye dyf}+ dxf? vhcurveto (30) |-                            double curX = _currentX;                          double curY = _currentY;                          int ncount = _currentIndex;                          while (ncount > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //+0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc'+0                                  );                                if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //+dxf'dyf                                   );                                  //                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX)' (float)(curY += _argStack[i + 7])  //+0'dyf                                   );                                  //                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dy1 dx2 dy2 dx3 {dxa dxb dyb dyc dyd dxe dye dxf}* dyf? vhcurveto (30) |-                          double curX = _currentX;                          double curY = _currentY;                            int ncount = _currentIndex;                          if (ncount == 5)                          {                              //only 1                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY += _argStack[i + 4]) //dx3'dyf                                );                              i += 5;                              ncount -= 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY) //dx3                                );                              i += 4;                              ncount -= 4;                          }                            while (ncount > 0)                          {                              //line to                                _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //dxa'                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0' dyc                                  );                              if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'dyf                                      );                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'0                                      );                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VH_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dya dxb dyb dxc dxd dxe dye dyf}+ dxf? vhcurveto (30) |-                            double curX = _currentX;                          double curY = _currentY;                          int ncount = _currentIndex;                          while (ncount > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //+0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc'+0                                  );                                if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //+dxf'dyf                                   );                                  //                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX)' (float)(curY += _argStack[i + 7])  //+0'dyf                                   );                                  //                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dy1 dx2 dy2 dx3 {dxa dxb dyb dyc dyd dxe dye dxf}* dyf? vhcurveto (30) |-                          double curX = _currentX;                          double curY = _currentY;                            int ncount = _currentIndex;                          if (ncount == 5)                          {                              //only 1                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY += _argStack[i + 4]) //dx3'dyf                                );                              i += 5;                              ncount -= 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY) //dx3                                );                              i += 4;                              ncount -= 4;                          }                            while (ncount > 0)                          {                              //line to                                _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //dxa'                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0' dyc                                  );                              if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'dyf                                      );                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'0                                      );                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VH_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dya dxb dyb dxc dxd dxe dye dyf}+ dxf? vhcurveto (30) |-                            double curX = _currentX;                          double curY = _currentY;                          int ncount = _currentIndex;                          while (ncount > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //+0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc'+0                                  );                                if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //+dxf'dyf                                   );                                  //                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX)' (float)(curY += _argStack[i + 7])  //+0'dyf                                   );                                  //                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dy1 dx2 dy2 dx3 {dxa dxb dyb dyc dyd dxe dye dxf}* dyf? vhcurveto (30) |-                          double curX = _currentX;                          double curY = _currentY;                            int ncount = _currentIndex;                          if (ncount == 5)                          {                              //only 1                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY += _argStack[i + 4]) //dx3'dyf                                );                              i += 5;                              ncount -= 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY) //dx3                                );                              i += 4;                              ncount -= 4;                          }                            while (ncount > 0)                          {                              //line to                                _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //dxa'                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0' dyc                                  );                              if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'dyf                                      );                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'0                                      );                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VH_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dya dxb dyb dxc dxd dxe dye dyf}+ dxf? vhcurveto (30) |-                            double curX = _currentX;                          double curY = _currentY;                          int ncount = _currentIndex;                          while (ncount > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //+0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc'+0                                  );                                if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //+dxf'dyf                                   );                                  //                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX)' (float)(curY += _argStack[i + 7])  //+0'dyf                                   );                                  //                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dy1 dx2 dy2 dx3 {dxa dxb dyb dyc dyd dxe dye dxf}* dyf? vhcurveto (30) |-                          double curX = _currentX;                          double curY = _currentY;                            int ncount = _currentIndex;                          if (ncount == 5)                          {                              //only 1                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY += _argStack[i + 4]) //dx3'dyf                                );                              i += 5;                              ncount -= 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY) //dx3                                );                              i += 4;                              ncount -= 4;                          }                            while (ncount > 0)                          {                              //line to                                _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //dxa'                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0' dyc                                  );                              if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'dyf                                      );                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'0                                      );                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VH_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dya dxb dyb dxc dxd dxe dye dyf}+ dxf? vhcurveto (30) |-                            double curX = _currentX;                          double curY = _currentY;                          int ncount = _currentIndex;                          while (ncount > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //+0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc'+0                                  );                                if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //+dxf'dyf                                   );                                  //                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX)' (float)(curY += _argStack[i + 7])  //+0'dyf                                   );                                  //                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dy1 dx2 dy2 dx3 {dxa dxb dyb dyc dyd dxe dye dxf}* dyf? vhcurveto (30) |-                          double curX = _currentX;                          double curY = _currentY;                            int ncount = _currentIndex;                          if (ncount == 5)                          {                              //only 1                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY += _argStack[i + 4]) //dx3'dyf                                );                              i += 5;                              ncount -= 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY) //dx3                                );                              i += 4;                              ncount -= 4;                          }                            while (ncount > 0)                          {                              //line to                                _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //dxa'                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0' dyc                                  );                              if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'dyf                                      );                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'0                                      );                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VH_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dya dxb dyb dxc dxd dxe dye dyf}+ dxf? vhcurveto (30) |-                            double curX = _currentX;                          double curY = _currentY;                          int ncount = _currentIndex;                          while (ncount > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //+0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc'+0                                  );                                if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //+dxf'dyf                                   );                                  //                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX)' (float)(curY += _argStack[i + 7])  //+0'dyf                                   );                                  //                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dy1 dx2 dy2 dx3 {dxa dxb dyb dyc dyd dxe dye dxf}* dyf? vhcurveto (30) |-                          double curX = _currentX;                          double curY = _currentY;                            int ncount = _currentIndex;                          if (ncount == 5)                          {                              //only 1                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY += _argStack[i + 4]) //dx3'dyf                                );                              i += 5;                              ncount -= 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY) //dx3                                );                              i += 4;                              ncount -= 4;                          }                            while (ncount > 0)                          {                              //line to                                _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //dxa'                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0' dyc                                  );                              if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'dyf                                      );                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'0                                      );                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VH_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dya dxb dyb dxc dxd dxe dye dyf}+ dxf? vhcurveto (30) |-                            double curX = _currentX;                          double curY = _currentY;                          int ncount = _currentIndex;                          while (ncount > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //+0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc'+0                                  );                                if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //+dxf'dyf                                   );                                  //                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX)' (float)(curY += _argStack[i + 7])  //+0'dyf                                   );                                  //                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dy1 dx2 dy2 dx3 {dxa dxb dyb dyc dyd dxe dye dxf}* dyf? vhcurveto (30) |-                          double curX = _currentX;                          double curY = _currentY;                            int ncount = _currentIndex;                          if (ncount == 5)                          {                              //only 1                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY += _argStack[i + 4]) //dx3'dyf                                );                              i += 5;                              ncount -= 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY) //dx3                                );                              i += 4;                              ncount -= 4;                          }                            while (ncount > 0)                          {                              //line to                                _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //dxa'                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0' dyc                                  );                              if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'dyf                                      );                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'0                                      );                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VH_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dya dxb dyb dxc dxd dxe dye dyf}+ dxf? vhcurveto (30) |-                            double curX = _currentX;                          double curY = _currentY;                          int ncount = _currentIndex;                          while (ncount > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //+0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc'+0                                  );                                if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //+dxf'dyf                                   );                                  //                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX)' (float)(curY += _argStack[i + 7])  //+0'dyf                                   );                                  //                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dy1 dx2 dy2 dx3 {dxa dxb dyb dyc dyd dxe dye dxf}* dyf? vhcurveto (30) |-                          double curX = _currentX;                          double curY = _currentY;                            int ncount = _currentIndex;                          if (ncount == 5)                          {                              //only 1                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY += _argStack[i + 4]) //dx3'dyf                                );                              i += 5;                              ncount -= 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY) //dx3                                );                              i += 4;                              ncount -= 4;                          }                            while (ncount > 0)                          {                              //line to                                _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //dxa'                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0' dyc                                  );                              if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'dyf                                      );                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'0                                      );                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VH_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dya dxb dyb dxc dxd dxe dye dyf}+ dxf? vhcurveto (30) |-                            double curX = _currentX;                          double curY = _currentY;                          int ncount = _currentIndex;                          while (ncount > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //+0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc'+0                                  );                                if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //+dxf'dyf                                   );                                  //                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX)' (float)(curY += _argStack[i + 7])  //+0'dyf                                   );                                  //                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dy1 dx2 dy2 dx3 {dxa dxb dyb dyc dyd dxe dye dxf}* dyf? vhcurveto (30) |-                          double curX = _currentX;                          double curY = _currentY;                            int ncount = _currentIndex;                          if (ncount == 5)                          {                              //only 1                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY += _argStack[i + 4]) //dx3'dyf                                );                              i += 5;                              ncount -= 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY) //dx3                                );                              i += 4;                              ncount -= 4;                          }                            while (ncount > 0)                          {                              //line to                                _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //dxa'                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0' dyc                                  );                              if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'dyf                                      );                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'0                                      );                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VH_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dya dxb dyb dxc dxd dxe dye dyf}+ dxf? vhcurveto (30) |-                            double curX = _currentX;                          double curY = _currentY;                          int ncount = _currentIndex;                          while (ncount > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //+0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc'+0                                  );                                if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //+dxf'dyf                                   );                                  //                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX)' (float)(curY += _argStack[i + 7])  //+0'dyf                                   );                                  //                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dy1 dx2 dy2 dx3 {dxa dxb dyb dyc dyd dxe dye dxf}* dyf? vhcurveto (30) |-                          double curX = _currentX;                          double curY = _currentY;                            int ncount = _currentIndex;                          if (ncount == 5)                          {                              //only 1                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY += _argStack[i + 4]) //dx3'dyf                                );                              i += 5;                              ncount -= 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY) //dx3                                );                              i += 4;                              ncount -= 4;                          }                            while (ncount > 0)                          {                              //line to                                _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //dxa'                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0' dyc                                  );                              if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'dyf                                      );                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'0                                      );                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VH_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dya dxb dyb dxc dxd dxe dye dyf}+ dxf? vhcurveto (30) |-                            double curX = _currentX;                          double curY = _currentY;                          int ncount = _currentIndex;                          while (ncount > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //+0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc'+0                                  );                                if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //+dxf'dyf                                   );                                  //                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX)' (float)(curY += _argStack[i + 7])  //+0'dyf                                   );                                  //                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dy1 dx2 dy2 dx3 {dxa dxb dyb dyc dyd dxe dye dxf}* dyf? vhcurveto (30) |-                          double curX = _currentX;                          double curY = _currentY;                            int ncount = _currentIndex;                          if (ncount == 5)                          {                              //only 1                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY += _argStack[i + 4]) //dx3'dyf                                );                              i += 5;                              ncount -= 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY) //dx3                                );                              i += 4;                              ncount -= 4;                          }                            while (ncount > 0)                          {                              //line to                                _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //dxa'                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0' dyc                                  );                              if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'dyf                                      );                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'0                                      );                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VH_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dya dxb dyb dxc dxd dxe dye dyf}+ dxf? vhcurveto (30) |-                            double curX = _currentX;                          double curY = _currentY;                          int ncount = _currentIndex;                          while (ncount > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //+0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc'+0                                  );                                if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //+dxf'dyf                                   );                                  //                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX)' (float)(curY += _argStack[i + 7])  //+0'dyf                                   );                                  //                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dy1 dx2 dy2 dx3 {dxa dxb dyb dyc dyd dxe dye dxf}* dyf? vhcurveto (30) |-                          double curX = _currentX;                          double curY = _currentY;                            int ncount = _currentIndex;                          if (ncount == 5)                          {                              //only 1                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY += _argStack[i + 4]) //dx3'dyf                                );                              i += 5;                              ncount -= 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY) //dx3                                );                              i += 4;                              ncount -= 4;                          }                            while (ncount > 0)                          {                              //line to                                _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //dxa'                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0' dyc                                  );                              if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'dyf                                      );                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'0                                      );                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VH_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dya dxb dyb dxc dxd dxe dye dyf}+ dxf? vhcurveto (30) |-                            double curX = _currentX;                          double curY = _currentY;                          int ncount = _currentIndex;                          while (ncount > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //+0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc'+0                                  );                                if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //+dxf'dyf                                   );                                  //                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX)' (float)(curY += _argStack[i + 7])  //+0'dyf                                   );                                  //                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dy1 dx2 dy2 dx3 {dxa dxb dyb dyc dyd dxe dye dxf}* dyf? vhcurveto (30) |-                          double curX = _currentX;                          double curY = _currentY;                            int ncount = _currentIndex;                          if (ncount == 5)                          {                              //only 1                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY += _argStack[i + 4]) //dx3'dyf                                );                              i += 5;                              ncount -= 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY) //dx3                                );                              i += 4;                              ncount -= 4;                          }                            while (ncount > 0)                          {                              //line to                                _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //dxa'                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0' dyc                                  );                              if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'dyf                                      );                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'0                                      );                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VH_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dya dxb dyb dxc dxd dxe dye dyf}+ dxf? vhcurveto (30) |-                            double curX = _currentX;                          double curY = _currentY;                          int ncount = _currentIndex;                          while (ncount > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //+0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc'+0                                  );                                if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //+dxf'dyf                                   );                                  //                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX)' (float)(curY += _argStack[i + 7])  //+0'dyf                                   );                                  //                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dy1 dx2 dy2 dx3 {dxa dxb dyb dyc dyd dxe dye dxf}* dyf? vhcurveto (30) |-                          double curX = _currentX;                          double curY = _currentY;                            int ncount = _currentIndex;                          if (ncount == 5)                          {                              //only 1                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY += _argStack[i + 4]) //dx3'dyf                                );                              i += 5;                              ncount -= 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY) //dx3                                );                              i += 4;                              ncount -= 4;                          }                            while (ncount > 0)                          {                              //line to                                _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //dxa'                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0' dyc                                  );                              if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'dyf                                      );                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'0                                      );                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VH_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dya dxb dyb dxc dxd dxe dye dyf}+ dxf? vhcurveto (30) |-                            double curX = _currentX;                          double curY = _currentY;                          int ncount = _currentIndex;                          while (ncount > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //+0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc'+0                                  );                                if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //+dxf'dyf                                   );                                  //                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX)' (float)(curY += _argStack[i + 7])  //+0'dyf                                   );                                  //                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dy1 dx2 dy2 dx3 {dxa dxb dyb dyc dyd dxe dye dxf}* dyf? vhcurveto (30) |-                          double curX = _currentX;                          double curY = _currentY;                            int ncount = _currentIndex;                          if (ncount == 5)                          {                              //only 1                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY += _argStack[i + 4]) //dx3'dyf                                );                              i += 5;                              ncount -= 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY) //dx3                                );                              i += 4;                              ncount -= 4;                          }                            while (ncount > 0)                          {                              //line to                                _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //dxa'                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0' dyc                                  );                              if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'dyf                                      );                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'0                                      );                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VH_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dya dxb dyb dxc dxd dxe dye dyf}+ dxf? vhcurveto (30) |-                            double curX = _currentX;                          double curY = _currentY;                          int ncount = _currentIndex;                          while (ncount > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //+0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc'+0                                  );                                if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //+dxf'dyf                                   );                                  //                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX)' (float)(curY += _argStack[i + 7])  //+0'dyf                                   );                                  //                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dy1 dx2 dy2 dx3 {dxa dxb dyb dyc dyd dxe dye dxf}* dyf? vhcurveto (30) |-                          double curX = _currentX;                          double curY = _currentY;                            int ncount = _currentIndex;                          if (ncount == 5)                          {                              //only 1                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY += _argStack[i + 4]) //dx3'dyf                                );                              i += 5;                              ncount -= 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY) //dx3                                );                              i += 4;                              ncount -= 4;                          }                            while (ncount > 0)                          {                              //line to                                _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //dxa'                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0' dyc                                  );                              if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'dyf                                      );                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'0                                      );                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VH_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dya dxb dyb dxc dxd dxe dye dyf}+ dxf? vhcurveto (30) |-                            double curX = _currentX;                          double curY = _currentY;                          int ncount = _currentIndex;                          while (ncount > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //+0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc'+0                                  );                                if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //+dxf'dyf                                   );                                  //                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX)' (float)(curY += _argStack[i + 7])  //+0'dyf                                   );                                  //                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dy1 dx2 dy2 dx3 {dxa dxb dyb dyc dyd dxe dye dxf}* dyf? vhcurveto (30) |-                          double curX = _currentX;                          double curY = _currentY;                            int ncount = _currentIndex;                          if (ncount == 5)                          {                              //only 1                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY += _argStack[i + 4]) //dx3'dyf                                );                              i += 5;                              ncount -= 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY) //dx3                                );                              i += 4;                              ncount -= 4;                          }                            while (ncount > 0)                          {                              //line to                                _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //dxa'                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0' dyc                                  );                              if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'dyf                                      );                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'0                                      );                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VH_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dya dxb dyb dxc dxd dxe dye dyf}+ dxf? vhcurveto (30) |-                            double curX = _currentX;                          double curY = _currentY;                          int ncount = _currentIndex;                          while (ncount > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //+0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc'+0                                  );                                if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //+dxf'dyf                                   );                                  //                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX)' (float)(curY += _argStack[i + 7])  //+0'dyf                                   );                                  //                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dy1 dx2 dy2 dx3 {dxa dxb dyb dyc dyd dxe dye dxf}* dyf? vhcurveto (30) |-                          double curX = _currentX;                          double curY = _currentY;                            int ncount = _currentIndex;                          if (ncount == 5)                          {                              //only 1                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY += _argStack[i + 4]) //dx3'dyf                                );                              i += 5;                              ncount -= 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY) //dx3                                );                              i += 4;                              ncount -= 4;                          }                            while (ncount > 0)                          {                              //line to                                _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //dxa'                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0' dyc                                  );                              if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'dyf                                      );                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'0                                      );                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VH_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dya dxb dyb dxc dxd dxe dye dyf}+ dxf? vhcurveto (30) |-                            double curX = _currentX;                          double curY = _currentY;                          int ncount = _currentIndex;                          while (ncount > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //+0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc'+0                                  );                                if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //+dxf'dyf                                   );                                  //                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX)' (float)(curY += _argStack[i + 7])  //+0'dyf                                   );                                  //                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dy1 dx2 dy2 dx3 {dxa dxb dyb dyc dyd dxe dye dxf}* dyf? vhcurveto (30) |-                          double curX = _currentX;                          double curY = _currentY;                            int ncount = _currentIndex;                          if (ncount == 5)                          {                              //only 1                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY += _argStack[i + 4]) //dx3'dyf                                );                              i += 5;                              ncount -= 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY) //dx3                                );                              i += 4;                              ncount -= 4;                          }                            while (ncount > 0)                          {                              //line to                                _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //dxa'                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0' dyc                                  );                              if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'dyf                                      );                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'0                                      );                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VH_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dya dxb dyb dxc dxd dxe dye dyf}+ dxf? vhcurveto (30) |-                            double curX = _currentX;                          double curY = _currentY;                          int ncount = _currentIndex;                          while (ncount > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //+0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc'+0                                  );                                if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //+dxf'dyf                                   );                                  //                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX)' (float)(curY += _argStack[i + 7])  //+0'dyf                                   );                                  //                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dy1 dx2 dy2 dx3 {dxa dxb dyb dyc dyd dxe dye dxf}* dyf? vhcurveto (30) |-                          double curX = _currentX;                          double curY = _currentY;                            int ncount = _currentIndex;                          if (ncount == 5)                          {                              //only 1                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY += _argStack[i + 4]) //dx3'dyf                                );                              i += 5;                              ncount -= 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY) //dx3                                );                              i += 4;                              ncount -= 4;                          }                            while (ncount > 0)                          {                              //line to                                _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //dxa'                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0' dyc                                  );                              if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'dyf                                      );                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'0                                      );                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VH_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dya dxb dyb dxc dxd dxe dye dyf}+ dxf? vhcurveto (30) |-                            double curX = _currentX;                          double curY = _currentY;                          int ncount = _currentIndex;                          while (ncount > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //+0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc'+0                                  );                                if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //+dxf'dyf                                   );                                  //                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX)' (float)(curY += _argStack[i + 7])  //+0'dyf                                   );                                  //                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dy1 dx2 dy2 dx3 {dxa dxb dyb dyc dyd dxe dye dxf}* dyf? vhcurveto (30) |-                          double curX = _currentX;                          double curY = _currentY;                            int ncount = _currentIndex;                          if (ncount == 5)                          {                              //only 1                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY += _argStack[i + 4]) //dx3'dyf                                );                              i += 5;                              ncount -= 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY) //dx3                                );                              i += 4;                              ncount -= 4;                          }                            while (ncount > 0)                          {                              //line to                                _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //dxa'                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0' dyc                                  );                              if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'dyf                                      );                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'0                                      );                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VH_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dya dxb dyb dxc dxd dxe dye dyf}+ dxf? vhcurveto (30) |-                            double curX = _currentX;                          double curY = _currentY;                          int ncount = _currentIndex;                          while (ncount > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //+0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc'+0                                  );                                if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //+dxf'dyf                                   );                                  //                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX)' (float)(curY += _argStack[i + 7])  //+0'dyf                                   );                                  //                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dy1 dx2 dy2 dx3 {dxa dxb dyb dyc dyd dxe dye dxf}* dyf? vhcurveto (30) |-                          double curX = _currentX;                          double curY = _currentY;                            int ncount = _currentIndex;                          if (ncount == 5)                          {                              //only 1                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY += _argStack[i + 4]) //dx3'dyf                                );                              i += 5;                              ncount -= 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY) //dx3                                );                              i += 4;                              ncount -= 4;                          }                            while (ncount > 0)                          {                              //line to                                _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //dxa'                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0' dyc                                  );                              if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'dyf                                      );                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'0                                      );                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VH_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dya dxb dyb dxc dxd dxe dye dyf}+ dxf? vhcurveto (30) |-                            double curX = _currentX;                          double curY = _currentY;                          int ncount = _currentIndex;                          while (ncount > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //+0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc'+0                                  );                                if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //+dxf'dyf                                   );                                  //                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX)' (float)(curY += _argStack[i + 7])  //+0'dyf                                   );                                  //                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dy1 dx2 dy2 dx3 {dxa dxb dyb dyc dyd dxe dye dxf}* dyf? vhcurveto (30) |-                          double curX = _currentX;                          double curY = _currentY;                            int ncount = _currentIndex;                          if (ncount == 5)                          {                              //only 1                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY += _argStack[i + 4]) //dx3'dyf                                );                              i += 5;                              ncount -= 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY) //dx3                                );                              i += 4;                              ncount -= 4;                          }                            while (ncount > 0)                          {                              //line to                                _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //dxa'                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0' dyc                                  );                              if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'dyf                                      );                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'0                                      );                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VH_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dya dxb dyb dxc dxd dxe dye dyf}+ dxf? vhcurveto (30) |-                            double curX = _currentX;                          double curY = _currentY;                          int ncount = _currentIndex;                          while (ncount > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //+0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc'+0                                  );                                if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //+dxf'dyf                                   );                                  //                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX)' (float)(curY += _argStack[i + 7])  //+0'dyf                                   );                                  //                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dy1 dx2 dy2 dx3 {dxa dxb dyb dyc dyd dxe dye dxf}* dyf? vhcurveto (30) |-                          double curX = _currentX;                          double curY = _currentY;                            int ncount = _currentIndex;                          if (ncount == 5)                          {                              //only 1                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY += _argStack[i + 4]) //dx3'dyf                                );                              i += 5;                              ncount -= 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY) //dx3                                );                              i += 4;                              ncount -= 4;                          }                            while (ncount > 0)                          {                              //line to                                _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //dxa'                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0' dyc                                  );                              if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'dyf                                      );                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'0                                      );                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VH_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dya dxb dyb dxc dxd dxe dye dyf}+ dxf? vhcurveto (30) |-                            double curX = _currentX;                          double curY = _currentY;                          int ncount = _currentIndex;                          while (ncount > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //+0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc'+0                                  );                                if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //+dxf'dyf                                   );                                  //                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX)' (float)(curY += _argStack[i + 7])  //+0'dyf                                   );                                  //                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dy1 dx2 dy2 dx3 {dxa dxb dyb dyc dyd dxe dye dxf}* dyf? vhcurveto (30) |-                          double curX = _currentX;                          double curY = _currentY;                            int ncount = _currentIndex;                          if (ncount == 5)                          {                              //only 1                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY += _argStack[i + 4]) //dx3'dyf                                );                              i += 5;                              ncount -= 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY) //dx3                                );                              i += 4;                              ncount -= 4;                          }                            while (ncount > 0)                          {                              //line to                                _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //dxa'                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0' dyc                                  );                              if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'dyf                                      );                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'0                                      );                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VH_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dya dxb dyb dxc dxd dxe dye dyf}+ dxf? vhcurveto (30) |-                            double curX = _currentX;                          double curY = _currentY;                          int ncount = _currentIndex;                          while (ncount > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //+0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc'+0                                  );                                if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //+dxf'dyf                                   );                                  //                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX)' (float)(curY += _argStack[i + 7])  //+0'dyf                                   );                                  //                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dy1 dx2 dy2 dx3 {dxa dxb dyb dyc dyd dxe dye dxf}* dyf? vhcurveto (30) |-                          double curX = _currentX;                          double curY = _currentY;                            int ncount = _currentIndex;                          if (ncount == 5)                          {                              //only 1                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY += _argStack[i + 4]) //dx3'dyf                                );                              i += 5;                              ncount -= 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY) //dx3                                );                              i += 4;                              ncount -= 4;                          }                            while (ncount > 0)                          {                              //line to                                _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //dxa'                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0' dyc                                  );                              if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'dyf                                      );                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'0                                      );                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VH_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dya dxb dyb dxc dxd dxe dye dyf}+ dxf? vhcurveto (30) |-                            double curX = _currentX;                          double curY = _currentY;                          int ncount = _currentIndex;                          while (ncount > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //+0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc'+0                                  );                                if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //+dxf'dyf                                   );                                  //                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX)' (float)(curY += _argStack[i + 7])  //+0'dyf                                   );                                  //                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dy1 dx2 dy2 dx3 {dxa dxb dyb dyc dyd dxe dye dxf}* dyf? vhcurveto (30) |-                          double curX = _currentX;                          double curY = _currentY;                            int ncount = _currentIndex;                          if (ncount == 5)                          {                              //only 1                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY += _argStack[i + 4]) //dx3'dyf                                );                              i += 5;                              ncount -= 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY) //dx3                                );                              i += 4;                              ncount -= 4;                          }                            while (ncount > 0)                          {                              //line to                                _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //dxa'                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0' dyc                                  );                              if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'dyf                                      );                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'0                                      );                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VH_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dya dxb dyb dxc dxd dxe dye dyf}+ dxf? vhcurveto (30) |-                            double curX = _currentX;                          double curY = _currentY;                          int ncount = _currentIndex;                          while (ncount > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //+0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc'+0                                  );                                if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //+dxf'dyf                                   );                                  //                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX)' (float)(curY += _argStack[i + 7])  //+0'dyf                                   );                                  //                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dy1 dx2 dy2 dx3 {dxa dxb dyb dyc dyd dxe dye dxf}* dyf? vhcurveto (30) |-                          double curX = _currentX;                          double curY = _currentY;                            int ncount = _currentIndex;                          if (ncount == 5)                          {                              //only 1                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY += _argStack[i + 4]) //dx3'dyf                                );                              i += 5;                              ncount -= 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY) //dx3                                );                              i += 4;                              ncount -= 4;                          }                            while (ncount > 0)                          {                              //line to                                _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //dxa'                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0' dyc                                  );                              if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'dyf                                      );                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'0                                      );                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VH_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dya dxb dyb dxc dxd dxe dye dyf}+ dxf? vhcurveto (30) |-                            double curX = _currentX;                          double curY = _currentY;                          int ncount = _currentIndex;                          while (ncount > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //+0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc'+0                                  );                                if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //+dxf'dyf                                   );                                  //                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX)' (float)(curY += _argStack[i + 7])  //+0'dyf                                   );                                  //                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dy1 dx2 dy2 dx3 {dxa dxb dyb dyc dyd dxe dye dxf}* dyf? vhcurveto (30) |-                          double curX = _currentX;                          double curY = _currentY;                            int ncount = _currentIndex;                          if (ncount == 5)                          {                              //only 1                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY += _argStack[i + 4]) //dx3'dyf                                );                              i += 5;                              ncount -= 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY) //dx3                                );                              i += 4;                              ncount -= 4;                          }                            while (ncount > 0)                          {                              //line to                                _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //dxa'                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0' dyc                                  );                              if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'dyf                                      );                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'0                                      );                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VH_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dya dxb dyb dxc dxd dxe dye dyf}+ dxf? vhcurveto (30) |-                            double curX = _currentX;                          double curY = _currentY;                          int ncount = _currentIndex;                          while (ncount > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //+0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc'+0                                  );                                if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //+dxf'dyf                                   );                                  //                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX)' (float)(curY += _argStack[i + 7])  //+0'dyf                                   );                                  //                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dy1 dx2 dy2 dx3 {dxa dxb dyb dyc dyd dxe dye dxf}* dyf? vhcurveto (30) |-                          double curX = _currentX;                          double curY = _currentY;                            int ncount = _currentIndex;                          if (ncount == 5)                          {                              //only 1                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY += _argStack[i + 4]) //dx3'dyf                                );                              i += 5;                              ncount -= 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY) //dx3                                );                              i += 4;                              ncount -= 4;                          }                            while (ncount > 0)                          {                              //line to                                _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //dxa'                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0' dyc                                  );                              if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'dyf                                      );                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'0                                      );                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VH_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dya dxb dyb dxc dxd dxe dye dyf}+ dxf? vhcurveto (30) |-                            double curX = _currentX;                          double curY = _currentY;                          int ncount = _currentIndex;                          while (ncount > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //+0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc'+0                                  );                                if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //+dxf'dyf                                   );                                  //                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX)' (float)(curY += _argStack[i + 7])  //+0'dyf                                   );                                  //                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dy1 dx2 dy2 dx3 {dxa dxb dyb dyc dyd dxe dye dxf}* dyf? vhcurveto (30) |-                          double curX = _currentX;                          double curY = _currentY;                            int ncount = _currentIndex;                          if (ncount == 5)                          {                              //only 1                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY += _argStack[i + 4]) //dx3'dyf                                );                              i += 5;                              ncount -= 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY) //dx3                                );                              i += 4;                              ncount -= 4;                          }                            while (ncount > 0)                          {                              //line to                                _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //dxa'                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0' dyc                                  );                              if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'dyf                                      );                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'0                                      );                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VH_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dya dxb dyb dxc dxd dxe dye dyf}+ dxf? vhcurveto (30) |-                            double curX = _currentX;                          double curY = _currentY;                          int ncount = _currentIndex;                          while (ncount > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //+0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc'+0                                  );                                if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //+dxf'dyf                                   );                                  //                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX)' (float)(curY += _argStack[i + 7])  //+0'dyf                                   );                                  //                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dy1 dx2 dy2 dx3 {dxa dxb dyb dyc dyd dxe dye dxf}* dyf? vhcurveto (30) |-                          double curX = _currentX;                          double curY = _currentY;                            int ncount = _currentIndex;                          if (ncount == 5)                          {                              //only 1                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY += _argStack[i + 4]) //dx3'dyf                                );                              i += 5;                              ncount -= 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY) //dx3                                );                              i += 4;                              ncount -= 4;                          }                            while (ncount > 0)                          {                              //line to                                _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //dxa'                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0' dyc                                  );                              if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'dyf                                      );                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'0                                      );                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VH_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dya dxb dyb dxc dxd dxe dye dyf}+ dxf? vhcurveto (30) |-                            double curX = _currentX;                          double curY = _currentY;                          int ncount = _currentIndex;                          while (ncount > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //+0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc'+0                                  );                                if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //+dxf'dyf                                   );                                  //                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX)' (float)(curY += _argStack[i + 7])  //+0'dyf                                   );                                  //                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dy1 dx2 dy2 dx3 {dxa dxb dyb dyc dyd dxe dye dxf}* dyf? vhcurveto (30) |-                          double curX = _currentX;                          double curY = _currentY;                            int ncount = _currentIndex;                          if (ncount == 5)                          {                              //only 1                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY += _argStack[i + 4]) //dx3'dyf                                );                              i += 5;                              ncount -= 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY) //dx3                                );                              i += 4;                              ncount -= 4;                          }                            while (ncount > 0)                          {                              //line to                                _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //dxa'                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0' dyc                                  );                              if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'dyf                                      );                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'0                                      );                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VH_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dya dxb dyb dxc dxd dxe dye dyf}+ dxf? vhcurveto (30) |-                            double curX = _currentX;                          double curY = _currentY;                          int ncount = _currentIndex;                          while (ncount > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //+0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc'+0                                  );                                if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //+dxf'dyf                                   );                                  //                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX)' (float)(curY += _argStack[i + 7])  //+0'dyf                                   );                                  //                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dy1 dx2 dy2 dx3 {dxa dxb dyb dyc dyd dxe dye dxf}* dyf? vhcurveto (30) |-                          double curX = _currentX;                          double curY = _currentY;                            int ncount = _currentIndex;                          if (ncount == 5)                          {                              //only 1                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY += _argStack[i + 4]) //dx3'dyf                                );                              i += 5;                              ncount -= 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY) //dx3                                );                              i += 4;                              ncount -= 4;                          }                            while (ncount > 0)                          {                              //line to                                _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //dxa'                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0' dyc                                  );                              if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'dyf                                      );                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'0                                      );                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VH_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dya dxb dyb dxc dxd dxe dye dyf}+ dxf? vhcurveto (30) |-                            double curX = _currentX;                          double curY = _currentY;                          int ncount = _currentIndex;                          while (ncount > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //+0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc'+0                                  );                                if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //+dxf'dyf                                   );                                  //                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX)' (float)(curY += _argStack[i + 7])  //+0'dyf                                   );                                  //                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dy1 dx2 dy2 dx3 {dxa dxb dyb dyc dyd dxe dye dxf}* dyf? vhcurveto (30) |-                          double curX = _currentX;                          double curY = _currentY;                            int ncount = _currentIndex;                          if (ncount == 5)                          {                              //only 1                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY += _argStack[i + 4]) //dx3'dyf                                );                              i += 5;                              ncount -= 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY) //dx3                                );                              i += 4;                              ncount -= 4;                          }                            while (ncount > 0)                          {                              //line to                                _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //dxa'                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0' dyc                                  );                              if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'dyf                                      );                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'0                                      );                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VH_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dya dxb dyb dxc dxd dxe dye dyf}+ dxf? vhcurveto (30) |-                            double curX = _currentX;                          double curY = _currentY;                          int ncount = _currentIndex;                          while (ncount > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //+0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc'+0                                  );                                if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //+dxf'dyf                                   );                                  //                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX)' (float)(curY += _argStack[i + 7])  //+0'dyf                                   );                                  //                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dy1 dx2 dy2 dx3 {dxa dxb dyb dyc dyd dxe dye dxf}* dyf? vhcurveto (30) |-                          double curX = _currentX;                          double curY = _currentY;                            int ncount = _currentIndex;                          if (ncount == 5)                          {                              //only 1                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY += _argStack[i + 4]) //dx3'dyf                                );                              i += 5;                              ncount -= 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY) //dx3                                );                              i += 4;                              ncount -= 4;                          }                            while (ncount > 0)                          {                              //line to                                _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //dxa'                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0' dyc                                  );                              if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'dyf                                      );                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'0                                      );                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VH_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dya dxb dyb dxc dxd dxe dye dyf}+ dxf? vhcurveto (30) |-                            double curX = _currentX;                          double curY = _currentY;                          int ncount = _currentIndex;                          while (ncount > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //+0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc'+0                                  );                                if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //+dxf'dyf                                   );                                  //                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX)' (float)(curY += _argStack[i + 7])  //+0'dyf                                   );                                  //                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dy1 dx2 dy2 dx3 {dxa dxb dyb dyc dyd dxe dye dxf}* dyf? vhcurveto (30) |-                          double curX = _currentX;                          double curY = _currentY;                            int ncount = _currentIndex;                          if (ncount == 5)                          {                              //only 1                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY += _argStack[i + 4]) //dx3'dyf                                );                              i += 5;                              ncount -= 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY) //dx3                                );                              i += 4;                              ncount -= 4;                          }                            while (ncount > 0)                          {                              //line to                                _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //dxa'                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0' dyc                                  );                              if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'dyf                                      );                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'0                                      );                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VH_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dya dxb dyb dxc dxd dxe dye dyf}+ dxf? vhcurveto (30) |-                            double curX = _currentX;                          double curY = _currentY;                          int ncount = _currentIndex;                          while (ncount > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //+0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc'+0                                  );                                if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //+dxf'dyf                                   );                                  //                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX)' (float)(curY += _argStack[i + 7])  //+0'dyf                                   );                                  //                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dy1 dx2 dy2 dx3 {dxa dxb dyb dyc dyd dxe dye dxf}* dyf? vhcurveto (30) |-                          double curX = _currentX;                          double curY = _currentY;                            int ncount = _currentIndex;                          if (ncount == 5)                          {                              //only 1                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY += _argStack[i + 4]) //dx3'dyf                                );                              i += 5;                              ncount -= 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY) //dx3                                );                              i += 4;                              ncount -= 4;                          }                            while (ncount > 0)                          {                              //line to                                _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //dxa'                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0' dyc                                  );                              if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'dyf                                      );                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'0                                      );                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VH_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dya dxb dyb dxc dxd dxe dye dyf}+ dxf? vhcurveto (30) |-                            double curX = _currentX;                          double curY = _currentY;                          int ncount = _currentIndex;                          while (ncount > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //+0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc'+0                                  );                                if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //+dxf'dyf                                   );                                  //                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX)' (float)(curY += _argStack[i + 7])  //+0'dyf                                   );                                  //                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dy1 dx2 dy2 dx3 {dxa dxb dyb dyc dyd dxe dye dxf}* dyf? vhcurveto (30) |-                          double curX = _currentX;                          double curY = _currentY;                            int ncount = _currentIndex;                          if (ncount == 5)                          {                              //only 1                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY += _argStack[i + 4]) //dx3'dyf                                );                              i += 5;                              ncount -= 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY) //dx3                                );                              i += 4;                              ncount -= 4;                          }                            while (ncount > 0)                          {                              //line to                                _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //dxa'                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0' dyc                                  );                              if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'dyf                                      );                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'0                                      );                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VH_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dya dxb dyb dxc dxd dxe dye dyf}+ dxf? vhcurveto (30) |-                            double curX = _currentX;                          double curY = _currentY;                          int ncount = _currentIndex;                          while (ncount > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //+0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc'+0                                  );                                if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //+dxf'dyf                                   );                                  //                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX)' (float)(curY += _argStack[i + 7])  //+0'dyf                                   );                                  //                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dy1 dx2 dy2 dx3 {dxa dxb dyb dyc dyd dxe dye dxf}* dyf? vhcurveto (30) |-                          double curX = _currentX;                          double curY = _currentY;                            int ncount = _currentIndex;                          if (ncount == 5)                          {                              //only 1                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY += _argStack[i + 4]) //dx3'dyf                                );                              i += 5;                              ncount -= 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY) //dx3                                );                              i += 4;                              ncount -= 4;                          }                            while (ncount > 0)                          {                              //line to                                _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //dxa'                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0' dyc                                  );                              if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'dyf                                      );                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'0                                      );                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VH_CurveTo,The following statement contains a magic number: switch (remainder = (_currentIndex % 8))              {                  default: throw new NotSupportedException();                  case 0:                  case 1:                      {                          //|- {dya dxb dyb dxc dxd dxe dye dyf}+ dxf? vhcurveto (30) |-                            double curX = _currentX;                          double curY = _currentY;                          int ncount = _currentIndex;                          while (ncount > 0)                          {                              _glyphTranslator.Curve4(                                  (float)(curX)' (float)(curY += _argStack[i + 0])' //+0'dya                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX += _argStack[i + 3])' (float)(curY)  //dxc'+0                                  );                                if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX += _argStack[i + 8])' (float)(curY += _argStack[i + 7])  //+dxf'dyf                                   );                                  //                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                   (float)(curX += _argStack[i + 4])' (float)(curY)' //dxd'+0                                   (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                   (float)(curX)' (float)(curY += _argStack[i + 7])  //+0'dyf                                   );                                  //                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;                    case 4:                  case 5:                      {                            //|- dy1 dx2 dy2 dx3 {dxa dxb dyb dyc dyd dxe dye dxf}* dyf? vhcurveto (30) |-                          double curX = _currentX;                          double curY = _currentY;                            int ncount = _currentIndex;                          if (ncount == 5)                          {                              //only 1                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY += _argStack[i + 4]) //dx3'dyf                                );                              i += 5;                              ncount -= 5;                          }                          else                          {                              _glyphTranslator.Curve4(                                (float)(curX)' (float)(curY += _argStack[i + 0])' //dy1                                (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dx2'dy2                                (float)(curX += _argStack[i + 3])' (float)(curY) //dx3                                );                              i += 4;                              ncount -= 4;                          }                            while (ncount > 0)                          {                              //line to                                _glyphTranslator.Curve4(                                  (float)(curX += _argStack[i + 0])' (float)(curY)' //dxa'                                  (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                                  (float)(curX)' (float)(curY += _argStack[i + 3])  //+0' dyc                                  );                              if (ncount == 9)                              {                                  //last cycle                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY += _argStack[i + 8])  //dxf'dyf                                      );                                  i += 9;                                  ncount -= 9;                              }                              else                              {                                  _glyphTranslator.Curve4(                                      (float)(curX)' (float)(curY += _argStack[i + 4])' //+0'dyd                                      (float)(curX += _argStack[i + 5])' (float)(curY += _argStack[i + 6])' //dxe'dye                                      (float)(curX += _argStack[i + 7])' (float)(curY)  //dxf'0                                      );                                  i += 8;                                  ncount -= 8;                              }                          }                          _currentX = curX;                          _currentY = curY;                      }                      break;              }
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VV_CurveTo,The following statement contains a magic number: _glyphTranslator.Curve4(                     (float)(curX += _argStack[0])' (float)(curY += _argStack[1])' //dx1?'+dya                     (float)(curX += _argStack[2])' (float)(curY += _argStack[3])' //dxb'dyb                     (float)(curX)' (float)(curY += _argStack[4])  //+0'+dyc                     );
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VV_CurveTo,The following statement contains a magic number: _glyphTranslator.Curve4(                     (float)(curX += _argStack[0])' (float)(curY += _argStack[1])' //dx1?'+dya                     (float)(curX += _argStack[2])' (float)(curY += _argStack[3])' //dxb'dyb                     (float)(curX)' (float)(curY += _argStack[4])  //+0'+dyc                     );
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VV_CurveTo,The following statement contains a magic number: _glyphTranslator.Curve4(                     (float)(curX += _argStack[0])' (float)(curY += _argStack[1])' //dx1?'+dya                     (float)(curX += _argStack[2])' (float)(curY += _argStack[3])' //dxb'dyb                     (float)(curX)' (float)(curY += _argStack[4])  //+0'+dyc                     );
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VV_CurveTo,The following statement contains a magic number: i += 5;
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VV_CurveTo,The following statement contains a magic number: count -= 5;
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VV_CurveTo,The following statement contains a magic number: (count % 2) != 0
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VV_CurveTo,The following statement contains a magic number: _glyphTranslator.Curve4(                      (float)(curX)' (float)(curY += _argStack[i + 0])' //+0'dya                      (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                      (float)(curX)' (float)(curY += _argStack[i + 3])  //+0'dyc                      );
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VV_CurveTo,The following statement contains a magic number: _glyphTranslator.Curve4(                      (float)(curX)' (float)(curY += _argStack[i + 0])' //+0'dya                      (float)(curX += _argStack[i + 1])' (float)(curY += _argStack[i + 2])' //dxb'dyb                      (float)(curX)' (float)(curY += _argStack[i + 3])  //+0'dyc                      );
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VV_CurveTo,The following statement contains a magic number: i += 4;
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,VV_CurveTo,The following statement contains a magic number: count -= 4;
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,H_Stem,The following statement contains a magic number: (_currentIndex % 2) != 0
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,V_Stem,The following statement contains a magic number: (_currentIndex % 2) != 0
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,V_StemHM,The following statement contains a magic number: (_currentIndex % 2) != 0
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,H_StemHM,The following statement contains a magic number: (_currentIndex % 2) != 0
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HintMaskBits,The following statement contains a magic number: _currentIndex != (bitCount + 7) / 8
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,HintMaskBits,The following statement contains a magic number: _currentIndex != (bitCount + 7) / 8
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,CounterSpaceMaskBits,The following statement contains a magic number: _currentIndex != (bitCount + 7) / 8
Magic Number,Typography.OpenFont.CFF,Type2EvaluationStack,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CffEvaluationEngine.cs,CounterSpaceMaskBits,The following statement contains a magic number: _currentIndex != (bitCount + 7) / 8
Magic Number,Typography.OpenFont.CFF,Cff1Parser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,ReadCharsets,The following statement contains a magic number: switch (format)              {                  default:                      throw new NotSupportedException();                  case 0:                      ReadCharsetsFormat0();                      break;                  case 1:                      ReadCharsetsFormat1();                      break;                  case 2:                      ReadCharsetsFormat2();                      break;              }
Magic Number,Typography.OpenFont.CFF,Cff1Parser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,ReadEntry,The following statement contains a magic number: b0 >= 0 && b0 <= 21
Magic Number,Typography.OpenFont.CFF,Cff1Parser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,ReadOperator,The following statement contains a magic number: b0 == 12
Magic Number,Typography.OpenFont.CFF,Cff1Parser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,ReadRealNumber,The following statement contains a magic number: int nb_0 = (b >> 4) & 0xf;
Magic Number,Typography.OpenFont.CFF,Cff1Parser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,ReadRealNumber,The following statement contains a magic number: !done && i < 2
Magic Number,Typography.OpenFont.CFF,Cff1Parser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,ReadIntegerNumber,The following statement contains a magic number: b0 == 28
Magic Number,Typography.OpenFont.CFF,CFFBinaryReaderExtension,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,ReadOffset,The following statement contains a magic number: switch (offsetSize)              {                  default: throw new NotSupportedException();                  case 1:                      return reader.ReadByte();                  case 2:                      return (reader.ReadByte() << 8) | (reader.ReadByte() << 0);                  case 3:                      return (reader.ReadByte() << 16) | (reader.ReadByte() << 8) | (reader.ReadByte() << 0);                  case 4:                      return (reader.ReadByte() << 24) | (reader.ReadByte() << 16) | (reader.ReadByte() << 8) | (reader.ReadByte() << 0);              }
Magic Number,Typography.OpenFont.CFF,CFFBinaryReaderExtension,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,ReadOffset,The following statement contains a magic number: switch (offsetSize)              {                  default: throw new NotSupportedException();                  case 1:                      return reader.ReadByte();                  case 2:                      return (reader.ReadByte() << 8) | (reader.ReadByte() << 0);                  case 3:                      return (reader.ReadByte() << 16) | (reader.ReadByte() << 8) | (reader.ReadByte() << 0);                  case 4:                      return (reader.ReadByte() << 24) | (reader.ReadByte() << 16) | (reader.ReadByte() << 8) | (reader.ReadByte() << 0);              }
Magic Number,Typography.OpenFont.CFF,CFFBinaryReaderExtension,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,ReadOffset,The following statement contains a magic number: switch (offsetSize)              {                  default: throw new NotSupportedException();                  case 1:                      return reader.ReadByte();                  case 2:                      return (reader.ReadByte() << 8) | (reader.ReadByte() << 0);                  case 3:                      return (reader.ReadByte() << 16) | (reader.ReadByte() << 8) | (reader.ReadByte() << 0);                  case 4:                      return (reader.ReadByte() << 24) | (reader.ReadByte() << 16) | (reader.ReadByte() << 8) | (reader.ReadByte() << 0);              }
Magic Number,Typography.OpenFont.CFF,CFFBinaryReaderExtension,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,ReadOffset,The following statement contains a magic number: switch (offsetSize)              {                  default: throw new NotSupportedException();                  case 1:                      return reader.ReadByte();                  case 2:                      return (reader.ReadByte() << 8) | (reader.ReadByte() << 0);                  case 3:                      return (reader.ReadByte() << 16) | (reader.ReadByte() << 8) | (reader.ReadByte() << 0);                  case 4:                      return (reader.ReadByte() << 24) | (reader.ReadByte() << 16) | (reader.ReadByte() << 8) | (reader.ReadByte() << 0);              }
Magic Number,Typography.OpenFont.CFF,CFFBinaryReaderExtension,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,ReadOffset,The following statement contains a magic number: switch (offsetSize)              {                  default: throw new NotSupportedException();                  case 1:                      return reader.ReadByte();                  case 2:                      return (reader.ReadByte() << 8) | (reader.ReadByte() << 0);                  case 3:                      return (reader.ReadByte() << 16) | (reader.ReadByte() << 8) | (reader.ReadByte() << 0);                  case 4:                      return (reader.ReadByte() << 24) | (reader.ReadByte() << 16) | (reader.ReadByte() << 8) | (reader.ReadByte() << 0);              }
Magic Number,Typography.OpenFont.CFF,CFFBinaryReaderExtension,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,ReadOffset,The following statement contains a magic number: switch (offsetSize)              {                  default: throw new NotSupportedException();                  case 1:                      return reader.ReadByte();                  case 2:                      return (reader.ReadByte() << 8) | (reader.ReadByte() << 0);                  case 3:                      return (reader.ReadByte() << 16) | (reader.ReadByte() << 8) | (reader.ReadByte() << 0);                  case 4:                      return (reader.ReadByte() << 24) | (reader.ReadByte() << 16) | (reader.ReadByte() << 8) | (reader.ReadByte() << 0);              }
Magic Number,Typography.OpenFont.CFF,CFFBinaryReaderExtension,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,ReadOffset,The following statement contains a magic number: switch (offsetSize)              {                  default: throw new NotSupportedException();                  case 1:                      return reader.ReadByte();                  case 2:                      return (reader.ReadByte() << 8) | (reader.ReadByte() << 0);                  case 3:                      return (reader.ReadByte() << 16) | (reader.ReadByte() << 8) | (reader.ReadByte() << 0);                  case 4:                      return (reader.ReadByte() << 24) | (reader.ReadByte() << 16) | (reader.ReadByte() << 8) | (reader.ReadByte() << 0);              }
Magic Number,Typography.OpenFont.CFF,CFFBinaryReaderExtension,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,ReadOffset,The following statement contains a magic number: switch (offsetSize)              {                  default: throw new NotSupportedException();                  case 1:                      return reader.ReadByte();                  case 2:                      return (reader.ReadByte() << 8) | (reader.ReadByte() << 0);                  case 3:                      return (reader.ReadByte() << 16) | (reader.ReadByte() << 8) | (reader.ReadByte() << 0);                  case 4:                      return (reader.ReadByte() << 24) | (reader.ReadByte() << 16) | (reader.ReadByte() << 8) | (reader.ReadByte() << 0);              }
Magic Number,Typography.OpenFont.CFF,CFFBinaryReaderExtension,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,ReadOffset,The following statement contains a magic number: switch (offsetSize)              {                  default: throw new NotSupportedException();                  case 1:                      return reader.ReadByte();                  case 2:                      return (reader.ReadByte() << 8) | (reader.ReadByte() << 0);                  case 3:                      return (reader.ReadByte() << 16) | (reader.ReadByte() << 8) | (reader.ReadByte() << 0);                  case 4:                      return (reader.ReadByte() << 24) | (reader.ReadByte() << 16) | (reader.ReadByte() << 8) | (reader.ReadByte() << 0);              }
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,GetOperatorByKey,The following statement contains a magic number: s_registered_Operators.TryGetValue((b1 << 8) | b0' out CFFOperator found);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,Register,The following statement contains a magic number: s_registered_Operators.Add((b1 << 8) | b0' new CFFOperator(operatorName' b0' b1' opopKind));
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 0' "Copyright"' OperatorOperandKind.SID);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(2' "FullName"' OperatorOperandKind.SID);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(3' "FamilyName"' OperatorOperandKind.SID);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(4' "Weight"' OperatorOperandKind.SID);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 1' "isFixedPitch"' OperatorOperandKind.Boolean);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 2' "ItalicAngle"' OperatorOperandKind.Number);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 2' "ItalicAngle"' OperatorOperandKind.Number);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 3' "UnderlinePosition"' OperatorOperandKind.Number);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 3' "UnderlinePosition"' OperatorOperandKind.Number);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 4' "UnderlineThickness"' OperatorOperandKind.Number);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 4' "UnderlineThickness"' OperatorOperandKind.Number);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 5' "PaintType"' OperatorOperandKind.Number);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 5' "PaintType"' OperatorOperandKind.Number);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 6' "CharstringType"' OperatorOperandKind.Number);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 6' "CharstringType"' OperatorOperandKind.Number);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 7' "FontMatrix"' OperatorOperandKind.Array);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 7' "FontMatrix"' OperatorOperandKind.Array);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(13' "UniqueID"' OperatorOperandKind.Number);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(5' "FontBBox"' OperatorOperandKind.Array);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 8' "StrokeWidth"' OperatorOperandKind.Number);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 8' "StrokeWidth"' OperatorOperandKind.Number);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(14' "XUID"' OperatorOperandKind.Array);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(15' "charset"' OperatorOperandKind.Number);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(16' "Encoding"' OperatorOperandKind.Number);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(17' "CharStrings"' OperatorOperandKind.Number);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(18' "Private"' OperatorOperandKind.NumberNumber);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 20' "SyntheticBase"' OperatorOperandKind.Number);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 20' "SyntheticBase"' OperatorOperandKind.Number);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 21' "PostScript"' OperatorOperandKind.SID);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 21' "PostScript"' OperatorOperandKind.SID);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 22' "BaseFontName"' OperatorOperandKind.SID);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 22' "BaseFontName"' OperatorOperandKind.SID);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 23' "BaseFontBlend"' OperatorOperandKind.SID);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 23' "BaseFontBlend"' OperatorOperandKind.SID);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 30' "ROS"' OperatorOperandKind.SID_SID_Number);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 30' "ROS"' OperatorOperandKind.SID_SID_Number);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 31' "CIDFontVersion"' OperatorOperandKind.Number);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 31' "CIDFontVersion"' OperatorOperandKind.Number);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 32' "CIDFontRevision"' OperatorOperandKind.Number);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 32' "CIDFontRevision"' OperatorOperandKind.Number);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 33' "CIDFontType"' OperatorOperandKind.Number);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 33' "CIDFontType"' OperatorOperandKind.Number);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 34' "CIDCount"' OperatorOperandKind.Number);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 34' "CIDCount"' OperatorOperandKind.Number);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 35' "UIDBase"' OperatorOperandKind.Number);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 35' "UIDBase"' OperatorOperandKind.Number);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 36' "FDArray"' OperatorOperandKind.Number);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 36' "FDArray"' OperatorOperandKind.Number);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 37' "FDSelect"' OperatorOperandKind.Number);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 37' "FDSelect"' OperatorOperandKind.Number);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 38' "FontName"' OperatorOperandKind.SID);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 38' "FontName"' OperatorOperandKind.SID);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(6' "BlueValues"' OperatorOperandKind.Delta);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(7' "OtherBlues"' OperatorOperandKind.Delta);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(8' "FamilyBlues"' OperatorOperandKind.Delta);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(9' "FamilyOtherBlues"' OperatorOperandKind.Delta);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 9' "BlueScale"' OperatorOperandKind.Number);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 9' "BlueScale"' OperatorOperandKind.Number);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 10' "BlueShift"' OperatorOperandKind.Number);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 10' "BlueShift"' OperatorOperandKind.Number);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 11' "BlueFuzz"' OperatorOperandKind.Number);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 11' "BlueFuzz"' OperatorOperandKind.Number);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(10' "StdHW"' OperatorOperandKind.Number);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(11' "StdVW"' OperatorOperandKind.Number);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 12' "StemSnapH"' OperatorOperandKind.Delta);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 12' "StemSnapH"' OperatorOperandKind.Delta);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 13' "StemSnapV"' OperatorOperandKind.Delta);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 13' "StemSnapV"' OperatorOperandKind.Delta);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 14' "ForceBold"' OperatorOperandKind.Boolean);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 14' "ForceBold"' OperatorOperandKind.Boolean);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 17' "LanguageGroup"' OperatorOperandKind.Number);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 17' "LanguageGroup"' OperatorOperandKind.Number);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 18' "ExpansionFactor"' OperatorOperandKind.Number);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 18' "ExpansionFactor"' OperatorOperandKind.Number);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 19' "initialRandomSeed"' OperatorOperandKind.Number);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(12' 19' "initialRandomSeed"' OperatorOperandKind.Number);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(19' "Subrs"' OperatorOperandKind.Number);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(20' "defaultWidthX"' OperatorOperandKind.Number);
Magic Number,Typography.OpenFont.CFF,CFFOperator,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,CFFOperator,The following statement contains a magic number: Register(21' "nominalWidthX"' OperatorOperandKind.Number);
Magic Number,Typography.OpenFont.CFF,Type2GlyphInstructionList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,debugCheck,The following statement contains a magic number: _dbugMark == 5 && _insts.Count > 50
Magic Number,Typography.OpenFont.CFF,Type2GlyphInstructionList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,debugCheck,The following statement contains a magic number: _dbugMark == 5 && _insts.Count > 50
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,CalculateBias,The following statement contains a magic number: return (nsubr < 1240) ? 107 : (nsubr < 33900) ? 1131 : 32768;
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,CalculateBias,The following statement contains a magic number: return (nsubr < 1240) ? 107 : (nsubr < 33900) ? 1131 : 32768;
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,CalculateBias,The following statement contains a magic number: return (nsubr < 1240) ? 107 : (nsubr < 33900) ? 1131 : 32768;
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,CalculateBias,The following statement contains a magic number: return (nsubr < 1240) ? 107 : (nsubr < 33900) ? 1131 : 32768;
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,CalculateBias,The following statement contains a magic number: return (nsubr < 1240) ? 107 : (nsubr < 33900) ? 1131 : 32768;
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,ParseType2CharStringBuffer,The following statement contains a magic number: b0 < 32
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,ParseType2CharStringBuffer,The following statement contains a magic number: switch (b0)                  {                      default: //else 32 -255                          {                              if (b0 < 32)                              {                                  Debug.WriteLine("err!:" + b0);                                  return;                              }                              _insts.AddInt(ReadIntegerNumber(ref reader' b0));                              if (_doStemCount)                              {                                  _current_integer_count++;                              }                          }                          break;                      case (byte)Type2Operator1.shortint: // 28                            //shortint                          //First byte of a 3-byte sequence specifying a number.                          //a ShortInt value is specified by using the operator (28) followed by two bytes                          //which represent numbers between –32768 and + 32767.The                          //most significant byte follows the(28)                          byte s_b0 = reader.ReadByte();                          byte s_b1 = reader.ReadByte();                          _insts.AddInt((short)((s_b0 << 8) | (s_b1)));                          //                          if (_doStemCount)                          {                              _current_integer_count++;                          }                          break;                      //---------------------------------------------------                      case (byte)Type2Operator1._Reserved0_://???                      case (byte)Type2Operator1._Reserved2_://???                      case (byte)Type2Operator1._Reserved9_://???                      case (byte)Type2Operator1._Reserved13_://???                      case (byte)Type2Operator1._Reserved15_://???                      case (byte)Type2Operator1._Reserved16_: //???                      case (byte)Type2Operator1._Reserved17_: //???                          //reserved' do nothing ?                          break;                      case (byte)Type2Operator1.endchar:                          _insts.AddOp(OperatorName.endchar);                          cont = false;                          //when we found end char                          //stop reading this...                          break;                      case (byte)Type2Operator1.escape: //12                          {                                b0 = reader.ReadByte();                              switch ((Type2Operator2)b0)                              {                                  default:                                      if (b0 <= 38)                                      {                                          Debug.WriteLine("err!:" + b0);                                          return;                                      }                                      break;                                  //-------------------------                                  //4.1: Path Construction Operators                                  case Type2Operator2.flex: _insts.AddOp(OperatorName.flex); break;                                  case Type2Operator2.hflex: _insts.AddOp(OperatorName.hflex); break;                                  case Type2Operator2.hflex1: _insts.AddOp(OperatorName.hflex1); break;                                  case Type2Operator2.flex1: _insts.AddOp(OperatorName.flex1); ; break;                                  //-------------------------                                  //4.4: Arithmetic Operators                                  case Type2Operator2.abs: _insts.AddOp(OperatorName.abs); break;                                  case Type2Operator2.add: _insts.AddOp(OperatorName.add); break;                                  case Type2Operator2.sub: _insts.AddOp(OperatorName.sub); break;                                  case Type2Operator2.div: _insts.AddOp(OperatorName.div); break;                                  case Type2Operator2.neg: _insts.AddOp(OperatorName.neg); break;                                  case Type2Operator2.random: _insts.AddOp(OperatorName.random); break;                                  case Type2Operator2.mul: _insts.AddOp(OperatorName.mul); break;                                  case Type2Operator2.sqrt: _insts.AddOp(OperatorName.sqrt); break;                                  case Type2Operator2.drop: _insts.AddOp(OperatorName.drop); break;                                  case Type2Operator2.exch: _insts.AddOp(OperatorName.exch); break;                                  case Type2Operator2.index: _insts.AddOp(OperatorName.index); break;                                  case Type2Operator2.roll: _insts.AddOp(OperatorName.roll); break;                                  case Type2Operator2.dup: _insts.AddOp(OperatorName.dup); break;                                    //-------------------------                                  //4.5: Storage Operators                                   case Type2Operator2.put: _insts.AddOp(OperatorName.put); break;                                  case Type2Operator2.get: _insts.AddOp(OperatorName.get); break;                                  //-------------------------                                  //4.6: Conditional                                  case Type2Operator2.and: _insts.AddOp(OperatorName.and); break;                                  case Type2Operator2.or: _insts.AddOp(OperatorName.or); break;                                  case Type2Operator2.not: _insts.AddOp(OperatorName.not); break;                                  case Type2Operator2.eq: _insts.AddOp(OperatorName.eq); break;                                  case Type2Operator2.ifelse: _insts.AddOp(OperatorName.ifelse); break;                              }                                StopStemCount();                          }                          break;                      case (byte)Type2Operator1.rmoveto: _insts.AddOp(OperatorName.rmoveto); StopStemCount(); break;                      case (byte)Type2Operator1.hmoveto: _insts.AddOp(OperatorName.hmoveto); StopStemCount(); break;                      case (byte)Type2Operator1.vmoveto: _insts.AddOp(OperatorName.vmoveto); StopStemCount(); break;                      //---------------------------------------------------------------------------                      case (byte)Type2Operator1.rlineto: _insts.AddOp(OperatorName.rlineto); StopStemCount(); break;                      case (byte)Type2Operator1.hlineto: _insts.AddOp(OperatorName.hlineto); StopStemCount(); break;                      case (byte)Type2Operator1.vlineto: _insts.AddOp(OperatorName.vlineto); StopStemCount(); break;                      case (byte)Type2Operator1.rrcurveto: _insts.AddOp(OperatorName.rrcurveto); StopStemCount(); break;                      case (byte)Type2Operator1.hhcurveto: _insts.AddOp(OperatorName.hhcurveto); StopStemCount(); break;                      case (byte)Type2Operator1.hvcurveto: _insts.AddOp(OperatorName.hvcurveto); StopStemCount(); break;                      case (byte)Type2Operator1.rcurveline: _insts.AddOp(OperatorName.rcurveline); StopStemCount(); break;                      case (byte)Type2Operator1.rlinecurve: _insts.AddOp(OperatorName.rlinecurve); StopStemCount(); break;                      case (byte)Type2Operator1.vhcurveto: _insts.AddOp(OperatorName.vhcurveto); StopStemCount(); break;                      case (byte)Type2Operator1.vvcurveto: _insts.AddOp(OperatorName.vvcurveto); StopStemCount(); break;                      //-------------------------------------------------------------------                      //4.3 Hint Operators                      case (byte)Type2Operator1.hstem: AddStemToList(OperatorName.hstem' ref _hintStemCount); break;                      case (byte)Type2Operator1.vstem: AddStemToList(OperatorName.vstem' ref _hintStemCount); break;                      case (byte)Type2Operator1.vstemhm: AddStemToList(OperatorName.vstemhm' ref _hintStemCount); break;                      case (byte)Type2Operator1.hstemhm: AddStemToList(OperatorName.hstemhm' ref _hintStemCount); break;                      //-------------------------------------------------------------------                      case (byte)Type2Operator1.hintmask: AddHintMaskToList(ref reader' ref _hintStemCount); StopStemCount(); break;                      case (byte)Type2Operator1.cntrmask: AddCounterMaskToList(ref reader' ref _hintStemCount); StopStemCount(); break;                      //-------------------------------------------------------------------                      //4.7: Subroutine Operators                                         case (byte)Type2Operator1._return:                          {  #if DEBUG                              if (!reader.IsEnd())                              {                                  throw new NotSupportedException();                              }    #endif                          }                          return;                      //-------------------------------------------------------------------                      case (byte)Type2Operator1.callsubr:                          {                              //get local subr proc                              if (_currentCff1Font != null)                              {                                  Type2Instruction inst = _insts.RemoveLast();                                  if (inst.Op != OperatorName.LoadInt)                                  {                                      throw new NotSupportedException();                                  }                                  if (_doStemCount)                                  {                                      _current_integer_count--;                                  }                                  //subr_no must be adjusted with proper bias value                                   ParseType2CharStringBuffer(_currentCff1Font._localSubrRawBufferList[inst.Value + _localSubrBias]);                              }                          }                          break;                      case (byte)Type2Operator1.callgsubr:                          {                              if (_currentCff1Font != null)                              {                                  Type2Instruction inst = _insts.RemoveLast();                                  if (inst.Op != OperatorName.LoadInt)                                  {                                      throw new NotSupportedException();                                  }                                  if (_doStemCount)                                  {                                      _current_integer_count--;                                  }                                  //subr_no must be adjusted with proper bias value                                   //load global subr                                  ParseType2CharStringBuffer(_currentCff1Font._globalSubrRawBufferList[inst.Value + _globalSubrBias]);                              }                          }                          break;                  }
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,ParseType2CharStringBuffer,The following statement contains a magic number: switch (b0)                  {                      default: //else 32 -255                          {                              if (b0 < 32)                              {                                  Debug.WriteLine("err!:" + b0);                                  return;                              }                              _insts.AddInt(ReadIntegerNumber(ref reader' b0));                              if (_doStemCount)                              {                                  _current_integer_count++;                              }                          }                          break;                      case (byte)Type2Operator1.shortint: // 28                            //shortint                          //First byte of a 3-byte sequence specifying a number.                          //a ShortInt value is specified by using the operator (28) followed by two bytes                          //which represent numbers between –32768 and + 32767.The                          //most significant byte follows the(28)                          byte s_b0 = reader.ReadByte();                          byte s_b1 = reader.ReadByte();                          _insts.AddInt((short)((s_b0 << 8) | (s_b1)));                          //                          if (_doStemCount)                          {                              _current_integer_count++;                          }                          break;                      //---------------------------------------------------                      case (byte)Type2Operator1._Reserved0_://???                      case (byte)Type2Operator1._Reserved2_://???                      case (byte)Type2Operator1._Reserved9_://???                      case (byte)Type2Operator1._Reserved13_://???                      case (byte)Type2Operator1._Reserved15_://???                      case (byte)Type2Operator1._Reserved16_: //???                      case (byte)Type2Operator1._Reserved17_: //???                          //reserved' do nothing ?                          break;                      case (byte)Type2Operator1.endchar:                          _insts.AddOp(OperatorName.endchar);                          cont = false;                          //when we found end char                          //stop reading this...                          break;                      case (byte)Type2Operator1.escape: //12                          {                                b0 = reader.ReadByte();                              switch ((Type2Operator2)b0)                              {                                  default:                                      if (b0 <= 38)                                      {                                          Debug.WriteLine("err!:" + b0);                                          return;                                      }                                      break;                                  //-------------------------                                  //4.1: Path Construction Operators                                  case Type2Operator2.flex: _insts.AddOp(OperatorName.flex); break;                                  case Type2Operator2.hflex: _insts.AddOp(OperatorName.hflex); break;                                  case Type2Operator2.hflex1: _insts.AddOp(OperatorName.hflex1); break;                                  case Type2Operator2.flex1: _insts.AddOp(OperatorName.flex1); ; break;                                  //-------------------------                                  //4.4: Arithmetic Operators                                  case Type2Operator2.abs: _insts.AddOp(OperatorName.abs); break;                                  case Type2Operator2.add: _insts.AddOp(OperatorName.add); break;                                  case Type2Operator2.sub: _insts.AddOp(OperatorName.sub); break;                                  case Type2Operator2.div: _insts.AddOp(OperatorName.div); break;                                  case Type2Operator2.neg: _insts.AddOp(OperatorName.neg); break;                                  case Type2Operator2.random: _insts.AddOp(OperatorName.random); break;                                  case Type2Operator2.mul: _insts.AddOp(OperatorName.mul); break;                                  case Type2Operator2.sqrt: _insts.AddOp(OperatorName.sqrt); break;                                  case Type2Operator2.drop: _insts.AddOp(OperatorName.drop); break;                                  case Type2Operator2.exch: _insts.AddOp(OperatorName.exch); break;                                  case Type2Operator2.index: _insts.AddOp(OperatorName.index); break;                                  case Type2Operator2.roll: _insts.AddOp(OperatorName.roll); break;                                  case Type2Operator2.dup: _insts.AddOp(OperatorName.dup); break;                                    //-------------------------                                  //4.5: Storage Operators                                   case Type2Operator2.put: _insts.AddOp(OperatorName.put); break;                                  case Type2Operator2.get: _insts.AddOp(OperatorName.get); break;                                  //-------------------------                                  //4.6: Conditional                                  case Type2Operator2.and: _insts.AddOp(OperatorName.and); break;                                  case Type2Operator2.or: _insts.AddOp(OperatorName.or); break;                                  case Type2Operator2.not: _insts.AddOp(OperatorName.not); break;                                  case Type2Operator2.eq: _insts.AddOp(OperatorName.eq); break;                                  case Type2Operator2.ifelse: _insts.AddOp(OperatorName.ifelse); break;                              }                                StopStemCount();                          }                          break;                      case (byte)Type2Operator1.rmoveto: _insts.AddOp(OperatorName.rmoveto); StopStemCount(); break;                      case (byte)Type2Operator1.hmoveto: _insts.AddOp(OperatorName.hmoveto); StopStemCount(); break;                      case (byte)Type2Operator1.vmoveto: _insts.AddOp(OperatorName.vmoveto); StopStemCount(); break;                      //---------------------------------------------------------------------------                      case (byte)Type2Operator1.rlineto: _insts.AddOp(OperatorName.rlineto); StopStemCount(); break;                      case (byte)Type2Operator1.hlineto: _insts.AddOp(OperatorName.hlineto); StopStemCount(); break;                      case (byte)Type2Operator1.vlineto: _insts.AddOp(OperatorName.vlineto); StopStemCount(); break;                      case (byte)Type2Operator1.rrcurveto: _insts.AddOp(OperatorName.rrcurveto); StopStemCount(); break;                      case (byte)Type2Operator1.hhcurveto: _insts.AddOp(OperatorName.hhcurveto); StopStemCount(); break;                      case (byte)Type2Operator1.hvcurveto: _insts.AddOp(OperatorName.hvcurveto); StopStemCount(); break;                      case (byte)Type2Operator1.rcurveline: _insts.AddOp(OperatorName.rcurveline); StopStemCount(); break;                      case (byte)Type2Operator1.rlinecurve: _insts.AddOp(OperatorName.rlinecurve); StopStemCount(); break;                      case (byte)Type2Operator1.vhcurveto: _insts.AddOp(OperatorName.vhcurveto); StopStemCount(); break;                      case (byte)Type2Operator1.vvcurveto: _insts.AddOp(OperatorName.vvcurveto); StopStemCount(); break;                      //-------------------------------------------------------------------                      //4.3 Hint Operators                      case (byte)Type2Operator1.hstem: AddStemToList(OperatorName.hstem' ref _hintStemCount); break;                      case (byte)Type2Operator1.vstem: AddStemToList(OperatorName.vstem' ref _hintStemCount); break;                      case (byte)Type2Operator1.vstemhm: AddStemToList(OperatorName.vstemhm' ref _hintStemCount); break;                      case (byte)Type2Operator1.hstemhm: AddStemToList(OperatorName.hstemhm' ref _hintStemCount); break;                      //-------------------------------------------------------------------                      case (byte)Type2Operator1.hintmask: AddHintMaskToList(ref reader' ref _hintStemCount); StopStemCount(); break;                      case (byte)Type2Operator1.cntrmask: AddCounterMaskToList(ref reader' ref _hintStemCount); StopStemCount(); break;                      //-------------------------------------------------------------------                      //4.7: Subroutine Operators                                         case (byte)Type2Operator1._return:                          {  #if DEBUG                              if (!reader.IsEnd())                              {                                  throw new NotSupportedException();                              }    #endif                          }                          return;                      //-------------------------------------------------------------------                      case (byte)Type2Operator1.callsubr:                          {                              //get local subr proc                              if (_currentCff1Font != null)                              {                                  Type2Instruction inst = _insts.RemoveLast();                                  if (inst.Op != OperatorName.LoadInt)                                  {                                      throw new NotSupportedException();                                  }                                  if (_doStemCount)                                  {                                      _current_integer_count--;                                  }                                  //subr_no must be adjusted with proper bias value                                   ParseType2CharStringBuffer(_currentCff1Font._localSubrRawBufferList[inst.Value + _localSubrBias]);                              }                          }                          break;                      case (byte)Type2Operator1.callgsubr:                          {                              if (_currentCff1Font != null)                              {                                  Type2Instruction inst = _insts.RemoveLast();                                  if (inst.Op != OperatorName.LoadInt)                                  {                                      throw new NotSupportedException();                                  }                                  if (_doStemCount)                                  {                                      _current_integer_count--;                                  }                                  //subr_no must be adjusted with proper bias value                                   //load global subr                                  ParseType2CharStringBuffer(_currentCff1Font._globalSubrRawBufferList[inst.Value + _globalSubrBias]);                              }                          }                          break;                  }
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,ParseType2CharStringBuffer,The following statement contains a magic number: switch (b0)                  {                      default: //else 32 -255                          {                              if (b0 < 32)                              {                                  Debug.WriteLine("err!:" + b0);                                  return;                              }                              _insts.AddInt(ReadIntegerNumber(ref reader' b0));                              if (_doStemCount)                              {                                  _current_integer_count++;                              }                          }                          break;                      case (byte)Type2Operator1.shortint: // 28                            //shortint                          //First byte of a 3-byte sequence specifying a number.                          //a ShortInt value is specified by using the operator (28) followed by two bytes                          //which represent numbers between –32768 and + 32767.The                          //most significant byte follows the(28)                          byte s_b0 = reader.ReadByte();                          byte s_b1 = reader.ReadByte();                          _insts.AddInt((short)((s_b0 << 8) | (s_b1)));                          //                          if (_doStemCount)                          {                              _current_integer_count++;                          }                          break;                      //---------------------------------------------------                      case (byte)Type2Operator1._Reserved0_://???                      case (byte)Type2Operator1._Reserved2_://???                      case (byte)Type2Operator1._Reserved9_://???                      case (byte)Type2Operator1._Reserved13_://???                      case (byte)Type2Operator1._Reserved15_://???                      case (byte)Type2Operator1._Reserved16_: //???                      case (byte)Type2Operator1._Reserved17_: //???                          //reserved' do nothing ?                          break;                      case (byte)Type2Operator1.endchar:                          _insts.AddOp(OperatorName.endchar);                          cont = false;                          //when we found end char                          //stop reading this...                          break;                      case (byte)Type2Operator1.escape: //12                          {                                b0 = reader.ReadByte();                              switch ((Type2Operator2)b0)                              {                                  default:                                      if (b0 <= 38)                                      {                                          Debug.WriteLine("err!:" + b0);                                          return;                                      }                                      break;                                  //-------------------------                                  //4.1: Path Construction Operators                                  case Type2Operator2.flex: _insts.AddOp(OperatorName.flex); break;                                  case Type2Operator2.hflex: _insts.AddOp(OperatorName.hflex); break;                                  case Type2Operator2.hflex1: _insts.AddOp(OperatorName.hflex1); break;                                  case Type2Operator2.flex1: _insts.AddOp(OperatorName.flex1); ; break;                                  //-------------------------                                  //4.4: Arithmetic Operators                                  case Type2Operator2.abs: _insts.AddOp(OperatorName.abs); break;                                  case Type2Operator2.add: _insts.AddOp(OperatorName.add); break;                                  case Type2Operator2.sub: _insts.AddOp(OperatorName.sub); break;                                  case Type2Operator2.div: _insts.AddOp(OperatorName.div); break;                                  case Type2Operator2.neg: _insts.AddOp(OperatorName.neg); break;                                  case Type2Operator2.random: _insts.AddOp(OperatorName.random); break;                                  case Type2Operator2.mul: _insts.AddOp(OperatorName.mul); break;                                  case Type2Operator2.sqrt: _insts.AddOp(OperatorName.sqrt); break;                                  case Type2Operator2.drop: _insts.AddOp(OperatorName.drop); break;                                  case Type2Operator2.exch: _insts.AddOp(OperatorName.exch); break;                                  case Type2Operator2.index: _insts.AddOp(OperatorName.index); break;                                  case Type2Operator2.roll: _insts.AddOp(OperatorName.roll); break;                                  case Type2Operator2.dup: _insts.AddOp(OperatorName.dup); break;                                    //-------------------------                                  //4.5: Storage Operators                                   case Type2Operator2.put: _insts.AddOp(OperatorName.put); break;                                  case Type2Operator2.get: _insts.AddOp(OperatorName.get); break;                                  //-------------------------                                  //4.6: Conditional                                  case Type2Operator2.and: _insts.AddOp(OperatorName.and); break;                                  case Type2Operator2.or: _insts.AddOp(OperatorName.or); break;                                  case Type2Operator2.not: _insts.AddOp(OperatorName.not); break;                                  case Type2Operator2.eq: _insts.AddOp(OperatorName.eq); break;                                  case Type2Operator2.ifelse: _insts.AddOp(OperatorName.ifelse); break;                              }                                StopStemCount();                          }                          break;                      case (byte)Type2Operator1.rmoveto: _insts.AddOp(OperatorName.rmoveto); StopStemCount(); break;                      case (byte)Type2Operator1.hmoveto: _insts.AddOp(OperatorName.hmoveto); StopStemCount(); break;                      case (byte)Type2Operator1.vmoveto: _insts.AddOp(OperatorName.vmoveto); StopStemCount(); break;                      //---------------------------------------------------------------------------                      case (byte)Type2Operator1.rlineto: _insts.AddOp(OperatorName.rlineto); StopStemCount(); break;                      case (byte)Type2Operator1.hlineto: _insts.AddOp(OperatorName.hlineto); StopStemCount(); break;                      case (byte)Type2Operator1.vlineto: _insts.AddOp(OperatorName.vlineto); StopStemCount(); break;                      case (byte)Type2Operator1.rrcurveto: _insts.AddOp(OperatorName.rrcurveto); StopStemCount(); break;                      case (byte)Type2Operator1.hhcurveto: _insts.AddOp(OperatorName.hhcurveto); StopStemCount(); break;                      case (byte)Type2Operator1.hvcurveto: _insts.AddOp(OperatorName.hvcurveto); StopStemCount(); break;                      case (byte)Type2Operator1.rcurveline: _insts.AddOp(OperatorName.rcurveline); StopStemCount(); break;                      case (byte)Type2Operator1.rlinecurve: _insts.AddOp(OperatorName.rlinecurve); StopStemCount(); break;                      case (byte)Type2Operator1.vhcurveto: _insts.AddOp(OperatorName.vhcurveto); StopStemCount(); break;                      case (byte)Type2Operator1.vvcurveto: _insts.AddOp(OperatorName.vvcurveto); StopStemCount(); break;                      //-------------------------------------------------------------------                      //4.3 Hint Operators                      case (byte)Type2Operator1.hstem: AddStemToList(OperatorName.hstem' ref _hintStemCount); break;                      case (byte)Type2Operator1.vstem: AddStemToList(OperatorName.vstem' ref _hintStemCount); break;                      case (byte)Type2Operator1.vstemhm: AddStemToList(OperatorName.vstemhm' ref _hintStemCount); break;                      case (byte)Type2Operator1.hstemhm: AddStemToList(OperatorName.hstemhm' ref _hintStemCount); break;                      //-------------------------------------------------------------------                      case (byte)Type2Operator1.hintmask: AddHintMaskToList(ref reader' ref _hintStemCount); StopStemCount(); break;                      case (byte)Type2Operator1.cntrmask: AddCounterMaskToList(ref reader' ref _hintStemCount); StopStemCount(); break;                      //-------------------------------------------------------------------                      //4.7: Subroutine Operators                                         case (byte)Type2Operator1._return:                          {  #if DEBUG                              if (!reader.IsEnd())                              {                                  throw new NotSupportedException();                              }    #endif                          }                          return;                      //-------------------------------------------------------------------                      case (byte)Type2Operator1.callsubr:                          {                              //get local subr proc                              if (_currentCff1Font != null)                              {                                  Type2Instruction inst = _insts.RemoveLast();                                  if (inst.Op != OperatorName.LoadInt)                                  {                                      throw new NotSupportedException();                                  }                                  if (_doStemCount)                                  {                                      _current_integer_count--;                                  }                                  //subr_no must be adjusted with proper bias value                                   ParseType2CharStringBuffer(_currentCff1Font._localSubrRawBufferList[inst.Value + _localSubrBias]);                              }                          }                          break;                      case (byte)Type2Operator1.callgsubr:                          {                              if (_currentCff1Font != null)                              {                                  Type2Instruction inst = _insts.RemoveLast();                                  if (inst.Op != OperatorName.LoadInt)                                  {                                      throw new NotSupportedException();                                  }                                  if (_doStemCount)                                  {                                      _current_integer_count--;                                  }                                  //subr_no must be adjusted with proper bias value                                   //load global subr                                  ParseType2CharStringBuffer(_currentCff1Font._globalSubrRawBufferList[inst.Value + _globalSubrBias]);                              }                          }                          break;                  }
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,ParseType2CharString,The following statement contains a magic number: dbugCurrentGlyphIndex == 496
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,ParseType2CharString,The following statement contains a magic number: dbugCurrentGlyphIndex == 496
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,AddStemToList,The following statement contains a magic number: (_current_integer_count % 2) != 0
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,AddStemToList,The following statement contains a magic number: hintStemCount += (_current_integer_count / 2);
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,AddHintMaskToList,The following statement contains a magic number: (_current_integer_count % 2) != 0
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,AddHintMaskToList,The following statement contains a magic number: switch (_latestOpName)                      {                          case OperatorName.hstem:                              //add vstem  ***( from reason above)                                hintStemCount += (_current_integer_count / 2); //save a snapshot of stem count                              _insts.AddOp(OperatorName.vstem);                                _latestOpName = OperatorName.vstem;                              _current_integer_count = 0; //clear                              break;                          case OperatorName.hstemhm:                              //add vstem  ***( from reason above) ??                              hintStemCount += (_current_integer_count / 2); //save a snapshot of stem count                              _insts.AddOp(OperatorName.vstem);                              _latestOpName = OperatorName.vstem;                              _current_integer_count = 0;//clear                              break;                          case OperatorName.vstemhm:                              //-------                              //TODO: review here?                               //found this in xits.otf                              hintStemCount += (_current_integer_count / 2); //save a snapshot of stem count                              _insts.AddOp(OperatorName.vstem);                              _latestOpName = OperatorName.vstem;                              _current_integer_count = 0;//clear                              break;                          default:                              throw new NotSupportedException();                      }
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,AddHintMaskToList,The following statement contains a magic number: switch (_latestOpName)                      {                          case OperatorName.hstem:                              //add vstem  ***( from reason above)                                hintStemCount += (_current_integer_count / 2); //save a snapshot of stem count                              _insts.AddOp(OperatorName.vstem);                                _latestOpName = OperatorName.vstem;                              _current_integer_count = 0; //clear                              break;                          case OperatorName.hstemhm:                              //add vstem  ***( from reason above) ??                              hintStemCount += (_current_integer_count / 2); //save a snapshot of stem count                              _insts.AddOp(OperatorName.vstem);                              _latestOpName = OperatorName.vstem;                              _current_integer_count = 0;//clear                              break;                          case OperatorName.vstemhm:                              //-------                              //TODO: review here?                               //found this in xits.otf                              hintStemCount += (_current_integer_count / 2); //save a snapshot of stem count                              _insts.AddOp(OperatorName.vstem);                              _latestOpName = OperatorName.vstem;                              _current_integer_count = 0;//clear                              break;                          default:                              throw new NotSupportedException();                      }
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,AddHintMaskToList,The following statement contains a magic number: switch (_latestOpName)                      {                          case OperatorName.hstem:                              //add vstem  ***( from reason above)                                hintStemCount += (_current_integer_count / 2); //save a snapshot of stem count                              _insts.AddOp(OperatorName.vstem);                                _latestOpName = OperatorName.vstem;                              _current_integer_count = 0; //clear                              break;                          case OperatorName.hstemhm:                              //add vstem  ***( from reason above) ??                              hintStemCount += (_current_integer_count / 2); //save a snapshot of stem count                              _insts.AddOp(OperatorName.vstem);                              _latestOpName = OperatorName.vstem;                              _current_integer_count = 0;//clear                              break;                          case OperatorName.vstemhm:                              //-------                              //TODO: review here?                               //found this in xits.otf                              hintStemCount += (_current_integer_count / 2); //save a snapshot of stem count                              _insts.AddOp(OperatorName.vstem);                              _latestOpName = OperatorName.vstem;                              _current_integer_count = 0;//clear                              break;                          default:                              throw new NotSupportedException();                      }
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,AddHintMaskToList,The following statement contains a magic number: hintStemCount = (_current_integer_count / 2);
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,AddHintMaskToList,The following statement contains a magic number: int properNumberOfMaskBytes = (hintStemCount + 7) / 8;
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,AddHintMaskToList,The following statement contains a magic number: int properNumberOfMaskBytes = (hintStemCount + 7) / 8;
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,AddHintMaskToList,The following statement contains a magic number: _insts.AddInt((                         (reader.ReadByte() << 24) |                         (reader.ReadByte() << 16) |                         (reader.ReadByte() << 8) |                         (reader.ReadByte())                         ));
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,AddHintMaskToList,The following statement contains a magic number: _insts.AddInt((                         (reader.ReadByte() << 24) |                         (reader.ReadByte() << 16) |                         (reader.ReadByte() << 8) |                         (reader.ReadByte())                         ));
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,AddHintMaskToList,The following statement contains a magic number: _insts.AddInt((                         (reader.ReadByte() << 24) |                         (reader.ReadByte() << 16) |                         (reader.ReadByte() << 8) |                         (reader.ReadByte())                         ));
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,AddHintMaskToList,The following statement contains a magic number: remaining -= 4;
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,AddHintMaskToList,The following statement contains a magic number: remaining > 3
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,AddHintMaskToList,The following statement contains a magic number: switch (remaining)                  {                      case 0:                          //do nothing                          break;                      case 1:                          _insts.AddInt(reader.ReadByte() << 24);                          break;                      case 2:                          _insts.AddInt(                              (reader.ReadByte() << 24) |                              (reader.ReadByte() << 16));                            break;                      case 3:                          _insts.AddInt(                              (reader.ReadByte() << 24) |                              (reader.ReadByte() << 16) |                              (reader.ReadByte() << 8));                          break;                      default: throw new NotSupportedException();//should not occur !                  }
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,AddHintMaskToList,The following statement contains a magic number: switch (remaining)                  {                      case 0:                          //do nothing                          break;                      case 1:                          _insts.AddInt(reader.ReadByte() << 24);                          break;                      case 2:                          _insts.AddInt(                              (reader.ReadByte() << 24) |                              (reader.ReadByte() << 16));                            break;                      case 3:                          _insts.AddInt(                              (reader.ReadByte() << 24) |                              (reader.ReadByte() << 16) |                              (reader.ReadByte() << 8));                          break;                      default: throw new NotSupportedException();//should not occur !                  }
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,AddHintMaskToList,The following statement contains a magic number: switch (remaining)                  {                      case 0:                          //do nothing                          break;                      case 1:                          _insts.AddInt(reader.ReadByte() << 24);                          break;                      case 2:                          _insts.AddInt(                              (reader.ReadByte() << 24) |                              (reader.ReadByte() << 16));                            break;                      case 3:                          _insts.AddInt(                              (reader.ReadByte() << 24) |                              (reader.ReadByte() << 16) |                              (reader.ReadByte() << 8));                          break;                      default: throw new NotSupportedException();//should not occur !                  }
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,AddHintMaskToList,The following statement contains a magic number: switch (remaining)                  {                      case 0:                          //do nothing                          break;                      case 1:                          _insts.AddInt(reader.ReadByte() << 24);                          break;                      case 2:                          _insts.AddInt(                              (reader.ReadByte() << 24) |                              (reader.ReadByte() << 16));                            break;                      case 3:                          _insts.AddInt(                              (reader.ReadByte() << 24) |                              (reader.ReadByte() << 16) |                              (reader.ReadByte() << 8));                          break;                      default: throw new NotSupportedException();//should not occur !                  }
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,AddHintMaskToList,The following statement contains a magic number: switch (remaining)                  {                      case 0:                          //do nothing                          break;                      case 1:                          _insts.AddInt(reader.ReadByte() << 24);                          break;                      case 2:                          _insts.AddInt(                              (reader.ReadByte() << 24) |                              (reader.ReadByte() << 16));                            break;                      case 3:                          _insts.AddInt(                              (reader.ReadByte() << 24) |                              (reader.ReadByte() << 16) |                              (reader.ReadByte() << 8));                          break;                      default: throw new NotSupportedException();//should not occur !                  }
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,AddHintMaskToList,The following statement contains a magic number: switch (remaining)                  {                      case 0:                          //do nothing                          break;                      case 1:                          _insts.AddInt(reader.ReadByte() << 24);                          break;                      case 2:                          _insts.AddInt(                              (reader.ReadByte() << 24) |                              (reader.ReadByte() << 16));                            break;                      case 3:                          _insts.AddInt(                              (reader.ReadByte() << 24) |                              (reader.ReadByte() << 16) |                              (reader.ReadByte() << 8));                          break;                      default: throw new NotSupportedException();//should not occur !                  }
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,AddHintMaskToList,The following statement contains a magic number: switch (remaining)                  {                      case 0:                          //do nothing                          break;                      case 1:                          _insts.AddInt(reader.ReadByte() << 24);                          break;                      case 2:                          _insts.AddInt(                              (reader.ReadByte() << 24) |                              (reader.ReadByte() << 16));                            break;                      case 3:                          _insts.AddInt(                              (reader.ReadByte() << 24) |                              (reader.ReadByte() << 16) |                              (reader.ReadByte() << 8));                          break;                      default: throw new NotSupportedException();//should not occur !                  }
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,AddHintMaskToList,The following statement contains a magic number: switch (remaining)                  {                      case 0:                          //do nothing                          break;                      case 1:                          _insts.AddInt(reader.ReadByte() << 24);                          break;                      case 2:                          _insts.AddInt(                              (reader.ReadByte() << 24) |                              (reader.ReadByte() << 16));                            break;                      case 3:                          _insts.AddInt(                              (reader.ReadByte() << 24) |                              (reader.ReadByte() << 16) |                              (reader.ReadByte() << 8));                          break;                      default: throw new NotSupportedException();//should not occur !                  }
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,AddHintMaskToList,The following statement contains a magic number: properNumberOfMaskBytes > 4
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,AddCounterMaskToList,The following statement contains a magic number: hintStemCount = (_current_integer_count / 2);
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,AddCounterMaskToList,The following statement contains a magic number: int properNumberOfMaskBytes = (hintStemCount + 7) / 8;
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,AddCounterMaskToList,The following statement contains a magic number: int properNumberOfMaskBytes = (hintStemCount + 7) / 8;
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,AddCounterMaskToList,The following statement contains a magic number: _insts.AddInt((                         (reader.ReadByte() << 24) |                         (reader.ReadByte() << 16) |                         (reader.ReadByte() << 8) |                         (reader.ReadByte())                         ));
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,AddCounterMaskToList,The following statement contains a magic number: _insts.AddInt((                         (reader.ReadByte() << 24) |                         (reader.ReadByte() << 16) |                         (reader.ReadByte() << 8) |                         (reader.ReadByte())                         ));
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,AddCounterMaskToList,The following statement contains a magic number: _insts.AddInt((                         (reader.ReadByte() << 24) |                         (reader.ReadByte() << 16) |                         (reader.ReadByte() << 8) |                         (reader.ReadByte())                         ));
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,AddCounterMaskToList,The following statement contains a magic number: remaining -= 4;
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,AddCounterMaskToList,The following statement contains a magic number: remaining > 3
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,AddCounterMaskToList,The following statement contains a magic number: switch (remaining)                  {                      case 0:                          //do nothing                          break;                      case 1:                          _insts.AddInt(reader.ReadByte() << 24);                          break;                      case 2:                          _insts.AddInt(                              (reader.ReadByte() << 24) |                              (reader.ReadByte() << 16));                            break;                      case 3:                          _insts.AddInt(                              (reader.ReadByte() << 24) |                              (reader.ReadByte() << 16) |                              (reader.ReadByte() << 8));                          break;                      default: throw new NotSupportedException();//should not occur !                  }
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,AddCounterMaskToList,The following statement contains a magic number: switch (remaining)                  {                      case 0:                          //do nothing                          break;                      case 1:                          _insts.AddInt(reader.ReadByte() << 24);                          break;                      case 2:                          _insts.AddInt(                              (reader.ReadByte() << 24) |                              (reader.ReadByte() << 16));                            break;                      case 3:                          _insts.AddInt(                              (reader.ReadByte() << 24) |                              (reader.ReadByte() << 16) |                              (reader.ReadByte() << 8));                          break;                      default: throw new NotSupportedException();//should not occur !                  }
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,AddCounterMaskToList,The following statement contains a magic number: switch (remaining)                  {                      case 0:                          //do nothing                          break;                      case 1:                          _insts.AddInt(reader.ReadByte() << 24);                          break;                      case 2:                          _insts.AddInt(                              (reader.ReadByte() << 24) |                              (reader.ReadByte() << 16));                            break;                      case 3:                          _insts.AddInt(                              (reader.ReadByte() << 24) |                              (reader.ReadByte() << 16) |                              (reader.ReadByte() << 8));                          break;                      default: throw new NotSupportedException();//should not occur !                  }
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,AddCounterMaskToList,The following statement contains a magic number: switch (remaining)                  {                      case 0:                          //do nothing                          break;                      case 1:                          _insts.AddInt(reader.ReadByte() << 24);                          break;                      case 2:                          _insts.AddInt(                              (reader.ReadByte() << 24) |                              (reader.ReadByte() << 16));                            break;                      case 3:                          _insts.AddInt(                              (reader.ReadByte() << 24) |                              (reader.ReadByte() << 16) |                              (reader.ReadByte() << 8));                          break;                      default: throw new NotSupportedException();//should not occur !                  }
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,AddCounterMaskToList,The following statement contains a magic number: switch (remaining)                  {                      case 0:                          //do nothing                          break;                      case 1:                          _insts.AddInt(reader.ReadByte() << 24);                          break;                      case 2:                          _insts.AddInt(                              (reader.ReadByte() << 24) |                              (reader.ReadByte() << 16));                            break;                      case 3:                          _insts.AddInt(                              (reader.ReadByte() << 24) |                              (reader.ReadByte() << 16) |                              (reader.ReadByte() << 8));                          break;                      default: throw new NotSupportedException();//should not occur !                  }
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,AddCounterMaskToList,The following statement contains a magic number: switch (remaining)                  {                      case 0:                          //do nothing                          break;                      case 1:                          _insts.AddInt(reader.ReadByte() << 24);                          break;                      case 2:                          _insts.AddInt(                              (reader.ReadByte() << 24) |                              (reader.ReadByte() << 16));                            break;                      case 3:                          _insts.AddInt(                              (reader.ReadByte() << 24) |                              (reader.ReadByte() << 16) |                              (reader.ReadByte() << 8));                          break;                      default: throw new NotSupportedException();//should not occur !                  }
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,AddCounterMaskToList,The following statement contains a magic number: switch (remaining)                  {                      case 0:                          //do nothing                          break;                      case 1:                          _insts.AddInt(reader.ReadByte() << 24);                          break;                      case 2:                          _insts.AddInt(                              (reader.ReadByte() << 24) |                              (reader.ReadByte() << 16));                            break;                      case 3:                          _insts.AddInt(                              (reader.ReadByte() << 24) |                              (reader.ReadByte() << 16) |                              (reader.ReadByte() << 8));                          break;                      default: throw new NotSupportedException();//should not occur !                  }
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,AddCounterMaskToList,The following statement contains a magic number: switch (remaining)                  {                      case 0:                          //do nothing                          break;                      case 1:                          _insts.AddInt(reader.ReadByte() << 24);                          break;                      case 2:                          _insts.AddInt(                              (reader.ReadByte() << 24) |                              (reader.ReadByte() << 16));                            break;                      case 3:                          _insts.AddInt(                              (reader.ReadByte() << 24) |                              (reader.ReadByte() << 16) |                              (reader.ReadByte() << 8));                          break;                      default: throw new NotSupportedException();//should not occur !                  }
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,AddCounterMaskToList,The following statement contains a magic number: properNumberOfMaskBytes > 4
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,ReadIntegerNumber,The following statement contains a magic number: return b0 - 139;
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,ReadIntegerNumber,The following statement contains a magic number: b0 >= 32 && b0 <= 246
Magic Number,Typography.OpenFont.CFF,Type2CharStringParser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,ReadIntegerNumber,The following statement contains a magic number: b0 >= 32 && b0 <= 246
Magic Number,Typography.OpenFont.CFF,SimpleBinaryReader,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\Type2CharStringParser.cs,ReadInt32,The following statement contains a magic number: _pos += 4;
Magic Number,System.Numerics,Vector2Ext,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\ForNet20.cs,Rotate,The following statement contains a magic number: double radian = degree * Math.PI / 180.0;
Magic Number,Extensions,TypefaceExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Typeface.cs,DoesSupportUnicode,The following statement contains a magic number: int bitpos = (int)(bits >> 32);
Magic Number,Extensions,TypefaceExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Typeface.cs,RecommendToUseTypoMetricsForLineSpacing,The following statement contains a magic number: return ((typeface.OS2Table.fsSelection >> 7) & 1) != 0;
Magic Number,Extensions,TypefaceExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Typeface.cs,TranslatedOS2FontStyle,The following statement contains a magic number: ((fsSelection >> 5) & 0x1) != 0
Magic Number,Extensions,TypefaceExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Typeface.cs,TranslatedOS2FontStyle,The following statement contains a magic number: ((fsSelection >> 6) & 0x1) != 0
Magic Number,Extensions,TypefaceExtensions,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Typeface.cs,TranslatedOS2FontStyle,The following statement contains a magic number: ((fsSelection >> 9) & 0x1) != 0
Magic Number,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,ReconstructGlyfTable,The following statement contains a magic number: int bitmapCount = (numGlyphs + 7) / 8;
Magic Number,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,ReconstructGlyfTable,The following statement contains a magic number: int bitmapCount = (numGlyphs + 7) / 8;
Magic Number,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,ExpandBitmap,The following statement contains a magic number: byte[] expandArr = new byte[orgBBoxBitmap.Length * 8];
Magic Number,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,ExpandBitmap,The following statement contains a magic number: expandArr[index++] = (byte)((b >> 7) & 0x1);
Magic Number,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,ExpandBitmap,The following statement contains a magic number: expandArr[index++] = (byte)((b >> 6) & 0x1);
Magic Number,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,ExpandBitmap,The following statement contains a magic number: expandArr[index++] = (byte)((b >> 5) & 0x1);
Magic Number,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,ExpandBitmap,The following statement contains a magic number: expandArr[index++] = (byte)((b >> 4) & 0x1);
Magic Number,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,ExpandBitmap,The following statement contains a magic number: expandArr[index++] = (byte)((b >> 3) & 0x1);
Magic Number,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,ExpandBitmap,The following statement contains a magic number: expandArr[index++] = (byte)((b >> 2) & 0x1);
Magic Number,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildSimpleGlyphStructure,The following statement contains a magic number: switch (enc.XBits)                      {                          default:                              throw new System.NotSupportedException();//???                          case 0: //0'8'                               x = 0;                              y = enc.Ty(packedXY[0]);                              break;                          case 4: //4'4                              x = enc.Tx(packedXY[0] >> 4);                              y = enc.Ty(packedXY[0] & 0xF);                              break;                          case 8: //8'0 or 8'8                              x = enc.Tx(packedXY[0]);                              y = (enc.YBits == 8) ?                                      enc.Ty(packedXY[1]) :                                      0;                              break;                          case 12: //12'12                                   //x = enc.Tx((packedXY[0] << 8) | (packedXY[1] >> 4));                                   //y = enc.Ty(((packedXY[1] & 0xF)) | (packedXY[2] >> 4));                              x = enc.Tx((packedXY[0] << 4) | (packedXY[1] >> 4));                              y = enc.Ty(((packedXY[1] & 0xF) << 8) | (packedXY[2]));                              break;                          case 16: //16'16                              x = enc.Tx((packedXY[0] << 8) | packedXY[1]);                              y = enc.Ty((packedXY[2] << 8) | packedXY[3]);                              break;                      }
Magic Number,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildSimpleGlyphStructure,The following statement contains a magic number: switch (enc.XBits)                      {                          default:                              throw new System.NotSupportedException();//???                          case 0: //0'8'                               x = 0;                              y = enc.Ty(packedXY[0]);                              break;                          case 4: //4'4                              x = enc.Tx(packedXY[0] >> 4);                              y = enc.Ty(packedXY[0] & 0xF);                              break;                          case 8: //8'0 or 8'8                              x = enc.Tx(packedXY[0]);                              y = (enc.YBits == 8) ?                                      enc.Ty(packedXY[1]) :                                      0;                              break;                          case 12: //12'12                                   //x = enc.Tx((packedXY[0] << 8) | (packedXY[1] >> 4));                                   //y = enc.Ty(((packedXY[1] & 0xF)) | (packedXY[2] >> 4));                              x = enc.Tx((packedXY[0] << 4) | (packedXY[1] >> 4));                              y = enc.Ty(((packedXY[1] & 0xF) << 8) | (packedXY[2]));                              break;                          case 16: //16'16                              x = enc.Tx((packedXY[0] << 8) | packedXY[1]);                              y = enc.Ty((packedXY[2] << 8) | packedXY[3]);                              break;                      }
Magic Number,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildSimpleGlyphStructure,The following statement contains a magic number: switch (enc.XBits)                      {                          default:                              throw new System.NotSupportedException();//???                          case 0: //0'8'                               x = 0;                              y = enc.Ty(packedXY[0]);                              break;                          case 4: //4'4                              x = enc.Tx(packedXY[0] >> 4);                              y = enc.Ty(packedXY[0] & 0xF);                              break;                          case 8: //8'0 or 8'8                              x = enc.Tx(packedXY[0]);                              y = (enc.YBits == 8) ?                                      enc.Ty(packedXY[1]) :                                      0;                              break;                          case 12: //12'12                                   //x = enc.Tx((packedXY[0] << 8) | (packedXY[1] >> 4));                                   //y = enc.Ty(((packedXY[1] & 0xF)) | (packedXY[2] >> 4));                              x = enc.Tx((packedXY[0] << 4) | (packedXY[1] >> 4));                              y = enc.Ty(((packedXY[1] & 0xF) << 8) | (packedXY[2]));                              break;                          case 16: //16'16                              x = enc.Tx((packedXY[0] << 8) | packedXY[1]);                              y = enc.Ty((packedXY[2] << 8) | packedXY[3]);                              break;                      }
Magic Number,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildSimpleGlyphStructure,The following statement contains a magic number: switch (enc.XBits)                      {                          default:                              throw new System.NotSupportedException();//???                          case 0: //0'8'                               x = 0;                              y = enc.Ty(packedXY[0]);                              break;                          case 4: //4'4                              x = enc.Tx(packedXY[0] >> 4);                              y = enc.Ty(packedXY[0] & 0xF);                              break;                          case 8: //8'0 or 8'8                              x = enc.Tx(packedXY[0]);                              y = (enc.YBits == 8) ?                                      enc.Ty(packedXY[1]) :                                      0;                              break;                          case 12: //12'12                                   //x = enc.Tx((packedXY[0] << 8) | (packedXY[1] >> 4));                                   //y = enc.Ty(((packedXY[1] & 0xF)) | (packedXY[2] >> 4));                              x = enc.Tx((packedXY[0] << 4) | (packedXY[1] >> 4));                              y = enc.Ty(((packedXY[1] & 0xF) << 8) | (packedXY[2]));                              break;                          case 16: //16'16                              x = enc.Tx((packedXY[0] << 8) | packedXY[1]);                              y = enc.Ty((packedXY[2] << 8) | packedXY[3]);                              break;                      }
Magic Number,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildSimpleGlyphStructure,The following statement contains a magic number: switch (enc.XBits)                      {                          default:                              throw new System.NotSupportedException();//???                          case 0: //0'8'                               x = 0;                              y = enc.Ty(packedXY[0]);                              break;                          case 4: //4'4                              x = enc.Tx(packedXY[0] >> 4);                              y = enc.Ty(packedXY[0] & 0xF);                              break;                          case 8: //8'0 or 8'8                              x = enc.Tx(packedXY[0]);                              y = (enc.YBits == 8) ?                                      enc.Ty(packedXY[1]) :                                      0;                              break;                          case 12: //12'12                                   //x = enc.Tx((packedXY[0] << 8) | (packedXY[1] >> 4));                                   //y = enc.Ty(((packedXY[1] & 0xF)) | (packedXY[2] >> 4));                              x = enc.Tx((packedXY[0] << 4) | (packedXY[1] >> 4));                              y = enc.Ty(((packedXY[1] & 0xF) << 8) | (packedXY[2]));                              break;                          case 16: //16'16                              x = enc.Tx((packedXY[0] << 8) | packedXY[1]);                              y = enc.Ty((packedXY[2] << 8) | packedXY[3]);                              break;                      }
Magic Number,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildSimpleGlyphStructure,The following statement contains a magic number: switch (enc.XBits)                      {                          default:                              throw new System.NotSupportedException();//???                          case 0: //0'8'                               x = 0;                              y = enc.Ty(packedXY[0]);                              break;                          case 4: //4'4                              x = enc.Tx(packedXY[0] >> 4);                              y = enc.Ty(packedXY[0] & 0xF);                              break;                          case 8: //8'0 or 8'8                              x = enc.Tx(packedXY[0]);                              y = (enc.YBits == 8) ?                                      enc.Ty(packedXY[1]) :                                      0;                              break;                          case 12: //12'12                                   //x = enc.Tx((packedXY[0] << 8) | (packedXY[1] >> 4));                                   //y = enc.Ty(((packedXY[1] & 0xF)) | (packedXY[2] >> 4));                              x = enc.Tx((packedXY[0] << 4) | (packedXY[1] >> 4));                              y = enc.Ty(((packedXY[1] & 0xF) << 8) | (packedXY[2]));                              break;                          case 16: //16'16                              x = enc.Tx((packedXY[0] << 8) | packedXY[1]);                              y = enc.Ty((packedXY[2] << 8) | packedXY[3]);                              break;                      }
Magic Number,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildSimpleGlyphStructure,The following statement contains a magic number: switch (enc.XBits)                      {                          default:                              throw new System.NotSupportedException();//???                          case 0: //0'8'                               x = 0;                              y = enc.Ty(packedXY[0]);                              break;                          case 4: //4'4                              x = enc.Tx(packedXY[0] >> 4);                              y = enc.Ty(packedXY[0] & 0xF);                              break;                          case 8: //8'0 or 8'8                              x = enc.Tx(packedXY[0]);                              y = (enc.YBits == 8) ?                                      enc.Ty(packedXY[1]) :                                      0;                              break;                          case 12: //12'12                                   //x = enc.Tx((packedXY[0] << 8) | (packedXY[1] >> 4));                                   //y = enc.Ty(((packedXY[1] & 0xF)) | (packedXY[2] >> 4));                              x = enc.Tx((packedXY[0] << 4) | (packedXY[1] >> 4));                              y = enc.Ty(((packedXY[1] & 0xF) << 8) | (packedXY[2]));                              break;                          case 16: //16'16                              x = enc.Tx((packedXY[0] << 8) | packedXY[1]);                              y = enc.Ty((packedXY[2] << 8) | packedXY[3]);                              break;                      }
Magic Number,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildSimpleGlyphStructure,The following statement contains a magic number: switch (enc.XBits)                      {                          default:                              throw new System.NotSupportedException();//???                          case 0: //0'8'                               x = 0;                              y = enc.Ty(packedXY[0]);                              break;                          case 4: //4'4                              x = enc.Tx(packedXY[0] >> 4);                              y = enc.Ty(packedXY[0] & 0xF);                              break;                          case 8: //8'0 or 8'8                              x = enc.Tx(packedXY[0]);                              y = (enc.YBits == 8) ?                                      enc.Ty(packedXY[1]) :                                      0;                              break;                          case 12: //12'12                                   //x = enc.Tx((packedXY[0] << 8) | (packedXY[1] >> 4));                                   //y = enc.Ty(((packedXY[1] & 0xF)) | (packedXY[2] >> 4));                              x = enc.Tx((packedXY[0] << 4) | (packedXY[1] >> 4));                              y = enc.Ty(((packedXY[1] & 0xF) << 8) | (packedXY[2]));                              break;                          case 16: //16'16                              x = enc.Tx((packedXY[0] << 8) | packedXY[1]);                              y = enc.Ty((packedXY[2] << 8) | packedXY[3]);                              break;                      }
Magic Number,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildSimpleGlyphStructure,The following statement contains a magic number: switch (enc.XBits)                      {                          default:                              throw new System.NotSupportedException();//???                          case 0: //0'8'                               x = 0;                              y = enc.Ty(packedXY[0]);                              break;                          case 4: //4'4                              x = enc.Tx(packedXY[0] >> 4);                              y = enc.Ty(packedXY[0] & 0xF);                              break;                          case 8: //8'0 or 8'8                              x = enc.Tx(packedXY[0]);                              y = (enc.YBits == 8) ?                                      enc.Ty(packedXY[1]) :                                      0;                              break;                          case 12: //12'12                                   //x = enc.Tx((packedXY[0] << 8) | (packedXY[1] >> 4));                                   //y = enc.Ty(((packedXY[1] & 0xF)) | (packedXY[2] >> 4));                              x = enc.Tx((packedXY[0] << 4) | (packedXY[1] >> 4));                              y = enc.Ty(((packedXY[1] & 0xF) << 8) | (packedXY[2]));                              break;                          case 16: //16'16                              x = enc.Tx((packedXY[0] << 8) | packedXY[1]);                              y = enc.Ty((packedXY[2] << 8) | packedXY[3]);                              break;                      }
Magic Number,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildSimpleGlyphStructure,The following statement contains a magic number: switch (enc.XBits)                      {                          default:                              throw new System.NotSupportedException();//???                          case 0: //0'8'                               x = 0;                              y = enc.Ty(packedXY[0]);                              break;                          case 4: //4'4                              x = enc.Tx(packedXY[0] >> 4);                              y = enc.Ty(packedXY[0] & 0xF);                              break;                          case 8: //8'0 or 8'8                              x = enc.Tx(packedXY[0]);                              y = (enc.YBits == 8) ?                                      enc.Ty(packedXY[1]) :                                      0;                              break;                          case 12: //12'12                                   //x = enc.Tx((packedXY[0] << 8) | (packedXY[1] >> 4));                                   //y = enc.Ty(((packedXY[1] & 0xF)) | (packedXY[2] >> 4));                              x = enc.Tx((packedXY[0] << 4) | (packedXY[1] >> 4));                              y = enc.Ty(((packedXY[1] & 0xF) << 8) | (packedXY[2]));                              break;                          case 16: //16'16                              x = enc.Tx((packedXY[0] << 8) | packedXY[1]);                              y = enc.Ty((packedXY[2] << 8) | packedXY[3]);                              break;                      }
Magic Number,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildSimpleGlyphStructure,The following statement contains a magic number: switch (enc.XBits)                      {                          default:                              throw new System.NotSupportedException();//???                          case 0: //0'8'                               x = 0;                              y = enc.Ty(packedXY[0]);                              break;                          case 4: //4'4                              x = enc.Tx(packedXY[0] >> 4);                              y = enc.Ty(packedXY[0] & 0xF);                              break;                          case 8: //8'0 or 8'8                              x = enc.Tx(packedXY[0]);                              y = (enc.YBits == 8) ?                                      enc.Ty(packedXY[1]) :                                      0;                              break;                          case 12: //12'12                                   //x = enc.Tx((packedXY[0] << 8) | (packedXY[1] >> 4));                                   //y = enc.Ty(((packedXY[1] & 0xF)) | (packedXY[2] >> 4));                              x = enc.Tx((packedXY[0] << 4) | (packedXY[1] >> 4));                              y = enc.Ty(((packedXY[1] & 0xF) << 8) | (packedXY[2]));                              break;                          case 16: //16'16                              x = enc.Tx((packedXY[0] << 8) | packedXY[1]);                              y = enc.Ty((packedXY[2] << 8) | packedXY[3]);                              break;                      }
Magic Number,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildSimpleGlyphStructure,The following statement contains a magic number: switch (enc.XBits)                      {                          default:                              throw new System.NotSupportedException();//???                          case 0: //0'8'                               x = 0;                              y = enc.Ty(packedXY[0]);                              break;                          case 4: //4'4                              x = enc.Tx(packedXY[0] >> 4);                              y = enc.Ty(packedXY[0] & 0xF);                              break;                          case 8: //8'0 or 8'8                              x = enc.Tx(packedXY[0]);                              y = (enc.YBits == 8) ?                                      enc.Ty(packedXY[1]) :                                      0;                              break;                          case 12: //12'12                                   //x = enc.Tx((packedXY[0] << 8) | (packedXY[1] >> 4));                                   //y = enc.Ty(((packedXY[1] & 0xF)) | (packedXY[2] >> 4));                              x = enc.Tx((packedXY[0] << 4) | (packedXY[1] >> 4));                              y = enc.Ty(((packedXY[1] & 0xF) << 8) | (packedXY[2]));                              break;                          case 16: //16'16                              x = enc.Tx((packedXY[0] << 8) | packedXY[1]);                              y = enc.Ty((packedXY[2] << 8) | packedXY[3]);                              break;                      }
Magic Number,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildSimpleGlyphStructure,The following statement contains a magic number: switch (enc.XBits)                      {                          default:                              throw new System.NotSupportedException();//???                          case 0: //0'8'                               x = 0;                              y = enc.Ty(packedXY[0]);                              break;                          case 4: //4'4                              x = enc.Tx(packedXY[0] >> 4);                              y = enc.Ty(packedXY[0] & 0xF);                              break;                          case 8: //8'0 or 8'8                              x = enc.Tx(packedXY[0]);                              y = (enc.YBits == 8) ?                                      enc.Ty(packedXY[1]) :                                      0;                              break;                          case 12: //12'12                                   //x = enc.Tx((packedXY[0] << 8) | (packedXY[1] >> 4));                                   //y = enc.Ty(((packedXY[1] & 0xF)) | (packedXY[2] >> 4));                              x = enc.Tx((packedXY[0] << 4) | (packedXY[1] >> 4));                              y = enc.Ty(((packedXY[1] & 0xF) << 8) | (packedXY[2]));                              break;                          case 16: //16'16                              x = enc.Tx((packedXY[0] << 8) | packedXY[1]);                              y = enc.Ty((packedXY[2] << 8) | packedXY[3]);                              break;                      }
Magic Number,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildSimpleGlyphStructure,The following statement contains a magic number: switch (enc.XBits)                      {                          default:                              throw new System.NotSupportedException();//???                          case 0: //0'8'                               x = 0;                              y = enc.Ty(packedXY[0]);                              break;                          case 4: //4'4                              x = enc.Tx(packedXY[0] >> 4);                              y = enc.Ty(packedXY[0] & 0xF);                              break;                          case 8: //8'0 or 8'8                              x = enc.Tx(packedXY[0]);                              y = (enc.YBits == 8) ?                                      enc.Ty(packedXY[1]) :                                      0;                              break;                          case 12: //12'12                                   //x = enc.Tx((packedXY[0] << 8) | (packedXY[1] >> 4));                                   //y = enc.Ty(((packedXY[1] & 0xF)) | (packedXY[2] >> 4));                              x = enc.Tx((packedXY[0] << 4) | (packedXY[1] >> 4));                              y = enc.Ty(((packedXY[1] & 0xF) << 8) | (packedXY[2]));                              break;                          case 16: //16'16                              x = enc.Tx((packedXY[0] << 8) | packedXY[1]);                              y = enc.Ty((packedXY[2] << 8) | packedXY[3]);                              break;                      }
Magic Number,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildSimpleGlyphStructure,The following statement contains a magic number: _glyphPoints[n] = new GlyphPointF(curX += x' curY += y' (f >> 7) == 0);
Magic Number,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,CompositeHasInstructions,The following statement contains a magic number: xscale = yscale = ((float)reader.ReadInt16()) / (1 << 14);
Magic Number,Typography.WebFont,TransformedGlyf,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,ReadCompositeGlyph,The following statement contains a magic number: xscale = yscale = ((float)reader.ReadInt16()) / (1 << 14);
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,TripleEncodingTable,The following statement contains a magic number: _records.Count != 128
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,dbugValidateTable,The following statement contains a magic number: xyFormat < 84
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,dbugValidateTable,The following statement contains a magic number: xyFormat < 128
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(2' 0' 8' null' new ushort[] { 0' 256' 512' 768' 1024 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(2' 0' 8' null' new ushort[] { 0' 256' 512' 768' 1024 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(2' 0' 8' null' new ushort[] { 0' 256' 512' 768' 1024 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(2' 0' 8' null' new ushort[] { 0' 256' 512' 768' 1024 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(2' 0' 8' null' new ushort[] { 0' 256' 512' 768' 1024 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(2' 0' 8' null' new ushort[] { 0' 256' 512' 768' 1024 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(2' 8' 0' new ushort[] { 0' 256' 512' 768' 1024 }' null);
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(2' 8' 0' new ushort[] { 0' 256' 512' 768' 1024 }' null);
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(2' 8' 0' new ushort[] { 0' 256' 512' 768' 1024 }' null);
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(2' 8' 0' new ushort[] { 0' 256' 512' 768' 1024 }' null);
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(2' 8' 0' new ushort[] { 0' 256' 512' 768' 1024 }' null);
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(2' 8' 0' new ushort[] { 0' 256' 512' 768' 1024 }' null);
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(2' 4' 4' new ushort[] { 1 }' new ushort[] { 1' 17' 33' 49 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(2' 4' 4' new ushort[] { 1 }' new ushort[] { 1' 17' 33' 49 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(2' 4' 4' new ushort[] { 1 }' new ushort[] { 1' 17' 33' 49 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(2' 4' 4' new ushort[] { 1 }' new ushort[] { 1' 17' 33' 49 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(2' 4' 4' new ushort[] { 1 }' new ushort[] { 1' 17' 33' 49 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(2' 4' 4' new ushort[] { 1 }' new ushort[] { 1' 17' 33' 49 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(2' 4' 4' new ushort[] { 17 }' new ushort[] { 1' 17' 33' 49 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(2' 4' 4' new ushort[] { 17 }' new ushort[] { 1' 17' 33' 49 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(2' 4' 4' new ushort[] { 17 }' new ushort[] { 1' 17' 33' 49 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(2' 4' 4' new ushort[] { 17 }' new ushort[] { 1' 17' 33' 49 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(2' 4' 4' new ushort[] { 17 }' new ushort[] { 1' 17' 33' 49 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(2' 4' 4' new ushort[] { 17 }' new ushort[] { 1' 17' 33' 49 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(2' 4' 4' new ushort[] { 17 }' new ushort[] { 1' 17' 33' 49 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(2' 4' 4' new ushort[] { 33 }' new ushort[] { 1' 17' 33' 49 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(2' 4' 4' new ushort[] { 33 }' new ushort[] { 1' 17' 33' 49 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(2' 4' 4' new ushort[] { 33 }' new ushort[] { 1' 17' 33' 49 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(2' 4' 4' new ushort[] { 33 }' new ushort[] { 1' 17' 33' 49 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(2' 4' 4' new ushort[] { 33 }' new ushort[] { 1' 17' 33' 49 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(2' 4' 4' new ushort[] { 33 }' new ushort[] { 1' 17' 33' 49 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(2' 4' 4' new ushort[] { 33 }' new ushort[] { 1' 17' 33' 49 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(2' 4' 4' new ushort[] { 49 }' new ushort[] { 1' 17' 33' 49 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(2' 4' 4' new ushort[] { 49 }' new ushort[] { 1' 17' 33' 49 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(2' 4' 4' new ushort[] { 49 }' new ushort[] { 1' 17' 33' 49 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(2' 4' 4' new ushort[] { 49 }' new ushort[] { 1' 17' 33' 49 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(2' 4' 4' new ushort[] { 49 }' new ushort[] { 1' 17' 33' 49 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(2' 4' 4' new ushort[] { 49 }' new ushort[] { 1' 17' 33' 49 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(2' 4' 4' new ushort[] { 49 }' new ushort[] { 1' 17' 33' 49 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(3' 8' 8' new ushort[] { 1 }' new ushort[] { 1' 257' 513 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(3' 8' 8' new ushort[] { 1 }' new ushort[] { 1' 257' 513 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(3' 8' 8' new ushort[] { 1 }' new ushort[] { 1' 257' 513 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(3' 8' 8' new ushort[] { 1 }' new ushort[] { 1' 257' 513 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(3' 8' 8' new ushort[] { 1 }' new ushort[] { 1' 257' 513 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(3' 8' 8' new ushort[] { 257 }' new ushort[] { 1' 257' 513 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(3' 8' 8' new ushort[] { 257 }' new ushort[] { 1' 257' 513 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(3' 8' 8' new ushort[] { 257 }' new ushort[] { 1' 257' 513 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(3' 8' 8' new ushort[] { 257 }' new ushort[] { 1' 257' 513 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(3' 8' 8' new ushort[] { 257 }' new ushort[] { 1' 257' 513 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(3' 8' 8' new ushort[] { 257 }' new ushort[] { 1' 257' 513 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(3' 8' 8' new ushort[] { 513 }' new ushort[] { 1' 257' 513 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(3' 8' 8' new ushort[] { 513 }' new ushort[] { 1' 257' 513 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(3' 8' 8' new ushort[] { 513 }' new ushort[] { 1' 257' 513 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(3' 8' 8' new ushort[] { 513 }' new ushort[] { 1' 257' 513 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(3' 8' 8' new ushort[] { 513 }' new ushort[] { 1' 257' 513 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(3' 8' 8' new ushort[] { 513 }' new ushort[] { 1' 257' 513 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(4' 12' 12' new ushort[] { 0 }' new ushort[] { 0 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(4' 12' 12' new ushort[] { 0 }' new ushort[] { 0 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(4' 12' 12' new ushort[] { 0 }' new ushort[] { 0 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(5' 16' 16' new ushort[] { 0 }' new ushort[] { 0 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(5' 16' 16' new ushort[] { 0 }' new ushort[] { 0 });
Magic Number,Typography.WebFont,TripleEncodingTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,BuildTable,The following statement contains a magic number: BuildRecords(5' 16' 16' new ushort[] { 0 }' new ushort[] { 0 });
Magic Number,Typography.WebFont,Woff2Reader,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,ReadTableDirectories,The following statement contains a magic number: knowTable < 63
Magic Number,Typography.WebFont,Woff2Reader,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,ReadTableDirectories,The following statement contains a magic number: table.PreprocessingTransformation = (byte)((flags >> 5) & 0x3);
Magic Number,Typography.WebFont,Woff2Reader,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,ReadTableDirectories,The following statement contains a magic number: switch (table.PreprocessingTransformation)                  {                      default:                          break;                      case 0:                          {                              if (table.Name == Glyf._N)                              {                                  if (!ReadUIntBase128(reader' out table.transformLength))                                  {                                      //can't read 128=> error                                  }                                  expectedTableStartAt += table.transformLength;//***                              }                              else if (table.Name == GlyphLocations._N)                              {                                  //BUT by spec' transform 'loca' MUST has transformLength=0                                  if (!ReadUIntBase128(reader' out table.transformLength))                                  {                                      //can't read 128=> error                                  }                                  expectedTableStartAt += table.transformLength;//***                              }                              else                              {                                  expectedTableStartAt += table.origLength;                              }                          }                          break;                      case 1:                          {                              expectedTableStartAt += table.origLength;                          }                          break;                      case 2:                          {                              expectedTableStartAt += table.origLength;                          }                          break;                      case 3:                          {                              expectedTableStartAt += table.origLength;                          }                          break;                  }
Magic Number,Typography.WebFont,Woff2Reader,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,ReadTableDirectories,The following statement contains a magic number: switch (table.PreprocessingTransformation)                  {                      default:                          break;                      case 0:                          {                              if (table.Name == Glyf._N)                              {                                  if (!ReadUIntBase128(reader' out table.transformLength))                                  {                                      //can't read 128=> error                                  }                                  expectedTableStartAt += table.transformLength;//***                              }                              else if (table.Name == GlyphLocations._N)                              {                                  //BUT by spec' transform 'loca' MUST has transformLength=0                                  if (!ReadUIntBase128(reader' out table.transformLength))                                  {                                      //can't read 128=> error                                  }                                  expectedTableStartAt += table.transformLength;//***                              }                              else                              {                                  expectedTableStartAt += table.origLength;                              }                          }                          break;                      case 1:                          {                              expectedTableStartAt += table.origLength;                          }                          break;                      case 2:                          {                              expectedTableStartAt += table.origLength;                          }                          break;                      case 3:                          {                              expectedTableStartAt += table.origLength;                          }                          break;                  }
Magic Number,Typography.WebFont,Woff2Reader,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,ReadUIntBase128,The following statement contains a magic number: accum = (uint)(accum << 7) | (uint)(data_byte & 0x7F);
Magic Number,Typography.WebFont,Woff2Reader,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,ReadUIntBase128,The following statement contains a magic number: i < 5
Magic Number,Typography.WebFont,Woff2Utils,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\WebFont\Woff2Reader.cs,Read255UInt16,The following statement contains a magic number: value <<= 8;
Duplicate Code,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,Execute,The method contains a code clone-set at the following line numbers (starting from the method definition): ((426' 448)' (495' 517))
Missing Default,Typography.TextLayout,GlyphSubstitution,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.GlyphLayout\GlyphSubstitution.cs,RebuildTables,The following switch statement is missing a default case: switch (feature.TagName)                  {                      case "ccmp": // glyph composition/decomposition                           featureIsNeeded = EnableComposition;                          break;                      case "liga": // Standard Ligatures --enable by default                          featureIsNeeded = EnableLigation;                          break;                  }
Missing Default,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,HintGlyph,The following switch statement is missing a default case: switch (_state.RoundState)              {                  case RoundMode.Super: SetSuperRound(1.0f); break;                  case RoundMode.Super45: SetSuperRound(Sqrt2Over2); break;              }
Missing Default,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,Execute,The following switch statement is missing a default case: switch (opcode)                                      {                                          case OpCode.IF: indent++; break;                                          case OpCode.EIF: indent--; break;                                          case OpCode.ELSE:                                              if (indent == 1)                                                  indent = 0;                                              break;                                      }
Missing Default,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,Execute,The following switch statement is missing a default case: switch (opcode)                                  {                                      case OpCode.IF: indent++; break;                                      case OpCode.EIF: indent--; break;                                  }
Missing Default,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,SetSuperRound,The following switch statement is missing a default case: switch (mode & 0x30)              {                  case 0: _roundPhase = 0; break;                  case 0x10: _roundPhase = roundPeriod / 4; break;                  case 0x20: _roundPhase = roundPeriod / 2; break;                  case 0x30: _roundPhase = roundPeriod * 3 / 4; break;              }
Missing Default,Typography.OpenFont,SharpFontInterpreter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\TrueTypeInterperter\Interpreter.cs,SkipNext,The following switch statement is missing a default case: switch (opcode)              {                  case OpCode.NPUSHB:                  case OpCode.PUSHB1:                  case OpCode.PUSHB2:                  case OpCode.PUSHB3:                  case OpCode.PUSHB4:                  case OpCode.PUSHB5:                  case OpCode.PUSHB6:                  case OpCode.PUSHB7:                  case OpCode.PUSHB8:                      {                          var count = opcode == OpCode.NPUSHB ? stream.NextByte() : opcode - OpCode.PUSHB1 + 1;                          for (int i = 0; i < count; i++)                              stream.NextByte();                      }                      break;                  case OpCode.NPUSHW:                  case OpCode.PUSHW1:                  case OpCode.PUSHW2:                  case OpCode.PUSHW3:                  case OpCode.PUSHW4:                  case OpCode.PUSHW5:                  case OpCode.PUSHW6:                  case OpCode.PUSHW7:                  case OpCode.PUSHW8:                      {                          var count = opcode == OpCode.NPUSHW ? stream.NextByte() : opcode - OpCode.PUSHW1 + 1;                          for (int i = 0; i < count; i++)                              stream.NextWord();                      }                      break;              }
Missing Default,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadSubTable,The following switch statement is missing a default case: switch (lookupType)                  {                      case 1: return ReadLookupType1(reader' subTableStartAt);                      case 2: return ReadLookupType2(reader' subTableStartAt);                      case 3: return ReadLookupType3(reader' subTableStartAt);                      case 4: return ReadLookupType4(reader' subTableStartAt);                      case 5: return ReadLookupType5(reader' subTableStartAt);                      case 6: return ReadLookupType6(reader' subTableStartAt);                      case 7: return ReadLookupType7(reader' subTableStartAt);                      case 8: return ReadLookupType8(reader' subTableStartAt);                      case 9: return ReadLookupType9(reader' subTableStartAt);                  }
Missing Default,Typography.OpenFont.Tables,LookupTable,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.AdvancedLayout\GPOS.cs,ReadSubTable,The following switch statement is missing a default case: switch (lookupType)                  {                      case 1: return ReadLookupType1(reader' subTableStartAt);                      case 2: return ReadLookupType2(reader' subTableStartAt);                      case 3: return ReadLookupType3(reader' subTableStartAt);                      case 4: return ReadLookupType4(reader' subTableStartAt);                      case 5: return ReadLookupType5(reader' subTableStartAt);                      case 6: return ReadLookupType6(reader' subTableStartAt);                      case 7: return ReadLookupType7(reader' subTableStartAt);                      case 8: return ReadLookupType8(reader' subTableStartAt);                  }
Missing Default,Typography.OpenFont.CFF,Cff1Parser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,ReadTopDICTIndex,The following switch statement is missing a default case: switch (entry._operator.Name)                  {                      case "CharStrings":                          _charStringsOffset = (int)entry.operands[0]._realNumValue;                          break;                      case "charset":                          _charsetOffset = (int)entry.operands[0]._realNumValue;                          break;                      case "Encoding":                          _encodingOffset = (int)entry.operands[0]._realNumValue;                          break;                      case "Private":                          //private DICT size and offset                          _privateDICTSize = (int)entry.operands[0]._realNumValue;                          _privateDICTOffset = (int)entry.operands[1]._realNumValue;                          break;                  }
Missing Default,Typography.OpenFont.CFF,Cff1Parser,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Typography.OpenFont\Tables.CFF\CFF.cs,ReadEncodings,The following switch statement is missing a default case: switch (format)              {                  case 0:                      {                          ReadFormat0Encoding();                      }                      break;                  case 1:                      {                          ReadFormat1Encoding();                      }                      break;              }
